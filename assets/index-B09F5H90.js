(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const c of document.querySelectorAll('link[rel="modulepreload"]'))a(c);new MutationObserver(c=>{for(const h of c)if(h.type==="childList")for(const p of h.addedNodes)p.tagName==="LINK"&&p.rel==="modulepreload"&&a(p)}).observe(document,{childList:!0,subtree:!0});function n(c){const h={};return c.integrity&&(h.integrity=c.integrity),c.referrerPolicy&&(h.referrerPolicy=c.referrerPolicy),c.crossOrigin==="use-credentials"?h.credentials="include":c.crossOrigin==="anonymous"?h.credentials="omit":h.credentials="same-origin",h}function a(c){if(c.ep)return;c.ep=!0;const h=n(c);fetch(c.href,h)}})();var W0=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function mle(r){if(Object.prototype.hasOwnProperty.call(r,"__esModule"))return r;var e=r.default;if(typeof e=="function"){var n=function a(){var c=!1;try{c=this instanceof a}catch{}return c?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(r).forEach(function(a){var c=Object.getOwnPropertyDescriptor(r,a);Object.defineProperty(n,a,c.get?c:{enumerable:!0,get:function(){return r[a]}})}),n}var uM={exports:{}},Ty={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var TF;function gle(){if(TF)return Ty;TF=1;var r=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function n(a,c,h){var p=null;if(h!==void 0&&(p=""+h),c.key!==void 0&&(p=""+c.key),"key"in c){h={};for(var b in c)b!=="key"&&(h[b]=c[b])}else h=c;return c=h.ref,{$$typeof:r,type:a,key:p,ref:c!==void 0?c:null,props:h}}return Ty.Fragment=e,Ty.jsx=n,Ty.jsxs=n,Ty}var MF;function Ale(){return MF||(MF=1,uM.exports=gle()),uM.exports}var Cr=Ale(),hM={exports:{}},pi={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _F;function ble(){if(_F)return pi;_F=1;var r=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),c=Symbol.for("react.profiler"),h=Symbol.for("react.consumer"),p=Symbol.for("react.context"),b=Symbol.for("react.forward_ref"),y=Symbol.for("react.suspense"),w=Symbol.for("react.memo"),I=Symbol.for("react.lazy"),E=Symbol.iterator;function R(fe){return fe===null||typeof fe!="object"?null:(fe=E&&fe[E]||fe["@@iterator"],typeof fe=="function"?fe:null)}var k={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},G=Object.assign,N={};function O(fe,Ve,Ne){this.props=fe,this.context=Ve,this.refs=N,this.updater=Ne||k}O.prototype.isReactComponent={},O.prototype.setState=function(fe,Ve){if(typeof fe!="object"&&typeof fe!="function"&&fe!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,fe,Ve,"setState")},O.prototype.forceUpdate=function(fe){this.updater.enqueueForceUpdate(this,fe,"forceUpdate")};function D(){}D.prototype=O.prototype;function W(fe,Ve,Ne){this.props=fe,this.context=Ve,this.refs=N,this.updater=Ne||k}var H=W.prototype=new D;H.constructor=W,G(H,O.prototype),H.isPureReactComponent=!0;var K=Array.isArray,j={H:null,A:null,T:null,S:null,V:null},J=Object.prototype.hasOwnProperty;function ee(fe,Ve,Ne,gt,bt,zt){return Ne=zt.ref,{$$typeof:r,type:fe,key:Ve,ref:Ne!==void 0?Ne:null,props:zt}}function re(fe,Ve){return ee(fe.type,Ve,void 0,void 0,void 0,fe.props)}function Y(fe){return typeof fe=="object"&&fe!==null&&fe.$$typeof===r}function ie(fe){var Ve={"=":"=0",":":"=2"};return"$"+fe.replace(/[=:]/g,function(Ne){return Ve[Ne]})}var ue=/\/+/g;function Re(fe,Ve){return typeof fe=="object"&&fe!==null&&fe.key!=null?ie(""+fe.key):Ve.toString(36)}function _e(){}function Pe(fe){switch(fe.status){case"fulfilled":return fe.value;case"rejected":throw fe.reason;default:switch(typeof fe.status=="string"?fe.then(_e,_e):(fe.status="pending",fe.then(function(Ve){fe.status==="pending"&&(fe.status="fulfilled",fe.value=Ve)},function(Ve){fe.status==="pending"&&(fe.status="rejected",fe.reason=Ve)})),fe.status){case"fulfilled":return fe.value;case"rejected":throw fe.reason}}throw fe}function rt(fe,Ve,Ne,gt,bt){var zt=typeof fe;(zt==="undefined"||zt==="boolean")&&(fe=null);var Tt=!1;if(fe===null)Tt=!0;else switch(zt){case"bigint":case"string":case"number":Tt=!0;break;case"object":switch(fe.$$typeof){case r:case e:Tt=!0;break;case I:return Tt=fe._init,rt(Tt(fe._payload),Ve,Ne,gt,bt)}}if(Tt)return bt=bt(fe),Tt=gt===""?"."+Re(fe,0):gt,K(bt)?(Ne="",Tt!=null&&(Ne=Tt.replace(ue,"$&/")+"/"),rt(bt,Ve,Ne,"",function(_t){return _t})):bt!=null&&(Y(bt)&&(bt=re(bt,Ne+(bt.key==null||fe&&fe.key===bt.key?"":(""+bt.key).replace(ue,"$&/")+"/")+Tt)),Ve.push(bt)),1;Tt=0;var Vt=gt===""?".":gt+":";if(K(fe))for(var je=0;je<fe.length;je++)gt=fe[je],zt=Vt+Re(gt,je),Tt+=rt(gt,Ve,Ne,zt,bt);else if(je=R(fe),typeof je=="function")for(fe=je.call(fe),je=0;!(gt=fe.next()).done;)gt=gt.value,zt=Vt+Re(gt,je++),Tt+=rt(gt,Ve,Ne,zt,bt);else if(zt==="object"){if(typeof fe.then=="function")return rt(Pe(fe),Ve,Ne,gt,bt);throw Ve=String(fe),Error("Objects are not valid as a React child (found: "+(Ve==="[object Object]"?"object with keys {"+Object.keys(fe).join(", ")+"}":Ve)+"). If you meant to render a collection of children, use an array instead.")}return Tt}function de(fe,Ve,Ne){if(fe==null)return fe;var gt=[],bt=0;return rt(fe,gt,"","",function(zt){return Ve.call(Ne,zt,bt++)}),gt}function we(fe){if(fe._status===-1){var Ve=fe._result;Ve=Ve(),Ve.then(function(Ne){(fe._status===0||fe._status===-1)&&(fe._status=1,fe._result=Ne)},function(Ne){(fe._status===0||fe._status===-1)&&(fe._status=2,fe._result=Ne)}),fe._status===-1&&(fe._status=0,fe._result=Ve)}if(fe._status===1)return fe._result.default;throw fe._result}var Le=typeof reportError=="function"?reportError:function(fe){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var Ve=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof fe=="object"&&fe!==null&&typeof fe.message=="string"?String(fe.message):String(fe),error:fe});if(!window.dispatchEvent(Ve))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",fe);return}console.error(fe)};function Je(){}return pi.Children={map:de,forEach:function(fe,Ve,Ne){de(fe,function(){Ve.apply(this,arguments)},Ne)},count:function(fe){var Ve=0;return de(fe,function(){Ve++}),Ve},toArray:function(fe){return de(fe,function(Ve){return Ve})||[]},only:function(fe){if(!Y(fe))throw Error("React.Children.only expected to receive a single React element child.");return fe}},pi.Component=O,pi.Fragment=n,pi.Profiler=c,pi.PureComponent=W,pi.StrictMode=a,pi.Suspense=y,pi.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=j,pi.__COMPILER_RUNTIME={__proto__:null,c:function(fe){return j.H.useMemoCache(fe)}},pi.cache=function(fe){return function(){return fe.apply(null,arguments)}},pi.cloneElement=function(fe,Ve,Ne){if(fe==null)throw Error("The argument must be a React element, but you passed "+fe+".");var gt=G({},fe.props),bt=fe.key,zt=void 0;if(Ve!=null)for(Tt in Ve.ref!==void 0&&(zt=void 0),Ve.key!==void 0&&(bt=""+Ve.key),Ve)!J.call(Ve,Tt)||Tt==="key"||Tt==="__self"||Tt==="__source"||Tt==="ref"&&Ve.ref===void 0||(gt[Tt]=Ve[Tt]);var Tt=arguments.length-2;if(Tt===1)gt.children=Ne;else if(1<Tt){for(var Vt=Array(Tt),je=0;je<Tt;je++)Vt[je]=arguments[je+2];gt.children=Vt}return ee(fe.type,bt,void 0,void 0,zt,gt)},pi.createContext=function(fe){return fe={$$typeof:p,_currentValue:fe,_currentValue2:fe,_threadCount:0,Provider:null,Consumer:null},fe.Provider=fe,fe.Consumer={$$typeof:h,_context:fe},fe},pi.createElement=function(fe,Ve,Ne){var gt,bt={},zt=null;if(Ve!=null)for(gt in Ve.key!==void 0&&(zt=""+Ve.key),Ve)J.call(Ve,gt)&&gt!=="key"&&gt!=="__self"&&gt!=="__source"&&(bt[gt]=Ve[gt]);var Tt=arguments.length-2;if(Tt===1)bt.children=Ne;else if(1<Tt){for(var Vt=Array(Tt),je=0;je<Tt;je++)Vt[je]=arguments[je+2];bt.children=Vt}if(fe&&fe.defaultProps)for(gt in Tt=fe.defaultProps,Tt)bt[gt]===void 0&&(bt[gt]=Tt[gt]);return ee(fe,zt,void 0,void 0,null,bt)},pi.createRef=function(){return{current:null}},pi.forwardRef=function(fe){return{$$typeof:b,render:fe}},pi.isValidElement=Y,pi.lazy=function(fe){return{$$typeof:I,_payload:{_status:-1,_result:fe},_init:we}},pi.memo=function(fe,Ve){return{$$typeof:w,type:fe,compare:Ve===void 0?null:Ve}},pi.startTransition=function(fe){var Ve=j.T,Ne={};j.T=Ne;try{var gt=fe(),bt=j.S;bt!==null&&bt(Ne,gt),typeof gt=="object"&&gt!==null&&typeof gt.then=="function"&&gt.then(Je,Le)}catch(zt){Le(zt)}finally{j.T=Ve}},pi.unstable_useCacheRefresh=function(){return j.H.useCacheRefresh()},pi.use=function(fe){return j.H.use(fe)},pi.useActionState=function(fe,Ve,Ne){return j.H.useActionState(fe,Ve,Ne)},pi.useCallback=function(fe,Ve){return j.H.useCallback(fe,Ve)},pi.useContext=function(fe){return j.H.useContext(fe)},pi.useDebugValue=function(){},pi.useDeferredValue=function(fe,Ve){return j.H.useDeferredValue(fe,Ve)},pi.useEffect=function(fe,Ve,Ne){var gt=j.H;if(typeof Ne=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return gt.useEffect(fe,Ve)},pi.useId=function(){return j.H.useId()},pi.useImperativeHandle=function(fe,Ve,Ne){return j.H.useImperativeHandle(fe,Ve,Ne)},pi.useInsertionEffect=function(fe,Ve){return j.H.useInsertionEffect(fe,Ve)},pi.useLayoutEffect=function(fe,Ve){return j.H.useLayoutEffect(fe,Ve)},pi.useMemo=function(fe,Ve){return j.H.useMemo(fe,Ve)},pi.useOptimistic=function(fe,Ve){return j.H.useOptimistic(fe,Ve)},pi.useReducer=function(fe,Ve,Ne){return j.H.useReducer(fe,Ve,Ne)},pi.useRef=function(fe){return j.H.useRef(fe)},pi.useState=function(fe){return j.H.useState(fe)},pi.useSyncExternalStore=function(fe,Ve,Ne){return j.H.useSyncExternalStore(fe,Ve,Ne)},pi.useTransition=function(){return j.H.useTransition()},pi.version="19.1.1",pi}var RF;function KR(){return RF||(RF=1,hM.exports=ble()),hM.exports}var hu=KR(),dM={exports:{}},My={},fM={exports:{}},pM={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var kF;function yle(){return kF||(kF=1,(function(r){function e(de,we){var Le=de.length;de.push(we);e:for(;0<Le;){var Je=Le-1>>>1,fe=de[Je];if(0<c(fe,we))de[Je]=we,de[Le]=fe,Le=Je;else break e}}function n(de){return de.length===0?null:de[0]}function a(de){if(de.length===0)return null;var we=de[0],Le=de.pop();if(Le!==we){de[0]=Le;e:for(var Je=0,fe=de.length,Ve=fe>>>1;Je<Ve;){var Ne=2*(Je+1)-1,gt=de[Ne],bt=Ne+1,zt=de[bt];if(0>c(gt,Le))bt<fe&&0>c(zt,gt)?(de[Je]=zt,de[bt]=Le,Je=bt):(de[Je]=gt,de[Ne]=Le,Je=Ne);else if(bt<fe&&0>c(zt,Le))de[Je]=zt,de[bt]=Le,Je=bt;else break e}}return we}function c(de,we){var Le=de.sortIndex-we.sortIndex;return Le!==0?Le:de.id-we.id}if(r.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var h=performance;r.unstable_now=function(){return h.now()}}else{var p=Date,b=p.now();r.unstable_now=function(){return p.now()-b}}var y=[],w=[],I=1,E=null,R=3,k=!1,G=!1,N=!1,O=!1,D=typeof setTimeout=="function"?setTimeout:null,W=typeof clearTimeout=="function"?clearTimeout:null,H=typeof setImmediate<"u"?setImmediate:null;function K(de){for(var we=n(w);we!==null;){if(we.callback===null)a(w);else if(we.startTime<=de)a(w),we.sortIndex=we.expirationTime,e(y,we);else break;we=n(w)}}function j(de){if(N=!1,K(de),!G)if(n(y)!==null)G=!0,J||(J=!0,Re());else{var we=n(w);we!==null&&rt(j,we.startTime-de)}}var J=!1,ee=-1,re=5,Y=-1;function ie(){return O?!0:!(r.unstable_now()-Y<re)}function ue(){if(O=!1,J){var de=r.unstable_now();Y=de;var we=!0;try{e:{G=!1,N&&(N=!1,W(ee),ee=-1),k=!0;var Le=R;try{t:{for(K(de),E=n(y);E!==null&&!(E.expirationTime>de&&ie());){var Je=E.callback;if(typeof Je=="function"){E.callback=null,R=E.priorityLevel;var fe=Je(E.expirationTime<=de);if(de=r.unstable_now(),typeof fe=="function"){E.callback=fe,K(de),we=!0;break t}E===n(y)&&a(y),K(de)}else a(y);E=n(y)}if(E!==null)we=!0;else{var Ve=n(w);Ve!==null&&rt(j,Ve.startTime-de),we=!1}}break e}finally{E=null,R=Le,k=!1}we=void 0}}finally{we?Re():J=!1}}}var Re;if(typeof H=="function")Re=function(){H(ue)};else if(typeof MessageChannel<"u"){var _e=new MessageChannel,Pe=_e.port2;_e.port1.onmessage=ue,Re=function(){Pe.postMessage(null)}}else Re=function(){D(ue,0)};function rt(de,we){ee=D(function(){de(r.unstable_now())},we)}r.unstable_IdlePriority=5,r.unstable_ImmediatePriority=1,r.unstable_LowPriority=4,r.unstable_NormalPriority=3,r.unstable_Profiling=null,r.unstable_UserBlockingPriority=2,r.unstable_cancelCallback=function(de){de.callback=null},r.unstable_forceFrameRate=function(de){0>de||125<de?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):re=0<de?Math.floor(1e3/de):5},r.unstable_getCurrentPriorityLevel=function(){return R},r.unstable_next=function(de){switch(R){case 1:case 2:case 3:var we=3;break;default:we=R}var Le=R;R=we;try{return de()}finally{R=Le}},r.unstable_requestPaint=function(){O=!0},r.unstable_runWithPriority=function(de,we){switch(de){case 1:case 2:case 3:case 4:case 5:break;default:de=3}var Le=R;R=de;try{return we()}finally{R=Le}},r.unstable_scheduleCallback=function(de,we,Le){var Je=r.unstable_now();switch(typeof Le=="object"&&Le!==null?(Le=Le.delay,Le=typeof Le=="number"&&0<Le?Je+Le:Je):Le=Je,de){case 1:var fe=-1;break;case 2:fe=250;break;case 5:fe=1073741823;break;case 4:fe=1e4;break;default:fe=5e3}return fe=Le+fe,de={id:I++,callback:we,priorityLevel:de,startTime:Le,expirationTime:fe,sortIndex:-1},Le>Je?(de.sortIndex=Le,e(w,de),n(y)===null&&de===n(w)&&(N?(W(ee),ee=-1):N=!0,rt(j,Le-Je))):(de.sortIndex=fe,e(y,de),G||k||(G=!0,J||(J=!0,Re()))),de},r.unstable_shouldYield=ie,r.unstable_wrapCallback=function(de){var we=R;return function(){var Le=R;R=we;try{return de.apply(this,arguments)}finally{R=Le}}}})(pM)),pM}var BF;function vle(){return BF||(BF=1,fM.exports=yle()),fM.exports}var mM={exports:{}},Aa={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var LF;function xle(){if(LF)return Aa;LF=1;var r=KR();function e(y){var w="https://react.dev/errors/"+y;if(1<arguments.length){w+="?args[]="+encodeURIComponent(arguments[1]);for(var I=2;I<arguments.length;I++)w+="&args[]="+encodeURIComponent(arguments[I])}return"Minified React error #"+y+"; visit "+w+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function n(){}var a={d:{f:n,r:function(){throw Error(e(522))},D:n,C:n,L:n,m:n,X:n,S:n,M:n},p:0,findDOMNode:null},c=Symbol.for("react.portal");function h(y,w,I){var E=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:c,key:E==null?null:""+E,children:y,containerInfo:w,implementation:I}}var p=r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function b(y,w){if(y==="font")return"";if(typeof w=="string")return w==="use-credentials"?w:""}return Aa.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=a,Aa.createPortal=function(y,w){var I=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!w||w.nodeType!==1&&w.nodeType!==9&&w.nodeType!==11)throw Error(e(299));return h(y,w,null,I)},Aa.flushSync=function(y){var w=p.T,I=a.p;try{if(p.T=null,a.p=2,y)return y()}finally{p.T=w,a.p=I,a.d.f()}},Aa.preconnect=function(y,w){typeof y=="string"&&(w?(w=w.crossOrigin,w=typeof w=="string"?w==="use-credentials"?w:"":void 0):w=null,a.d.C(y,w))},Aa.prefetchDNS=function(y){typeof y=="string"&&a.d.D(y)},Aa.preinit=function(y,w){if(typeof y=="string"&&w&&typeof w.as=="string"){var I=w.as,E=b(I,w.crossOrigin),R=typeof w.integrity=="string"?w.integrity:void 0,k=typeof w.fetchPriority=="string"?w.fetchPriority:void 0;I==="style"?a.d.S(y,typeof w.precedence=="string"?w.precedence:void 0,{crossOrigin:E,integrity:R,fetchPriority:k}):I==="script"&&a.d.X(y,{crossOrigin:E,integrity:R,fetchPriority:k,nonce:typeof w.nonce=="string"?w.nonce:void 0})}},Aa.preinitModule=function(y,w){if(typeof y=="string")if(typeof w=="object"&&w!==null){if(w.as==null||w.as==="script"){var I=b(w.as,w.crossOrigin);a.d.M(y,{crossOrigin:I,integrity:typeof w.integrity=="string"?w.integrity:void 0,nonce:typeof w.nonce=="string"?w.nonce:void 0})}}else w==null&&a.d.M(y)},Aa.preload=function(y,w){if(typeof y=="string"&&typeof w=="object"&&w!==null&&typeof w.as=="string"){var I=w.as,E=b(I,w.crossOrigin);a.d.L(y,I,{crossOrigin:E,integrity:typeof w.integrity=="string"?w.integrity:void 0,nonce:typeof w.nonce=="string"?w.nonce:void 0,type:typeof w.type=="string"?w.type:void 0,fetchPriority:typeof w.fetchPriority=="string"?w.fetchPriority:void 0,referrerPolicy:typeof w.referrerPolicy=="string"?w.referrerPolicy:void 0,imageSrcSet:typeof w.imageSrcSet=="string"?w.imageSrcSet:void 0,imageSizes:typeof w.imageSizes=="string"?w.imageSizes:void 0,media:typeof w.media=="string"?w.media:void 0})}},Aa.preloadModule=function(y,w){if(typeof y=="string")if(w){var I=b(w.as,w.crossOrigin);a.d.m(y,{as:typeof w.as=="string"&&w.as!=="script"?w.as:void 0,crossOrigin:I,integrity:typeof w.integrity=="string"?w.integrity:void 0})}else a.d.m(y)},Aa.requestFormReset=function(y){a.d.r(y)},Aa.unstable_batchedUpdates=function(y,w){return y(w)},Aa.useFormState=function(y,w,I){return p.H.useFormState(y,w,I)},Aa.useFormStatus=function(){return p.H.useHostTransitionStatus()},Aa.version="19.1.1",Aa}var NF;function wle(){if(NF)return mM.exports;NF=1;function r(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)}catch(e){console.error(e)}}return r(),mM.exports=xle(),mM.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var DF;function Cle(){if(DF)return My;DF=1;var r=vle(),e=KR(),n=wle();function a(d){var m="https://react.dev/errors/"+d;if(1<arguments.length){m+="?args[]="+encodeURIComponent(arguments[1]);for(var x=2;x<arguments.length;x++)m+="&args[]="+encodeURIComponent(arguments[x])}return"Minified React error #"+d+"; visit "+m+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function c(d){return!(!d||d.nodeType!==1&&d.nodeType!==9&&d.nodeType!==11)}function h(d){var m=d,x=d;if(d.alternate)for(;m.return;)m=m.return;else{d=m;do m=d,(m.flags&4098)!==0&&(x=m.return),d=m.return;while(d)}return m.tag===3?x:null}function p(d){if(d.tag===13){var m=d.memoizedState;if(m===null&&(d=d.alternate,d!==null&&(m=d.memoizedState)),m!==null)return m.dehydrated}return null}function b(d){if(h(d)!==d)throw Error(a(188))}function y(d){var m=d.alternate;if(!m){if(m=h(d),m===null)throw Error(a(188));return m!==d?null:d}for(var x=d,T=m;;){var L=x.return;if(L===null)break;var z=L.alternate;if(z===null){if(T=L.return,T!==null){x=T;continue}break}if(L.child===z.child){for(z=L.child;z;){if(z===x)return b(L),d;if(z===T)return b(L),m;z=z.sibling}throw Error(a(188))}if(x.return!==T.return)x=L,T=z;else{for(var te=!1,le=L.child;le;){if(le===x){te=!0,x=L,T=z;break}if(le===T){te=!0,T=L,x=z;break}le=le.sibling}if(!te){for(le=z.child;le;){if(le===x){te=!0,x=z,T=L;break}if(le===T){te=!0,T=z,x=L;break}le=le.sibling}if(!te)throw Error(a(189))}}if(x.alternate!==T)throw Error(a(190))}if(x.tag!==3)throw Error(a(188));return x.stateNode.current===x?d:m}function w(d){var m=d.tag;if(m===5||m===26||m===27||m===6)return d;for(d=d.child;d!==null;){if(m=w(d),m!==null)return m;d=d.sibling}return null}var I=Object.assign,E=Symbol.for("react.element"),R=Symbol.for("react.transitional.element"),k=Symbol.for("react.portal"),G=Symbol.for("react.fragment"),N=Symbol.for("react.strict_mode"),O=Symbol.for("react.profiler"),D=Symbol.for("react.provider"),W=Symbol.for("react.consumer"),H=Symbol.for("react.context"),K=Symbol.for("react.forward_ref"),j=Symbol.for("react.suspense"),J=Symbol.for("react.suspense_list"),ee=Symbol.for("react.memo"),re=Symbol.for("react.lazy"),Y=Symbol.for("react.activity"),ie=Symbol.for("react.memo_cache_sentinel"),ue=Symbol.iterator;function Re(d){return d===null||typeof d!="object"?null:(d=ue&&d[ue]||d["@@iterator"],typeof d=="function"?d:null)}var _e=Symbol.for("react.client.reference");function Pe(d){if(d==null)return null;if(typeof d=="function")return d.$$typeof===_e?null:d.displayName||d.name||null;if(typeof d=="string")return d;switch(d){case G:return"Fragment";case O:return"Profiler";case N:return"StrictMode";case j:return"Suspense";case J:return"SuspenseList";case Y:return"Activity"}if(typeof d=="object")switch(d.$$typeof){case k:return"Portal";case H:return(d.displayName||"Context")+".Provider";case W:return(d._context.displayName||"Context")+".Consumer";case K:var m=d.render;return d=d.displayName,d||(d=m.displayName||m.name||"",d=d!==""?"ForwardRef("+d+")":"ForwardRef"),d;case ee:return m=d.displayName||null,m!==null?m:Pe(d.type)||"Memo";case re:m=d._payload,d=d._init;try{return Pe(d(m))}catch{}}return null}var rt=Array.isArray,de=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,we=n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,Le={pending:!1,data:null,method:null,action:null},Je=[],fe=-1;function Ve(d){return{current:d}}function Ne(d){0>fe||(d.current=Je[fe],Je[fe]=null,fe--)}function gt(d,m){fe++,Je[fe]=d.current,d.current=m}var bt=Ve(null),zt=Ve(null),Tt=Ve(null),Vt=Ve(null);function je(d,m){switch(gt(Tt,m),gt(zt,d),gt(bt,null),m.nodeType){case 9:case 11:d=(d=m.documentElement)&&(d=d.namespaceURI)?b1(d):0;break;default:if(d=m.tagName,m=m.namespaceURI)m=b1(m),d=y1(m,d);else switch(d){case"svg":d=1;break;case"math":d=2;break;default:d=0}}Ne(bt),gt(bt,d)}function _t(){Ne(bt),Ne(zt),Ne(Tt)}function Ot(d){d.memoizedState!==null&&gt(Vt,d);var m=bt.current,x=y1(m,d.type);m!==x&&(gt(zt,d),gt(bt,x))}function on(d){zt.current===d&&(Ne(bt),Ne(zt)),Vt.current===d&&(Ne(Vt),wd._currentValue=Le)}var vt=Object.prototype.hasOwnProperty,Mt=r.unstable_scheduleCallback,Bt=r.unstable_cancelCallback,ve=r.unstable_shouldYield,Kt=r.unstable_requestPaint,Ee=r.unstable_now,Q=r.unstable_getCurrentPriorityLevel,Z=r.unstable_ImmediatePriority,ae=r.unstable_UserBlockingPriority,Ae=r.unstable_NormalPriority,Ie=r.unstable_LowPriority,Ze=r.unstable_IdlePriority,At=r.log,dn=r.unstable_setDisableYieldValue,ge=null,se=null;function Ge(d){if(typeof At=="function"&&dn(d),se&&typeof se.setStrictMode=="function")try{se.setStrictMode(ge,d)}catch{}}var ut=Math.clz32?Math.clz32:fn,kt=Math.log,xt=Math.LN2;function fn(d){return d>>>=0,d===0?32:31-(kt(d)/xt|0)|0}var Gt=256,Jt=4194304;function Ln(d){var m=d&42;if(m!==0)return m;switch(d&-d){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return d&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return d&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return d}}function Zt(d,m,x){var T=d.pendingLanes;if(T===0)return 0;var L=0,z=d.suspendedLanes,te=d.pingedLanes;d=d.warmLanes;var le=T&134217727;return le!==0?(T=le&~z,T!==0?L=Ln(T):(te&=le,te!==0?L=Ln(te):x||(x=le&~d,x!==0&&(L=Ln(x))))):(le=T&~z,le!==0?L=Ln(le):te!==0?L=Ln(te):x||(x=T&~d,x!==0&&(L=Ln(x)))),L===0?0:m!==0&&m!==L&&(m&z)===0&&(z=L&-L,x=m&-m,z>=x||z===32&&(x&4194048)!==0)?m:L}function bn(d,m){return(d.pendingLanes&~(d.suspendedLanes&~d.pingedLanes)&m)===0}function Jn(d,m){switch(d){case 1:case 2:case 4:case 8:case 64:return m+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return m+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function ke(){var d=Gt;return Gt<<=1,(Gt&4194048)===0&&(Gt=256),d}function wt(){var d=Jt;return Jt<<=1,(Jt&62914560)===0&&(Jt=4194304),d}function Wt(d){for(var m=[],x=0;31>x;x++)m.push(d);return m}function jt(d,m){d.pendingLanes|=m,m!==268435456&&(d.suspendedLanes=0,d.pingedLanes=0,d.warmLanes=0)}function tn(d,m,x,T,L,z){var te=d.pendingLanes;d.pendingLanes=x,d.suspendedLanes=0,d.pingedLanes=0,d.warmLanes=0,d.expiredLanes&=x,d.entangledLanes&=x,d.errorRecoveryDisabledLanes&=x,d.shellSuspendCounter=0;var le=d.entanglements,Ce=d.expirationTimes,it=d.hiddenUpdates;for(x=te&~x;0<x;){var Ct=31-ut(x),Rt=1<<Ct;le[Ct]=0,Ce[Ct]=-1;var at=it[Ct];if(at!==null)for(it[Ct]=null,Ct=0;Ct<at.length;Ct++){var lt=at[Ct];lt!==null&&(lt.lane&=-536870913)}x&=~Rt}T!==0&&cn(d,T,0),z!==0&&L===0&&d.tag!==0&&(d.suspendedLanes|=z&~(te&~m))}function cn(d,m,x){d.pendingLanes|=m,d.suspendedLanes&=~m;var T=31-ut(m);d.entangledLanes|=m,d.entanglements[T]=d.entanglements[T]|1073741824|x&4194090}function Vn(d,m){var x=d.entangledLanes|=m;for(d=d.entanglements;x;){var T=31-ut(x),L=1<<T;L&m|d[T]&m&&(d[T]|=m),x&=~L}}function nn(d){switch(d){case 2:d=1;break;case 8:d=4;break;case 32:d=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:d=128;break;case 268435456:d=134217728;break;default:d=0}return d}function qt(d){return d&=-d,2<d?8<d?(d&134217727)!==0?32:268435456:8:2}function mn(){var d=we.p;return d!==0?d:(d=window.event,d===void 0?32:L1(d.type))}function fi(d,m){var x=we.p;try{return we.p=d,m()}finally{we.p=x}}var Ki=Math.random().toString(36).slice(2),Ts="__reactFiber$"+Ki,ir="__reactProps$"+Ki,ro="__reactContainer$"+Ki,xc="__reactEvents$"+Ki,ao="__reactListeners$"+Ki,wc="__reactHandles$"+Ki,Cc="__reactResources$"+Ki,nl="__reactMarker$"+Ki;function oo(d){delete d[Ts],delete d[ir],delete d[xc],delete d[ao],delete d[wc]}function Ea(d){var m=d[Ts];if(m)return m;for(var x=d.parentNode;x;){if(m=x[ro]||x[Ts]){if(x=m.alternate,m.child!==null||x!==null&&x.child!==null)for(d=v1(d);d!==null;){if(x=d[Ts])return x;d=v1(d)}return m}d=x,x=d.parentNode}return null}function Sa(d){if(d=d[Ts]||d[ro]){var m=d.tag;if(m===5||m===6||m===13||m===26||m===27||m===3)return d}return null}function ko(d){var m=d.tag;if(m===5||m===26||m===27||m===6)return d.stateNode;throw Error(a(33))}function Bo(d){var m=d[Cc];return m||(m=d[Cc]={hoistableStyles:new Map,hoistableScripts:new Map}),m}function Vs(d){d[nl]=!0}var Bh=new Set,Cu={};function Lo(d,m){il(d,m),il(d+"Capture",m)}function il(d,m){for(Cu[d]=m,d=0;d<m.length;d++)Bh.add(m[d])}var Lm=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),ce={},We={};function st(d){return vt.call(We,d)?!0:vt.call(ce,d)?!1:Lm.test(d)?We[d]=!0:(ce[d]=!0,!1)}function ot(d,m,x){if(st(m))if(x===null)d.removeAttribute(m);else{switch(typeof x){case"undefined":case"function":case"symbol":d.removeAttribute(m);return;case"boolean":var T=m.toLowerCase().slice(0,5);if(T!=="data-"&&T!=="aria-"){d.removeAttribute(m);return}}d.setAttribute(m,""+x)}}function Xe(d,m,x){if(x===null)d.removeAttribute(m);else{switch(typeof x){case"undefined":case"function":case"symbol":case"boolean":d.removeAttribute(m);return}d.setAttribute(m,""+x)}}function Nt(d,m,x,T){if(T===null)d.removeAttribute(x);else{switch(typeof T){case"undefined":case"function":case"symbol":case"boolean":d.removeAttribute(x);return}d.setAttributeNS(m,x,""+T)}}var sn,un;function ln(d){if(sn===void 0)try{throw Error()}catch(x){var m=x.stack.trim().match(/\n( *(at )?)/);sn=m&&m[1]||"",un=-1<x.stack.indexOf(`
    at`)?" (<anonymous>)":-1<x.stack.indexOf("@")?"@unknown:0:0":""}return`
`+sn+d+un}var Dn=!1;function Un(d,m){if(!d||Dn)return"";Dn=!0;var x=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var T={DetermineComponentFrameRoot:function(){try{if(m){var Rt=function(){throw Error()};if(Object.defineProperty(Rt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Rt,[])}catch(lt){var at=lt}Reflect.construct(d,[],Rt)}else{try{Rt.call()}catch(lt){at=lt}d.call(Rt.prototype)}}else{try{throw Error()}catch(lt){at=lt}(Rt=d())&&typeof Rt.catch=="function"&&Rt.catch(function(){})}}catch(lt){if(lt&&at&&typeof lt.stack=="string")return[lt.stack,at.stack]}return[null,null]}};T.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var L=Object.getOwnPropertyDescriptor(T.DetermineComponentFrameRoot,"name");L&&L.configurable&&Object.defineProperty(T.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var z=T.DetermineComponentFrameRoot(),te=z[0],le=z[1];if(te&&le){var Ce=te.split(`
`),it=le.split(`
`);for(L=T=0;T<Ce.length&&!Ce[T].includes("DetermineComponentFrameRoot");)T++;for(;L<it.length&&!it[L].includes("DetermineComponentFrameRoot");)L++;if(T===Ce.length||L===it.length)for(T=Ce.length-1,L=it.length-1;1<=T&&0<=L&&Ce[T]!==it[L];)L--;for(;1<=T&&0<=L;T--,L--)if(Ce[T]!==it[L]){if(T!==1||L!==1)do if(T--,L--,0>L||Ce[T]!==it[L]){var Ct=`
`+Ce[T].replace(" at new "," at ");return d.displayName&&Ct.includes("<anonymous>")&&(Ct=Ct.replace("<anonymous>",d.displayName)),Ct}while(1<=T&&0<=L);break}}}finally{Dn=!1,Error.prepareStackTrace=x}return(x=d?d.displayName||d.name:"")?ln(x):""}function Mn(d){switch(d.tag){case 26:case 27:case 5:return ln(d.type);case 16:return ln("Lazy");case 13:return ln("Suspense");case 19:return ln("SuspenseList");case 0:case 15:return Un(d.type,!1);case 11:return Un(d.type.render,!1);case 1:return Un(d.type,!0);case 31:return ln("Activity");default:return""}}function Ai(d){try{var m="";do m+=Mn(d),d=d.return;while(d);return m}catch(x){return`
Error generating stack: `+x.message+`
`+x.stack}}function Yn(d){switch(typeof d){case"bigint":case"boolean":case"number":case"string":case"undefined":return d;case"object":return d;default:return""}}function ys(d){var m=d.type;return(d=d.nodeName)&&d.toLowerCase()==="input"&&(m==="checkbox"||m==="radio")}function ss(d){var m=ys(d)?"checked":"value",x=Object.getOwnPropertyDescriptor(d.constructor.prototype,m),T=""+d[m];if(!d.hasOwnProperty(m)&&typeof x<"u"&&typeof x.get=="function"&&typeof x.set=="function"){var L=x.get,z=x.set;return Object.defineProperty(d,m,{configurable:!0,get:function(){return L.call(this)},set:function(te){T=""+te,z.call(this,te)}}),Object.defineProperty(d,m,{enumerable:x.enumerable}),{getValue:function(){return T},setValue:function(te){T=""+te},stopTracking:function(){d._valueTracker=null,delete d[m]}}}}function ei(d){d._valueTracker||(d._valueTracker=ss(d))}function Fs(d){if(!d)return!1;var m=d._valueTracker;if(!m)return!0;var x=m.getValue(),T="";return d&&(T=ys(d)?d.checked?"true":"false":d.value),d=T,d!==x?(m.setValue(d),!0):!1}function xn(d){if(d=d||(typeof document<"u"?document:void 0),typeof d>"u")return null;try{return d.activeElement||d.body}catch{return d.body}}var Ec=/[\n"\\]/g;function Qn(d){return d.replace(Ec,function(m){return"\\"+m.charCodeAt(0).toString(16)+" "})}function Ws(d,m,x,T,L,z,te,le){d.name="",te!=null&&typeof te!="function"&&typeof te!="symbol"&&typeof te!="boolean"?d.type=te:d.removeAttribute("type"),m!=null?te==="number"?(m===0&&d.value===""||d.value!=m)&&(d.value=""+Yn(m)):d.value!==""+Yn(m)&&(d.value=""+Yn(m)):te!=="submit"&&te!=="reset"||d.removeAttribute("value"),m!=null?Ia(d,te,Yn(m)):x!=null?Ia(d,te,Yn(x)):T!=null&&d.removeAttribute("value"),L==null&&z!=null&&(d.defaultChecked=!!z),L!=null&&(d.checked=L&&typeof L!="function"&&typeof L!="symbol"),le!=null&&typeof le!="function"&&typeof le!="symbol"&&typeof le!="boolean"?d.name=""+Yn(le):d.removeAttribute("name")}function Sr(d,m,x,T,L,z,te,le){if(z!=null&&typeof z!="function"&&typeof z!="symbol"&&typeof z!="boolean"&&(d.type=z),m!=null||x!=null){if(!(z!=="submit"&&z!=="reset"||m!=null))return;x=x!=null?""+Yn(x):"",m=m!=null?""+Yn(m):x,le||m===d.value||(d.value=m),d.defaultValue=m}T=T??L,T=typeof T!="function"&&typeof T!="symbol"&&!!T,d.checked=le?d.checked:!!T,d.defaultChecked=!!T,te!=null&&typeof te!="function"&&typeof te!="symbol"&&typeof te!="boolean"&&(d.name=te)}function Ia(d,m,x){m==="number"&&xn(d.ownerDocument)===d||d.defaultValue===""+x||(d.defaultValue=""+x)}function Xr(d,m,x,T){if(d=d.options,m){m={};for(var L=0;L<x.length;L++)m["$"+x[L]]=!0;for(x=0;x<d.length;x++)L=m.hasOwnProperty("$"+d[x].value),d[x].selected!==L&&(d[x].selected=L),L&&T&&(d[x].defaultSelected=!0)}else{for(x=""+Yn(x),m=null,L=0;L<d.length;L++){if(d[L].value===x){d[L].selected=!0,T&&(d[L].defaultSelected=!0);return}m!==null||d[L].disabled||(m=d[L])}m!==null&&(m.selected=!0)}}function Si(d,m,x){if(m!=null&&(m=""+Yn(m),m!==d.value&&(d.value=m),x==null)){d.defaultValue!==m&&(d.defaultValue=m);return}d.defaultValue=x!=null?""+Yn(x):""}function Cs(d,m,x,T){if(m==null){if(T!=null){if(x!=null)throw Error(a(92));if(rt(T)){if(1<T.length)throw Error(a(93));T=T[0]}x=T}x==null&&(x=""),m=x}x=Yn(m),d.defaultValue=x,T=d.textContent,T===x&&T!==""&&T!==null&&(d.value=T)}function sr(d,m){if(m){var x=d.firstChild;if(x&&x===d.lastChild&&x.nodeType===3){x.nodeValue=m;return}}d.textContent=m}var vs=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function lo(d,m,x){var T=m.indexOf("--")===0;x==null||typeof x=="boolean"||x===""?T?d.setProperty(m,""):m==="float"?d.cssFloat="":d[m]="":T?d.setProperty(m,x):typeof x!="number"||x===0||vs.has(m)?m==="float"?d.cssFloat=x:d[m]=(""+x).trim():d[m]=x+"px"}function co(d,m,x){if(m!=null&&typeof m!="object")throw Error(a(62));if(d=d.style,x!=null){for(var T in x)!x.hasOwnProperty(T)||m!=null&&m.hasOwnProperty(T)||(T.indexOf("--")===0?d.setProperty(T,""):T==="float"?d.cssFloat="":d[T]="");for(var L in m)T=m[L],m.hasOwnProperty(L)&&x[L]!==T&&lo(d,L,T)}else for(var z in m)m.hasOwnProperty(z)&&lo(d,z,m[z])}function Eu(d){if(d.indexOf("-")===-1)return!1;switch(d){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var of=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),lf=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Su(d){return lf.test(""+d)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":d}var Lh=null;function Nh(d){return d=d.target||d.srcElement||window,d.correspondingUseElement&&(d=d.correspondingUseElement),d.nodeType===3?d.parentNode:d}var Dh=null,Ll=null;function Nm(d){var m=Sa(d);if(m&&(d=m.stateNode)){var x=d[ir]||null;e:switch(d=m.stateNode,m.type){case"input":if(Ws(d,x.value,x.defaultValue,x.defaultValue,x.checked,x.defaultChecked,x.type,x.name),m=x.name,x.type==="radio"&&m!=null){for(x=d;x.parentNode;)x=x.parentNode;for(x=x.querySelectorAll('input[name="'+Qn(""+m)+'"][type="radio"]'),m=0;m<x.length;m++){var T=x[m];if(T!==d&&T.form===d.form){var L=T[ir]||null;if(!L)throw Error(a(90));Ws(T,L.value,L.defaultValue,L.defaultValue,L.checked,L.defaultChecked,L.type,L.name)}}for(m=0;m<x.length;m++)T=x[m],T.form===d.form&&Fs(T)}break e;case"textarea":Si(d,x.value,x.defaultValue);break e;case"select":m=x.value,m!=null&&Xr(d,!!x.multiple,m,!1)}}}var Fh=!1;function Oh(d,m,x){if(Fh)return d(m,x);Fh=!0;try{var T=d(m);return T}finally{if(Fh=!1,(Dh!==null||Ll!==null)&&(qi(),Dh&&(m=Dh,d=Ll,Ll=Dh=null,Nm(m),d)))for(m=0;m<d.length;m++)Nm(d[m])}}function Sc(d,m){var x=d.stateNode;if(x===null)return null;var T=x[ir]||null;if(T===null)return null;x=T[m];e:switch(m){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(T=!T.disabled)||(d=d.type,T=!(d==="button"||d==="input"||d==="select"||d==="textarea")),d=!T;break e;default:d=!1}if(d)return null;if(x&&typeof x!="function")throw Error(a(231,m,typeof x));return x}var No=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Gh=!1;if(No)try{var Iu={};Object.defineProperty(Iu,"passive",{get:function(){Gh=!0}}),window.addEventListener("test",Iu,Iu),window.removeEventListener("test",Iu,Iu)}catch{Gh=!1}var Nl=null,Uh=null,Tu=null;function Ph(){if(Tu)return Tu;var d,m=Uh,x=m.length,T,L="value"in Nl?Nl.value:Nl.textContent,z=L.length;for(d=0;d<x&&m[d]===L[d];d++);var te=x-d;for(T=1;T<=te&&m[x-T]===L[z-T];T++);return Tu=L.slice(d,1<T?1-T:void 0)}function Mu(d){var m=d.keyCode;return"charCode"in d?(d=d.charCode,d===0&&m===13&&(d=13)):d=m,d===10&&(d=13),32<=d||d===13?d:0}function Ic(){return!0}function cA(){return!1}function dr(d){function m(x,T,L,z,te){this._reactName=x,this._targetInst=L,this.type=T,this.nativeEvent=z,this.target=te,this.currentTarget=null;for(var le in d)d.hasOwnProperty(le)&&(x=d[le],this[le]=x?x(z):z[le]);return this.isDefaultPrevented=(z.defaultPrevented!=null?z.defaultPrevented:z.returnValue===!1)?Ic:cA,this.isPropagationStopped=cA,this}return I(m.prototype,{preventDefault:function(){this.defaultPrevented=!0;var x=this.nativeEvent;x&&(x.preventDefault?x.preventDefault():typeof x.returnValue!="unknown"&&(x.returnValue=!1),this.isDefaultPrevented=Ic)},stopPropagation:function(){var x=this.nativeEvent;x&&(x.stopPropagation?x.stopPropagation():typeof x.cancelBubble!="unknown"&&(x.cancelBubble=!0),this.isPropagationStopped=Ic)},persist:function(){},isPersistent:Ic}),m}var sl={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(d){return d.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},_u=dr(sl),Ru=I({},sl,{view:0,detail:0}),uA=dr(Ru),cf,zh,Tc,ku=I({},Ru,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Bu,button:0,buttons:0,relatedTarget:function(d){return d.relatedTarget===void 0?d.fromElement===d.srcElement?d.toElement:d.fromElement:d.relatedTarget},movementX:function(d){return"movementX"in d?d.movementX:(d!==Tc&&(Tc&&d.type==="mousemove"?(cf=d.screenX-Tc.screenX,zh=d.screenY-Tc.screenY):zh=cf=0,Tc=d),cf)},movementY:function(d){return"movementY"in d?d.movementY:zh}}),uf=dr(ku),hf=I({},ku,{dataTransfer:0}),Dm=dr(hf),Fm=I({},Ru,{relatedTarget:0}),Om=dr(Fm),$v=I({},sl,{animationName:0,elapsedTime:0,pseudoElement:0}),hA=dr($v),dA=I({},sl,{clipboardData:function(d){return"clipboardData"in d?d.clipboardData:window.clipboardData}}),df=dr(dA),ff=I({},sl,{data:0}),pf=dr(ff),Gm={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fA={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Um={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function pA(d){var m=this.nativeEvent;return m.getModifierState?m.getModifierState(d):(d=Um[d])?!!m[d]:!1}function Bu(){return pA}var Pm=I({},Ru,{key:function(d){if(d.key){var m=Gm[d.key]||d.key;if(m!=="Unidentified")return m}return d.type==="keypress"?(d=Mu(d),d===13?"Enter":String.fromCharCode(d)):d.type==="keydown"||d.type==="keyup"?fA[d.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Bu,charCode:function(d){return d.type==="keypress"?Mu(d):0},keyCode:function(d){return d.type==="keydown"||d.type==="keyup"?d.keyCode:0},which:function(d){return d.type==="keypress"?Mu(d):d.type==="keydown"||d.type==="keyup"?d.keyCode:0}}),mf=dr(Pm),gf=I({},ku,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),mA=dr(gf),Yv=I({},Ru,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Bu}),zm=dr(Yv),Af=I({},sl,{propertyName:0,elapsedTime:0,pseudoElement:0}),Vm=dr(Af),bf=I({},ku,{deltaX:function(d){return"deltaX"in d?d.deltaX:"wheelDeltaX"in d?-d.wheelDeltaX:0},deltaY:function(d){return"deltaY"in d?d.deltaY:"wheelDeltaY"in d?-d.wheelDeltaY:"wheelDelta"in d?-d.wheelDelta:0},deltaZ:0,deltaMode:0}),yf=dr(bf),vf=I({},sl,{newState:0,oldState:0}),xf=dr(vf),wf=[9,13,27,32],Lu=No&&"CompositionEvent"in window,Mc=null;No&&"documentMode"in document&&(Mc=document.documentMode);var Wm=No&&"TextEvent"in window&&!Mc,Cf=No&&(!Lu||Mc&&8<Mc&&11>=Mc),Ef=" ",gA=!1;function AA(d,m){switch(d){case"keyup":return wf.indexOf(m.keyCode)!==-1;case"keydown":return m.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function bA(d){return d=d.detail,typeof d=="object"&&"data"in d?d.data:null}var Nu=!1;function jv(d,m){switch(d){case"compositionend":return bA(m);case"keypress":return m.which!==32?null:(gA=!0,Ef);case"textInput":return d=m.data,d===Ef&&gA?null:d;default:return null}}function Sf(d,m){if(Nu)return d==="compositionend"||!Lu&&AA(d,m)?(d=Ph(),Tu=Uh=Nl=null,Nu=!1,d):null;switch(d){case"paste":return null;case"keypress":if(!(m.ctrlKey||m.altKey||m.metaKey)||m.ctrlKey&&m.altKey){if(m.char&&1<m.char.length)return m.char;if(m.which)return String.fromCharCode(m.which)}return null;case"compositionend":return Cf&&m.locale!=="ko"?null:m.data;default:return null}}var yA={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Hm(d){var m=d&&d.nodeName&&d.nodeName.toLowerCase();return m==="input"?!!yA[d.type]:m==="textarea"}function vA(d,m,x,T){Dh?Ll?Ll.push(T):Ll=[T]:Dh=T,m=kg(m,"onChange"),0<m.length&&(x=new _u("onChange","change",null,x,T),d.push({event:x,listeners:m}))}var Vh=null,Wh=null;function If(d){m1(d,0)}function _c(d){var m=ko(d);if(Fs(m))return d}function Hh(d,m){if(d==="change")return m}var Xh=!1;if(No){var Tf;if(No){var Mf="oninput"in document;if(!Mf){var Du=document.createElement("div");Du.setAttribute("oninput","return;"),Mf=typeof Du.oninput=="function"}Tf=Mf}else Tf=!1;Xh=Tf&&(!document.documentMode||9<document.documentMode)}function Xm(){Vh&&(Vh.detachEvent("onpropertychange",_f),Wh=Vh=null)}function _f(d){if(d.propertyName==="value"&&_c(Wh)){var m=[];vA(m,Wh,d,Nh(d)),Oh(If,m)}}function Qm(d,m,x){d==="focusin"?(Xm(),Vh=m,Wh=x,Vh.attachEvent("onpropertychange",_f)):d==="focusout"&&Xm()}function Km(d){if(d==="selectionchange"||d==="keyup"||d==="keydown")return _c(Wh)}function Rf(d,m){if(d==="click")return _c(m)}function xA(d,m){if(d==="input"||d==="change")return _c(m)}function wA(d,m){return d===m&&(d!==0||1/d===1/m)||d!==d&&m!==m}var Gr=typeof Object.is=="function"?Object.is:wA;function Rc(d,m){if(Gr(d,m))return!0;if(typeof d!="object"||d===null||typeof m!="object"||m===null)return!1;var x=Object.keys(d),T=Object.keys(m);if(x.length!==T.length)return!1;for(T=0;T<x.length;T++){var L=x[T];if(!vt.call(m,L)||!Gr(d[L],m[L]))return!1}return!0}function CA(d){for(;d&&d.firstChild;)d=d.firstChild;return d}function sa(d,m){var x=CA(d);d=0;for(var T;x;){if(x.nodeType===3){if(T=d+x.textContent.length,d<=m&&T>=m)return{node:x,offset:m-d};d=T}e:{for(;x;){if(x.nextSibling){x=x.nextSibling;break e}x=x.parentNode}x=void 0}x=CA(x)}}function qv(d,m){return d&&m?d===m?!0:d&&d.nodeType===3?!1:m&&m.nodeType===3?qv(d,m.parentNode):"contains"in d?d.contains(m):d.compareDocumentPosition?!!(d.compareDocumentPosition(m)&16):!1:!1}function kf(d){d=d!=null&&d.ownerDocument!=null&&d.ownerDocument.defaultView!=null?d.ownerDocument.defaultView:window;for(var m=xn(d.document);m instanceof d.HTMLIFrameElement;){try{var x=typeof m.contentWindow.location.href=="string"}catch{x=!1}if(x)d=m.contentWindow;else break;m=xn(d.document)}return m}function Bf(d){var m=d&&d.nodeName&&d.nodeName.toLowerCase();return m&&(m==="input"&&(d.type==="text"||d.type==="search"||d.type==="tel"||d.type==="url"||d.type==="password")||m==="textarea"||d.contentEditable==="true")}var EA=No&&"documentMode"in document&&11>=document.documentMode,Fu=null,Zm=null,Ir=null,SA=!1;function IA(d,m,x){var T=x.window===x?x.document:x.nodeType===9?x:x.ownerDocument;SA||Fu==null||Fu!==xn(T)||(T=Fu,"selectionStart"in T&&Bf(T)?T={start:T.selectionStart,end:T.selectionEnd}:(T=(T.ownerDocument&&T.ownerDocument.defaultView||window).getSelection(),T={anchorNode:T.anchorNode,anchorOffset:T.anchorOffset,focusNode:T.focusNode,focusOffset:T.focusOffset}),Ir&&Rc(Ir,T)||(Ir=T,T=kg(Zm,"onSelect"),0<T.length&&(m=new _u("onSelect","select",null,m,x),d.push({event:m,listeners:T}),m.target=Fu)))}function ra(d,m){var x={};return x[d.toLowerCase()]=m.toLowerCase(),x["Webkit"+d]="webkit"+m,x["Moz"+d]="moz"+m,x}var Qh={animationend:ra("Animation","AnimationEnd"),animationiteration:ra("Animation","AnimationIteration"),animationstart:ra("Animation","AnimationStart"),transitionrun:ra("Transition","TransitionRun"),transitionstart:ra("Transition","TransitionStart"),transitioncancel:ra("Transition","TransitionCancel"),transitionend:ra("Transition","TransitionEnd")},Lf={},Ta={};No&&(Ta=document.createElement("div").style,"AnimationEvent"in window||(delete Qh.animationend.animation,delete Qh.animationiteration.animation,delete Qh.animationstart.animation),"TransitionEvent"in window||delete Qh.transitionend.transition);function Oi(d){if(Lf[d])return Lf[d];if(!Qh[d])return d;var m=Qh[d],x;for(x in m)if(m.hasOwnProperty(x)&&x in Ta)return Lf[d]=m[x];return d}var Qr=Oi("animationend"),TA=Oi("animationiteration"),MA=Oi("animationstart"),Ou=Oi("transitionrun"),uo=Oi("transitionstart"),ds=Oi("transitioncancel"),Nf=Oi("transitionend"),$m=new Map,Ma="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Ma.push("scrollEnd");function ho(d,m){$m.set(d,m),Lo(m,[d])}var Jv=new WeakMap;function Tr(d,m){if(typeof d=="object"&&d!==null){var x=Jv.get(d);return x!==void 0?x:(m={value:d,source:m,stack:Ai(m)},Jv.set(d,m),m)}return{value:d,source:m,stack:Ai(m)}}var _a=[],Gu=0,Ym=0;function Kr(){for(var d=Gu,m=Ym=Gu=0;m<d;){var x=_a[m];_a[m++]=null;var T=_a[m];_a[m++]=null;var L=_a[m];_a[m++]=null;var z=_a[m];if(_a[m++]=null,T!==null&&L!==null){var te=T.pending;te===null?L.next=L:(L.next=te.next,te.next=L),T.pending=L}z!==0&&jm(x,L,z)}}function rl(d,m,x,T){_a[Gu++]=d,_a[Gu++]=m,_a[Gu++]=x,_a[Gu++]=T,Ym|=T,d.lanes|=T,d=d.alternate,d!==null&&(d.lanes|=T)}function kc(d,m,x,T){return rl(d,m,x,T),Df(d)}function Uu(d,m){return rl(d,null,null,m),Df(d)}function jm(d,m,x){d.lanes|=x;var T=d.alternate;T!==null&&(T.lanes|=x);for(var L=!1,z=d.return;z!==null;)z.childLanes|=x,T=z.alternate,T!==null&&(T.childLanes|=x),z.tag===22&&(d=z.stateNode,d===null||d._visibility&1||(L=!0)),d=z,z=z.return;return d.tag===3?(z=d.stateNode,L&&m!==null&&(L=31-ut(x),d=z.hiddenUpdates,T=d[L],T===null?d[L]=[m]:T.push(m),m.lane=x|536870912),z):null}function Df(d){if(50<ha)throw ha=0,gb=null,Error(a(185));for(var m=d.return;m!==null;)d=m,m=d.return;return d.tag===3?d.stateNode:null}var Pu={};function aa(d,m,x,T){this.tag=d,this.key=x,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=m,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=T,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ht(d,m,x,T){return new aa(d,m,x,T)}function _A(d){return d=d.prototype,!(!d||!d.isReactComponent)}function Zr(d,m){var x=d.alternate;return x===null?(x=Ht(d.tag,m,d.key,d.mode),x.elementType=d.elementType,x.type=d.type,x.stateNode=d.stateNode,x.alternate=d,d.alternate=x):(x.pendingProps=m,x.type=d.type,x.flags=0,x.subtreeFlags=0,x.deletions=null),x.flags=d.flags&65011712,x.childLanes=d.childLanes,x.lanes=d.lanes,x.child=d.child,x.memoizedProps=d.memoizedProps,x.memoizedState=d.memoizedState,x.updateQueue=d.updateQueue,m=d.dependencies,x.dependencies=m===null?null:{lanes:m.lanes,firstContext:m.firstContext},x.sibling=d.sibling,x.index=d.index,x.ref=d.ref,x.refCleanup=d.refCleanup,x}function Ff(d,m){d.flags&=65011714;var x=d.alternate;return x===null?(d.childLanes=0,d.lanes=m,d.child=null,d.subtreeFlags=0,d.memoizedProps=null,d.memoizedState=null,d.updateQueue=null,d.dependencies=null,d.stateNode=null):(d.childLanes=x.childLanes,d.lanes=x.lanes,d.child=x.child,d.subtreeFlags=0,d.deletions=null,d.memoizedProps=x.memoizedProps,d.memoizedState=x.memoizedState,d.updateQueue=x.updateQueue,d.type=x.type,m=x.dependencies,d.dependencies=m===null?null:{lanes:m.lanes,firstContext:m.firstContext}),d}function Of(d,m,x,T,L,z){var te=0;if(T=d,typeof d=="function")_A(d)&&(te=1);else if(typeof d=="string")te=OS(d,x,bt.current)?26:d==="html"||d==="head"||d==="body"?27:5;else e:switch(d){case Y:return d=Ht(31,x,m,L),d.elementType=Y,d.lanes=z,d;case G:return Ra(x.children,L,z,m);case N:te=8,L|=24;break;case O:return d=Ht(12,x,m,L|2),d.elementType=O,d.lanes=z,d;case j:return d=Ht(13,x,m,L),d.elementType=j,d.lanes=z,d;case J:return d=Ht(19,x,m,L),d.elementType=J,d.lanes=z,d;default:if(typeof d=="object"&&d!==null)switch(d.$$typeof){case D:case H:te=10;break e;case W:te=9;break e;case K:te=11;break e;case ee:te=14;break e;case re:te=16,T=null;break e}te=29,x=Error(a(130,d===null?"null":typeof d,"")),T=null}return m=Ht(te,x,m,L),m.elementType=d,m.type=T,m.lanes=z,m}function Ra(d,m,x,T){return d=Ht(7,d,T,m),d.lanes=x,d}function fr(d,m,x){return d=Ht(6,d,null,m),d.lanes=x,d}function Gf(d,m,x){return m=Ht(4,d.children!==null?d.children:[],d.key,m),m.lanes=x,m.stateNode={containerInfo:d.containerInfo,pendingChildren:null,implementation:d.implementation},m}var zu=[],Gi=0,Uf=null,Os=0,rr=[],fo=0,al=null,Dl=1,Fl="";function Vu(d,m){zu[Gi++]=Os,zu[Gi++]=Uf,Uf=d,Os=m}function RA(d,m,x){rr[fo++]=Dl,rr[fo++]=Fl,rr[fo++]=al,al=d;var T=Dl;d=Fl;var L=32-ut(T)-1;T&=~(1<<L),x+=1;var z=32-ut(m)+L;if(30<z){var te=L-L%5;z=(T&(1<<te)-1).toString(32),T>>=te,L-=te,Dl=1<<32-ut(m)+L|x<<L|T,Fl=z+d}else Dl=1<<z|x<<L|T,Fl=d}function Do(d){d.return!==null&&(Vu(d,1),RA(d,1,0))}function kA(d){for(;d===Uf;)Uf=zu[--Gi],zu[Gi]=null,Os=zu[--Gi],zu[Gi]=null;for(;d===al;)al=rr[--fo],rr[fo]=null,Fl=rr[--fo],rr[fo]=null,Dl=rr[--fo],rr[fo]=null}var Gs=null,wi=null,ri=!1,oa=null,ol=!1,BA=Error(a(519));function Wu(d){var m=Error(a(418,""));throw Pf(Tr(m,d)),BA}function ex(d){var m=d.stateNode,x=d.type,T=d.memoizedProps;switch(m[Ts]=d,m[ir]=T,x){case"dialog":xi("cancel",m),xi("close",m);break;case"iframe":case"object":case"embed":xi("load",m);break;case"video":case"audio":for(x=0;x<Ad.length;x++)xi(Ad[x],m);break;case"source":xi("error",m);break;case"img":case"image":case"link":xi("error",m),xi("load",m);break;case"details":xi("toggle",m);break;case"input":xi("invalid",m),Sr(m,T.value,T.defaultValue,T.checked,T.defaultChecked,T.type,T.name,!0),ei(m);break;case"select":xi("invalid",m);break;case"textarea":xi("invalid",m),Cs(m,T.value,T.defaultValue,T.children),ei(m)}x=T.children,typeof x!="string"&&typeof x!="number"&&typeof x!="bigint"||m.textContent===""+x||T.suppressHydrationWarning===!0||Yl(m.textContent,x)?(T.popover!=null&&(xi("beforetoggle",m),xi("toggle",m)),T.onScroll!=null&&xi("scroll",m),T.onScrollEnd!=null&&xi("scrollend",m),T.onClick!=null&&(m.onclick=Lg),m=!0):m=!1,m||Wu(d)}function tx(d){for(Gs=d.return;Gs;)switch(Gs.tag){case 5:case 13:ol=!1;return;case 27:case 3:ol=!0;return;default:Gs=Gs.return}}function Kh(d){if(d!==Gs)return!1;if(!ri)return tx(d),ri=!0,!1;var m=d.tag,x;if((x=m!==3&&m!==27)&&((x=m===5)&&(x=d.type,x=!(x!=="form"&&x!=="button")||Ib(d.type,d.memoizedProps)),x=!x),x&&wi&&Wu(d),tx(d),m===13){if(d=d.memoizedState,d=d!==null?d.dehydrated:null,!d)throw Error(a(317));e:{for(d=d.nextSibling,m=0;d;){if(d.nodeType===8)if(x=d.data,x==="/$"){if(m===0){wi=Ha(d.nextSibling);break e}m--}else x!=="$"&&x!=="$!"&&x!=="$?"||m++;d=d.nextSibling}wi=null}}else m===27?(m=wi,jc(d.type)?(d=Rb,Rb=null,wi=d):wi=m):wi=Gs?Ha(d.stateNode.nextSibling):null;return!0}function Ol(){wi=Gs=null,ri=!1}function qm(){var d=oa;return d!==null&&(ua===null?ua=d:ua.push.apply(ua,d),oa=null),d}function Pf(d){oa===null?oa=[d]:oa.push(d)}var LA=Ve(null),Fo=null,ll=null;function Oo(d,m,x){gt(LA,m._currentValue),m._currentValue=x}function ka(d){d._currentValue=LA.current,Ne(LA)}function Hs(d,m,x){for(;d!==null;){var T=d.alternate;if((d.childLanes&m)!==m?(d.childLanes|=m,T!==null&&(T.childLanes|=m)):T!==null&&(T.childLanes&m)!==m&&(T.childLanes|=m),d===x)break;d=d.return}}function Ba(d,m,x,T){var L=d.child;for(L!==null&&(L.return=d);L!==null;){var z=L.dependencies;if(z!==null){var te=L.child;z=z.firstContext;e:for(;z!==null;){var le=z;z=L;for(var Ce=0;Ce<m.length;Ce++)if(le.context===m[Ce]){z.lanes|=x,le=z.alternate,le!==null&&(le.lanes|=x),Hs(z.return,x,d),T||(te=null);break e}z=le.next}}else if(L.tag===18){if(te=L.return,te===null)throw Error(a(341));te.lanes|=x,z=te.alternate,z!==null&&(z.lanes|=x),Hs(te,x,d),te=null}else te=L.child;if(te!==null)te.return=L;else for(te=L;te!==null;){if(te===d){te=null;break}if(L=te.sibling,L!==null){L.return=te.return,te=L;break}te=te.return}L=te}}function cl(d,m,x,T){d=null;for(var L=m,z=!1;L!==null;){if(!z){if((L.flags&524288)!==0)z=!0;else if((L.flags&262144)!==0)break}if(L.tag===10){var te=L.alternate;if(te===null)throw Error(a(387));if(te=te.memoizedProps,te!==null){var le=L.type;Gr(L.pendingProps.value,te.value)||(d!==null?d.push(le):d=[le])}}else if(L===Vt.current){if(te=L.alternate,te===null)throw Error(a(387));te.memoizedState.memoizedState!==L.memoizedState.memoizedState&&(d!==null?d.push(wd):d=[wd])}L=L.return}d!==null&&Ba(m,d,x,T),m.flags|=262144}function Jm(d){for(d=d.firstContext;d!==null;){if(!Gr(d.context._currentValue,d.memoizedValue))return!0;d=d.next}return!1}function Hu(d){Fo=d,ll=null,d=d.dependencies,d!==null&&(d.firstContext=null)}function Ci(d){return zf(Fo,d)}function dt(d,m){return Fo===null&&Hu(d),zf(d,m)}function zf(d,m){var x=m._currentValue;if(m={context:m,memoizedValue:x,next:null},ll===null){if(d===null)throw Error(a(308));ll=m,d.dependencies={lanes:0,firstContext:m},d.flags|=524288}else ll=ll.next=m;return x}var nx=typeof AbortController<"u"?AbortController:function(){var d=[],m=this.signal={aborted:!1,addEventListener:function(x,T){d.push(T)}};this.abort=function(){m.aborted=!0,d.forEach(function(x){return x()})}},NA=r.unstable_scheduleCallback,DA=r.unstable_NormalPriority,Xs={$$typeof:H,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Vf(){return{controller:new nx,data:new Map,refCount:0}}function Wf(d){d.refCount--,d.refCount===0&&NA(DA,function(){d.controller.abort()})}var ar=null,Hf=0,rs=0,Xu=null;function ix(d,m){if(ar===null){var x=ar=[];Hf=0,rs=Yc(),Xu={status:"pending",value:void 0,then:function(T){x.push(T)}}}return Hf++,m.then(sx,sx),m}function sx(){if(--Hf===0&&ar!==null){Xu!==null&&(Xu.status="fulfilled");var d=ar;ar=null,rs=0,Xu=null;for(var m=0;m<d.length;m++)(0,d[m])()}}function FA(d,m){var x=[],T={status:"pending",value:null,reason:null,then:function(L){x.push(L)}};return d.then(function(){T.status="fulfilled",T.value=m;for(var L=0;L<x.length;L++)(0,x[L])(m)},function(L){for(T.status="rejected",T.reason=L,L=0;L<x.length;L++)(0,x[L])(void 0)}),T}var OA=de.S;de.S=function(d,m){typeof m=="object"&&m!==null&&typeof m.then=="function"&&ix(d,m),OA!==null&&OA(d,m)};var po=Ve(null);function GA(){var d=po.current;return d!==null?d:ps.pooledCache}function Xf(d,m){m===null?gt(po,po.current):gt(po,m.pool)}function ze(){var d=GA();return d===null?null:{parent:Xs._currentValue,pool:d}}var Qf=Error(a(460)),rx=Error(a(474)),Kf=Error(a(542)),eg={then:function(){}};function $r(d){return d=d.status,d==="fulfilled"||d==="rejected"}function Bc(){}function UA(d,m,x){switch(x=d[x],x===void 0?d.push(m):x!==m&&(m.then(Bc,Bc),m=x),m.status){case"fulfilled":return m.value;case"rejected":throw d=m.reason,PA(d),d;default:if(typeof m.status=="string")m.then(Bc,Bc);else{if(d=ps,d!==null&&100<d.shellSuspendCounter)throw Error(a(482));d=m,d.status="pending",d.then(function(T){if(m.status==="pending"){var L=m;L.status="fulfilled",L.value=T}},function(T){if(m.status==="pending"){var L=m;L.status="rejected",L.reason=T}})}switch(m.status){case"fulfilled":return m.value;case"rejected":throw d=m.reason,PA(d),d}throw Zh=m,Qf}}var Zh=null;function Se(){if(Zh===null)throw Error(a(459));var d=Zh;return Zh=null,d}function PA(d){if(d===Qf||d===Kf)throw Error(a(483))}var Lc=!1;function Qe(d){d.updateQueue={baseState:d.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function zA(d,m){d=d.updateQueue,m.updateQueue===d&&(m.updateQueue={baseState:d.baseState,firstBaseUpdate:d.firstBaseUpdate,lastBaseUpdate:d.lastBaseUpdate,shared:d.shared,callbacks:null})}function La(d){return{lane:d,tag:0,payload:null,callback:null,next:null}}function mo(d,m,x){var T=d.updateQueue;if(T===null)return null;if(T=T.shared,(Zi&2)!==0){var L=T.pending;return L===null?m.next=m:(m.next=L.next,L.next=m),T.pending=m,m=Df(d),jm(d,null,x),m}return rl(d,T,m,x),Df(d)}function Ur(d,m,x){if(m=m.updateQueue,m!==null&&(m=m.shared,(x&4194048)!==0)){var T=m.lanes;T&=d.pendingLanes,x|=T,m.lanes=x,Vn(d,x)}}function tg(d,m){var x=d.updateQueue,T=d.alternate;if(T!==null&&(T=T.updateQueue,x===T)){var L=null,z=null;if(x=x.firstBaseUpdate,x!==null){do{var te={lane:x.lane,tag:x.tag,payload:x.payload,callback:null,next:null};z===null?L=z=te:z=z.next=te,x=x.next}while(x!==null);z===null?L=z=m:z=z.next=m}else L=z=m;x={baseState:T.baseState,firstBaseUpdate:L,lastBaseUpdate:z,shared:T.shared,callbacks:T.callbacks},d.updateQueue=x;return}d=x.lastBaseUpdate,d===null?x.firstBaseUpdate=m:d.next=m,x.lastBaseUpdate=m}var ng=!1;function Zf(){if(ng){var d=Xu;if(d!==null)throw d}}function Qu(d,m,x,T){ng=!1;var L=d.updateQueue;Lc=!1;var z=L.firstBaseUpdate,te=L.lastBaseUpdate,le=L.shared.pending;if(le!==null){L.shared.pending=null;var Ce=le,it=Ce.next;Ce.next=null,te===null?z=it:te.next=it,te=Ce;var Ct=d.alternate;Ct!==null&&(Ct=Ct.updateQueue,le=Ct.lastBaseUpdate,le!==te&&(le===null?Ct.firstBaseUpdate=it:le.next=it,Ct.lastBaseUpdate=Ce))}if(z!==null){var Rt=L.baseState;te=0,Ct=it=Ce=null,le=z;do{var at=le.lane&-536870913,lt=at!==le.lane;if(lt?(ki&at)===at:(T&at)===at){at!==0&&at===rs&&(ng=!0),Ct!==null&&(Ct=Ct.next={lane:0,tag:le.tag,payload:le.payload,callback:null,next:null});e:{var Fn=d,Pn=le;at=m;var Ji=x;switch(Pn.tag){case 1:if(Fn=Pn.payload,typeof Fn=="function"){Rt=Fn.call(Ji,Rt,at);break e}Rt=Fn;break e;case 3:Fn.flags=Fn.flags&-65537|128;case 0:if(Fn=Pn.payload,at=typeof Fn=="function"?Fn.call(Ji,Rt,at):Fn,at==null)break e;Rt=I({},Rt,at);break e;case 2:Lc=!0}}at=le.callback,at!==null&&(d.flags|=64,lt&&(d.flags|=8192),lt=L.callbacks,lt===null?L.callbacks=[at]:lt.push(at))}else lt={lane:at,tag:le.tag,payload:le.payload,callback:le.callback,next:null},Ct===null?(it=Ct=lt,Ce=Rt):Ct=Ct.next=lt,te|=at;if(le=le.next,le===null){if(le=L.shared.pending,le===null)break;lt=le,le=lt.next,lt.next=null,L.lastBaseUpdate=lt,L.shared.pending=null}}while(!0);Ct===null&&(Ce=Rt),L.baseState=Ce,L.firstBaseUpdate=it,L.lastBaseUpdate=Ct,z===null&&(L.shared.lanes=0),Kc|=te,d.lanes=te,d.memoizedState=Rt}}function VA(d,m){if(typeof d!="function")throw Error(a(191,d));d.call(m)}function ax(d,m){var x=d.callbacks;if(x!==null)for(d.callbacks=null,d=0;d<x.length;d++)VA(x[d],m)}var $h=Ve(null),ig=Ve(0);function WA(d,m){d=Kl,gt(ig,d),gt($h,m),Kl=d|m.baseLanes}function pr(){gt(ig,Kl),gt($h,$h.current)}function HA(){Kl=ig.current,Ne($h),Ne(ig)}var ul=0,ai=null,_i=null,as=null,$f=!1,Nc=!1,Na=!1,Yf=0,jf=0,Yh=null,iS=0;function Yi(){throw Error(a(321))}function Dc(d,m){if(m===null)return!1;for(var x=0;x<m.length&&x<d.length;x++)if(!Gr(d[x],m[x]))return!1;return!0}function sg(d,m,x,T,L,z){return ul=z,ai=m,m.memoizedState=null,m.updateQueue=null,m.lanes=0,de.H=d===null||d.memoizedState===null?np:ip,Na=!1,z=x(T,L),Na=!1,Nc&&(z=lx(m,x,T,L)),ox(d),z}function ox(d){de.H=Ku;var m=_i!==null&&_i.next!==null;if(ul=0,as=_i=ai=null,$f=!1,jf=0,Yh=null,m)throw Error(a(300));d===null||mr||(d=d.dependencies,d!==null&&Jm(d)&&(mr=!0))}function lx(d,m,x,T){ai=d;var L=0;do{if(Nc&&(Yh=null),jf=0,Nc=!1,25<=L)throw Error(a(301));if(L+=1,as=_i=null,d.updateQueue!=null){var z=d.updateQueue;z.lastEffect=null,z.events=null,z.stores=null,z.memoCache!=null&&(z.memoCache.index=0)}de.H=nb,z=m(x,T)}while(Nc);return z}function sS(){var d=de.H,m=d.useState()[0];return m=typeof m.then=="function"?jh(m):m,d=d.useState()[0],(_i!==null?_i.memoizedState:null)!==d&&(ai.flags|=1024),m}function XA(){var d=Yf!==0;return Yf=0,d}function rg(d,m,x){m.updateQueue=d.updateQueue,m.flags&=-2053,d.lanes&=~x}function ag(d){if($f){for(d=d.memoizedState;d!==null;){var m=d.queue;m!==null&&(m.pending=null),d=d.next}$f=!1}ul=0,as=_i=ai=null,Nc=!1,jf=Yf=0,Yh=null}function la(){var d={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return as===null?ai.memoizedState=as=d:as=as.next=d,as}function js(){if(_i===null){var d=ai.alternate;d=d!==null?d.memoizedState:null}else d=_i.next;var m=as===null?ai.memoizedState:as.next;if(m!==null)as=m,_i=d;else{if(d===null)throw ai.alternate===null?Error(a(467)):Error(a(310));_i=d,d={memoizedState:_i.memoizedState,baseState:_i.baseState,baseQueue:_i.baseQueue,queue:_i.queue,next:null},as===null?ai.memoizedState=as=d:as=as.next=d}return as}function Gl(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function jh(d){var m=jf;return jf+=1,Yh===null&&(Yh=[]),d=UA(Yh,d,m),m=ai,(as===null?m.memoizedState:as.next)===null&&(m=m.alternate,de.H=m===null||m.memoizedState===null?np:ip),d}function og(d){if(d!==null&&typeof d=="object"){if(typeof d.then=="function")return jh(d);if(d.$$typeof===H)return Ci(d)}throw Error(a(438,String(d)))}function QA(d){var m=null,x=ai.updateQueue;if(x!==null&&(m=x.memoCache),m==null){var T=ai.alternate;T!==null&&(T=T.updateQueue,T!==null&&(T=T.memoCache,T!=null&&(m={data:T.data.map(function(L){return L.slice()}),index:0})))}if(m==null&&(m={data:[],index:0}),x===null&&(x=Gl(),ai.updateQueue=x),x.memoCache=m,x=m.data[m.index],x===void 0)for(x=m.data[m.index]=Array(d),T=0;T<d;T++)x[T]=ie;return m.index++,x}function hl(d,m){return typeof m=="function"?m(d):m}function Da(d){var m=js();return KA(m,_i,d)}function KA(d,m,x){var T=d.queue;if(T===null)throw Error(a(311));T.lastRenderedReducer=x;var L=d.baseQueue,z=T.pending;if(z!==null){if(L!==null){var te=L.next;L.next=z.next,z.next=te}m.baseQueue=L=z,T.pending=null}if(z=d.baseState,L===null)d.memoizedState=z;else{m=L.next;var le=te=null,Ce=null,it=m,Ct=!1;do{var Rt=it.lane&-536870913;if(Rt!==it.lane?(ki&Rt)===Rt:(ul&Rt)===Rt){var at=it.revertLane;if(at===0)Ce!==null&&(Ce=Ce.next={lane:0,revertLane:0,action:it.action,hasEagerState:it.hasEagerState,eagerState:it.eagerState,next:null}),Rt===rs&&(Ct=!0);else if((ul&at)===at){it=it.next,at===rs&&(Ct=!0);continue}else Rt={lane:0,revertLane:it.revertLane,action:it.action,hasEagerState:it.hasEagerState,eagerState:it.eagerState,next:null},Ce===null?(le=Ce=Rt,te=z):Ce=Ce.next=Rt,ai.lanes|=at,Kc|=at;Rt=it.action,Na&&x(z,Rt),z=it.hasEagerState?it.eagerState:x(z,Rt)}else at={lane:Rt,revertLane:it.revertLane,action:it.action,hasEagerState:it.hasEagerState,eagerState:it.eagerState,next:null},Ce===null?(le=Ce=at,te=z):Ce=Ce.next=at,ai.lanes|=Rt,Kc|=Rt;it=it.next}while(it!==null&&it!==m);if(Ce===null?te=z:Ce.next=le,!Gr(z,d.memoizedState)&&(mr=!0,Ct&&(x=Xu,x!==null)))throw x;d.memoizedState=z,d.baseState=te,d.baseQueue=Ce,T.lastRenderedState=z}return L===null&&(T.lanes=0),[d.memoizedState,T.dispatch]}function ZA(d){var m=js(),x=m.queue;if(x===null)throw Error(a(311));x.lastRenderedReducer=d;var T=x.dispatch,L=x.pending,z=m.memoizedState;if(L!==null){x.pending=null;var te=L=L.next;do z=d(z,te.action),te=te.next;while(te!==L);Gr(z,m.memoizedState)||(mr=!0),m.memoizedState=z,m.baseQueue===null&&(m.baseState=z),x.lastRenderedState=z}return[z,T]}function lg(d,m,x){var T=ai,L=js(),z=ri;if(z){if(x===void 0)throw Error(a(407));x=x()}else x=m();var te=!Gr((_i||L).memoizedState,x);te&&(L.memoizedState=x,mr=!0),L=L.queue;var le=ux.bind(null,T,L,d);if(Gc(2048,8,le,[d]),L.getSnapshot!==m||te||as!==null&&as.memoizedState.tag&1){if(T.flags|=2048,Oc(9,ug(),On.bind(null,T,L,x,m),null),ps===null)throw Error(a(349));z||(ul&124)!==0||cx(T,m,x)}return x}function cx(d,m,x){d.flags|=16384,d={getSnapshot:m,value:x},m=ai.updateQueue,m===null?(m=Gl(),ai.updateQueue=m,m.stores=[d]):(x=m.stores,x===null?m.stores=[d]:x.push(d))}function On(d,m,x,T){m.value=x,m.getSnapshot=T,hn(m)&&hx(d)}function ux(d,m,x){return x(function(){hn(m)&&hx(d)})}function hn(d){var m=d.getSnapshot;d=d.value;try{var x=m();return!Gr(d,x)}catch{return!0}}function hx(d){var m=Uu(d,2);m!==null&&gr(m,d,2)}function Ul(d){var m=la();if(typeof d=="function"){var x=d;if(d=x(),Na){Ge(!0);try{x()}finally{Ge(!1)}}}return m.memoizedState=m.baseState=d,m.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:hl,lastRenderedState:d},m}function dx(d,m,x,T){return d.baseState=x,KA(d,_i,typeof T=="function"?T:hl)}function rS(d,m,x,T,L){if(tp(d))throw Error(a(485));if(d=m.action,d!==null){var z={payload:L,action:d,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(te){z.listeners.push(te)}};de.T!==null?x(!0):z.isTransition=!1,T(z),x=m.pending,x===null?(z.next=m.pending=z,Li(m,z)):(z.next=x.next,m.pending=x.next=z)}}function Li(d,m){var x=m.action,T=m.payload,L=d.state;if(m.isTransition){var z=de.T,te={};de.T=te;try{var le=x(L,T),Ce=de.S;Ce!==null&&Ce(te,le),fx(d,m,le)}catch(it){os(d,m,it)}finally{de.T=z}}else try{z=x(L,T),fx(d,m,z)}catch(it){os(d,m,it)}}function fx(d,m,x){x!==null&&typeof x=="object"&&typeof x.then=="function"?x.then(function(T){$A(d,m,T)},function(T){return os(d,m,T)}):$A(d,m,x)}function $A(d,m,x){m.status="fulfilled",m.value=x,cg(m),d.state=x,m=d.pending,m!==null&&(x=m.next,x===m?d.pending=null:(x=x.next,m.next=x,Li(d,x)))}function os(d,m,x){var T=d.pending;if(d.pending=null,T!==null){T=T.next;do m.status="rejected",m.reason=x,cg(m),m=m.next;while(m!==T)}d.action=null}function cg(d){d=d.listeners;for(var m=0;m<d.length;m++)(0,d[m])()}function $e(d,m){return m}function ci(d,m){if(ri){var x=ps.formState;if(x!==null){e:{var T=ai;if(ri){if(wi){t:{for(var L=wi,z=ol;L.nodeType!==8;){if(!z){L=null;break t}if(L=Ha(L.nextSibling),L===null){L=null;break t}}z=L.data,L=z==="F!"||z==="F"?L:null}if(L){wi=Ha(L.nextSibling),T=L.data==="F!";break e}}Wu(T)}T=!1}T&&(m=x[0])}}return x=la(),x.memoizedState=x.baseState=m,T={pending:null,lanes:0,dispatch:null,lastRenderedReducer:$e,lastRenderedState:m},x.queue=T,x=Cx.bind(null,ai,T),T.dispatch=x,T=Ul(!1),z=pg.bind(null,ai,!1,T.queue),T=la(),L={state:m,dispatch:null,action:d,pending:null},T.queue=L,x=rS.bind(null,ai,L,z,x),L.dispatch=x,T.memoizedState=d,[m,x,!1]}function ca(d){var m=js();return YA(m,_i,d)}function YA(d,m,x){if(m=KA(d,m,$e)[0],d=Da(hl)[0],typeof m=="object"&&m!==null&&typeof m.then=="function")try{var T=jh(m)}catch(te){throw te===Qf?Kf:te}else T=m;m=js();var L=m.queue,z=L.dispatch;return x!==m.memoizedState&&(ai.flags|=2048,Oc(9,ug(),Fc.bind(null,L,x),null)),[T,z,d]}function Fc(d,m){d.action=m}function px(d){var m=js(),x=_i;if(x!==null)return YA(m,x,d);js(),m=m.memoizedState,x=js();var T=x.queue.dispatch;return x.memoizedState=d,[m,T,!1]}function Oc(d,m,x,T){return d={tag:d,create:x,deps:T,inst:m,next:null},m=ai.updateQueue,m===null&&(m=Gl(),ai.updateQueue=m),x=m.lastEffect,x===null?m.lastEffect=d.next=d:(T=x.next,x.next=d,d.next=T,m.lastEffect=d),d}function ug(){return{destroy:void 0,resource:void 0}}function Us(){return js().memoizedState}function hg(d,m,x,T){var L=la();T=T===void 0?null:T,ai.flags|=d,L.memoizedState=Oc(1|m,ug(),x,T)}function Gc(d,m,x,T){var L=js();T=T===void 0?null:T;var z=L.memoizedState.inst;_i!==null&&T!==null&&Dc(T,_i.memoizedState.deps)?L.memoizedState=Oc(m,z,x,T):(ai.flags|=d,L.memoizedState=Oc(1|m,z,x,T))}function mx(d,m){hg(8390656,8,d,m)}function bi(d,m){Gc(2048,8,d,m)}function Pl(d,m){return Gc(4,2,d,m)}function Qs(d,m){return Gc(4,4,d,m)}function $n(d,m){if(typeof m=="function"){d=d();var x=m(d);return function(){typeof x=="function"?x():m(null)}}if(m!=null)return d=d(),m.current=d,function(){m.current=null}}function gx(d,m,x){x=x!=null?x.concat([d]):null,Gc(4,4,$n.bind(null,m,d),x)}function zl(){}function Ax(d,m){var x=js();m=m===void 0?null:m;var T=x.memoizedState;return m!==null&&Dc(m,T[1])?T[0]:(x.memoizedState=[d,m],d)}function bx(d,m){var x=js();m=m===void 0?null:m;var T=x.memoizedState;if(m!==null&&Dc(m,T[1]))return T[0];if(T=d(),Na){Ge(!0);try{d()}finally{Ge(!1)}}return x.memoizedState=[T,m],T}function qf(d,m,x){return x===void 0||(ul&1073741824)!==0?d.memoizedState=m:(d.memoizedState=x,d=i1(),ai.lanes|=d,Kc|=d,x)}function jA(d,m,x,T){return Gr(x,m)?x:$h.current!==null?(d=qf(d,x,T),Gr(d,m)||(mr=!0),d):(ul&42)===0?(mr=!0,d.memoizedState=x):(d=i1(),ai.lanes|=d,Kc|=d,m)}function yx(d,m,x,T,L){var z=we.p;we.p=z!==0&&8>z?z:8;var te=de.T,le={};de.T=le,pg(d,!1,m,x);try{var Ce=L(),it=de.S;if(it!==null&&it(le,Ce),Ce!==null&&typeof Ce=="object"&&typeof Ce.then=="function"){var Ct=FA(Ce,T);qh(d,m,Ct,jr(d))}else qh(d,m,T,jr(d))}catch(Rt){qh(d,m,{then:function(){},status:"rejected",reason:Rt},jr())}finally{we.p=z,de.T=te}}function Jf(){}function ep(d,m,x,T){if(d.tag!==5)throw Error(a(476));var L=vx(d).queue;yx(d,L,m,Le,x===null?Jf:function(){return dg(d),x(T)})}function vx(d){var m=d.memoizedState;if(m!==null)return m;m={memoizedState:Le,baseState:Le,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:hl,lastRenderedState:Le},next:null};var x={};return m.next={memoizedState:x,baseState:x,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:hl,lastRenderedState:x},next:null},d.memoizedState=m,d=d.alternate,d!==null&&(d.memoizedState=m),m}function dg(d){var m=vx(d).next.queue;qh(d,m,{},jr())}function qA(){return Ci(wd)}function fg(){return js().memoizedState}function JA(){return js().memoizedState}function xx(d){for(var m=d.return;m!==null;){switch(m.tag){case 24:case 3:var x=jr();d=La(x);var T=mo(m,d,x);T!==null&&(gr(T,m,x),Ur(T,m,x)),m={cache:Vf()},d.payload=m;return}m=m.return}}function wx(d,m,x){var T=jr();x={lane:T,revertLane:0,action:x,hasEagerState:!1,eagerState:null,next:null},tp(d)?eb(m,x):(x=kc(d,m,x,T),x!==null&&(gr(x,d,T),tb(x,m,T)))}function Cx(d,m,x){var T=jr();qh(d,m,x,T)}function qh(d,m,x,T){var L={lane:T,revertLane:0,action:x,hasEagerState:!1,eagerState:null,next:null};if(tp(d))eb(m,L);else{var z=d.alternate;if(d.lanes===0&&(z===null||z.lanes===0)&&(z=m.lastRenderedReducer,z!==null))try{var te=m.lastRenderedState,le=z(te,x);if(L.hasEagerState=!0,L.eagerState=le,Gr(le,te))return rl(d,m,L,0),ps===null&&Kr(),!1}catch{}finally{}if(x=kc(d,m,L,T),x!==null)return gr(x,d,T),tb(x,m,T),!0}return!1}function pg(d,m,x,T){if(T={lane:2,revertLane:Yc(),action:T,hasEagerState:!1,eagerState:null,next:null},tp(d)){if(m)throw Error(a(479))}else m=kc(d,x,T,2),m!==null&&gr(m,d,2)}function tp(d){var m=d.alternate;return d===ai||m!==null&&m===ai}function eb(d,m){Nc=$f=!0;var x=d.pending;x===null?m.next=m:(m.next=x.next,x.next=m),d.pending=m}function tb(d,m,x){if((x&4194048)!==0){var T=m.lanes;T&=d.pendingLanes,x|=T,m.lanes=x,Vn(d,x)}}var Ku={readContext:Ci,use:og,useCallback:Yi,useContext:Yi,useEffect:Yi,useImperativeHandle:Yi,useLayoutEffect:Yi,useInsertionEffect:Yi,useMemo:Yi,useReducer:Yi,useRef:Yi,useState:Yi,useDebugValue:Yi,useDeferredValue:Yi,useTransition:Yi,useSyncExternalStore:Yi,useId:Yi,useHostTransitionStatus:Yi,useFormState:Yi,useActionState:Yi,useOptimistic:Yi,useMemoCache:Yi,useCacheRefresh:Yi},np={readContext:Ci,use:og,useCallback:function(d,m){return la().memoizedState=[d,m===void 0?null:m],d},useContext:Ci,useEffect:mx,useImperativeHandle:function(d,m,x){x=x!=null?x.concat([d]):null,hg(4194308,4,$n.bind(null,m,d),x)},useLayoutEffect:function(d,m){return hg(4194308,4,d,m)},useInsertionEffect:function(d,m){hg(4,2,d,m)},useMemo:function(d,m){var x=la();m=m===void 0?null:m;var T=d();if(Na){Ge(!0);try{d()}finally{Ge(!1)}}return x.memoizedState=[T,m],T},useReducer:function(d,m,x){var T=la();if(x!==void 0){var L=x(m);if(Na){Ge(!0);try{x(m)}finally{Ge(!1)}}}else L=m;return T.memoizedState=T.baseState=L,d={pending:null,lanes:0,dispatch:null,lastRenderedReducer:d,lastRenderedState:L},T.queue=d,d=d.dispatch=wx.bind(null,ai,d),[T.memoizedState,d]},useRef:function(d){var m=la();return d={current:d},m.memoizedState=d},useState:function(d){d=Ul(d);var m=d.queue,x=Cx.bind(null,ai,m);return m.dispatch=x,[d.memoizedState,x]},useDebugValue:zl,useDeferredValue:function(d,m){var x=la();return qf(x,d,m)},useTransition:function(){var d=Ul(!1);return d=yx.bind(null,ai,d.queue,!0,!1),la().memoizedState=d,[!1,d]},useSyncExternalStore:function(d,m,x){var T=ai,L=la();if(ri){if(x===void 0)throw Error(a(407));x=x()}else{if(x=m(),ps===null)throw Error(a(349));(ki&124)!==0||cx(T,m,x)}L.memoizedState=x;var z={value:x,getSnapshot:m};return L.queue=z,mx(ux.bind(null,T,z,d),[d]),T.flags|=2048,Oc(9,ug(),On.bind(null,T,z,x,m),null),x},useId:function(){var d=la(),m=ps.identifierPrefix;if(ri){var x=Fl,T=Dl;x=(T&~(1<<32-ut(T)-1)).toString(32)+x,m=""+m+"R"+x,x=Yf++,0<x&&(m+="H"+x.toString(32)),m+=""}else x=iS++,m=""+m+"r"+x.toString(32)+"";return d.memoizedState=m},useHostTransitionStatus:qA,useFormState:ci,useActionState:ci,useOptimistic:function(d){var m=la();m.memoizedState=m.baseState=d;var x={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return m.queue=x,m=pg.bind(null,ai,!0,x),x.dispatch=m,[d,m]},useMemoCache:QA,useCacheRefresh:function(){return la().memoizedState=xx.bind(null,ai)}},ip={readContext:Ci,use:og,useCallback:Ax,useContext:Ci,useEffect:bi,useImperativeHandle:gx,useInsertionEffect:Pl,useLayoutEffect:Qs,useMemo:bx,useReducer:Da,useRef:Us,useState:function(){return Da(hl)},useDebugValue:zl,useDeferredValue:function(d,m){var x=js();return jA(x,_i.memoizedState,d,m)},useTransition:function(){var d=Da(hl)[0],m=js().memoizedState;return[typeof d=="boolean"?d:jh(d),m]},useSyncExternalStore:lg,useId:fg,useHostTransitionStatus:qA,useFormState:ca,useActionState:ca,useOptimistic:function(d,m){var x=js();return dx(x,_i,d,m)},useMemoCache:QA,useCacheRefresh:JA},nb={readContext:Ci,use:og,useCallback:Ax,useContext:Ci,useEffect:bi,useImperativeHandle:gx,useInsertionEffect:Pl,useLayoutEffect:Qs,useMemo:bx,useReducer:ZA,useRef:Us,useState:function(){return ZA(hl)},useDebugValue:zl,useDeferredValue:function(d,m){var x=js();return _i===null?qf(x,d,m):jA(x,_i.memoizedState,d,m)},useTransition:function(){var d=ZA(hl)[0],m=js().memoizedState;return[typeof d=="boolean"?d:jh(d),m]},useSyncExternalStore:lg,useId:fg,useHostTransitionStatus:qA,useFormState:px,useActionState:px,useOptimistic:function(d,m){var x=js();return _i!==null?dx(x,_i,d,m):(x.baseState=d,[d,x.queue.dispatch])},useMemoCache:QA,useCacheRefresh:JA},Jh=null,ed=0;function mg(d){var m=ed;return ed+=1,Jh===null&&(Jh=[]),UA(Jh,d,m)}function dl(d,m){m=m.props.ref,d.ref=m!==void 0?m:null}function Yr(d,m){throw m.$$typeof===E?Error(a(525)):(d=Object.prototype.toString.call(m),Error(a(31,d==="[object Object]"?"object with keys {"+Object.keys(m).join(", ")+"}":d)))}function Lt(d){var m=d._init;return m(d._payload)}function Ex(d){function m(Ke,Fe){if(d){var qe=Ke.deletions;qe===null?(Ke.deletions=[Fe],Ke.flags|=16):qe.push(Fe)}}function x(Ke,Fe){if(!d)return null;for(;Fe!==null;)m(Ke,Fe),Fe=Fe.sibling;return null}function T(Ke){for(var Fe=new Map;Ke!==null;)Ke.key!==null?Fe.set(Ke.key,Ke):Fe.set(Ke.index,Ke),Ke=Ke.sibling;return Fe}function L(Ke,Fe){return Ke=Zr(Ke,Fe),Ke.index=0,Ke.sibling=null,Ke}function z(Ke,Fe,qe){return Ke.index=qe,d?(qe=Ke.alternate,qe!==null?(qe=qe.index,qe<Fe?(Ke.flags|=67108866,Fe):qe):(Ke.flags|=67108866,Fe)):(Ke.flags|=1048576,Fe)}function te(Ke){return d&&Ke.alternate===null&&(Ke.flags|=67108866),Ke}function le(Ke,Fe,qe,St){return Fe===null||Fe.tag!==6?(Fe=fr(qe,Ke.mode,St),Fe.return=Ke,Fe):(Fe=L(Fe,qe),Fe.return=Ke,Fe)}function Ce(Ke,Fe,qe,St){var gn=qe.type;return gn===G?Ct(Ke,Fe,qe.props.children,St,qe.key):Fe!==null&&(Fe.elementType===gn||typeof gn=="object"&&gn!==null&&gn.$$typeof===re&&Lt(gn)===Fe.type)?(Fe=L(Fe,qe.props),dl(Fe,qe),Fe.return=Ke,Fe):(Fe=Of(qe.type,qe.key,qe.props,null,Ke.mode,St),dl(Fe,qe),Fe.return=Ke,Fe)}function it(Ke,Fe,qe,St){return Fe===null||Fe.tag!==4||Fe.stateNode.containerInfo!==qe.containerInfo||Fe.stateNode.implementation!==qe.implementation?(Fe=Gf(qe,Ke.mode,St),Fe.return=Ke,Fe):(Fe=L(Fe,qe.children||[]),Fe.return=Ke,Fe)}function Ct(Ke,Fe,qe,St,gn){return Fe===null||Fe.tag!==7?(Fe=Ra(qe,Ke.mode,St,gn),Fe.return=Ke,Fe):(Fe=L(Fe,qe),Fe.return=Ke,Fe)}function Rt(Ke,Fe,qe){if(typeof Fe=="string"&&Fe!==""||typeof Fe=="number"||typeof Fe=="bigint")return Fe=fr(""+Fe,Ke.mode,qe),Fe.return=Ke,Fe;if(typeof Fe=="object"&&Fe!==null){switch(Fe.$$typeof){case R:return qe=Of(Fe.type,Fe.key,Fe.props,null,Ke.mode,qe),dl(qe,Fe),qe.return=Ke,qe;case k:return Fe=Gf(Fe,Ke.mode,qe),Fe.return=Ke,Fe;case re:var St=Fe._init;return Fe=St(Fe._payload),Rt(Ke,Fe,qe)}if(rt(Fe)||Re(Fe))return Fe=Ra(Fe,Ke.mode,qe,null),Fe.return=Ke,Fe;if(typeof Fe.then=="function")return Rt(Ke,mg(Fe),qe);if(Fe.$$typeof===H)return Rt(Ke,dt(Ke,Fe),qe);Yr(Ke,Fe)}return null}function at(Ke,Fe,qe,St){var gn=Fe!==null?Fe.key:null;if(typeof qe=="string"&&qe!==""||typeof qe=="number"||typeof qe=="bigint")return gn!==null?null:le(Ke,Fe,""+qe,St);if(typeof qe=="object"&&qe!==null){switch(qe.$$typeof){case R:return qe.key===gn?Ce(Ke,Fe,qe,St):null;case k:return qe.key===gn?it(Ke,Fe,qe,St):null;case re:return gn=qe._init,qe=gn(qe._payload),at(Ke,Fe,qe,St)}if(rt(qe)||Re(qe))return gn!==null?null:Ct(Ke,Fe,qe,St,null);if(typeof qe.then=="function")return at(Ke,Fe,mg(qe),St);if(qe.$$typeof===H)return at(Ke,Fe,dt(Ke,qe),St);Yr(Ke,qe)}return null}function lt(Ke,Fe,qe,St,gn){if(typeof St=="string"&&St!==""||typeof St=="number"||typeof St=="bigint")return Ke=Ke.get(qe)||null,le(Fe,Ke,""+St,gn);if(typeof St=="object"&&St!==null){switch(St.$$typeof){case R:return Ke=Ke.get(St.key===null?qe:St.key)||null,Ce(Fe,Ke,St,gn);case k:return Ke=Ke.get(St.key===null?qe:St.key)||null,it(Fe,Ke,St,gn);case re:var ui=St._init;return St=ui(St._payload),lt(Ke,Fe,qe,St,gn)}if(rt(St)||Re(St))return Ke=Ke.get(qe)||null,Ct(Fe,Ke,St,gn,null);if(typeof St.then=="function")return lt(Ke,Fe,qe,mg(St),gn);if(St.$$typeof===H)return lt(Ke,Fe,qe,dt(Fe,St),gn);Yr(Fe,St)}return null}function Fn(Ke,Fe,qe,St){for(var gn=null,ui=null,Sn=Fe,Gn=Fe=0,Js=null;Sn!==null&&Gn<qe.length;Gn++){Sn.index>Gn?(Js=Sn,Sn=null):Js=Sn.sibling;var Ui=at(Ke,Sn,qe[Gn],St);if(Ui===null){Sn===null&&(Sn=Js);break}d&&Sn&&Ui.alternate===null&&m(Ke,Sn),Fe=z(Ui,Fe,Gn),ui===null?gn=Ui:ui.sibling=Ui,ui=Ui,Sn=Js}if(Gn===qe.length)return x(Ke,Sn),ri&&Vu(Ke,Gn),gn;if(Sn===null){for(;Gn<qe.length;Gn++)Sn=Rt(Ke,qe[Gn],St),Sn!==null&&(Fe=z(Sn,Fe,Gn),ui===null?gn=Sn:ui.sibling=Sn,ui=Sn);return ri&&Vu(Ke,Gn),gn}for(Sn=T(Sn);Gn<qe.length;Gn++)Js=lt(Sn,Ke,Gn,qe[Gn],St),Js!==null&&(d&&Js.alternate!==null&&Sn.delete(Js.key===null?Gn:Js.key),Fe=z(Js,Fe,Gn),ui===null?gn=Js:ui.sibling=Js,ui=Js);return d&&Sn.forEach(function(nu){return m(Ke,nu)}),ri&&Vu(Ke,Gn),gn}function Pn(Ke,Fe,qe,St){if(qe==null)throw Error(a(151));for(var gn=null,ui=null,Sn=Fe,Gn=Fe=0,Js=null,Ui=qe.next();Sn!==null&&!Ui.done;Gn++,Ui=qe.next()){Sn.index>Gn?(Js=Sn,Sn=null):Js=Sn.sibling;var nu=at(Ke,Sn,Ui.value,St);if(nu===null){Sn===null&&(Sn=Js);break}d&&Sn&&nu.alternate===null&&m(Ke,Sn),Fe=z(nu,Fe,Gn),ui===null?gn=nu:ui.sibling=nu,ui=nu,Sn=Js}if(Ui.done)return x(Ke,Sn),ri&&Vu(Ke,Gn),gn;if(Sn===null){for(;!Ui.done;Gn++,Ui=qe.next())Ui=Rt(Ke,Ui.value,St),Ui!==null&&(Fe=z(Ui,Fe,Gn),ui===null?gn=Ui:ui.sibling=Ui,ui=Ui);return ri&&Vu(Ke,Gn),gn}for(Sn=T(Sn);!Ui.done;Gn++,Ui=qe.next())Ui=lt(Sn,Ke,Gn,Ui.value,St),Ui!==null&&(d&&Ui.alternate!==null&&Sn.delete(Ui.key===null?Gn:Ui.key),Fe=z(Ui,Fe,Gn),ui===null?gn=Ui:ui.sibling=Ui,ui=Ui);return d&&Sn.forEach(function(QS){return m(Ke,QS)}),ri&&Vu(Ke,Gn),gn}function Ji(Ke,Fe,qe,St){if(typeof qe=="object"&&qe!==null&&qe.type===G&&qe.key===null&&(qe=qe.props.children),typeof qe=="object"&&qe!==null){switch(qe.$$typeof){case R:e:{for(var gn=qe.key;Fe!==null;){if(Fe.key===gn){if(gn=qe.type,gn===G){if(Fe.tag===7){x(Ke,Fe.sibling),St=L(Fe,qe.props.children),St.return=Ke,Ke=St;break e}}else if(Fe.elementType===gn||typeof gn=="object"&&gn!==null&&gn.$$typeof===re&&Lt(gn)===Fe.type){x(Ke,Fe.sibling),St=L(Fe,qe.props),dl(St,qe),St.return=Ke,Ke=St;break e}x(Ke,Fe);break}else m(Ke,Fe);Fe=Fe.sibling}qe.type===G?(St=Ra(qe.props.children,Ke.mode,St,qe.key),St.return=Ke,Ke=St):(St=Of(qe.type,qe.key,qe.props,null,Ke.mode,St),dl(St,qe),St.return=Ke,Ke=St)}return te(Ke);case k:e:{for(gn=qe.key;Fe!==null;){if(Fe.key===gn)if(Fe.tag===4&&Fe.stateNode.containerInfo===qe.containerInfo&&Fe.stateNode.implementation===qe.implementation){x(Ke,Fe.sibling),St=L(Fe,qe.children||[]),St.return=Ke,Ke=St;break e}else{x(Ke,Fe);break}else m(Ke,Fe);Fe=Fe.sibling}St=Gf(qe,Ke.mode,St),St.return=Ke,Ke=St}return te(Ke);case re:return gn=qe._init,qe=gn(qe._payload),Ji(Ke,Fe,qe,St)}if(rt(qe))return Fn(Ke,Fe,qe,St);if(Re(qe)){if(gn=Re(qe),typeof gn!="function")throw Error(a(150));return qe=gn.call(qe),Pn(Ke,Fe,qe,St)}if(typeof qe.then=="function")return Ji(Ke,Fe,mg(qe),St);if(qe.$$typeof===H)return Ji(Ke,Fe,dt(Ke,qe),St);Yr(Ke,qe)}return typeof qe=="string"&&qe!==""||typeof qe=="number"||typeof qe=="bigint"?(qe=""+qe,Fe!==null&&Fe.tag===6?(x(Ke,Fe.sibling),St=L(Fe,qe),St.return=Ke,Ke=St):(x(Ke,Fe),St=fr(qe,Ke.mode,St),St.return=Ke,Ke=St),te(Ke)):x(Ke,Fe)}return function(Ke,Fe,qe,St){try{ed=0;var gn=Ji(Ke,Fe,qe,St);return Jh=null,gn}catch(Sn){if(Sn===Qf||Sn===Kf)throw Sn;var ui=Ht(29,Sn,null,Ke.mode);return ui.lanes=St,ui.return=Ke,ui}finally{}}}var Ut=Ex(!0),Sx=Ex(!1),Fa=Ve(null),fl=null;function En(d){var m=d.alternate;gt(Ri,Ri.current&1),gt(Fa,d),fl===null&&(m===null||$h.current!==null||m.memoizedState!==null)&&(fl=d)}function Ix(d){if(d.tag===22){if(gt(Ri,Ri.current),gt(Fa,d),fl===null){var m=d.alternate;m!==null&&m.memoizedState!==null&&(fl=d)}}else Oe()}function Oe(){gt(Ri,Ri.current),gt(Fa,Fa.current)}function Vl(d){Ne(Fa),fl===d&&(fl=null),Ne(Ri)}var Ri=Ve(0);function gg(d){for(var m=d;m!==null;){if(m.tag===13){var x=m.memoizedState;if(x!==null&&(x=x.dehydrated,x===null||x.data==="$?"||_b(x)))return m}else if(m.tag===19&&m.memoizedProps.revealOrder!==void 0){if((m.flags&128)!==0)return m}else if(m.child!==null){m.child.return=m,m=m.child;continue}if(m===d)break;for(;m.sibling===null;){if(m.return===null||m.return===d)return null;m=m.return}m.sibling.return=m.return,m=m.sibling}return null}function ib(d,m,x,T){m=d.memoizedState,x=x(T,m),x=x==null?m:I({},m,x),d.memoizedState=x,d.lanes===0&&(d.updateQueue.baseState=x)}var sb={enqueueSetState:function(d,m,x){d=d._reactInternals;var T=jr(),L=La(T);L.payload=m,x!=null&&(L.callback=x),m=mo(d,L,T),m!==null&&(gr(m,d,T),Ur(m,d,T))},enqueueReplaceState:function(d,m,x){d=d._reactInternals;var T=jr(),L=La(T);L.tag=1,L.payload=m,x!=null&&(L.callback=x),m=mo(d,L,T),m!==null&&(gr(m,d,T),Ur(m,d,T))},enqueueForceUpdate:function(d,m){d=d._reactInternals;var x=jr(),T=La(x);T.tag=2,m!=null&&(T.callback=m),m=mo(d,T,x),m!==null&&(gr(m,d,x),Ur(m,d,x))}};function Tx(d,m,x,T,L,z,te){return d=d.stateNode,typeof d.shouldComponentUpdate=="function"?d.shouldComponentUpdate(T,z,te):m.prototype&&m.prototype.isPureReactComponent?!Rc(x,T)||!Rc(L,z):!0}function Mx(d,m,x,T){d=m.state,typeof m.componentWillReceiveProps=="function"&&m.componentWillReceiveProps(x,T),typeof m.UNSAFE_componentWillReceiveProps=="function"&&m.UNSAFE_componentWillReceiveProps(x,T),m.state!==d&&sb.enqueueReplaceState(m,m.state,null)}function Uc(d,m){var x=m;if("ref"in m){x={};for(var T in m)T!=="ref"&&(x[T]=m[T])}if(d=d.defaultProps){x===m&&(x=I({},x));for(var L in d)x[L]===void 0&&(x[L]=d[L])}return x}var Ag=typeof reportError=="function"?reportError:function(d){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var m=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof d=="object"&&d!==null&&typeof d.message=="string"?String(d.message):String(d),error:d});if(!window.dispatchEvent(m))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",d);return}console.error(d)};function bg(d){Ag(d)}function _x(d){console.error(d)}function td(d){Ag(d)}function yg(d,m){try{var x=d.onUncaughtError;x(m.value,{componentStack:m.stack})}catch(T){setTimeout(function(){throw T})}}function Rx(d,m,x){try{var T=d.onCaughtError;T(x.value,{componentStack:x.stack,errorBoundary:m.tag===1?m.stateNode:null})}catch(L){setTimeout(function(){throw L})}}function rb(d,m,x){return x=La(x),x.tag=3,x.payload={element:null},x.callback=function(){yg(d,m)},x}function kx(d){return d=La(d),d.tag=3,d}function Bx(d,m,x,T){var L=x.type.getDerivedStateFromError;if(typeof L=="function"){var z=T.value;d.payload=function(){return L(z)},d.callback=function(){Rx(m,x,T)}}var te=x.stateNode;te!==null&&typeof te.componentDidCatch=="function"&&(d.callback=function(){Rx(m,x,T),typeof L!="function"&&(Zl===null?Zl=new Set([this]):Zl.add(this));var le=T.stack;this.componentDidCatch(T.value,{componentStack:le!==null?le:""})})}function aS(d,m,x,T,L){if(x.flags|=32768,T!==null&&typeof T=="object"&&typeof T.then=="function"){if(m=x.alternate,m!==null&&cl(m,x,L,!0),x=Fa.current,x!==null){switch(x.tag){case 13:return fl===null?yb():x.alternate===null&&Ii===0&&(Ii=3),x.flags&=-257,x.flags|=65536,x.lanes=L,T===eg?x.flags|=16384:(m=x.updateQueue,m===null?x.updateQueue=new Set([T]):m.add(T),$c(d,T,L)),!1;case 22:return x.flags|=65536,T===eg?x.flags|=16384:(m=x.updateQueue,m===null?(m={transitions:null,markerInstances:null,retryQueue:new Set([T])},x.updateQueue=m):(x=m.retryQueue,x===null?m.retryQueue=new Set([T]):x.add(T)),$c(d,T,L)),!1}throw Error(a(435,x.tag))}return $c(d,T,L),yb(),!1}if(ri)return m=Fa.current,m!==null?((m.flags&65536)===0&&(m.flags|=256),m.flags|=65536,m.lanes=L,T!==BA&&(d=Error(a(422),{cause:T}),Pf(Tr(d,x)))):(T!==BA&&(m=Error(a(423),{cause:T}),Pf(Tr(m,x))),d=d.current.alternate,d.flags|=65536,L&=-L,d.lanes|=L,T=Tr(T,x),L=rb(d.stateNode,T,L),tg(d,L),Ii!==4&&(Ii=2)),!1;var z=Error(a(520),{cause:T});if(z=Tr(z,x),hp===null?hp=[z]:hp.push(z),Ii!==4&&(Ii=2),m===null)return!0;T=Tr(T,x),x=m;do{switch(x.tag){case 3:return x.flags|=65536,d=L&-L,x.lanes|=d,d=rb(x.stateNode,T,d),tg(x,d),!1;case 1:if(m=x.type,z=x.stateNode,(x.flags&128)===0&&(typeof m.getDerivedStateFromError=="function"||z!==null&&typeof z.componentDidCatch=="function"&&(Zl===null||!Zl.has(z))))return x.flags|=65536,L&=-L,x.lanes|=L,L=kx(L),Bx(L,d,x,T),tg(x,L),!1}x=x.return}while(x!==null);return!1}var Lx=Error(a(461)),mr=!1;function Mr(d,m,x,T){m.child=d===null?Sx(m,null,x,T):Ut(m,d.child,x,T)}function Nx(d,m,x,T,L){x=x.render;var z=m.ref;if("ref"in T){var te={};for(var le in T)le!=="ref"&&(te[le]=T[le])}else te=T;return Hu(m),T=sg(d,m,x,te,z,L),le=XA(),d!==null&&!mr?(rg(d,m,L),Ms(d,m,L)):(ri&&le&&Do(m),m.flags|=1,Mr(d,m,T,L),m.child)}function Dx(d,m,x,T,L){if(d===null){var z=x.type;return typeof z=="function"&&!_A(z)&&z.defaultProps===void 0&&x.compare===null?(m.tag=15,m.type=z,Fx(d,m,z,T,L)):(d=Of(x.type,null,T,m,m.mode,L),d.ref=m.ref,d.return=m,m.child=d)}if(z=d.child,!ob(d,L)){var te=z.memoizedProps;if(x=x.compare,x=x!==null?x:Rc,x(te,T)&&d.ref===m.ref)return Ms(d,m,L)}return m.flags|=1,d=Zr(z,T),d.ref=m.ref,d.return=m,m.child=d}function Fx(d,m,x,T,L){if(d!==null){var z=d.memoizedProps;if(Rc(z,T)&&d.ref===m.ref)if(mr=!1,m.pendingProps=T=z,ob(d,L))(d.flags&131072)!==0&&(mr=!0);else return m.lanes=d.lanes,Ms(d,m,L)}return qs(d,m,x,T,L)}function nd(d,m,x){var T=m.pendingProps,L=T.children,z=d!==null?d.memoizedState:null;if(T.mode==="hidden"){if((m.flags&128)!==0){if(T=z!==null?z.baseLanes|x:x,d!==null){for(L=m.child=d.child,z=0;L!==null;)z=z|L.lanes|L.childLanes,L=L.sibling;m.childLanes=z&~T}else m.childLanes=0,m.child=null;return Oa(d,m,T,x)}if((x&536870912)!==0)m.memoizedState={baseLanes:0,cachePool:null},d!==null&&Xf(m,z!==null?z.cachePool:null),z!==null?WA(m,z):pr(),Ix(m);else return m.lanes=m.childLanes=536870912,Oa(d,m,z!==null?z.baseLanes|x:x,x)}else z!==null?(Xf(m,z.cachePool),WA(m,z),Oe(),m.memoizedState=null):(d!==null&&Xf(m,null),pr(),Oe());return Mr(d,m,L,x),m.child}function Oa(d,m,x,T){var L=GA();return L=L===null?null:{parent:Xs._currentValue,pool:L},m.memoizedState={baseLanes:x,cachePool:L},d!==null&&Xf(m,null),pr(),Ix(m),d!==null&&cl(d,m,T,!0),null}function go(d,m){var x=m.ref;if(x===null)d!==null&&d.ref!==null&&(m.flags|=4194816);else{if(typeof x!="function"&&typeof x!="object")throw Error(a(284));(d===null||d.ref!==x)&&(m.flags|=4194816)}}function qs(d,m,x,T,L){return Hu(m),x=sg(d,m,x,T,void 0,L),T=XA(),d!==null&&!mr?(rg(d,m,L),Ms(d,m,L)):(ri&&T&&Do(m),m.flags|=1,Mr(d,m,x,L),m.child)}function Wl(d,m,x,T,L,z){return Hu(m),m.updateQueue=null,x=lx(m,T,x,L),ox(d),T=XA(),d!==null&&!mr?(rg(d,m,z),Ms(d,m,z)):(ri&&T&&Do(m),m.flags|=1,Mr(d,m,x,z),m.child)}function Ox(d,m,x,T,L){if(Hu(m),m.stateNode===null){var z=Pu,te=x.contextType;typeof te=="object"&&te!==null&&(z=Ci(te)),z=new x(T,z),m.memoizedState=z.state!==null&&z.state!==void 0?z.state:null,z.updater=sb,m.stateNode=z,z._reactInternals=m,z=m.stateNode,z.props=T,z.state=m.memoizedState,z.refs={},Qe(m),te=x.contextType,z.context=typeof te=="object"&&te!==null?Ci(te):Pu,z.state=m.memoizedState,te=x.getDerivedStateFromProps,typeof te=="function"&&(ib(m,x,te,T),z.state=m.memoizedState),typeof x.getDerivedStateFromProps=="function"||typeof z.getSnapshotBeforeUpdate=="function"||typeof z.UNSAFE_componentWillMount!="function"&&typeof z.componentWillMount!="function"||(te=z.state,typeof z.componentWillMount=="function"&&z.componentWillMount(),typeof z.UNSAFE_componentWillMount=="function"&&z.UNSAFE_componentWillMount(),te!==z.state&&sb.enqueueReplaceState(z,z.state,null),Qu(m,T,z,L),Zf(),z.state=m.memoizedState),typeof z.componentDidMount=="function"&&(m.flags|=4194308),T=!0}else if(d===null){z=m.stateNode;var le=m.memoizedProps,Ce=Uc(x,le);z.props=Ce;var it=z.context,Ct=x.contextType;te=Pu,typeof Ct=="object"&&Ct!==null&&(te=Ci(Ct));var Rt=x.getDerivedStateFromProps;Ct=typeof Rt=="function"||typeof z.getSnapshotBeforeUpdate=="function",le=m.pendingProps!==le,Ct||typeof z.UNSAFE_componentWillReceiveProps!="function"&&typeof z.componentWillReceiveProps!="function"||(le||it!==te)&&Mx(m,z,T,te),Lc=!1;var at=m.memoizedState;z.state=at,Qu(m,T,z,L),Zf(),it=m.memoizedState,le||at!==it||Lc?(typeof Rt=="function"&&(ib(m,x,Rt,T),it=m.memoizedState),(Ce=Lc||Tx(m,x,Ce,T,at,it,te))?(Ct||typeof z.UNSAFE_componentWillMount!="function"&&typeof z.componentWillMount!="function"||(typeof z.componentWillMount=="function"&&z.componentWillMount(),typeof z.UNSAFE_componentWillMount=="function"&&z.UNSAFE_componentWillMount()),typeof z.componentDidMount=="function"&&(m.flags|=4194308)):(typeof z.componentDidMount=="function"&&(m.flags|=4194308),m.memoizedProps=T,m.memoizedState=it),z.props=T,z.state=it,z.context=te,T=Ce):(typeof z.componentDidMount=="function"&&(m.flags|=4194308),T=!1)}else{z=m.stateNode,zA(d,m),te=m.memoizedProps,Ct=Uc(x,te),z.props=Ct,Rt=m.pendingProps,at=z.context,it=x.contextType,Ce=Pu,typeof it=="object"&&it!==null&&(Ce=Ci(it)),le=x.getDerivedStateFromProps,(it=typeof le=="function"||typeof z.getSnapshotBeforeUpdate=="function")||typeof z.UNSAFE_componentWillReceiveProps!="function"&&typeof z.componentWillReceiveProps!="function"||(te!==Rt||at!==Ce)&&Mx(m,z,T,Ce),Lc=!1,at=m.memoizedState,z.state=at,Qu(m,T,z,L),Zf();var lt=m.memoizedState;te!==Rt||at!==lt||Lc||d!==null&&d.dependencies!==null&&Jm(d.dependencies)?(typeof le=="function"&&(ib(m,x,le,T),lt=m.memoizedState),(Ct=Lc||Tx(m,x,Ct,T,at,lt,Ce)||d!==null&&d.dependencies!==null&&Jm(d.dependencies))?(it||typeof z.UNSAFE_componentWillUpdate!="function"&&typeof z.componentWillUpdate!="function"||(typeof z.componentWillUpdate=="function"&&z.componentWillUpdate(T,lt,Ce),typeof z.UNSAFE_componentWillUpdate=="function"&&z.UNSAFE_componentWillUpdate(T,lt,Ce)),typeof z.componentDidUpdate=="function"&&(m.flags|=4),typeof z.getSnapshotBeforeUpdate=="function"&&(m.flags|=1024)):(typeof z.componentDidUpdate!="function"||te===d.memoizedProps&&at===d.memoizedState||(m.flags|=4),typeof z.getSnapshotBeforeUpdate!="function"||te===d.memoizedProps&&at===d.memoizedState||(m.flags|=1024),m.memoizedProps=T,m.memoizedState=lt),z.props=T,z.state=lt,z.context=Ce,T=Ct):(typeof z.componentDidUpdate!="function"||te===d.memoizedProps&&at===d.memoizedState||(m.flags|=4),typeof z.getSnapshotBeforeUpdate!="function"||te===d.memoizedProps&&at===d.memoizedState||(m.flags|=1024),T=!1)}return z=T,go(d,m),T=(m.flags&128)!==0,z||T?(z=m.stateNode,x=T&&typeof x.getDerivedStateFromError!="function"?null:z.render(),m.flags|=1,d!==null&&T?(m.child=Ut(m,d.child,null,L),m.child=Ut(m,null,x,L)):Mr(d,m,x,L),m.memoizedState=z.state,d=m.child):d=Ms(d,m,L),d}function Gx(d,m,x,T){return Ol(),m.flags|=256,Mr(d,m,x,T),m.child}var sp={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function id(d){return{baseLanes:d,cachePool:ze()}}function rp(d,m,x){return d=d!==null?d.childLanes&~x:0,m&&(d|=bo),d}function Zu(d,m,x){var T=m.pendingProps,L=!1,z=(m.flags&128)!==0,te;if((te=z)||(te=d!==null&&d.memoizedState===null?!1:(Ri.current&2)!==0),te&&(L=!0,m.flags&=-129),te=(m.flags&32)!==0,m.flags&=-33,d===null){if(ri){if(L?En(m):Oe(),ri){var le=wi,Ce;if(Ce=le){e:{for(Ce=le,le=ol;Ce.nodeType!==8;){if(!le){le=null;break e}if(Ce=Ha(Ce.nextSibling),Ce===null){le=null;break e}}le=Ce}le!==null?(m.memoizedState={dehydrated:le,treeContext:al!==null?{id:Dl,overflow:Fl}:null,retryLane:536870912,hydrationErrors:null},Ce=Ht(18,null,null,0),Ce.stateNode=le,Ce.return=m,m.child=Ce,Gs=m,wi=null,Ce=!0):Ce=!1}Ce||Wu(m)}if(le=m.memoizedState,le!==null&&(le=le.dehydrated,le!==null))return _b(le)?m.lanes=32:m.lanes=536870912,null;Vl(m)}return le=T.children,T=T.fallback,L?(Oe(),L=m.mode,le=vg({mode:"hidden",children:le},L),T=Ra(T,L,x,null),le.return=m,T.return=m,le.sibling=T,m.child=le,L=m.child,L.memoizedState=id(x),L.childLanes=rp(d,te,x),m.memoizedState=sp,T):(En(m),ab(m,le))}if(Ce=d.memoizedState,Ce!==null&&(le=Ce.dehydrated,le!==null)){if(z)m.flags&256?(En(m),m.flags&=-257,m=Hl(d,m,x)):m.memoizedState!==null?(Oe(),m.child=d.child,m.flags|=128,m=null):(Oe(),L=T.fallback,le=m.mode,T=vg({mode:"visible",children:T.children},le),L=Ra(L,le,x,null),L.flags|=2,T.return=m,L.return=m,T.sibling=L,m.child=T,Ut(m,d.child,null,x),T=m.child,T.memoizedState=id(x),T.childLanes=rp(d,te,x),m.memoizedState=sp,m=L);else if(En(m),_b(le)){if(te=le.nextSibling&&le.nextSibling.dataset,te)var it=te.dgst;te=it,T=Error(a(419)),T.stack="",T.digest=te,Pf({value:T,source:null,stack:null}),m=Hl(d,m,x)}else if(mr||cl(d,m,x,!1),te=(x&d.childLanes)!==0,mr||te){if(te=ps,te!==null&&(T=x&-x,T=(T&42)!==0?1:nn(T),T=(T&(te.suspendedLanes|x))!==0?0:T,T!==0&&T!==Ce.retryLane))throw Ce.retryLane=T,Uu(d,T),gr(te,d,T),Lx;le.data==="$?"||yb(),m=Hl(d,m,x)}else le.data==="$?"?(m.flags|=192,m.child=d.child,m=null):(d=Ce.treeContext,wi=Ha(le.nextSibling),Gs=m,ri=!0,oa=null,ol=!1,d!==null&&(rr[fo++]=Dl,rr[fo++]=Fl,rr[fo++]=al,Dl=d.id,Fl=d.overflow,al=m),m=ab(m,T.children),m.flags|=4096);return m}return L?(Oe(),L=T.fallback,le=m.mode,Ce=d.child,it=Ce.sibling,T=Zr(Ce,{mode:"hidden",children:T.children}),T.subtreeFlags=Ce.subtreeFlags&65011712,it!==null?L=Zr(it,L):(L=Ra(L,le,x,null),L.flags|=2),L.return=m,T.return=m,T.sibling=L,m.child=T,T=L,L=m.child,le=d.child.memoizedState,le===null?le=id(x):(Ce=le.cachePool,Ce!==null?(it=Xs._currentValue,Ce=Ce.parent!==it?{parent:it,pool:it}:Ce):Ce=ze(),le={baseLanes:le.baseLanes|x,cachePool:Ce}),L.memoizedState=le,L.childLanes=rp(d,te,x),m.memoizedState=sp,T):(En(m),x=d.child,d=x.sibling,x=Zr(x,{mode:"visible",children:T.children}),x.return=m,x.sibling=null,d!==null&&(te=m.deletions,te===null?(m.deletions=[d],m.flags|=16):te.push(d)),m.child=x,m.memoizedState=null,x)}function ab(d,m){return m=vg({mode:"visible",children:m},d.mode),m.return=d,d.child=m}function vg(d,m){return d=Ht(22,d,null,m),d.lanes=0,d.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},d}function Hl(d,m,x){return Ut(m,d.child,null,x),d=ab(m,m.pendingProps.children),d.flags|=2,m.memoizedState=null,d}function Pc(d,m,x){d.lanes|=m;var T=d.alternate;T!==null&&(T.lanes|=m),Hs(d.return,m,x)}function or(d,m,x,T,L){var z=d.memoizedState;z===null?d.memoizedState={isBackwards:m,rendering:null,renderingStartTime:0,last:T,tail:x,tailMode:L}:(z.isBackwards=m,z.rendering=null,z.renderingStartTime=0,z.last=T,z.tail=x,z.tailMode=L)}function pl(d,m,x){var T=m.pendingProps,L=T.revealOrder,z=T.tail;if(Mr(d,m,T.children,x),T=Ri.current,(T&2)!==0)T=T&1|2,m.flags|=128;else{if(d!==null&&(d.flags&128)!==0)e:for(d=m.child;d!==null;){if(d.tag===13)d.memoizedState!==null&&Pc(d,x,m);else if(d.tag===19)Pc(d,x,m);else if(d.child!==null){d.child.return=d,d=d.child;continue}if(d===m)break e;for(;d.sibling===null;){if(d.return===null||d.return===m)break e;d=d.return}d.sibling.return=d.return,d=d.sibling}T&=1}switch(gt(Ri,T),L){case"forwards":for(x=m.child,L=null;x!==null;)d=x.alternate,d!==null&&gg(d)===null&&(L=x),x=x.sibling;x=L,x===null?(L=m.child,m.child=null):(L=x.sibling,x.sibling=null),or(m,!1,L,x,z);break;case"backwards":for(x=null,L=m.child,m.child=null;L!==null;){if(d=L.alternate,d!==null&&gg(d)===null){m.child=L;break}d=L.sibling,L.sibling=x,x=L,L=d}or(m,!0,x,null,z);break;case"together":or(m,!1,null,null,void 0);break;default:m.memoizedState=null}return m.child}function Ms(d,m,x){if(d!==null&&(m.dependencies=d.dependencies),Kc|=m.lanes,(x&m.childLanes)===0)if(d!==null){if(cl(d,m,x,!1),(x&m.childLanes)===0)return null}else return null;if(d!==null&&m.child!==d.child)throw Error(a(153));if(m.child!==null){for(d=m.child,x=Zr(d,d.pendingProps),m.child=x,x.return=m;d.sibling!==null;)d=d.sibling,x=x.sibling=Zr(d,d.pendingProps),x.return=m;x.sibling=null}return m.child}function ob(d,m){return(d.lanes&m)!==0?!0:(d=d.dependencies,!!(d!==null&&Jm(d)))}function He(d,m,x){switch(m.tag){case 3:je(m,m.stateNode.containerInfo),Oo(m,Xs,d.memoizedState.cache),Ol();break;case 27:case 5:Ot(m);break;case 4:je(m,m.stateNode.containerInfo);break;case 10:Oo(m,m.type,m.memoizedProps.value);break;case 13:var T=m.memoizedState;if(T!==null)return T.dehydrated!==null?(En(m),m.flags|=128,null):(x&m.child.childLanes)!==0?Zu(d,m,x):(En(m),d=Ms(d,m,x),d!==null?d.sibling:null);En(m);break;case 19:var L=(d.flags&128)!==0;if(T=(x&m.childLanes)!==0,T||(cl(d,m,x,!1),T=(x&m.childLanes)!==0),L){if(T)return pl(d,m,x);m.flags|=128}if(L=m.memoizedState,L!==null&&(L.rendering=null,L.tail=null,L.lastEffect=null),gt(Ri,Ri.current),T)break;return null;case 22:case 23:return m.lanes=0,nd(d,m,x);case 24:Oo(m,Xs,d.memoizedState.cache)}return Ms(d,m,x)}function Ux(d,m,x){if(d!==null)if(d.memoizedProps!==m.pendingProps)mr=!0;else{if(!ob(d,x)&&(m.flags&128)===0)return mr=!1,He(d,m,x);mr=(d.flags&131072)!==0}else mr=!1,ri&&(m.flags&1048576)!==0&&RA(m,Os,m.index);switch(m.lanes=0,m.tag){case 16:e:{d=m.pendingProps;var T=m.elementType,L=T._init;if(T=L(T._payload),m.type=T,typeof T=="function")_A(T)?(d=Uc(T,d),m.tag=1,m=Ox(null,m,T,d,x)):(m.tag=0,m=qs(null,m,T,d,x));else{if(T!=null){if(L=T.$$typeof,L===K){m.tag=11,m=Nx(null,m,T,d,x);break e}else if(L===ee){m.tag=14,m=Dx(null,m,T,d,x);break e}}throw m=Pe(T)||T,Error(a(306,m,""))}}return m;case 0:return qs(d,m,m.type,m.pendingProps,x);case 1:return T=m.type,L=Uc(T,m.pendingProps),Ox(d,m,T,L,x);case 3:e:{if(je(m,m.stateNode.containerInfo),d===null)throw Error(a(387));T=m.pendingProps;var z=m.memoizedState;L=z.element,zA(d,m),Qu(m,T,null,x);var te=m.memoizedState;if(T=te.cache,Oo(m,Xs,T),T!==z.cache&&Ba(m,[Xs],x,!0),Zf(),T=te.element,z.isDehydrated)if(z={element:T,isDehydrated:!1,cache:te.cache},m.updateQueue.baseState=z,m.memoizedState=z,m.flags&256){m=Gx(d,m,T,x);break e}else if(T!==L){L=Tr(Error(a(424)),m),Pf(L),m=Gx(d,m,T,x);break e}else{switch(d=m.stateNode.containerInfo,d.nodeType){case 9:d=d.body;break;default:d=d.nodeName==="HTML"?d.ownerDocument.body:d}for(wi=Ha(d.firstChild),Gs=m,ri=!0,oa=null,ol=!0,x=Sx(m,null,T,x),m.child=x;x;)x.flags=x.flags&-3|4096,x=x.sibling}else{if(Ol(),T===L){m=Ms(d,m,x);break e}Mr(d,m,T,x)}m=m.child}return m;case 26:return go(d,m),d===null?(x=C1(m.type,null,m.pendingProps,null))?m.memoizedState=x:ri||(x=m.type,d=m.pendingProps,T=Ng(Tt.current).createElement(x),T[Ts]=m,T[ir]=d,ks(T,x,d),Vs(T),m.stateNode=T):m.memoizedState=C1(m.type,d.memoizedProps,m.pendingProps,d.memoizedState),null;case 27:return Ot(m),d===null&&ri&&(T=m.stateNode=Fg(m.type,m.pendingProps,Tt.current),Gs=m,ol=!0,L=wi,jc(m.type)?(Rb=L,wi=Ha(T.firstChild)):wi=L),Mr(d,m,m.pendingProps.children,x),go(d,m),d===null&&(m.flags|=4194304),m.child;case 5:return d===null&&ri&&((L=T=wi)&&(T=MS(T,m.type,m.pendingProps,ol),T!==null?(m.stateNode=T,Gs=m,wi=Ha(T.firstChild),ol=!1,L=!0):L=!1),L||Wu(m)),Ot(m),L=m.type,z=m.pendingProps,te=d!==null?d.memoizedProps:null,T=z.children,Ib(L,z)?T=null:te!==null&&Ib(L,te)&&(m.flags|=32),m.memoizedState!==null&&(L=sg(d,m,sS,null,null,x),wd._currentValue=L),go(d,m),Mr(d,m,T,x),m.child;case 6:return d===null&&ri&&((d=x=wi)&&(x=_S(x,m.pendingProps,ol),x!==null?(m.stateNode=x,Gs=m,wi=null,d=!0):d=!1),d||Wu(m)),null;case 13:return Zu(d,m,x);case 4:return je(m,m.stateNode.containerInfo),T=m.pendingProps,d===null?m.child=Ut(m,null,T,x):Mr(d,m,T,x),m.child;case 11:return Nx(d,m,m.type,m.pendingProps,x);case 7:return Mr(d,m,m.pendingProps,x),m.child;case 8:return Mr(d,m,m.pendingProps.children,x),m.child;case 12:return Mr(d,m,m.pendingProps.children,x),m.child;case 10:return T=m.pendingProps,Oo(m,m.type,T.value),Mr(d,m,T.children,x),m.child;case 9:return L=m.type._context,T=m.pendingProps.children,Hu(m),L=Ci(L),T=T(L),m.flags|=1,Mr(d,m,T,x),m.child;case 14:return Dx(d,m,m.type,m.pendingProps,x);case 15:return Fx(d,m,m.type,m.pendingProps,x);case 19:return pl(d,m,x);case 31:return T=m.pendingProps,x=m.mode,T={mode:T.mode,children:T.children},d===null?(x=vg(T,x),x.ref=m.ref,m.child=x,x.return=m,m=x):(x=Zr(d.child,T),x.ref=m.ref,m.child=x,x.return=m,m=x),m;case 22:return nd(d,m,x);case 24:return Hu(m),T=Ci(Xs),d===null?(L=GA(),L===null&&(L=ps,z=Vf(),L.pooledCache=z,z.refCount++,z!==null&&(L.pooledCacheLanes|=x),L=z),m.memoizedState={parent:T,cache:L},Qe(m),Oo(m,Xs,L)):((d.lanes&x)!==0&&(zA(d,m),Qu(m,null,null,x),Zf()),L=d.memoizedState,z=m.memoizedState,L.parent!==T?(L={parent:T,cache:T},m.memoizedState=L,m.lanes===0&&(m.memoizedState=m.updateQueue.baseState=L),Oo(m,Xs,T)):(T=z.cache,Oo(m,Xs,T),T!==L.cache&&Ba(m,[Xs],x,!0))),Mr(d,m,m.pendingProps.children,x),m.child;case 29:throw m.pendingProps}throw Error(a(156,m.tag))}function Go(d){d.flags|=4}function Px(d,m){if(m.type!=="stylesheet"||(m.state.loading&4)!==0)d.flags&=-16777217;else if(d.flags|=16777216,!T1(m)){if(m=Fa.current,m!==null&&((ki&4194048)===ki?fl!==null:(ki&62914560)!==ki&&(ki&536870912)===0||m!==fl))throw Zh=eg,rx;d.flags|=8192}}function xg(d,m){m!==null&&(d.flags|=4),d.flags&16384&&(m=d.tag!==22?wt():536870912,d.lanes|=m,ud|=m)}function ap(d,m){if(!ri)switch(d.tailMode){case"hidden":m=d.tail;for(var x=null;m!==null;)m.alternate!==null&&(x=m),m=m.sibling;x===null?d.tail=null:x.sibling=null;break;case"collapsed":x=d.tail;for(var T=null;x!==null;)x.alternate!==null&&(T=x),x=x.sibling;T===null?m||d.tail===null?d.tail=null:d.tail.sibling=null:T.sibling=null}}function yi(d){var m=d.alternate!==null&&d.alternate.child===d.child,x=0,T=0;if(m)for(var L=d.child;L!==null;)x|=L.lanes|L.childLanes,T|=L.subtreeFlags&65011712,T|=L.flags&65011712,L.return=d,L=L.sibling;else for(L=d.child;L!==null;)x|=L.lanes|L.childLanes,T|=L.subtreeFlags,T|=L.flags,L.return=d,L=L.sibling;return d.subtreeFlags|=T,d.childLanes=x,m}function oS(d,m,x){var T=m.pendingProps;switch(kA(m),m.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return yi(m),null;case 1:return yi(m),null;case 3:return x=m.stateNode,T=null,d!==null&&(T=d.memoizedState.cache),m.memoizedState.cache!==T&&(m.flags|=2048),ka(Xs),_t(),x.pendingContext&&(x.context=x.pendingContext,x.pendingContext=null),(d===null||d.child===null)&&(Kh(m)?Go(m):d===null||d.memoizedState.isDehydrated&&(m.flags&256)===0||(m.flags|=1024,qm())),yi(m),null;case 26:return x=m.memoizedState,d===null?(Go(m),x!==null?(yi(m),Px(m,x)):(yi(m),m.flags&=-16777217)):x?x!==d.memoizedState?(Go(m),yi(m),Px(m,x)):(yi(m),m.flags&=-16777217):(d.memoizedProps!==T&&Go(m),yi(m),m.flags&=-16777217),null;case 27:on(m),x=Tt.current;var L=m.type;if(d!==null&&m.stateNode!=null)d.memoizedProps!==T&&Go(m);else{if(!T){if(m.stateNode===null)throw Error(a(166));return yi(m),null}d=bt.current,Kh(m)?ex(m):(d=Fg(L,T,x),m.stateNode=d,Go(m))}return yi(m),null;case 5:if(on(m),x=m.type,d!==null&&m.stateNode!=null)d.memoizedProps!==T&&Go(m);else{if(!T){if(m.stateNode===null)throw Error(a(166));return yi(m),null}if(d=bt.current,Kh(m))ex(m);else{switch(L=Ng(Tt.current),d){case 1:d=L.createElementNS("http://www.w3.org/2000/svg",x);break;case 2:d=L.createElementNS("http://www.w3.org/1998/Math/MathML",x);break;default:switch(x){case"svg":d=L.createElementNS("http://www.w3.org/2000/svg",x);break;case"math":d=L.createElementNS("http://www.w3.org/1998/Math/MathML",x);break;case"script":d=L.createElement("div"),d.innerHTML="<script><\/script>",d=d.removeChild(d.firstChild);break;case"select":d=typeof T.is=="string"?L.createElement("select",{is:T.is}):L.createElement("select"),T.multiple?d.multiple=!0:T.size&&(d.size=T.size);break;default:d=typeof T.is=="string"?L.createElement(x,{is:T.is}):L.createElement(x)}}d[Ts]=m,d[ir]=T;e:for(L=m.child;L!==null;){if(L.tag===5||L.tag===6)d.appendChild(L.stateNode);else if(L.tag!==4&&L.tag!==27&&L.child!==null){L.child.return=L,L=L.child;continue}if(L===m)break e;for(;L.sibling===null;){if(L.return===null||L.return===m)break e;L=L.return}L.sibling.return=L.return,L=L.sibling}m.stateNode=d;e:switch(ks(d,x,T),x){case"button":case"input":case"select":case"textarea":d=!!T.autoFocus;break e;case"img":d=!0;break e;default:d=!1}d&&Go(m)}}return yi(m),m.flags&=-16777217,null;case 6:if(d&&m.stateNode!=null)d.memoizedProps!==T&&Go(m);else{if(typeof T!="string"&&m.stateNode===null)throw Error(a(166));if(d=Tt.current,Kh(m)){if(d=m.stateNode,x=m.memoizedProps,T=null,L=Gs,L!==null)switch(L.tag){case 27:case 5:T=L.memoizedProps}d[Ts]=m,d=!!(d.nodeValue===x||T!==null&&T.suppressHydrationWarning===!0||Yl(d.nodeValue,x)),d||Wu(m)}else d=Ng(d).createTextNode(T),d[Ts]=m,m.stateNode=d}return yi(m),null;case 13:if(T=m.memoizedState,d===null||d.memoizedState!==null&&d.memoizedState.dehydrated!==null){if(L=Kh(m),T!==null&&T.dehydrated!==null){if(d===null){if(!L)throw Error(a(318));if(L=m.memoizedState,L=L!==null?L.dehydrated:null,!L)throw Error(a(317));L[Ts]=m}else Ol(),(m.flags&128)===0&&(m.memoizedState=null),m.flags|=4;yi(m),L=!1}else L=qm(),d!==null&&d.memoizedState!==null&&(d.memoizedState.hydrationErrors=L),L=!0;if(!L)return m.flags&256?(Vl(m),m):(Vl(m),null)}if(Vl(m),(m.flags&128)!==0)return m.lanes=x,m;if(x=T!==null,d=d!==null&&d.memoizedState!==null,x){T=m.child,L=null,T.alternate!==null&&T.alternate.memoizedState!==null&&T.alternate.memoizedState.cachePool!==null&&(L=T.alternate.memoizedState.cachePool.pool);var z=null;T.memoizedState!==null&&T.memoizedState.cachePool!==null&&(z=T.memoizedState.cachePool.pool),z!==L&&(T.flags|=2048)}return x!==d&&x&&(m.child.flags|=8192),xg(m,m.updateQueue),yi(m),null;case 4:return _t(),d===null&&gp(m.stateNode.containerInfo),yi(m),null;case 10:return ka(m.type),yi(m),null;case 19:if(Ne(Ri),L=m.memoizedState,L===null)return yi(m),null;if(T=(m.flags&128)!==0,z=L.rendering,z===null)if(T)ap(L,!1);else{if(Ii!==0||d!==null&&(d.flags&128)!==0)for(d=m.child;d!==null;){if(z=gg(d),z!==null){for(m.flags|=128,ap(L,!1),d=z.updateQueue,m.updateQueue=d,xg(m,d),m.subtreeFlags=0,d=x,x=m.child;x!==null;)Ff(x,d),x=x.sibling;return gt(Ri,Ri.current&1|2),m.child}d=d.sibling}L.tail!==null&&Ee()>Eg&&(m.flags|=128,T=!0,ap(L,!1),m.lanes=4194304)}else{if(!T)if(d=gg(z),d!==null){if(m.flags|=128,T=!0,d=d.updateQueue,m.updateQueue=d,xg(m,d),ap(L,!0),L.tail===null&&L.tailMode==="hidden"&&!z.alternate&&!ri)return yi(m),null}else 2*Ee()-L.renderingStartTime>Eg&&x!==536870912&&(m.flags|=128,T=!0,ap(L,!1),m.lanes=4194304);L.isBackwards?(z.sibling=m.child,m.child=z):(d=L.last,d!==null?d.sibling=z:m.child=z,L.last=z)}return L.tail!==null?(m=L.tail,L.rendering=m,L.tail=m.sibling,L.renderingStartTime=Ee(),m.sibling=null,d=Ri.current,gt(Ri,T?d&1|2:d&1),m):(yi(m),null);case 22:case 23:return Vl(m),HA(),T=m.memoizedState!==null,d!==null?d.memoizedState!==null!==T&&(m.flags|=8192):T&&(m.flags|=8192),T?(x&536870912)!==0&&(m.flags&128)===0&&(yi(m),m.subtreeFlags&6&&(m.flags|=8192)):yi(m),x=m.updateQueue,x!==null&&xg(m,x.retryQueue),x=null,d!==null&&d.memoizedState!==null&&d.memoizedState.cachePool!==null&&(x=d.memoizedState.cachePool.pool),T=null,m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(T=m.memoizedState.cachePool.pool),T!==x&&(m.flags|=2048),d!==null&&Ne(po),null;case 24:return x=null,d!==null&&(x=d.memoizedState.cache),m.memoizedState.cache!==x&&(m.flags|=2048),ka(Xs),yi(m),null;case 25:return null;case 30:return null}throw Error(a(156,m.tag))}function sd(d,m){switch(kA(m),m.tag){case 1:return d=m.flags,d&65536?(m.flags=d&-65537|128,m):null;case 3:return ka(Xs),_t(),d=m.flags,(d&65536)!==0&&(d&128)===0?(m.flags=d&-65537|128,m):null;case 26:case 27:case 5:return on(m),null;case 13:if(Vl(m),d=m.memoizedState,d!==null&&d.dehydrated!==null){if(m.alternate===null)throw Error(a(340));Ol()}return d=m.flags,d&65536?(m.flags=d&-65537|128,m):null;case 19:return Ne(Ri),null;case 4:return _t(),null;case 10:return ka(m.type),null;case 22:case 23:return Vl(m),HA(),d!==null&&Ne(po),d=m.flags,d&65536?(m.flags=d&-65537|128,m):null;case 24:return ka(Xs),null;case 25:return null;default:return null}}function zx(d,m){switch(kA(m),m.tag){case 3:ka(Xs),_t();break;case 26:case 27:case 5:on(m);break;case 4:_t();break;case 13:Vl(m);break;case 19:Ne(Ri);break;case 10:ka(m.type);break;case 22:case 23:Vl(m),HA(),d!==null&&Ne(po);break;case 24:ka(Xs)}}function Vi(d,m){try{var x=m.updateQueue,T=x!==null?x.lastEffect:null;if(T!==null){var L=T.next;x=L;do{if((x.tag&d)===d){T=void 0;var z=x.create,te=x.inst;T=z(),te.destroy=T}x=x.next}while(x!==L)}}catch(le){ls(m,m.return,le)}}function zc(d,m,x){try{var T=m.updateQueue,L=T!==null?T.lastEffect:null;if(L!==null){var z=L.next;T=z;do{if((T.tag&d)===d){var te=T.inst,le=te.destroy;if(le!==void 0){te.destroy=void 0,L=m;var Ce=x,it=le;try{it()}catch(Ct){ls(L,Ce,Ct)}}}T=T.next}while(T!==z)}}catch(Ct){ls(m,m.return,Ct)}}function wg(d){var m=d.updateQueue;if(m!==null){var x=d.stateNode;try{ax(m,x)}catch(T){ls(d,d.return,T)}}}function Vx(d,m,x){x.props=Uc(d.type,d.memoizedProps),x.state=d.memoizedState;try{x.componentWillUnmount()}catch(T){ls(d,m,T)}}function $u(d,m){try{var x=d.ref;if(x!==null){switch(d.tag){case 26:case 27:case 5:var T=d.stateNode;break;case 30:T=d.stateNode;break;default:T=d.stateNode}typeof x=="function"?d.refCleanup=x(T):x.current=T}}catch(L){ls(d,m,L)}}function ml(d,m){var x=d.ref,T=d.refCleanup;if(x!==null)if(typeof T=="function")try{T()}catch(L){ls(d,m,L)}finally{d.refCleanup=null,d=d.alternate,d!=null&&(d.refCleanup=null)}else if(typeof x=="function")try{x(null)}catch(L){ls(d,m,L)}else x.current=null}function Wx(d){var m=d.type,x=d.memoizedProps,T=d.stateNode;try{e:switch(m){case"button":case"input":case"select":case"textarea":x.autoFocus&&T.focus();break e;case"img":x.src?T.src=x.src:x.srcSet&&(T.srcset=x.srcSet)}}catch(L){ls(d,d.return,L)}}function rd(d,m,x){try{var T=d.stateNode;ES(T,d.type,x,m),T[ir]=m}catch(L){ls(d,d.return,L)}}function Hx(d){return d.tag===5||d.tag===3||d.tag===26||d.tag===27&&jc(d.type)||d.tag===4}function lb(d){e:for(;;){for(;d.sibling===null;){if(d.return===null||Hx(d.return))return null;d=d.return}for(d.sibling.return=d.return,d=d.sibling;d.tag!==5&&d.tag!==6&&d.tag!==18;){if(d.tag===27&&jc(d.type)||d.flags&2||d.child===null||d.tag===4)continue e;d.child.return=d,d=d.child}if(!(d.flags&2))return d.stateNode}}function cb(d,m,x){var T=d.tag;if(T===5||T===6)d=d.stateNode,m?(x.nodeType===9?x.body:x.nodeName==="HTML"?x.ownerDocument.body:x).insertBefore(d,m):(m=x.nodeType===9?x.body:x.nodeName==="HTML"?x.ownerDocument.body:x,m.appendChild(d),x=x._reactRootContainer,x!=null||m.onclick!==null||(m.onclick=Lg));else if(T!==4&&(T===27&&jc(d.type)&&(x=d.stateNode,m=null),d=d.child,d!==null))for(cb(d,m,x),d=d.sibling;d!==null;)cb(d,m,x),d=d.sibling}function Cg(d,m,x){var T=d.tag;if(T===5||T===6)d=d.stateNode,m?x.insertBefore(d,m):x.appendChild(d);else if(T!==4&&(T===27&&jc(d.type)&&(x=d.stateNode),d=d.child,d!==null))for(Cg(d,m,x),d=d.sibling;d!==null;)Cg(d,m,x),d=d.sibling}function Xx(d){var m=d.stateNode,x=d.memoizedProps;try{for(var T=d.type,L=m.attributes;L.length;)m.removeAttributeNode(L[0]);ks(m,T,x),m[Ts]=d,m[ir]=x}catch(z){ls(d,d.return,z)}}var Xl=!1,Ks=!1,ub=!1,Qx=typeof WeakSet=="function"?WeakSet:Set,_s=null;function lS(d,m){if(d=d.containerInfo,bp=Ep,d=kf(d),Bf(d)){if("selectionStart"in d)var x={start:d.selectionStart,end:d.selectionEnd};else e:{x=(x=d.ownerDocument)&&x.defaultView||window;var T=x.getSelection&&x.getSelection();if(T&&T.rangeCount!==0){x=T.anchorNode;var L=T.anchorOffset,z=T.focusNode;T=T.focusOffset;try{x.nodeType,z.nodeType}catch{x=null;break e}var te=0,le=-1,Ce=-1,it=0,Ct=0,Rt=d,at=null;t:for(;;){for(var lt;Rt!==x||L!==0&&Rt.nodeType!==3||(le=te+L),Rt!==z||T!==0&&Rt.nodeType!==3||(Ce=te+T),Rt.nodeType===3&&(te+=Rt.nodeValue.length),(lt=Rt.firstChild)!==null;)at=Rt,Rt=lt;for(;;){if(Rt===d)break t;if(at===x&&++it===L&&(le=te),at===z&&++Ct===T&&(Ce=te),(lt=Rt.nextSibling)!==null)break;Rt=at,at=Rt.parentNode}Rt=lt}x=le===-1||Ce===-1?null:{start:le,end:Ce}}else x=null}x=x||{start:0,end:0}}else x=null;for(Sb={focusedElem:d,selectionRange:x},Ep=!1,_s=m;_s!==null;)if(m=_s,d=m.child,(m.subtreeFlags&1024)!==0&&d!==null)d.return=m,_s=d;else for(;_s!==null;){switch(m=_s,z=m.alternate,d=m.flags,m.tag){case 0:break;case 11:case 15:break;case 1:if((d&1024)!==0&&z!==null){d=void 0,x=m,L=z.memoizedProps,z=z.memoizedState,T=x.stateNode;try{var Fn=Uc(x.type,L,x.elementType===x.type);d=T.getSnapshotBeforeUpdate(Fn,z),T.__reactInternalSnapshotBeforeUpdate=d}catch(Pn){ls(x,x.return,Pn)}}break;case 3:if((d&1024)!==0){if(d=m.stateNode.containerInfo,x=d.nodeType,x===9)Mb(d);else if(x===1)switch(d.nodeName){case"HEAD":case"HTML":case"BODY":Mb(d);break;default:d.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((d&1024)!==0)throw Error(a(163))}if(d=m.sibling,d!==null){d.return=m.return,_s=d;break}_s=m.return}}function Kx(d,m,x){var T=x.flags;switch(x.tag){case 0:case 11:case 15:Wc(d,x),T&4&&Vi(5,x);break;case 1:if(Wc(d,x),T&4)if(d=x.stateNode,m===null)try{d.componentDidMount()}catch(te){ls(x,x.return,te)}else{var L=Uc(x.type,m.memoizedProps);m=m.memoizedState;try{d.componentDidUpdate(L,m,d.__reactInternalSnapshotBeforeUpdate)}catch(te){ls(x,x.return,te)}}T&64&&wg(x),T&512&&$u(x,x.return);break;case 3:if(Wc(d,x),T&64&&(d=x.updateQueue,d!==null)){if(m=null,x.child!==null)switch(x.child.tag){case 27:case 5:m=x.child.stateNode;break;case 1:m=x.child.stateNode}try{ax(d,m)}catch(te){ls(x,x.return,te)}}break;case 27:m===null&&T&4&&Xx(x);case 26:case 5:Wc(d,x),m===null&&T&4&&Wx(x),T&512&&$u(x,x.return);break;case 12:Wc(d,x);break;case 13:Wc(d,x),T&4&&$x(d,x),T&64&&(d=x.memoizedState,d!==null&&(d=d.dehydrated,d!==null&&(x=pS.bind(null,x),RS(d,x))));break;case 22:if(T=x.memoizedState!==null||Xl,!T){m=m!==null&&m.memoizedState!==null||Ks,L=Xl;var z=Ks;Xl=T,(Ks=m)&&!z?Xc(d,x,(x.subtreeFlags&8772)!==0):Wc(d,x),Xl=L,Ks=z}break;case 30:break;default:Wc(d,x)}}function op(d){var m=d.alternate;m!==null&&(d.alternate=null,op(m)),d.child=null,d.deletions=null,d.sibling=null,d.tag===5&&(m=d.stateNode,m!==null&&oo(m)),d.stateNode=null,d.return=null,d.dependencies=null,d.memoizedProps=null,d.memoizedState=null,d.pendingProps=null,d.stateNode=null,d.updateQueue=null}var Es=null,fs=!1;function Ql(d,m,x){for(x=x.child;x!==null;)Zx(d,m,x),x=x.sibling}function Zx(d,m,x){if(se&&typeof se.onCommitFiberUnmount=="function")try{se.onCommitFiberUnmount(ge,x)}catch{}switch(x.tag){case 26:Ks||ml(x,m),Ql(d,m,x),x.memoizedState?x.memoizedState.count--:x.stateNode&&(x=x.stateNode,x.parentNode.removeChild(x));break;case 27:Ks||ml(x,m);var T=Es,L=fs;jc(x.type)&&(Es=x.stateNode,fs=!1),Ql(d,m,x),xp(x.stateNode),Es=T,fs=L;break;case 5:Ks||ml(x,m);case 6:if(T=Es,L=fs,Es=null,Ql(d,m,x),Es=T,fs=L,Es!==null)if(fs)try{(Es.nodeType===9?Es.body:Es.nodeName==="HTML"?Es.ownerDocument.body:Es).removeChild(x.stateNode)}catch(z){ls(x,m,z)}else try{Es.removeChild(x.stateNode)}catch(z){ls(x,m,z)}break;case 18:Es!==null&&(fs?(d=Es,Dg(d.nodeType===9?d.body:d.nodeName==="HTML"?d.ownerDocument.body:d,x.stateNode),Jl(d)):Dg(Es,x.stateNode));break;case 4:T=Es,L=fs,Es=x.stateNode.containerInfo,fs=!0,Ql(d,m,x),Es=T,fs=L;break;case 0:case 11:case 14:case 15:Ks||zc(2,x,m),Ks||zc(4,x,m),Ql(d,m,x);break;case 1:Ks||(ml(x,m),T=x.stateNode,typeof T.componentWillUnmount=="function"&&Vx(x,m,T)),Ql(d,m,x);break;case 21:Ql(d,m,x);break;case 22:Ks=(T=Ks)||x.memoizedState!==null,Ql(d,m,x),Ks=T;break;default:Ql(d,m,x)}}function $x(d,m){if(m.memoizedState===null&&(d=m.alternate,d!==null&&(d=d.memoizedState,d!==null&&(d=d.dehydrated,d!==null))))try{Jl(d)}catch(x){ls(m,m.return,x)}}function cS(d){switch(d.tag){case 13:case 19:var m=d.stateNode;return m===null&&(m=d.stateNode=new Qx),m;case 22:return d=d.stateNode,m=d._retryCache,m===null&&(m=d._retryCache=new Qx),m;default:throw Error(a(435,d.tag))}}function hb(d,m){var x=cS(d);m.forEach(function(T){var L=mS.bind(null,d,T);x.has(T)||(x.add(T),T.then(L,L))})}function Ga(d,m){var x=m.deletions;if(x!==null)for(var T=0;T<x.length;T++){var L=x[T],z=d,te=m,le=te;e:for(;le!==null;){switch(le.tag){case 27:if(jc(le.type)){Es=le.stateNode,fs=!1;break e}break;case 5:Es=le.stateNode,fs=!1;break e;case 3:case 4:Es=le.stateNode.containerInfo,fs=!0;break e}le=le.return}if(Es===null)throw Error(a(160));Zx(z,te,L),Es=null,fs=!1,z=L.alternate,z!==null&&(z.return=null),L.return=null}if(m.subtreeFlags&13878)for(m=m.child;m!==null;)Yx(m,d),m=m.sibling}var Uo=null;function Yx(d,m){var x=d.alternate,T=d.flags;switch(d.tag){case 0:case 11:case 14:case 15:Ga(m,d),Ua(d),T&4&&(zc(3,d,d.return),Vi(3,d),zc(5,d,d.return));break;case 1:Ga(m,d),Ua(d),T&512&&(Ks||x===null||ml(x,x.return)),T&64&&Xl&&(d=d.updateQueue,d!==null&&(T=d.callbacks,T!==null&&(x=d.shared.hiddenCallbacks,d.shared.hiddenCallbacks=x===null?T:x.concat(T))));break;case 26:var L=Uo;if(Ga(m,d),Ua(d),T&512&&(Ks||x===null||ml(x,x.return)),T&4){var z=x!==null?x.memoizedState:null;if(T=d.memoizedState,x===null)if(T===null)if(d.stateNode===null){e:{T=d.type,x=d.memoizedProps,L=L.ownerDocument||L;t:switch(T){case"title":z=L.getElementsByTagName("title")[0],(!z||z[nl]||z[Ts]||z.namespaceURI==="http://www.w3.org/2000/svg"||z.hasAttribute("itemprop"))&&(z=L.createElement(T),L.head.insertBefore(z,L.querySelector("head > title"))),ks(z,T,x),z[Ts]=d,Vs(z),T=z;break e;case"link":var te=Cp("link","href",L).get(T+(x.href||""));if(te){for(var le=0;le<te.length;le++)if(z=te[le],z.getAttribute("href")===(x.href==null||x.href===""?null:x.href)&&z.getAttribute("rel")===(x.rel==null?null:x.rel)&&z.getAttribute("title")===(x.title==null?null:x.title)&&z.getAttribute("crossorigin")===(x.crossOrigin==null?null:x.crossOrigin)){te.splice(le,1);break t}}z=L.createElement(T),ks(z,T,x),L.head.appendChild(z);break;case"meta":if(te=Cp("meta","content",L).get(T+(x.content||""))){for(le=0;le<te.length;le++)if(z=te[le],z.getAttribute("content")===(x.content==null?null:""+x.content)&&z.getAttribute("name")===(x.name==null?null:x.name)&&z.getAttribute("property")===(x.property==null?null:x.property)&&z.getAttribute("http-equiv")===(x.httpEquiv==null?null:x.httpEquiv)&&z.getAttribute("charset")===(x.charSet==null?null:x.charSet)){te.splice(le,1);break t}}z=L.createElement(T),ks(z,T,x),L.head.appendChild(z);break;default:throw Error(a(468,T))}z[Ts]=d,Vs(z),T=z}d.stateNode=T}else I1(L,d.type,d.stateNode);else d.stateNode=S1(L,T,d.memoizedProps);else z!==T?(z===null?x.stateNode!==null&&(x=x.stateNode,x.parentNode.removeChild(x)):z.count--,T===null?I1(L,d.type,d.stateNode):S1(L,T,d.memoizedProps)):T===null&&d.stateNode!==null&&rd(d,d.memoizedProps,x.memoizedProps)}break;case 27:Ga(m,d),Ua(d),T&512&&(Ks||x===null||ml(x,x.return)),x!==null&&T&4&&rd(d,d.memoizedProps,x.memoizedProps);break;case 5:if(Ga(m,d),Ua(d),T&512&&(Ks||x===null||ml(x,x.return)),d.flags&32){L=d.stateNode;try{sr(L,"")}catch(lt){ls(d,d.return,lt)}}T&4&&d.stateNode!=null&&(L=d.memoizedProps,rd(d,L,x!==null?x.memoizedProps:L)),T&1024&&(ub=!0);break;case 6:if(Ga(m,d),Ua(d),T&4){if(d.stateNode===null)throw Error(a(162));T=d.memoizedProps,x=d.stateNode;try{x.nodeValue=T}catch(lt){ls(d,d.return,lt)}}break;case 3:if(Ju=null,L=Uo,Uo=yd(m.containerInfo),Ga(m,d),Uo=L,Ua(d),T&4&&x!==null&&x.memoizedState.isDehydrated)try{Jl(m.containerInfo)}catch(lt){ls(d,d.return,lt)}ub&&(ub=!1,Vc(d));break;case 4:T=Uo,Uo=yd(d.stateNode.containerInfo),Ga(m,d),Ua(d),Uo=T;break;case 12:Ga(m,d),Ua(d);break;case 13:Ga(m,d),Ua(d),d.child.flags&8192&&d.memoizedState!==null!=(x!==null&&x.memoizedState!==null)&&(mb=Ee()),T&4&&(T=d.updateQueue,T!==null&&(d.updateQueue=null,hb(d,T)));break;case 22:L=d.memoizedState!==null;var Ce=x!==null&&x.memoizedState!==null,it=Xl,Ct=Ks;if(Xl=it||L,Ks=Ct||Ce,Ga(m,d),Ks=Ct,Xl=it,Ua(d),T&8192)e:for(m=d.stateNode,m._visibility=L?m._visibility&-2:m._visibility|1,L&&(x===null||Ce||Xl||Ks||Hc(d)),x=null,m=d;;){if(m.tag===5||m.tag===26){if(x===null){Ce=x=m;try{if(z=Ce.stateNode,L)te=z.style,typeof te.setProperty=="function"?te.setProperty("display","none","important"):te.display="none";else{le=Ce.stateNode;var Rt=Ce.memoizedProps.style,at=Rt!=null&&Rt.hasOwnProperty("display")?Rt.display:null;le.style.display=at==null||typeof at=="boolean"?"":(""+at).trim()}}catch(lt){ls(Ce,Ce.return,lt)}}}else if(m.tag===6){if(x===null){Ce=m;try{Ce.stateNode.nodeValue=L?"":Ce.memoizedProps}catch(lt){ls(Ce,Ce.return,lt)}}}else if((m.tag!==22&&m.tag!==23||m.memoizedState===null||m===d)&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===d)break e;for(;m.sibling===null;){if(m.return===null||m.return===d)break e;x===m&&(x=null),m=m.return}x===m&&(x=null),m.sibling.return=m.return,m=m.sibling}T&4&&(T=d.updateQueue,T!==null&&(x=T.retryQueue,x!==null&&(T.retryQueue=null,hb(d,x))));break;case 19:Ga(m,d),Ua(d),T&4&&(T=d.updateQueue,T!==null&&(d.updateQueue=null,hb(d,T)));break;case 30:break;case 21:break;default:Ga(m,d),Ua(d)}}function Ua(d){var m=d.flags;if(m&2){try{for(var x,T=d.return;T!==null;){if(Hx(T)){x=T;break}T=T.return}if(x==null)throw Error(a(160));switch(x.tag){case 27:var L=x.stateNode,z=lb(d);Cg(d,z,L);break;case 5:var te=x.stateNode;x.flags&32&&(sr(te,""),x.flags&=-33);var le=lb(d);Cg(d,le,te);break;case 3:case 4:var Ce=x.stateNode.containerInfo,it=lb(d);cb(d,it,Ce);break;default:throw Error(a(161))}}catch(Ct){ls(d,d.return,Ct)}d.flags&=-3}m&4096&&(d.flags&=-4097)}function Vc(d){if(d.subtreeFlags&1024)for(d=d.child;d!==null;){var m=d;Vc(m),m.tag===5&&m.flags&1024&&m.stateNode.reset(),d=d.sibling}}function Wc(d,m){if(m.subtreeFlags&8772)for(m=m.child;m!==null;)Kx(d,m.alternate,m),m=m.sibling}function Hc(d){for(d=d.child;d!==null;){var m=d;switch(m.tag){case 0:case 11:case 14:case 15:zc(4,m,m.return),Hc(m);break;case 1:ml(m,m.return);var x=m.stateNode;typeof x.componentWillUnmount=="function"&&Vx(m,m.return,x),Hc(m);break;case 27:xp(m.stateNode);case 26:case 5:ml(m,m.return),Hc(m);break;case 22:m.memoizedState===null&&Hc(m);break;case 30:Hc(m);break;default:Hc(m)}d=d.sibling}}function Xc(d,m,x){for(x=x&&(m.subtreeFlags&8772)!==0,m=m.child;m!==null;){var T=m.alternate,L=d,z=m,te=z.flags;switch(z.tag){case 0:case 11:case 15:Xc(L,z,x),Vi(4,z);break;case 1:if(Xc(L,z,x),T=z,L=T.stateNode,typeof L.componentDidMount=="function")try{L.componentDidMount()}catch(it){ls(T,T.return,it)}if(T=z,L=T.updateQueue,L!==null){var le=T.stateNode;try{var Ce=L.shared.hiddenCallbacks;if(Ce!==null)for(L.shared.hiddenCallbacks=null,L=0;L<Ce.length;L++)VA(Ce[L],le)}catch(it){ls(T,T.return,it)}}x&&te&64&&wg(z),$u(z,z.return);break;case 27:Xx(z);case 26:case 5:Xc(L,z,x),x&&T===null&&te&4&&Wx(z),$u(z,z.return);break;case 12:Xc(L,z,x);break;case 13:Xc(L,z,x),x&&te&4&&$x(L,z);break;case 22:z.memoizedState===null&&Xc(L,z,x),$u(z,z.return);break;case 30:break;default:Xc(L,z,x)}m=m.sibling}}function lp(d,m){var x=null;d!==null&&d.memoizedState!==null&&d.memoizedState.cachePool!==null&&(x=d.memoizedState.cachePool.pool),d=null,m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(d=m.memoizedState.cachePool.pool),d!==x&&(d!=null&&d.refCount++,x!=null&&Wf(x))}function db(d,m){d=null,m.alternate!==null&&(d=m.alternate.memoizedState.cache),m=m.memoizedState.cache,m!==d&&(m.refCount++,d!=null&&Wf(d))}function Po(d,m,x,T){if(m.subtreeFlags&10256)for(m=m.child;m!==null;)jx(d,m,x,T),m=m.sibling}function jx(d,m,x,T){var L=m.flags;switch(m.tag){case 0:case 11:case 15:Po(d,m,x,T),L&2048&&Vi(9,m);break;case 1:Po(d,m,x,T);break;case 3:Po(d,m,x,T),L&2048&&(d=null,m.alternate!==null&&(d=m.alternate.memoizedState.cache),m=m.memoizedState.cache,m!==d&&(m.refCount++,d!=null&&Wf(d)));break;case 12:if(L&2048){Po(d,m,x,T),d=m.stateNode;try{var z=m.memoizedProps,te=z.id,le=z.onPostCommit;typeof le=="function"&&le(te,m.alternate===null?"mount":"update",d.passiveEffectDuration,-0)}catch(Ce){ls(m,m.return,Ce)}}else Po(d,m,x,T);break;case 13:Po(d,m,x,T);break;case 23:break;case 22:z=m.stateNode,te=m.alternate,m.memoizedState!==null?z._visibility&2?Po(d,m,x,T):cp(d,m):z._visibility&2?Po(d,m,x,T):(z._visibility|=2,ad(d,m,x,T,(m.subtreeFlags&10256)!==0)),L&2048&&lp(te,m);break;case 24:Po(d,m,x,T),L&2048&&db(m.alternate,m);break;default:Po(d,m,x,T)}}function ad(d,m,x,T,L){for(L=L&&(m.subtreeFlags&10256)!==0,m=m.child;m!==null;){var z=d,te=m,le=x,Ce=T,it=te.flags;switch(te.tag){case 0:case 11:case 15:ad(z,te,le,Ce,L),Vi(8,te);break;case 23:break;case 22:var Ct=te.stateNode;te.memoizedState!==null?Ct._visibility&2?ad(z,te,le,Ce,L):cp(z,te):(Ct._visibility|=2,ad(z,te,le,Ce,L)),L&&it&2048&&lp(te.alternate,te);break;case 24:ad(z,te,le,Ce,L),L&&it&2048&&db(te.alternate,te);break;default:ad(z,te,le,Ce,L)}m=m.sibling}}function cp(d,m){if(m.subtreeFlags&10256)for(m=m.child;m!==null;){var x=d,T=m,L=T.flags;switch(T.tag){case 22:cp(x,T),L&2048&&lp(T.alternate,T);break;case 24:cp(x,T),L&2048&&db(T.alternate,T);break;default:cp(x,T)}m=m.sibling}}var od=8192;function ld(d){if(d.subtreeFlags&od)for(d=d.child;d!==null;)qx(d),d=d.sibling}function qx(d){switch(d.tag){case 26:ld(d),d.flags&od&&d.memoizedState!==null&&M1(Uo,d.memoizedState,d.memoizedProps);break;case 5:ld(d);break;case 3:case 4:var m=Uo;Uo=yd(d.stateNode.containerInfo),ld(d),Uo=m;break;case 22:d.memoizedState===null&&(m=d.alternate,m!==null&&m.memoizedState!==null?(m=od,od=16777216,ld(d),od=m):ld(d));break;default:ld(d)}}function Jx(d){var m=d.alternate;if(m!==null&&(d=m.child,d!==null)){m.child=null;do m=d.sibling,d.sibling=null,d=m;while(d!==null)}}function Yu(d){var m=d.deletions;if((d.flags&16)!==0){if(m!==null)for(var x=0;x<m.length;x++){var T=m[x];_s=T,t1(T,d)}Jx(d)}if(d.subtreeFlags&10256)for(d=d.child;d!==null;)e1(d),d=d.sibling}function e1(d){switch(d.tag){case 0:case 11:case 15:Yu(d),d.flags&2048&&zc(9,d,d.return);break;case 3:Yu(d);break;case 12:Yu(d);break;case 22:var m=d.stateNode;d.memoizedState!==null&&m._visibility&2&&(d.return===null||d.return.tag!==13)?(m._visibility&=-3,up(d)):Yu(d);break;default:Yu(d)}}function up(d){var m=d.deletions;if((d.flags&16)!==0){if(m!==null)for(var x=0;x<m.length;x++){var T=m[x];_s=T,t1(T,d)}Jx(d)}for(d=d.child;d!==null;){switch(m=d,m.tag){case 0:case 11:case 15:zc(8,m,m.return),up(m);break;case 22:x=m.stateNode,x._visibility&2&&(x._visibility&=-3,up(m));break;default:up(m)}d=d.sibling}}function t1(d,m){for(;_s!==null;){var x=_s;switch(x.tag){case 0:case 11:case 15:zc(8,x,m);break;case 23:case 22:if(x.memoizedState!==null&&x.memoizedState.cachePool!==null){var T=x.memoizedState.cachePool.pool;T!=null&&T.refCount++}break;case 24:Wf(x.memoizedState.cache)}if(T=x.child,T!==null)T.return=x,_s=T;else e:for(x=d;_s!==null;){T=_s;var L=T.sibling,z=T.return;if(op(T),T===x){_s=null;break e}if(L!==null){L.return=z,_s=L;break e}_s=z}}}var fb={getCacheForType:function(d){var m=Ci(Xs),x=m.data.get(d);return x===void 0&&(x=d(),m.data.set(d,x)),x}},uS=typeof WeakMap=="function"?WeakMap:Map,Zi=0,ps=null,vi=null,ki=0,Wi=0,Pa=null,Qc=!1,cd=!1,Ao=!1,Kl=0,Ii=0,Kc=0,oi=0,pb=0,bo=0,ud=0,hp=null,ua=null,hd=!1,mb=0,Eg=1/0,dd=null,Zl=null,Ei=0,ts=null,Rs=null,ji=0,gl=0,Ss=null,n1=null,ha=0,gb=null;function jr(){if((Zi&2)!==0&&ki!==0)return ki&-ki;if(de.T!==null){var d=rs;return d!==0?d:Yc()}return mn()}function i1(){bo===0&&(bo=(ki&536870912)===0||ri?ke():536870912);var d=Fa.current;return d!==null&&(d.flags|=32),bo}function gr(d,m,x){(d===ps&&(Wi===2||Wi===9)||d.cancelPendingCommit!==null)&&(wn(d,0),Zc(d,ki,bo,!1)),jt(d,x),((Zi&2)===0||d!==ps)&&(d===ps&&((Zi&2)===0&&(oi|=x),Ii===4&&Zc(d,ki,bo,!1)),qr(d))}function Ni(d,m,x){if((Zi&6)!==0)throw Error(a(327));var T=!x&&(m&124)===0&&(m&d.expiredLanes)===0||bn(d,m),L=T?$l(d,m):vb(d,m,!0),z=T;do{if(L===0){cd&&!T&&Zc(d,m,0,!1);break}else{if(x=d.current.alternate,z&&!Pr(x)){L=vb(d,m,!1),z=!1;continue}if(L===2){if(z=m,d.errorRecoveryDisabledLanes&z)var te=0;else te=d.pendingLanes&-536870913,te=te!==0?te:te&536870912?536870912:0;if(te!==0){m=te;e:{var le=d;L=hp;var Ce=le.current.memoizedState.isDehydrated;if(Ce&&(wn(le,te).flags|=256),te=vb(le,te,!1),te!==2){if(Ao&&!Ce){le.errorRecoveryDisabledLanes|=z,oi|=z,L=4;break e}z=ua,ua=L,z!==null&&(ua===null?ua=z:ua.push.apply(ua,z))}L=te}if(z=!1,L!==2)continue}}if(L===1){wn(d,0),Zc(d,m,0,!0);break}e:{switch(T=d,z=L,z){case 0:case 1:throw Error(a(345));case 4:if((m&4194048)!==m)break;case 6:Zc(T,m,bo,!Qc);break e;case 2:ua=null;break;case 3:case 5:break;default:throw Error(a(329))}if((m&62914560)===m&&(L=mb+300-Ee(),10<L)){if(Zc(T,m,bo,!Qc),Zt(T,0,!0)!==0)break e;T.timeoutHandle=vp(s1.bind(null,T,x,ua,dd,hd,m,bo,oi,ud,Qc,z,2,-0,0),L);break e}s1(T,x,ua,dd,hd,m,bo,oi,ud,Qc,z,0,-0,0)}}break}while(!0);qr(d)}function s1(d,m,x,T,L,z,te,le,Ce,it,Ct,Rt,at,lt){if(d.timeoutHandle=-1,Rt=m.subtreeFlags,(Rt&8192||(Rt&16785408)===16785408)&&(Wo={stylesheets:null,count:0,unsuspend:GS},qx(m),Rt=US(),Rt!==null)){d.cancelPendingCommit=Rt(o1.bind(null,d,m,z,x,T,L,te,le,Ce,Ct,1,at,lt)),Zc(d,z,te,!it);return}o1(d,m,z,x,T,L,te,le,Ce)}function Pr(d){for(var m=d;;){var x=m.tag;if((x===0||x===11||x===15)&&m.flags&16384&&(x=m.updateQueue,x!==null&&(x=x.stores,x!==null)))for(var T=0;T<x.length;T++){var L=x[T],z=L.getSnapshot;L=L.value;try{if(!Gr(z(),L))return!1}catch{return!1}}if(x=m.child,m.subtreeFlags&16384&&x!==null)x.return=m,m=x;else{if(m===d)break;for(;m.sibling===null;){if(m.return===null||m.return===d)return!0;m=m.return}m.sibling.return=m.return,m=m.sibling}}return!0}function Zc(d,m,x,T){m&=~pb,m&=~oi,d.suspendedLanes|=m,d.pingedLanes&=~m,T&&(d.warmLanes|=m),T=d.expirationTimes;for(var L=m;0<L;){var z=31-ut(L),te=1<<z;T[z]=-1,L&=~te}x!==0&&cn(d,x,m)}function qi(){return(Zi&6)===0?(mp(0),!1):!0}function Ab(){if(vi!==null){if(Wi===0)var d=vi.return;else d=vi,ll=Fo=null,ag(d),Jh=null,ed=0,d=vi;for(;d!==null;)zx(d.alternate,d),d=d.return;vi=null}}function wn(d,m){var x=d.timeoutHandle;x!==-1&&(d.timeoutHandle=-1,IS(x)),x=d.cancelPendingCommit,x!==null&&(d.cancelPendingCommit=null,x()),Ab(),ps=d,vi=x=Zr(d.current,null),ki=m,Wi=0,Pa=null,Qc=!1,cd=bn(d,m),Ao=!1,ud=bo=pb=oi=Kc=Ii=0,ua=hp=null,hd=!1,(m&8)!==0&&(m|=m&32);var T=d.entangledLanes;if(T!==0)for(d=d.entanglements,T&=m;0<T;){var L=31-ut(T),z=1<<L;m|=d[L],T&=~z}return Kl=m,Kr(),x}function r1(d,m){ai=null,de.H=Ku,m===Qf||m===Kf?(m=Se(),Wi=3):m===rx?(m=Se(),Wi=4):Wi=m===Lx?8:m!==null&&typeof m=="object"&&typeof m.then=="function"?6:1,Pa=m,vi===null&&(Ii=1,yg(d,Tr(m,d.current)))}function bb(){var d=de.H;return de.H=Ku,d===null?Ku:d}function dp(){var d=de.A;return de.A=fb,d}function yb(){Ii=4,Qc||(ki&4194048)!==ki&&Fa.current!==null||(cd=!0),(Kc&134217727)===0&&(oi&134217727)===0||ps===null||Zc(ps,ki,bo,!1)}function vb(d,m,x){var T=Zi;Zi|=2;var L=bb(),z=dp();(ps!==d||ki!==m)&&(dd=null,wn(d,m)),m=!1;var te=Ii;e:do try{if(Wi!==0&&vi!==null){var le=vi,Ce=Pa;switch(Wi){case 8:Ab(),te=6;break e;case 3:case 2:case 9:case 6:Fa.current===null&&(m=!0);var it=Wi;if(Wi=0,Pa=null,fd(d,le,Ce,it),x&&cd){te=0;break e}break;default:it=Wi,Wi=0,Pa=null,fd(d,le,Ce,it)}}hS(),te=Ii;break}catch(Ct){r1(d,Ct)}while(!0);return m&&d.shellSuspendCounter++,ll=Fo=null,Zi=T,de.H=L,de.A=z,vi===null&&(ps=null,ki=0,Kr()),te}function hS(){for(;vi!==null;)za(vi)}function $l(d,m){var x=Zi;Zi|=2;var T=bb(),L=dp();ps!==d||ki!==m?(dd=null,Eg=Ee()+500,wn(d,m)):cd=bn(d,m);e:do try{if(Wi!==0&&vi!==null){m=vi;var z=Pa;t:switch(Wi){case 1:Wi=0,Pa=null,fd(d,m,z,1);break;case 2:case 9:if($r(z)){Wi=0,Pa=null,a1(m);break}m=function(){Wi!==2&&Wi!==9||ps!==d||(Wi=7),qr(d)},z.then(m,m);break e;case 3:Wi=7;break e;case 4:Wi=5;break e;case 7:$r(z)?(Wi=0,Pa=null,a1(m)):(Wi=0,Pa=null,fd(d,m,z,7));break;case 5:var te=null;switch(vi.tag){case 26:te=vi.memoizedState;case 5:case 27:var le=vi;if(!te||T1(te)){Wi=0,Pa=null;var Ce=le.sibling;if(Ce!==null)vi=Ce;else{var it=le.return;it!==null?(vi=it,Sg(it)):vi=null}break t}}Wi=0,Pa=null,fd(d,m,z,5);break;case 6:Wi=0,Pa=null,fd(d,m,z,6);break;case 8:Ab(),Ii=6;break e;default:throw Error(a(462))}}dS();break}catch(Ct){r1(d,Ct)}while(!0);return ll=Fo=null,de.H=T,de.A=L,Zi=x,vi!==null?0:(ps=null,ki=0,Kr(),Ii)}function dS(){for(;vi!==null&&!ve();)za(vi)}function za(d){var m=Ux(d.alternate,d,Kl);d.memoizedProps=d.pendingProps,m===null?Sg(d):vi=m}function a1(d){var m=d,x=m.alternate;switch(m.tag){case 15:case 0:m=Wl(x,m,m.pendingProps,m.type,void 0,ki);break;case 11:m=Wl(x,m,m.pendingProps,m.type.render,m.ref,ki);break;case 5:ag(m);default:zx(x,m),m=vi=Ff(m,Kl),m=Ux(x,m,Kl)}d.memoizedProps=d.pendingProps,m===null?Sg(d):vi=m}function fd(d,m,x,T){ll=Fo=null,ag(m),Jh=null,ed=0;var L=m.return;try{if(aS(d,L,m,x,ki)){Ii=1,yg(d,Tr(x,d.current)),vi=null;return}}catch(z){if(L!==null)throw vi=L,z;Ii=1,yg(d,Tr(x,d.current)),vi=null;return}m.flags&32768?(ri||T===1?d=!0:cd||(ki&536870912)!==0?d=!1:(Qc=d=!0,(T===2||T===9||T===3||T===6)&&(T=Fa.current,T!==null&&T.tag===13&&(T.flags|=16384))),yo(m,d)):Sg(m)}function Sg(d){var m=d;do{if((m.flags&32768)!==0){yo(m,Qc);return}d=m.return;var x=oS(m.alternate,m,Kl);if(x!==null){vi=x;return}if(m=m.sibling,m!==null){vi=m;return}vi=m=d}while(m!==null);Ii===0&&(Ii=5)}function yo(d,m){do{var x=sd(d.alternate,d);if(x!==null){x.flags&=32767,vi=x;return}if(x=d.return,x!==null&&(x.flags|=32768,x.subtreeFlags=0,x.deletions=null),!m&&(d=d.sibling,d!==null)){vi=d;return}vi=d=x}while(d!==null);Ii=6,vi=null}function o1(d,m,x,T,L,z,te,le,Ce){d.cancelPendingCommit=null;do pd();while(Ei!==0);if((Zi&6)!==0)throw Error(a(327));if(m!==null){if(m===d.current)throw Error(a(177));if(z=m.lanes|m.childLanes,z|=Ym,tn(d,x,z,te,le,Ce),d===ps&&(vi=ps=null,ki=0),Rs=m,ts=d,ji=x,gl=z,Ss=L,n1=T,(m.subtreeFlags&10256)!==0||(m.flags&10256)!==0?(d.callbackNode=null,d.callbackPriority=0,gS(Ae,function(){return u1(),null})):(d.callbackNode=null,d.callbackPriority=0),T=(m.flags&13878)!==0,(m.subtreeFlags&13878)!==0||T){T=de.T,de.T=null,L=we.p,we.p=2,te=Zi,Zi|=4;try{lS(d,m,x)}finally{Zi=te,we.p=L,de.T=T}}Ei=1,xb(),l1(),fp()}}function xb(){if(Ei===1){Ei=0;var d=ts,m=Rs,x=(m.flags&13878)!==0;if((m.subtreeFlags&13878)!==0||x){x=de.T,de.T=null;var T=we.p;we.p=2;var L=Zi;Zi|=4;try{Yx(m,d);var z=Sb,te=kf(d.containerInfo),le=z.focusedElem,Ce=z.selectionRange;if(te!==le&&le&&le.ownerDocument&&qv(le.ownerDocument.documentElement,le)){if(Ce!==null&&Bf(le)){var it=Ce.start,Ct=Ce.end;if(Ct===void 0&&(Ct=it),"selectionStart"in le)le.selectionStart=it,le.selectionEnd=Math.min(Ct,le.value.length);else{var Rt=le.ownerDocument||document,at=Rt&&Rt.defaultView||window;if(at.getSelection){var lt=at.getSelection(),Fn=le.textContent.length,Pn=Math.min(Ce.start,Fn),Ji=Ce.end===void 0?Pn:Math.min(Ce.end,Fn);!lt.extend&&Pn>Ji&&(te=Ji,Ji=Pn,Pn=te);var Ke=sa(le,Pn),Fe=sa(le,Ji);if(Ke&&Fe&&(lt.rangeCount!==1||lt.anchorNode!==Ke.node||lt.anchorOffset!==Ke.offset||lt.focusNode!==Fe.node||lt.focusOffset!==Fe.offset)){var qe=Rt.createRange();qe.setStart(Ke.node,Ke.offset),lt.removeAllRanges(),Pn>Ji?(lt.addRange(qe),lt.extend(Fe.node,Fe.offset)):(qe.setEnd(Fe.node,Fe.offset),lt.addRange(qe))}}}}for(Rt=[],lt=le;lt=lt.parentNode;)lt.nodeType===1&&Rt.push({element:lt,left:lt.scrollLeft,top:lt.scrollTop});for(typeof le.focus=="function"&&le.focus(),le=0;le<Rt.length;le++){var St=Rt[le];St.element.scrollLeft=St.left,St.element.scrollTop=St.top}}Ep=!!bp,Sb=bp=null}finally{Zi=L,we.p=T,de.T=x}}d.current=m,Ei=2}}function l1(){if(Ei===2){Ei=0;var d=ts,m=Rs,x=(m.flags&8772)!==0;if((m.subtreeFlags&8772)!==0||x){x=de.T,de.T=null;var T=we.p;we.p=2;var L=Zi;Zi|=4;try{Kx(d,m.alternate,m)}finally{Zi=L,we.p=T,de.T=x}}Ei=3}}function fp(){if(Ei===4||Ei===3){Ei=0,Kt();var d=ts,m=Rs,x=ji,T=n1;(m.subtreeFlags&10256)!==0||(m.flags&10256)!==0?Ei=5:(Ei=0,Rs=ts=null,c1(d,d.pendingLanes));var L=d.pendingLanes;if(L===0&&(Zl=null),qt(x),m=m.stateNode,se&&typeof se.onCommitFiberRoot=="function")try{se.onCommitFiberRoot(ge,m,void 0,(m.current.flags&128)===128)}catch{}if(T!==null){m=de.T,L=we.p,we.p=2,de.T=null;try{for(var z=d.onRecoverableError,te=0;te<T.length;te++){var le=T[te];z(le.value,{componentStack:le.stack})}}finally{de.T=m,we.p=L}}(ji&3)!==0&&pd(),qr(d),L=d.pendingLanes,(x&4194090)!==0&&(L&42)!==0?d===gb?ha++:(ha=0,gb=d):ha=0,mp(0)}}function c1(d,m){(d.pooledCacheLanes&=m)===0&&(m=d.pooledCache,m!=null&&(d.pooledCache=null,Wf(m)))}function pd(d){return xb(),l1(),fp(),u1()}function u1(){if(Ei!==5)return!1;var d=ts,m=gl;gl=0;var x=qt(ji),T=de.T,L=we.p;try{we.p=32>x?32:x,de.T=null,x=Ss,Ss=null;var z=ts,te=ji;if(Ei=0,Rs=ts=null,ji=0,(Zi&6)!==0)throw Error(a(331));var le=Zi;if(Zi|=4,e1(z.current),jx(z,z.current,te,x),Zi=le,mp(0,!1),se&&typeof se.onPostCommitFiberRoot=="function")try{se.onPostCommitFiberRoot(ge,z)}catch{}return!0}finally{we.p=L,de.T=T,c1(d,m)}}function Va(d,m,x){m=Tr(x,m),m=rb(d.stateNode,m,2),d=mo(d,m,2),d!==null&&(jt(d,2),qr(d))}function ls(d,m,x){if(d.tag===3)Va(d,d,x);else for(;m!==null;){if(m.tag===3){Va(m,d,x);break}else if(m.tag===1){var T=m.stateNode;if(typeof m.type.getDerivedStateFromError=="function"||typeof T.componentDidCatch=="function"&&(Zl===null||!Zl.has(T))){d=Tr(x,d),x=kx(2),T=mo(m,x,2),T!==null&&(Bx(x,T,m,d),jt(T,2),qr(T));break}}m=m.return}}function $c(d,m,x){var T=d.pingCache;if(T===null){T=d.pingCache=new uS;var L=new Set;T.set(m,L)}else L=T.get(m),L===void 0&&(L=new Set,T.set(m,L));L.has(x)||(Ao=!0,L.add(x),d=fS.bind(null,d,m,x),m.then(d,d))}function fS(d,m,x){var T=d.pingCache;T!==null&&T.delete(m),d.pingedLanes|=d.suspendedLanes&x,d.warmLanes&=~x,ps===d&&(ki&x)===x&&(Ii===4||Ii===3&&(ki&62914560)===ki&&300>Ee()-mb?(Zi&2)===0&&wn(d,0):pb|=x,ud===ki&&(ud=0)),qr(d)}function h1(d,m){m===0&&(m=wt()),d=Uu(d,m),d!==null&&(jt(d,m),qr(d))}function pS(d){var m=d.memoizedState,x=0;m!==null&&(x=m.retryLane),h1(d,x)}function mS(d,m){var x=0;switch(d.tag){case 13:var T=d.stateNode,L=d.memoizedState;L!==null&&(x=L.retryLane);break;case 19:T=d.stateNode;break;case 22:T=d.stateNode._retryCache;break;default:throw Error(a(314))}T!==null&&T.delete(m),h1(d,x)}function gS(d,m){return Mt(d,m)}var Ig=null,md=null,pp=!1,Tg=!1,Mg=!1,ju=0;function qr(d){d!==md&&d.next===null&&(md===null?Ig=md=d:md=md.next=d),Tg=!0,pp||(pp=!0,bS())}function mp(d,m){if(!Mg&&Tg){Mg=!0;do for(var x=!1,T=Ig;T!==null;){if(d!==0){var L=T.pendingLanes;if(L===0)var z=0;else{var te=T.suspendedLanes,le=T.pingedLanes;z=(1<<31-ut(42|d)+1)-1,z&=L&~(te&~le),z=z&201326741?z&201326741|1:z?z|2:0}z!==0&&(x=!0,wb(T,z))}else z=ki,z=Zt(T,T===ps?z:0,T.cancelPendingCommit!==null||T.timeoutHandle!==-1),(z&3)===0||bn(T,z)||(x=!0,wb(T,z));T=T.next}while(x);Mg=!1}}function AS(){d1()}function d1(){Tg=pp=!1;var d=0;ju!==0&&(SS()&&(d=ju),ju=0);for(var m=Ee(),x=null,T=Ig;T!==null;){var L=T.next,z=zo(T,m);z===0?(T.next=null,x===null?Ig=L:x.next=L,L===null&&(md=x)):(x=T,(d!==0||(z&3)!==0)&&(Tg=!0)),T=L}mp(d)}function zo(d,m){for(var x=d.suspendedLanes,T=d.pingedLanes,L=d.expirationTimes,z=d.pendingLanes&-62914561;0<z;){var te=31-ut(z),le=1<<te,Ce=L[te];Ce===-1?((le&x)===0||(le&T)!==0)&&(L[te]=Jn(le,m)):Ce<=m&&(d.expiredLanes|=le),z&=~le}if(m=ps,x=ki,x=Zt(d,d===m?x:0,d.cancelPendingCommit!==null||d.timeoutHandle!==-1),T=d.callbackNode,x===0||d===m&&(Wi===2||Wi===9)||d.cancelPendingCommit!==null)return T!==null&&T!==null&&Bt(T),d.callbackNode=null,d.callbackPriority=0;if((x&3)===0||bn(d,x)){if(m=x&-x,m===d.callbackPriority)return m;switch(T!==null&&Bt(T),qt(x)){case 2:case 8:x=ae;break;case 32:x=Ae;break;case 268435456:x=Ze;break;default:x=Ae}return T=f1.bind(null,d),x=Mt(x,T),d.callbackPriority=m,d.callbackNode=x,m}return T!==null&&T!==null&&Bt(T),d.callbackPriority=2,d.callbackNode=null,2}function f1(d,m){if(Ei!==0&&Ei!==5)return d.callbackNode=null,d.callbackPriority=0,null;var x=d.callbackNode;if(pd()&&d.callbackNode!==x)return null;var T=ki;return T=Zt(d,d===ps?T:0,d.cancelPendingCommit!==null||d.timeoutHandle!==-1),T===0?null:(Ni(d,T,m),zo(d,Ee()),d.callbackNode!=null&&d.callbackNode===x?f1.bind(null,d):null)}function wb(d,m){if(pd())return null;Ni(d,m,!0)}function bS(){TS(function(){(Zi&6)!==0?Mt(Z,AS):d1()})}function Yc(){return ju===0&&(ju=ke()),ju}function p1(d){return d==null||typeof d=="symbol"||typeof d=="boolean"?null:typeof d=="function"?d:Su(""+d)}function gd(d,m){var x=m.ownerDocument.createElement("input");return x.name=m.name,x.value=m.value,d.id&&x.setAttribute("form",d.id),m.parentNode.insertBefore(x,m),d=new FormData(d),x.parentNode.removeChild(x),d}function yS(d,m,x,T,L){if(m==="submit"&&x&&x.stateNode===L){var z=p1((L[ir]||null).action),te=T.submitter;te&&(m=(m=te[ir]||null)?p1(m.formAction):te.getAttribute("formAction"),m!==null&&(z=m,te=null));var le=new _u("action","action",null,T,L);d.push({event:le,listeners:[{instance:null,listener:function(){if(T.defaultPrevented){if(ju!==0){var Ce=te?gd(L,te):new FormData(L);ep(x,{pending:!0,data:Ce,method:L.method,action:z},null,Ce)}}else typeof z=="function"&&(le.preventDefault(),Ce=te?gd(L,te):new FormData(L),ep(x,{pending:!0,data:Ce,method:L.method,action:z},z,Ce))},currentTarget:L}]})}}for(var Cb=0;Cb<Ma.length;Cb++){var Eb=Ma[Cb],Wn=Eb.toLowerCase(),vS=Eb[0].toUpperCase()+Eb.slice(1);ho(Wn,"on"+vS)}ho(Qr,"onAnimationEnd"),ho(TA,"onAnimationIteration"),ho(MA,"onAnimationStart"),ho("dblclick","onDoubleClick"),ho("focusin","onFocus"),ho("focusout","onBlur"),ho(Ou,"onTransitionRun"),ho(uo,"onTransitionStart"),ho(ds,"onTransitionCancel"),ho(Nf,"onTransitionEnd"),il("onMouseEnter",["mouseout","mouseover"]),il("onMouseLeave",["mouseout","mouseover"]),il("onPointerEnter",["pointerout","pointerover"]),il("onPointerLeave",["pointerout","pointerover"]),Lo("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Lo("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Lo("onBeforeInput",["compositionend","keypress","textInput","paste"]),Lo("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Lo("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Lo("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Ad="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),xS=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ad));function m1(d,m){m=(m&4)!==0;for(var x=0;x<d.length;x++){var T=d[x],L=T.event;T=T.listeners;e:{var z=void 0;if(m)for(var te=T.length-1;0<=te;te--){var le=T[te],Ce=le.instance,it=le.currentTarget;if(le=le.listener,Ce!==z&&L.isPropagationStopped())break e;z=le,L.currentTarget=it;try{z(L)}catch(Ct){Ag(Ct)}L.currentTarget=null,z=Ce}else for(te=0;te<T.length;te++){if(le=T[te],Ce=le.instance,it=le.currentTarget,le=le.listener,Ce!==z&&L.isPropagationStopped())break e;z=le,L.currentTarget=it;try{z(L)}catch(Ct){Ag(Ct)}L.currentTarget=null,z=Ce}}}}function xi(d,m){var x=m[xc];x===void 0&&(x=m[xc]=new Set);var T=d+"__bubble";x.has(T)||(g1(m,d,2,!1),x.add(T))}function Vo(d,m,x){var T=0;m&&(T|=4),g1(x,d,T,m)}var _g="_reactListening"+Math.random().toString(36).slice(2);function gp(d){if(!d[_g]){d[_g]=!0,Bh.forEach(function(x){x!=="selectionchange"&&(xS.has(x)||Vo(x,!1,d),Vo(x,!0,d))});var m=d.nodeType===9?d:d.ownerDocument;m===null||m[_g]||(m[_g]=!0,Vo("selectionchange",!1,m))}}function g1(d,m,x,T){switch(L1(m)){case 2:var L=VS;break;case 8:L=B1;break;default:L=Ub}x=L.bind(null,m,x,d),L=void 0,!Gh||m!=="touchstart"&&m!=="touchmove"&&m!=="wheel"||(L=!0),T?L!==void 0?d.addEventListener(m,x,{capture:!0,passive:L}):d.addEventListener(m,x,!0):L!==void 0?d.addEventListener(m,x,{passive:L}):d.addEventListener(m,x,!1)}function Rg(d,m,x,T,L){var z=T;if((m&1)===0&&(m&2)===0&&T!==null)e:for(;;){if(T===null)return;var te=T.tag;if(te===3||te===4){var le=T.stateNode.containerInfo;if(le===L)break;if(te===4)for(te=T.return;te!==null;){var Ce=te.tag;if((Ce===3||Ce===4)&&te.stateNode.containerInfo===L)return;te=te.return}for(;le!==null;){if(te=Ea(le),te===null)return;if(Ce=te.tag,Ce===5||Ce===6||Ce===26||Ce===27){T=z=te;continue e}le=le.parentNode}}T=T.return}Oh(function(){var it=z,Ct=Nh(x),Rt=[];e:{var at=$m.get(d);if(at!==void 0){var lt=_u,Fn=d;switch(d){case"keypress":if(Mu(x)===0)break e;case"keydown":case"keyup":lt=mf;break;case"focusin":Fn="focus",lt=Om;break;case"focusout":Fn="blur",lt=Om;break;case"beforeblur":case"afterblur":lt=Om;break;case"click":if(x.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":lt=uf;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":lt=Dm;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":lt=zm;break;case Qr:case TA:case MA:lt=hA;break;case Nf:lt=Vm;break;case"scroll":case"scrollend":lt=uA;break;case"wheel":lt=yf;break;case"copy":case"cut":case"paste":lt=df;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":lt=mA;break;case"toggle":case"beforetoggle":lt=xf}var Pn=(m&4)!==0,Ji=!Pn&&(d==="scroll"||d==="scrollend"),Ke=Pn?at!==null?at+"Capture":null:at;Pn=[];for(var Fe=it,qe;Fe!==null;){var St=Fe;if(qe=St.stateNode,St=St.tag,St!==5&&St!==26&&St!==27||qe===null||Ke===null||(St=Sc(Fe,Ke),St!=null&&Pn.push(Ap(Fe,St,qe))),Ji)break;Fe=Fe.return}0<Pn.length&&(at=new lt(at,Fn,null,x,Ct),Rt.push({event:at,listeners:Pn}))}}if((m&7)===0){e:{if(at=d==="mouseover"||d==="pointerover",lt=d==="mouseout"||d==="pointerout",at&&x!==Lh&&(Fn=x.relatedTarget||x.fromElement)&&(Ea(Fn)||Fn[ro]))break e;if((lt||at)&&(at=Ct.window===Ct?Ct:(at=Ct.ownerDocument)?at.defaultView||at.parentWindow:window,lt?(Fn=x.relatedTarget||x.toElement,lt=it,Fn=Fn?Ea(Fn):null,Fn!==null&&(Ji=h(Fn),Pn=Fn.tag,Fn!==Ji||Pn!==5&&Pn!==27&&Pn!==6)&&(Fn=null)):(lt=null,Fn=it),lt!==Fn)){if(Pn=uf,St="onMouseLeave",Ke="onMouseEnter",Fe="mouse",(d==="pointerout"||d==="pointerover")&&(Pn=mA,St="onPointerLeave",Ke="onPointerEnter",Fe="pointer"),Ji=lt==null?at:ko(lt),qe=Fn==null?at:ko(Fn),at=new Pn(St,Fe+"leave",lt,x,Ct),at.target=Ji,at.relatedTarget=qe,St=null,Ea(Ct)===it&&(Pn=new Pn(Ke,Fe+"enter",Fn,x,Ct),Pn.target=qe,Pn.relatedTarget=Ji,St=Pn),Ji=St,lt&&Fn)t:{for(Pn=lt,Ke=Fn,Fe=0,qe=Pn;qe;qe=bd(qe))Fe++;for(qe=0,St=Ke;St;St=bd(St))qe++;for(;0<Fe-qe;)Pn=bd(Pn),Fe--;for(;0<qe-Fe;)Ke=bd(Ke),qe--;for(;Fe--;){if(Pn===Ke||Ke!==null&&Pn===Ke.alternate)break t;Pn=bd(Pn),Ke=bd(Ke)}Pn=null}else Pn=null;lt!==null&&Bg(Rt,at,lt,Pn,!1),Fn!==null&&Ji!==null&&Bg(Rt,Ji,Fn,Pn,!0)}}e:{if(at=it?ko(it):window,lt=at.nodeName&&at.nodeName.toLowerCase(),lt==="select"||lt==="input"&&at.type==="file")var gn=Hh;else if(Hm(at))if(Xh)gn=xA;else{gn=Km;var ui=Qm}else lt=at.nodeName,!lt||lt.toLowerCase()!=="input"||at.type!=="checkbox"&&at.type!=="radio"?it&&Eu(it.elementType)&&(gn=Hh):gn=Rf;if(gn&&(gn=gn(d,it))){vA(Rt,gn,x,Ct);break e}ui&&ui(d,at,it),d==="focusout"&&it&&at.type==="number"&&it.memoizedProps.value!=null&&Ia(at,"number",at.value)}switch(ui=it?ko(it):window,d){case"focusin":(Hm(ui)||ui.contentEditable==="true")&&(Fu=ui,Zm=it,Ir=null);break;case"focusout":Ir=Zm=Fu=null;break;case"mousedown":SA=!0;break;case"contextmenu":case"mouseup":case"dragend":SA=!1,IA(Rt,x,Ct);break;case"selectionchange":if(EA)break;case"keydown":case"keyup":IA(Rt,x,Ct)}var Sn;if(Lu)e:{switch(d){case"compositionstart":var Gn="onCompositionStart";break e;case"compositionend":Gn="onCompositionEnd";break e;case"compositionupdate":Gn="onCompositionUpdate";break e}Gn=void 0}else Nu?AA(d,x)&&(Gn="onCompositionEnd"):d==="keydown"&&x.keyCode===229&&(Gn="onCompositionStart");Gn&&(Cf&&x.locale!=="ko"&&(Nu||Gn!=="onCompositionStart"?Gn==="onCompositionEnd"&&Nu&&(Sn=Ph()):(Nl=Ct,Uh="value"in Nl?Nl.value:Nl.textContent,Nu=!0)),ui=kg(it,Gn),0<ui.length&&(Gn=new pf(Gn,d,null,x,Ct),Rt.push({event:Gn,listeners:ui}),Sn?Gn.data=Sn:(Sn=bA(x),Sn!==null&&(Gn.data=Sn)))),(Sn=Wm?jv(d,x):Sf(d,x))&&(Gn=kg(it,"onBeforeInput"),0<Gn.length&&(ui=new pf("onBeforeInput","beforeinput",null,x,Ct),Rt.push({event:ui,listeners:Gn}),ui.data=Sn)),yS(Rt,d,it,x,Ct)}m1(Rt,m)})}function Ap(d,m,x){return{instance:d,listener:m,currentTarget:x}}function kg(d,m){for(var x=m+"Capture",T=[];d!==null;){var L=d,z=L.stateNode;if(L=L.tag,L!==5&&L!==26&&L!==27||z===null||(L=Sc(d,x),L!=null&&T.unshift(Ap(d,L,z)),L=Sc(d,m),L!=null&&T.push(Ap(d,L,z))),d.tag===3)return T;d=d.return}return[]}function bd(d){if(d===null)return null;do d=d.return;while(d&&d.tag!==5&&d.tag!==27);return d||null}function Bg(d,m,x,T,L){for(var z=m._reactName,te=[];x!==null&&x!==T;){var le=x,Ce=le.alternate,it=le.stateNode;if(le=le.tag,Ce!==null&&Ce===T)break;le!==5&&le!==26&&le!==27||it===null||(Ce=it,L?(it=Sc(x,z),it!=null&&te.unshift(Ap(x,it,Ce))):L||(it=Sc(x,z),it!=null&&te.push(Ap(x,it,Ce)))),x=x.return}te.length!==0&&d.push({event:m,listeners:te})}var wS=/\r\n?/g,CS=/\u0000|\uFFFD/g;function A1(d){return(typeof d=="string"?d:""+d).replace(wS,`
`).replace(CS,"")}function Yl(d,m){return m=A1(m),A1(d)===m}function Lg(){}function Hn(d,m,x,T,L,z){switch(x){case"children":typeof T=="string"?m==="body"||m==="textarea"&&T===""||sr(d,T):(typeof T=="number"||typeof T=="bigint")&&m!=="body"&&sr(d,""+T);break;case"className":Xe(d,"class",T);break;case"tabIndex":Xe(d,"tabindex",T);break;case"dir":case"role":case"viewBox":case"width":case"height":Xe(d,x,T);break;case"style":co(d,T,z);break;case"data":if(m!=="object"){Xe(d,"data",T);break}case"src":case"href":if(T===""&&(m!=="a"||x!=="href")){d.removeAttribute(x);break}if(T==null||typeof T=="function"||typeof T=="symbol"||typeof T=="boolean"){d.removeAttribute(x);break}T=Su(""+T),d.setAttribute(x,T);break;case"action":case"formAction":if(typeof T=="function"){d.setAttribute(x,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof z=="function"&&(x==="formAction"?(m!=="input"&&Hn(d,m,"name",L.name,L,null),Hn(d,m,"formEncType",L.formEncType,L,null),Hn(d,m,"formMethod",L.formMethod,L,null),Hn(d,m,"formTarget",L.formTarget,L,null)):(Hn(d,m,"encType",L.encType,L,null),Hn(d,m,"method",L.method,L,null),Hn(d,m,"target",L.target,L,null)));if(T==null||typeof T=="symbol"||typeof T=="boolean"){d.removeAttribute(x);break}T=Su(""+T),d.setAttribute(x,T);break;case"onClick":T!=null&&(d.onclick=Lg);break;case"onScroll":T!=null&&xi("scroll",d);break;case"onScrollEnd":T!=null&&xi("scrollend",d);break;case"dangerouslySetInnerHTML":if(T!=null){if(typeof T!="object"||!("__html"in T))throw Error(a(61));if(x=T.__html,x!=null){if(L.children!=null)throw Error(a(60));d.innerHTML=x}}break;case"multiple":d.multiple=T&&typeof T!="function"&&typeof T!="symbol";break;case"muted":d.muted=T&&typeof T!="function"&&typeof T!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(T==null||typeof T=="function"||typeof T=="boolean"||typeof T=="symbol"){d.removeAttribute("xlink:href");break}x=Su(""+T),d.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",x);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":T!=null&&typeof T!="function"&&typeof T!="symbol"?d.setAttribute(x,""+T):d.removeAttribute(x);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":T&&typeof T!="function"&&typeof T!="symbol"?d.setAttribute(x,""):d.removeAttribute(x);break;case"capture":case"download":T===!0?d.setAttribute(x,""):T!==!1&&T!=null&&typeof T!="function"&&typeof T!="symbol"?d.setAttribute(x,T):d.removeAttribute(x);break;case"cols":case"rows":case"size":case"span":T!=null&&typeof T!="function"&&typeof T!="symbol"&&!isNaN(T)&&1<=T?d.setAttribute(x,T):d.removeAttribute(x);break;case"rowSpan":case"start":T==null||typeof T=="function"||typeof T=="symbol"||isNaN(T)?d.removeAttribute(x):d.setAttribute(x,T);break;case"popover":xi("beforetoggle",d),xi("toggle",d),ot(d,"popover",T);break;case"xlinkActuate":Nt(d,"http://www.w3.org/1999/xlink","xlink:actuate",T);break;case"xlinkArcrole":Nt(d,"http://www.w3.org/1999/xlink","xlink:arcrole",T);break;case"xlinkRole":Nt(d,"http://www.w3.org/1999/xlink","xlink:role",T);break;case"xlinkShow":Nt(d,"http://www.w3.org/1999/xlink","xlink:show",T);break;case"xlinkTitle":Nt(d,"http://www.w3.org/1999/xlink","xlink:title",T);break;case"xlinkType":Nt(d,"http://www.w3.org/1999/xlink","xlink:type",T);break;case"xmlBase":Nt(d,"http://www.w3.org/XML/1998/namespace","xml:base",T);break;case"xmlLang":Nt(d,"http://www.w3.org/XML/1998/namespace","xml:lang",T);break;case"xmlSpace":Nt(d,"http://www.w3.org/XML/1998/namespace","xml:space",T);break;case"is":ot(d,"is",T);break;case"innerText":case"textContent":break;default:(!(2<x.length)||x[0]!=="o"&&x[0]!=="O"||x[1]!=="n"&&x[1]!=="N")&&(x=of.get(x)||x,ot(d,x,T))}}function Zs(d,m,x,T,L,z){switch(x){case"style":co(d,T,z);break;case"dangerouslySetInnerHTML":if(T!=null){if(typeof T!="object"||!("__html"in T))throw Error(a(61));if(x=T.__html,x!=null){if(L.children!=null)throw Error(a(60));d.innerHTML=x}}break;case"children":typeof T=="string"?sr(d,T):(typeof T=="number"||typeof T=="bigint")&&sr(d,""+T);break;case"onScroll":T!=null&&xi("scroll",d);break;case"onScrollEnd":T!=null&&xi("scrollend",d);break;case"onClick":T!=null&&(d.onclick=Lg);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Cu.hasOwnProperty(x))e:{if(x[0]==="o"&&x[1]==="n"&&(L=x.endsWith("Capture"),m=x.slice(2,L?x.length-7:void 0),z=d[ir]||null,z=z!=null?z[x]:null,typeof z=="function"&&d.removeEventListener(m,z,L),typeof T=="function")){typeof z!="function"&&z!==null&&(x in d?d[x]=null:d.hasAttribute(x)&&d.removeAttribute(x)),d.addEventListener(m,T,L);break e}x in d?d[x]=T:T===!0?d.setAttribute(x,""):ot(d,x,T)}}}function ks(d,m,x){switch(m){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":xi("error",d),xi("load",d);var T=!1,L=!1,z;for(z in x)if(x.hasOwnProperty(z)){var te=x[z];if(te!=null)switch(z){case"src":T=!0;break;case"srcSet":L=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(a(137,m));default:Hn(d,m,z,te,x,null)}}L&&Hn(d,m,"srcSet",x.srcSet,x,null),T&&Hn(d,m,"src",x.src,x,null);return;case"input":xi("invalid",d);var le=z=te=L=null,Ce=null,it=null;for(T in x)if(x.hasOwnProperty(T)){var Ct=x[T];if(Ct!=null)switch(T){case"name":L=Ct;break;case"type":te=Ct;break;case"checked":Ce=Ct;break;case"defaultChecked":it=Ct;break;case"value":z=Ct;break;case"defaultValue":le=Ct;break;case"children":case"dangerouslySetInnerHTML":if(Ct!=null)throw Error(a(137,m));break;default:Hn(d,m,T,Ct,x,null)}}Sr(d,z,le,Ce,it,te,L,!1),ei(d);return;case"select":xi("invalid",d),T=te=z=null;for(L in x)if(x.hasOwnProperty(L)&&(le=x[L],le!=null))switch(L){case"value":z=le;break;case"defaultValue":te=le;break;case"multiple":T=le;default:Hn(d,m,L,le,x,null)}m=z,x=te,d.multiple=!!T,m!=null?Xr(d,!!T,m,!1):x!=null&&Xr(d,!!T,x,!0);return;case"textarea":xi("invalid",d),z=L=T=null;for(te in x)if(x.hasOwnProperty(te)&&(le=x[te],le!=null))switch(te){case"value":T=le;break;case"defaultValue":L=le;break;case"children":z=le;break;case"dangerouslySetInnerHTML":if(le!=null)throw Error(a(91));break;default:Hn(d,m,te,le,x,null)}Cs(d,T,L,z),ei(d);return;case"option":for(Ce in x)if(x.hasOwnProperty(Ce)&&(T=x[Ce],T!=null))switch(Ce){case"selected":d.selected=T&&typeof T!="function"&&typeof T!="symbol";break;default:Hn(d,m,Ce,T,x,null)}return;case"dialog":xi("beforetoggle",d),xi("toggle",d),xi("cancel",d),xi("close",d);break;case"iframe":case"object":xi("load",d);break;case"video":case"audio":for(T=0;T<Ad.length;T++)xi(Ad[T],d);break;case"image":xi("error",d),xi("load",d);break;case"details":xi("toggle",d);break;case"embed":case"source":case"link":xi("error",d),xi("load",d);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(it in x)if(x.hasOwnProperty(it)&&(T=x[it],T!=null))switch(it){case"children":case"dangerouslySetInnerHTML":throw Error(a(137,m));default:Hn(d,m,it,T,x,null)}return;default:if(Eu(m)){for(Ct in x)x.hasOwnProperty(Ct)&&(T=x[Ct],T!==void 0&&Zs(d,m,Ct,T,x,void 0));return}}for(le in x)x.hasOwnProperty(le)&&(T=x[le],T!=null&&Hn(d,m,le,T,x,null))}function ES(d,m,x,T){switch(m){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var L=null,z=null,te=null,le=null,Ce=null,it=null,Ct=null;for(lt in x){var Rt=x[lt];if(x.hasOwnProperty(lt)&&Rt!=null)switch(lt){case"checked":break;case"value":break;case"defaultValue":Ce=Rt;default:T.hasOwnProperty(lt)||Hn(d,m,lt,null,T,Rt)}}for(var at in T){var lt=T[at];if(Rt=x[at],T.hasOwnProperty(at)&&(lt!=null||Rt!=null))switch(at){case"type":z=lt;break;case"name":L=lt;break;case"checked":it=lt;break;case"defaultChecked":Ct=lt;break;case"value":te=lt;break;case"defaultValue":le=lt;break;case"children":case"dangerouslySetInnerHTML":if(lt!=null)throw Error(a(137,m));break;default:lt!==Rt&&Hn(d,m,at,lt,T,Rt)}}Ws(d,te,le,Ce,it,Ct,z,L);return;case"select":lt=te=le=at=null;for(z in x)if(Ce=x[z],x.hasOwnProperty(z)&&Ce!=null)switch(z){case"value":break;case"multiple":lt=Ce;default:T.hasOwnProperty(z)||Hn(d,m,z,null,T,Ce)}for(L in T)if(z=T[L],Ce=x[L],T.hasOwnProperty(L)&&(z!=null||Ce!=null))switch(L){case"value":at=z;break;case"defaultValue":le=z;break;case"multiple":te=z;default:z!==Ce&&Hn(d,m,L,z,T,Ce)}m=le,x=te,T=lt,at!=null?Xr(d,!!x,at,!1):!!T!=!!x&&(m!=null?Xr(d,!!x,m,!0):Xr(d,!!x,x?[]:"",!1));return;case"textarea":lt=at=null;for(le in x)if(L=x[le],x.hasOwnProperty(le)&&L!=null&&!T.hasOwnProperty(le))switch(le){case"value":break;case"children":break;default:Hn(d,m,le,null,T,L)}for(te in T)if(L=T[te],z=x[te],T.hasOwnProperty(te)&&(L!=null||z!=null))switch(te){case"value":at=L;break;case"defaultValue":lt=L;break;case"children":break;case"dangerouslySetInnerHTML":if(L!=null)throw Error(a(91));break;default:L!==z&&Hn(d,m,te,L,T,z)}Si(d,at,lt);return;case"option":for(var Fn in x)if(at=x[Fn],x.hasOwnProperty(Fn)&&at!=null&&!T.hasOwnProperty(Fn))switch(Fn){case"selected":d.selected=!1;break;default:Hn(d,m,Fn,null,T,at)}for(Ce in T)if(at=T[Ce],lt=x[Ce],T.hasOwnProperty(Ce)&&at!==lt&&(at!=null||lt!=null))switch(Ce){case"selected":d.selected=at&&typeof at!="function"&&typeof at!="symbol";break;default:Hn(d,m,Ce,at,T,lt)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Pn in x)at=x[Pn],x.hasOwnProperty(Pn)&&at!=null&&!T.hasOwnProperty(Pn)&&Hn(d,m,Pn,null,T,at);for(it in T)if(at=T[it],lt=x[it],T.hasOwnProperty(it)&&at!==lt&&(at!=null||lt!=null))switch(it){case"children":case"dangerouslySetInnerHTML":if(at!=null)throw Error(a(137,m));break;default:Hn(d,m,it,at,T,lt)}return;default:if(Eu(m)){for(var Ji in x)at=x[Ji],x.hasOwnProperty(Ji)&&at!==void 0&&!T.hasOwnProperty(Ji)&&Zs(d,m,Ji,void 0,T,at);for(Ct in T)at=T[Ct],lt=x[Ct],!T.hasOwnProperty(Ct)||at===lt||at===void 0&&lt===void 0||Zs(d,m,Ct,at,T,lt);return}}for(var Ke in x)at=x[Ke],x.hasOwnProperty(Ke)&&at!=null&&!T.hasOwnProperty(Ke)&&Hn(d,m,Ke,null,T,at);for(Rt in T)at=T[Rt],lt=x[Rt],!T.hasOwnProperty(Rt)||at===lt||at==null&&lt==null||Hn(d,m,Rt,at,T,lt)}var bp=null,Sb=null;function Ng(d){return d.nodeType===9?d:d.ownerDocument}function b1(d){switch(d){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function y1(d,m){if(d===0)switch(m){case"svg":return 1;case"math":return 2;default:return 0}return d===1&&m==="foreignObject"?0:d}function Ib(d,m){return d==="textarea"||d==="noscript"||typeof m.children=="string"||typeof m.children=="number"||typeof m.children=="bigint"||typeof m.dangerouslySetInnerHTML=="object"&&m.dangerouslySetInnerHTML!==null&&m.dangerouslySetInnerHTML.__html!=null}var yp=null;function SS(){var d=window.event;return d&&d.type==="popstate"?d===yp?!1:(yp=d,!0):(yp=null,!1)}var vp=typeof setTimeout=="function"?setTimeout:void 0,IS=typeof clearTimeout=="function"?clearTimeout:void 0,Wa=typeof Promise=="function"?Promise:void 0,TS=typeof queueMicrotask=="function"?queueMicrotask:typeof Wa<"u"?function(d){return Wa.resolve(null).then(d).catch(Tb)}:vp;function Tb(d){setTimeout(function(){throw d})}function jc(d){return d==="head"}function Dg(d,m){var x=m,T=0,L=0;do{var z=x.nextSibling;if(d.removeChild(x),z&&z.nodeType===8)if(x=z.data,x==="/$"){if(0<T&&8>T){x=T;var te=d.ownerDocument;if(x&1&&xp(te.documentElement),x&2&&xp(te.body),x&4)for(x=te.head,xp(x),te=x.firstChild;te;){var le=te.nextSibling,Ce=te.nodeName;te[nl]||Ce==="SCRIPT"||Ce==="STYLE"||Ce==="LINK"&&te.rel.toLowerCase()==="stylesheet"||x.removeChild(te),te=le}}if(L===0){d.removeChild(z),Jl(m);return}L--}else x==="$"||x==="$?"||x==="$!"?L++:T=x.charCodeAt(0)-48;else T=0;x=z}while(x);Jl(m)}function Mb(d){var m=d.firstChild;for(m&&m.nodeType===10&&(m=m.nextSibling);m;){var x=m;switch(m=m.nextSibling,x.nodeName){case"HTML":case"HEAD":case"BODY":Mb(x),oo(x);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(x.rel.toLowerCase()==="stylesheet")continue}d.removeChild(x)}}function MS(d,m,x,T){for(;d.nodeType===1;){var L=x;if(d.nodeName.toLowerCase()!==m.toLowerCase()){if(!T&&(d.nodeName!=="INPUT"||d.type!=="hidden"))break}else if(T){if(!d[nl])switch(m){case"meta":if(!d.hasAttribute("itemprop"))break;return d;case"link":if(z=d.getAttribute("rel"),z==="stylesheet"&&d.hasAttribute("data-precedence"))break;if(z!==L.rel||d.getAttribute("href")!==(L.href==null||L.href===""?null:L.href)||d.getAttribute("crossorigin")!==(L.crossOrigin==null?null:L.crossOrigin)||d.getAttribute("title")!==(L.title==null?null:L.title))break;return d;case"style":if(d.hasAttribute("data-precedence"))break;return d;case"script":if(z=d.getAttribute("src"),(z!==(L.src==null?null:L.src)||d.getAttribute("type")!==(L.type==null?null:L.type)||d.getAttribute("crossorigin")!==(L.crossOrigin==null?null:L.crossOrigin))&&z&&d.hasAttribute("async")&&!d.hasAttribute("itemprop"))break;return d;default:return d}}else if(m==="input"&&d.type==="hidden"){var z=L.name==null?null:""+L.name;if(L.type==="hidden"&&d.getAttribute("name")===z)return d}else return d;if(d=Ha(d.nextSibling),d===null)break}return null}function _S(d,m,x){if(m==="")return null;for(;d.nodeType!==3;)if((d.nodeType!==1||d.nodeName!=="INPUT"||d.type!=="hidden")&&!x||(d=Ha(d.nextSibling),d===null))return null;return d}function _b(d){return d.data==="$!"||d.data==="$?"&&d.ownerDocument.readyState==="complete"}function RS(d,m){var x=d.ownerDocument;if(d.data!=="$?"||x.readyState==="complete")m();else{var T=function(){m(),x.removeEventListener("DOMContentLoaded",T)};x.addEventListener("DOMContentLoaded",T),d._reactRetry=T}}function Ha(d){for(;d!=null;d=d.nextSibling){var m=d.nodeType;if(m===1||m===3)break;if(m===8){if(m=d.data,m==="$"||m==="$!"||m==="$?"||m==="F!"||m==="F")break;if(m==="/$")return null}}return d}var Rb=null;function v1(d){d=d.previousSibling;for(var m=0;d;){if(d.nodeType===8){var x=d.data;if(x==="$"||x==="$!"||x==="$?"){if(m===0)return d;m--}else x==="/$"&&m++}d=d.previousSibling}return null}function Fg(d,m,x){switch(m=Ng(x),d){case"html":if(d=m.documentElement,!d)throw Error(a(452));return d;case"head":if(d=m.head,!d)throw Error(a(453));return d;case"body":if(d=m.body,!d)throw Error(a(454));return d;default:throw Error(a(451))}}function xp(d){for(var m=d.attributes;m.length;)d.removeAttributeNode(m[0]);oo(d)}var da=new Map,x1=new Set;function yd(d){return typeof d.getRootNode=="function"?d.getRootNode():d.nodeType===9?d:d.ownerDocument}var jl=we.d;we.d={f:kb,r:kS,D:Bb,C:BS,L:Lb,m:LS,X:DS,S:NS,M:FS};function kb(){var d=jl.f(),m=qi();return d||m}function kS(d){var m=Sa(d);m!==null&&m.tag===5&&m.type==="form"?dg(m):jl.r(d)}var qc=typeof document>"u"?null:document;function w1(d,m,x){var T=qc;if(T&&typeof m=="string"&&m){var L=Qn(m);L='link[rel="'+d+'"][href="'+L+'"]',typeof x=="string"&&(L+='[crossorigin="'+x+'"]'),x1.has(L)||(x1.add(L),d={rel:d,crossOrigin:x,href:m},T.querySelector(L)===null&&(m=T.createElement("link"),ks(m,"link",d),Vs(m),T.head.appendChild(m)))}}function Bb(d){jl.D(d),w1("dns-prefetch",d,null)}function BS(d,m){jl.C(d,m),w1("preconnect",d,m)}function Lb(d,m,x){jl.L(d,m,x);var T=qc;if(T&&d&&m){var L='link[rel="preload"][as="'+Qn(m)+'"]';m==="image"&&x&&x.imageSrcSet?(L+='[imagesrcset="'+Qn(x.imageSrcSet)+'"]',typeof x.imageSizes=="string"&&(L+='[imagesizes="'+Qn(x.imageSizes)+'"]')):L+='[href="'+Qn(d)+'"]';var z=L;switch(m){case"style":z=vd(d);break;case"script":z=Jc(d)}da.has(z)||(d=I({rel:"preload",href:m==="image"&&x&&x.imageSrcSet?void 0:d,as:m},x),da.set(z,d),T.querySelector(L)!==null||m==="style"&&T.querySelector(wp(z))||m==="script"&&T.querySelector(xd(z))||(m=T.createElement("link"),ks(m,"link",d),Vs(m),T.head.appendChild(m)))}}function LS(d,m){jl.m(d,m);var x=qc;if(x&&d){var T=m&&typeof m.as=="string"?m.as:"script",L='link[rel="modulepreload"][as="'+Qn(T)+'"][href="'+Qn(d)+'"]',z=L;switch(T){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":z=Jc(d)}if(!da.has(z)&&(d=I({rel:"modulepreload",href:d},m),da.set(z,d),x.querySelector(L)===null)){switch(T){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(x.querySelector(xd(z)))return}T=x.createElement("link"),ks(T,"link",d),Vs(T),x.head.appendChild(T)}}}function NS(d,m,x){jl.S(d,m,x);var T=qc;if(T&&d){var L=Bo(T).hoistableStyles,z=vd(d);m=m||"default";var te=L.get(z);if(!te){var le={loading:0,preload:null};if(te=T.querySelector(wp(z)))le.loading=5;else{d=I({rel:"stylesheet",href:d,"data-precedence":m},x),(x=da.get(z))&&Nb(d,x);var Ce=te=T.createElement("link");Vs(Ce),ks(Ce,"link",d),Ce._p=new Promise(function(it,Ct){Ce.onload=it,Ce.onerror=Ct}),Ce.addEventListener("load",function(){le.loading|=1}),Ce.addEventListener("error",function(){le.loading|=2}),le.loading|=4,Og(te,m,T)}te={type:"stylesheet",instance:te,count:1,state:le},L.set(z,te)}}}function DS(d,m){jl.X(d,m);var x=qc;if(x&&d){var T=Bo(x).hoistableScripts,L=Jc(d),z=T.get(L);z||(z=x.querySelector(xd(L)),z||(d=I({src:d,async:!0},m),(m=da.get(L))&&Db(d,m),z=x.createElement("script"),Vs(z),ks(z,"link",d),x.head.appendChild(z)),z={type:"script",instance:z,count:1,state:null},T.set(L,z))}}function FS(d,m){jl.M(d,m);var x=qc;if(x&&d){var T=Bo(x).hoistableScripts,L=Jc(d),z=T.get(L);z||(z=x.querySelector(xd(L)),z||(d=I({src:d,async:!0,type:"module"},m),(m=da.get(L))&&Db(d,m),z=x.createElement("script"),Vs(z),ks(z,"link",d),x.head.appendChild(z)),z={type:"script",instance:z,count:1,state:null},T.set(L,z))}}function C1(d,m,x,T){var L=(L=Tt.current)?yd(L):null;if(!L)throw Error(a(446));switch(d){case"meta":case"title":return null;case"style":return typeof x.precedence=="string"&&typeof x.href=="string"?(m=vd(x.href),x=Bo(L).hoistableStyles,T=x.get(m),T||(T={type:"style",instance:null,count:0,state:null},x.set(m,T)),T):{type:"void",instance:null,count:0,state:null};case"link":if(x.rel==="stylesheet"&&typeof x.href=="string"&&typeof x.precedence=="string"){d=vd(x.href);var z=Bo(L).hoistableStyles,te=z.get(d);if(te||(L=L.ownerDocument||L,te={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},z.set(d,te),(z=L.querySelector(wp(d)))&&!z._p&&(te.instance=z,te.state.loading=5),da.has(d)||(x={rel:"preload",as:"style",href:x.href,crossOrigin:x.crossOrigin,integrity:x.integrity,media:x.media,hrefLang:x.hrefLang,referrerPolicy:x.referrerPolicy},da.set(d,x),z||qu(L,d,x,te.state))),m&&T===null)throw Error(a(528,""));return te}if(m&&T!==null)throw Error(a(529,""));return null;case"script":return m=x.async,x=x.src,typeof x=="string"&&m&&typeof m!="function"&&typeof m!="symbol"?(m=Jc(x),x=Bo(L).hoistableScripts,T=x.get(m),T||(T={type:"script",instance:null,count:0,state:null},x.set(m,T)),T):{type:"void",instance:null,count:0,state:null};default:throw Error(a(444,d))}}function vd(d){return'href="'+Qn(d)+'"'}function wp(d){return'link[rel="stylesheet"]['+d+"]"}function E1(d){return I({},d,{"data-precedence":d.precedence,precedence:null})}function qu(d,m,x,T){d.querySelector('link[rel="preload"][as="style"]['+m+"]")?T.loading=1:(m=d.createElement("link"),T.preload=m,m.addEventListener("load",function(){return T.loading|=1}),m.addEventListener("error",function(){return T.loading|=2}),ks(m,"link",x),Vs(m),d.head.appendChild(m))}function Jc(d){return'[src="'+Qn(d)+'"]'}function xd(d){return"script[async]"+d}function S1(d,m,x){if(m.count++,m.instance===null)switch(m.type){case"style":var T=d.querySelector('style[data-href~="'+Qn(x.href)+'"]');if(T)return m.instance=T,Vs(T),T;var L=I({},x,{"data-href":x.href,"data-precedence":x.precedence,href:null,precedence:null});return T=(d.ownerDocument||d).createElement("style"),Vs(T),ks(T,"style",L),Og(T,x.precedence,d),m.instance=T;case"stylesheet":L=vd(x.href);var z=d.querySelector(wp(L));if(z)return m.state.loading|=4,m.instance=z,Vs(z),z;T=E1(x),(L=da.get(L))&&Nb(T,L),z=(d.ownerDocument||d).createElement("link"),Vs(z);var te=z;return te._p=new Promise(function(le,Ce){te.onload=le,te.onerror=Ce}),ks(z,"link",T),m.state.loading|=4,Og(z,x.precedence,d),m.instance=z;case"script":return z=Jc(x.src),(L=d.querySelector(xd(z)))?(m.instance=L,Vs(L),L):(T=x,(L=da.get(z))&&(T=I({},x),Db(T,L)),d=d.ownerDocument||d,L=d.createElement("script"),Vs(L),ks(L,"link",T),d.head.appendChild(L),m.instance=L);case"void":return null;default:throw Error(a(443,m.type))}else m.type==="stylesheet"&&(m.state.loading&4)===0&&(T=m.instance,m.state.loading|=4,Og(T,x.precedence,d));return m.instance}function Og(d,m,x){for(var T=x.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),L=T.length?T[T.length-1]:null,z=L,te=0;te<T.length;te++){var le=T[te];if(le.dataset.precedence===m)z=le;else if(z!==L)break}z?z.parentNode.insertBefore(d,z.nextSibling):(m=x.nodeType===9?x.head:x,m.insertBefore(d,m.firstChild))}function Nb(d,m){d.crossOrigin==null&&(d.crossOrigin=m.crossOrigin),d.referrerPolicy==null&&(d.referrerPolicy=m.referrerPolicy),d.title==null&&(d.title=m.title)}function Db(d,m){d.crossOrigin==null&&(d.crossOrigin=m.crossOrigin),d.referrerPolicy==null&&(d.referrerPolicy=m.referrerPolicy),d.integrity==null&&(d.integrity=m.integrity)}var Ju=null;function Cp(d,m,x){if(Ju===null){var T=new Map,L=Ju=new Map;L.set(x,T)}else L=Ju,T=L.get(x),T||(T=new Map,L.set(x,T));if(T.has(d))return T;for(T.set(d,null),x=x.getElementsByTagName(d),L=0;L<x.length;L++){var z=x[L];if(!(z[nl]||z[Ts]||d==="link"&&z.getAttribute("rel")==="stylesheet")&&z.namespaceURI!=="http://www.w3.org/2000/svg"){var te=z.getAttribute(m)||"";te=d+te;var le=T.get(te);le?le.push(z):T.set(te,[z])}}return T}function I1(d,m,x){d=d.ownerDocument||d,d.head.insertBefore(x,m==="title"?d.querySelector("head > title"):null)}function OS(d,m,x){if(x===1||m.itemProp!=null)return!1;switch(d){case"meta":case"title":return!0;case"style":if(typeof m.precedence!="string"||typeof m.href!="string"||m.href==="")break;return!0;case"link":if(typeof m.rel!="string"||typeof m.href!="string"||m.href===""||m.onLoad||m.onError)break;switch(m.rel){case"stylesheet":return d=m.disabled,typeof m.precedence=="string"&&d==null;default:return!0}case"script":if(m.async&&typeof m.async!="function"&&typeof m.async!="symbol"&&!m.onLoad&&!m.onError&&m.src&&typeof m.src=="string")return!0}return!1}function T1(d){return!(d.type==="stylesheet"&&(d.state.loading&3)===0)}var Wo=null;function GS(){}function M1(d,m,x){if(Wo===null)throw Error(a(475));var T=Wo;if(m.type==="stylesheet"&&(typeof x.media!="string"||matchMedia(x.media).matches!==!1)&&(m.state.loading&4)===0){if(m.instance===null){var L=vd(x.href),z=d.querySelector(wp(L));if(z){d=z._p,d!==null&&typeof d=="object"&&typeof d.then=="function"&&(T.count++,T=Al.bind(T),d.then(T,T)),m.state.loading|=4,m.instance=z,Vs(z);return}z=d.ownerDocument||d,x=E1(x),(L=da.get(L))&&Nb(x,L),z=z.createElement("link"),Vs(z);var te=z;te._p=new Promise(function(le,Ce){te.onload=le,te.onerror=Ce}),ks(z,"link",x),m.instance=z}T.stylesheets===null&&(T.stylesheets=new Map),T.stylesheets.set(m,d),(d=m.state.preload)&&(m.state.loading&3)===0&&(T.count++,m=Al.bind(T),d.addEventListener("load",m),d.addEventListener("error",m))}}function US(){if(Wo===null)throw Error(a(475));var d=Wo;return d.stylesheets&&d.count===0&&Ug(d,d.stylesheets),0<d.count?function(m){var x=setTimeout(function(){if(d.stylesheets&&Ug(d,d.stylesheets),d.unsuspend){var T=d.unsuspend;d.unsuspend=null,T()}},6e4);return d.unsuspend=m,function(){d.unsuspend=null,clearTimeout(x)}}:null}function Al(){if(this.count--,this.count===0){if(this.stylesheets)Ug(this,this.stylesheets);else if(this.unsuspend){var d=this.unsuspend;this.unsuspend=null,d()}}}var Gg=null;function Ug(d,m){d.stylesheets=null,d.unsuspend!==null&&(d.count++,Gg=new Map,m.forEach(PS,d),Gg=null,Al.call(d))}function PS(d,m){if(!(m.state.loading&4)){var x=Gg.get(d);if(x)var T=x.get(null);else{x=new Map,Gg.set(d,x);for(var L=d.querySelectorAll("link[data-precedence],style[data-precedence]"),z=0;z<L.length;z++){var te=L[z];(te.nodeName==="LINK"||te.getAttribute("media")!=="not all")&&(x.set(te.dataset.precedence,te),T=te)}T&&x.set(null,T)}L=m.instance,te=L.getAttribute("data-precedence"),z=x.get(te)||T,z===T&&x.set(null,L),x.set(te,L),this.count++,T=Al.bind(this),L.addEventListener("load",T),L.addEventListener("error",T),z?z.parentNode.insertBefore(L,z.nextSibling):(d=d.nodeType===9?d.head:d,d.insertBefore(L,d.firstChild)),m.state.loading|=4}}var wd={$$typeof:H,Provider:null,Consumer:null,_currentValue:Le,_currentValue2:Le,_threadCount:0};function zS(d,m,x,T,L,z,te,le){this.tag=1,this.containerInfo=d,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Wt(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Wt(0),this.hiddenUpdates=Wt(null),this.identifierPrefix=T,this.onUncaughtError=L,this.onCaughtError=z,this.onRecoverableError=te,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=le,this.incompleteTransitions=new Map}function Fb(d,m,x,T,L,z,te,le,Ce,it,Ct,Rt){return d=new zS(d,m,x,te,le,Ce,it,Rt),m=1,z===!0&&(m|=24),z=Ht(3,null,null,m),d.current=z,z.stateNode=d,m=Vf(),m.refCount++,d.pooledCache=m,m.refCount++,z.memoizedState={element:T,isDehydrated:x,cache:m},Qe(z),d}function _1(d){return d?(d=Pu,d):Pu}function Ob(d,m,x,T,L,z){L=_1(L),T.context===null?T.context=L:T.pendingContext=L,T=La(m),T.payload={element:x},z=z===void 0?null:z,z!==null&&(T.callback=z),x=mo(d,T,m),x!==null&&(gr(x,d,m),Ur(x,d,m))}function R1(d,m){if(d=d.memoizedState,d!==null&&d.dehydrated!==null){var x=d.retryLane;d.retryLane=x!==0&&x<m?x:m}}function Gb(d,m){R1(d,m),(d=d.alternate)&&R1(d,m)}function k1(d){if(d.tag===13){var m=Uu(d,67108864);m!==null&&gr(m,d,67108864),Gb(d,67108864)}}var Ep=!0;function VS(d,m,x,T){var L=de.T;de.T=null;var z=we.p;try{we.p=2,Ub(d,m,x,T)}finally{we.p=z,de.T=L}}function B1(d,m,x,T){var L=de.T;de.T=null;var z=we.p;try{we.p=8,Ub(d,m,x,T)}finally{we.p=z,de.T=L}}function Ub(d,m,x,T){if(Ep){var L=Sp(T);if(L===null)Rg(d,m,T,Pg,x),Vg(d,T);else if(HS(L,d,m,x,T))T.stopPropagation();else if(Vg(d,T),m&4&&-1<WS.indexOf(d)){for(;L!==null;){var z=Sa(L);if(z!==null)switch(z.tag){case 3:if(z=z.stateNode,z.current.memoizedState.isDehydrated){var te=Ln(z.pendingLanes);if(te!==0){var le=z;for(le.pendingLanes|=2,le.entangledLanes|=2;te;){var Ce=1<<31-ut(te);le.entanglements[1]|=Ce,te&=~Ce}qr(z),(Zi&6)===0&&(Eg=Ee()+500,mp(0))}}break;case 13:le=Uu(z,2),le!==null&&gr(le,z,2),qi(),Gb(z,2)}if(z=Sp(T),z===null&&Rg(d,m,T,Pg,x),z===L)break;L=z}L!==null&&T.stopPropagation()}else Rg(d,m,T,null,x)}}function Sp(d){return d=Nh(d),zg(d)}var Pg=null;function zg(d){if(Pg=null,d=Ea(d),d!==null){var m=h(d);if(m===null)d=null;else{var x=m.tag;if(x===13){if(d=p(m),d!==null)return d;d=null}else if(x===3){if(m.stateNode.current.memoizedState.isDehydrated)return m.tag===3?m.stateNode.containerInfo:null;d=null}else m!==d&&(d=null)}}return Pg=d,null}function L1(d){switch(d){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Q()){case Z:return 2;case ae:return 8;case Ae:case Ie:return 32;case Ze:return 268435456;default:return 32}default:return 32}}var Ip=!1,eu=null,Ho=null,tu=null,eh=new Map,Tp=new Map,ql=[],WS="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function Vg(d,m){switch(d){case"focusin":case"focusout":eu=null;break;case"dragenter":case"dragleave":Ho=null;break;case"mouseover":case"mouseout":tu=null;break;case"pointerover":case"pointerout":eh.delete(m.pointerId);break;case"gotpointercapture":case"lostpointercapture":Tp.delete(m.pointerId)}}function Mp(d,m,x,T,L,z){return d===null||d.nativeEvent!==z?(d={blockedOn:m,domEventName:x,eventSystemFlags:T,nativeEvent:z,targetContainers:[L]},m!==null&&(m=Sa(m),m!==null&&k1(m)),d):(d.eventSystemFlags|=T,m=d.targetContainers,L!==null&&m.indexOf(L)===-1&&m.push(L),d)}function HS(d,m,x,T,L){switch(m){case"focusin":return eu=Mp(eu,d,m,x,T,L),!0;case"dragenter":return Ho=Mp(Ho,d,m,x,T,L),!0;case"mouseover":return tu=Mp(tu,d,m,x,T,L),!0;case"pointerover":var z=L.pointerId;return eh.set(z,Mp(eh.get(z)||null,d,m,x,T,L)),!0;case"gotpointercapture":return z=L.pointerId,Tp.set(z,Mp(Tp.get(z)||null,d,m,x,T,L)),!0}return!1}function N1(d){var m=Ea(d.target);if(m!==null){var x=h(m);if(x!==null){if(m=x.tag,m===13){if(m=p(x),m!==null){d.blockedOn=m,fi(d.priority,function(){if(x.tag===13){var T=jr();T=nn(T);var L=Uu(x,T);L!==null&&gr(L,x,T),Gb(x,T)}});return}}else if(m===3&&x.stateNode.current.memoizedState.isDehydrated){d.blockedOn=x.tag===3?x.stateNode.containerInfo:null;return}}}d.blockedOn=null}function zr(d){if(d.blockedOn!==null)return!1;for(var m=d.targetContainers;0<m.length;){var x=Sp(d.nativeEvent);if(x===null){x=d.nativeEvent;var T=new x.constructor(x.type,x);Lh=T,x.target.dispatchEvent(T),Lh=null}else return m=Sa(x),m!==null&&k1(m),d.blockedOn=x,!1;m.shift()}return!0}function D1(d,m,x){zr(d)&&x.delete(m)}function XS(){Ip=!1,eu!==null&&zr(eu)&&(eu=null),Ho!==null&&zr(Ho)&&(Ho=null),tu!==null&&zr(tu)&&(tu=null),eh.forEach(D1),Tp.forEach(D1)}function Wg(d,m){d.blockedOn===m&&(d.blockedOn=null,Ip||(Ip=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,XS)))}var Hg=null;function F1(d){Hg!==d&&(Hg=d,r.unstable_scheduleCallback(r.unstable_NormalPriority,function(){Hg===d&&(Hg=null);for(var m=0;m<d.length;m+=3){var x=d[m],T=d[m+1],L=d[m+2];if(typeof T!="function"){if(zg(T||x)===null)continue;break}var z=Sa(x);z!==null&&(d.splice(m,3),m-=3,ep(z,{pending:!0,data:L,method:x.method,action:T},T,L))}}))}function Jl(d){function m(Ce){return Wg(Ce,d)}eu!==null&&Wg(eu,d),Ho!==null&&Wg(Ho,d),tu!==null&&Wg(tu,d),eh.forEach(m),Tp.forEach(m);for(var x=0;x<ql.length;x++){var T=ql[x];T.blockedOn===d&&(T.blockedOn=null)}for(;0<ql.length&&(x=ql[0],x.blockedOn===null);)N1(x),x.blockedOn===null&&ql.shift();if(x=(d.ownerDocument||d).$$reactFormReplay,x!=null)for(T=0;T<x.length;T+=3){var L=x[T],z=x[T+1],te=L[ir]||null;if(typeof z=="function")te||F1(x);else if(te){var le=null;if(z&&z.hasAttribute("formAction")){if(L=z,te=z[ir]||null)le=te.formAction;else if(zg(L)!==null)continue}else le=te.action;typeof le=="function"?x[T+1]=le:(x.splice(T,3),T-=3),F1(x)}}}function Pb(d){this._internalRoot=d}Xo.prototype.render=Pb.prototype.render=function(d){var m=this._internalRoot;if(m===null)throw Error(a(409));var x=m.current,T=jr();Ob(x,T,d,m,null,null)},Xo.prototype.unmount=Pb.prototype.unmount=function(){var d=this._internalRoot;if(d!==null){this._internalRoot=null;var m=d.containerInfo;Ob(d.current,2,null,d,null,null),qi(),m[ro]=null}};function Xo(d){this._internalRoot=d}Xo.prototype.unstable_scheduleHydration=function(d){if(d){var m=mn();d={blockedOn:null,target:d,priority:m};for(var x=0;x<ql.length&&m!==0&&m<ql[x].priority;x++);ql.splice(x,0,d),x===0&&N1(d)}};var O1=e.version;if(O1!=="19.1.1")throw Error(a(527,O1,"19.1.1"));we.findDOMNode=function(d){var m=d._reactInternals;if(m===void 0)throw typeof d.render=="function"?Error(a(188)):(d=Object.keys(d).join(","),Error(a(268,d)));return d=y(m),d=d!==null?w(d):null,d=d===null?null:d.stateNode,d};var _p={bundleType:0,version:"19.1.1",rendererPackageName:"react-dom",currentDispatcherRef:de,reconcilerVersion:"19.1.1"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Xg=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Xg.isDisabled&&Xg.supportsFiber)try{ge=Xg.inject(_p),se=Xg}catch{}}return My.createRoot=function(d,m){if(!c(d))throw Error(a(299));var x=!1,T="",L=bg,z=_x,te=td,le=null;return m!=null&&(m.unstable_strictMode===!0&&(x=!0),m.identifierPrefix!==void 0&&(T=m.identifierPrefix),m.onUncaughtError!==void 0&&(L=m.onUncaughtError),m.onCaughtError!==void 0&&(z=m.onCaughtError),m.onRecoverableError!==void 0&&(te=m.onRecoverableError),m.unstable_transitionCallbacks!==void 0&&(le=m.unstable_transitionCallbacks)),m=Fb(d,1,!1,null,null,x,T,L,z,te,le,null),d[ro]=m.current,gp(d),new Pb(m)},My.hydrateRoot=function(d,m,x){if(!c(d))throw Error(a(299));var T=!1,L="",z=bg,te=_x,le=td,Ce=null,it=null;return x!=null&&(x.unstable_strictMode===!0&&(T=!0),x.identifierPrefix!==void 0&&(L=x.identifierPrefix),x.onUncaughtError!==void 0&&(z=x.onUncaughtError),x.onCaughtError!==void 0&&(te=x.onCaughtError),x.onRecoverableError!==void 0&&(le=x.onRecoverableError),x.unstable_transitionCallbacks!==void 0&&(Ce=x.unstable_transitionCallbacks),x.formState!==void 0&&(it=x.formState)),m=Fb(d,1,!0,m,x??null,T,L,z,te,le,Ce,it),m.context=_1(null),x=m.current,T=jr(),T=nn(T),L=La(T),L.callback=null,mo(x,L,T),x=T,m.current.lanes=x,jt(m,x),qr(m),d[ro]=m.current,gp(d),new Xo(m)},My.version="19.1.1",My}var FF;function Ele(){if(FF)return dM.exports;FF=1;function r(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)}catch(e){console.error(e)}}return r(),dM.exports=Cle(),dM.exports}var Sle=Ele();/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const g2="173",Ile={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Tle={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},bP=0,J_=1,yP=2,Mle=3,_le=0,ZR=1,vP=2,fu=3,Mh=0,no=1,mu=2,Ch=0,wm=1,eR=2,tR=3,nR=4,xP=5,Zd=100,wP=101,CP=102,EP=103,SP=104,IP=200,TP=201,MP=202,_P=203,mE=204,gE=205,RP=206,kP=207,BP=208,LP=209,NP=210,DP=211,FP=212,OP=213,GP=214,AE=0,bE=1,yE=2,Im=3,vE=4,xE=5,wE=6,CE=7,Ov=0,UP=1,PP=2,Eh=0,zP=1,VP=2,WP=3,HP=4,XP=5,QP=6,KP=7,iR="attached",ZP="detached",A2=300,_h=301,qd=302,pv=303,mv=304,iA=306,gv=1e3,Rl=1001,Av=1002,ia=1003,$R=1004,Rle=1004,H0=1005,kle=1005,Dr=1006,iv=1007,Ble=1007,gu=1008,Lle=1008,vu=1009,YR=1010,jR=1011,q0=1012,b2=1013,Rh=1014,qa=1015,sA=1016,y2=1017,v2=1018,$d=1020,qR=35902,JR=1021,ek=1022,to=1023,tk=1024,nk=1025,Yd=1026,jd=1027,x2=1028,Gv=1029,ik=1030,w2=1031,Nle=1032,C2=1033,sv=33776,rv=33777,av=33778,ov=33779,EE=35840,SE=35841,IE=35842,TE=35843,ME=36196,_E=37492,RE=37496,kE=37808,BE=37809,LE=37810,NE=37811,DE=37812,FE=37813,OE=37814,GE=37815,UE=37816,PE=37817,zE=37818,VE=37819,WE=37820,HE=37821,lv=36492,XE=36494,QE=36495,sk=36283,KE=36284,ZE=36285,$E=36286,$P=2200,YP=2201,jP=2202,bv=2300,YE=2301,rE=2302,bm=2400,ym=2401,yv=2402,E2=2500,rk=2501,Dle=0,Fle=1,Ole=2,qP=3200,JP=3201,Gle=3202,Ule=3203,nf=0,ez=1,Ah="",Io="srgb",Tm="srgb-linear",vv="linear",hs="srgb",Ple=0,mm=7680,zle=7681,Vle=7682,Wle=7683,Hle=34055,Xle=34056,Qle=5386,Kle=512,Zle=513,$le=514,Yle=515,jle=516,qle=517,Jle=518,sR=519,tz=512,nz=513,iz=514,ak=515,sz=516,rz=517,az=518,oz=519,xv=35044,ece=35048,tce=35040,nce=35045,ice=35049,sce=35041,rce=35046,ace=35050,oce=35042,lce="100",rR="300 es",gc=2e3,wv=2001,cce={COMPUTE:"compute",RENDER:"render"};class xu{addEventListener(e,n){this._listeners===void 0&&(this._listeners={});const a=this._listeners;a[e]===void 0&&(a[e]=[]),a[e].indexOf(n)===-1&&a[e].push(n)}hasEventListener(e,n){const a=this._listeners;return a===void 0?!1:a[e]!==void 0&&a[e].indexOf(n)!==-1}removeEventListener(e,n){const a=this._listeners;if(a===void 0)return;const c=a[e];if(c!==void 0){const h=c.indexOf(n);h!==-1&&c.splice(h,1)}}dispatchEvent(e){const n=this._listeners;if(n===void 0)return;const a=n[e.type];if(a!==void 0){e.target=this;const c=a.slice(0);for(let h=0,p=c.length;h<p;h++)c[h].call(this,e);e.target=null}}}const ba=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let OF=1234567;const Cm=Math.PI/180,J0=180/Math.PI;function Jo(){const r=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0,a=Math.random()*4294967295|0;return(ba[r&255]+ba[r>>8&255]+ba[r>>16&255]+ba[r>>24&255]+"-"+ba[e&255]+ba[e>>8&255]+"-"+ba[e>>16&15|64]+ba[e>>24&255]+"-"+ba[n&63|128]+ba[n>>8&255]+"-"+ba[n>>16&255]+ba[n>>24&255]+ba[a&255]+ba[a>>8&255]+ba[a>>16&255]+ba[a>>24&255]).toLowerCase()}function si(r,e,n){return Math.max(e,Math.min(n,r))}function ok(r,e){return(r%e+e)%e}function uce(r,e,n,a,c){return a+(r-e)*(c-a)/(n-e)}function hce(r,e,n){return r!==e?(n-r)/(e-r):0}function cv(r,e,n){return(1-n)*r+n*e}function dce(r,e,n,a){return cv(r,e,1-Math.exp(-n*a))}function fce(r,e=1){return e-Math.abs(ok(r,e*2)-e)}function pce(r,e,n){return r<=e?0:r>=n?1:(r=(r-e)/(n-e),r*r*(3-2*r))}function mce(r,e,n){return r<=e?0:r>=n?1:(r=(r-e)/(n-e),r*r*r*(r*(r*6-15)+10))}function gce(r,e){return r+Math.floor(Math.random()*(e-r+1))}function Ace(r,e){return r+Math.random()*(e-r)}function bce(r){return r*(.5-Math.random())}function yce(r){r!==void 0&&(OF=r);let e=OF+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function vce(r){return r*Cm}function xce(r){return r*J0}function wce(r){return(r&r-1)===0&&r!==0}function Cce(r){return Math.pow(2,Math.ceil(Math.log(r)/Math.LN2))}function Ece(r){return Math.pow(2,Math.floor(Math.log(r)/Math.LN2))}function Sce(r,e,n,a,c){const h=Math.cos,p=Math.sin,b=h(n/2),y=p(n/2),w=h((e+a)/2),I=p((e+a)/2),E=h((e-a)/2),R=p((e-a)/2),k=h((a-e)/2),G=p((a-e)/2);switch(c){case"XYX":r.set(b*I,y*E,y*R,b*w);break;case"YZY":r.set(y*R,b*I,y*E,b*w);break;case"ZXZ":r.set(y*E,y*R,b*I,b*w);break;case"XZX":r.set(b*I,y*G,y*k,b*w);break;case"YXY":r.set(y*k,b*I,y*G,b*w);break;case"ZYZ":r.set(y*G,y*k,b*I,b*w);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+c)}}function Ja(r,e){switch(e.constructor){case Float32Array:return r;case Uint32Array:return r/4294967295;case Uint16Array:return r/65535;case Uint8Array:return r/255;case Int32Array:return Math.max(r/2147483647,-1);case Int16Array:return Math.max(r/32767,-1);case Int8Array:return Math.max(r/127,-1);default:throw new Error("Invalid component type.")}}function di(r,e){switch(e.constructor){case Float32Array:return r;case Uint32Array:return Math.round(r*4294967295);case Uint16Array:return Math.round(r*65535);case Uint8Array:return Math.round(r*255);case Int32Array:return Math.round(r*2147483647);case Int16Array:return Math.round(r*32767);case Int8Array:return Math.round(r*127);default:throw new Error("Invalid component type.")}}const Ice={DEG2RAD:Cm,RAD2DEG:J0,generateUUID:Jo,clamp:si,euclideanModulo:ok,mapLinear:uce,inverseLerp:hce,lerp:cv,damp:dce,pingpong:fce,smoothstep:pce,smootherstep:mce,randInt:gce,randFloat:Ace,randFloatSpread:bce,seededRandom:yce,degToRad:vce,radToDeg:xce,isPowerOfTwo:wce,ceilPowerOfTwo:Cce,floorPowerOfTwo:Ece,setQuaternionFromProperEuler:Sce,normalize:di,denormalize:Ja};class Dt{constructor(e=0,n=0){Dt.prototype.isVector2=!0,this.x=e,this.y=n}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,n){return this.x=e,this.y=n,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this}addScaledVector(e,n){return this.x+=e.x*n,this.y+=e.y*n,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const n=this.x,a=this.y,c=e.elements;return this.x=c[0]*n+c[3]*a+c[6],this.y=c[1]*n+c[4]*a+c[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,n){return this.x=si(this.x,e.x,n.x),this.y=si(this.y,e.y,n.y),this}clampScalar(e,n){return this.x=si(this.x,e,n),this.y=si(this.y,e,n),this}clampLength(e,n){const a=this.length();return this.divideScalar(a||1).multiplyScalar(si(a,e,n))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const n=Math.sqrt(this.lengthSq()*e.lengthSq());if(n===0)return Math.PI/2;const a=this.dot(e)/n;return Math.acos(si(a,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const n=this.x-e.x,a=this.y-e.y;return n*n+a*a}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this}lerpVectors(e,n,a){return this.x=e.x+(n.x-e.x)*a,this.y=e.y+(n.y-e.y)*a,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,n=0){return this.x=e[n],this.y=e[n+1],this}toArray(e=[],n=0){return e[n]=this.x,e[n+1]=this.y,e}fromBufferAttribute(e,n){return this.x=e.getX(n),this.y=e.getY(n),this}rotateAround(e,n){const a=Math.cos(n),c=Math.sin(n),h=this.x-e.x,p=this.y-e.y;return this.x=h*a-p*c+e.x,this.y=h*c+p*a+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class ii{constructor(e,n,a,c,h,p,b,y,w){ii.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,n,a,c,h,p,b,y,w)}set(e,n,a,c,h,p,b,y,w){const I=this.elements;return I[0]=e,I[1]=c,I[2]=b,I[3]=n,I[4]=h,I[5]=y,I[6]=a,I[7]=p,I[8]=w,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const n=this.elements,a=e.elements;return n[0]=a[0],n[1]=a[1],n[2]=a[2],n[3]=a[3],n[4]=a[4],n[5]=a[5],n[6]=a[6],n[7]=a[7],n[8]=a[8],this}extractBasis(e,n,a){return e.setFromMatrix3Column(this,0),n.setFromMatrix3Column(this,1),a.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const n=e.elements;return this.set(n[0],n[4],n[8],n[1],n[5],n[9],n[2],n[6],n[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,n){const a=e.elements,c=n.elements,h=this.elements,p=a[0],b=a[3],y=a[6],w=a[1],I=a[4],E=a[7],R=a[2],k=a[5],G=a[8],N=c[0],O=c[3],D=c[6],W=c[1],H=c[4],K=c[7],j=c[2],J=c[5],ee=c[8];return h[0]=p*N+b*W+y*j,h[3]=p*O+b*H+y*J,h[6]=p*D+b*K+y*ee,h[1]=w*N+I*W+E*j,h[4]=w*O+I*H+E*J,h[7]=w*D+I*K+E*ee,h[2]=R*N+k*W+G*j,h[5]=R*O+k*H+G*J,h[8]=R*D+k*K+G*ee,this}multiplyScalar(e){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=e,n[4]*=e,n[7]*=e,n[2]*=e,n[5]*=e,n[8]*=e,this}determinant(){const e=this.elements,n=e[0],a=e[1],c=e[2],h=e[3],p=e[4],b=e[5],y=e[6],w=e[7],I=e[8];return n*p*I-n*b*w-a*h*I+a*b*y+c*h*w-c*p*y}invert(){const e=this.elements,n=e[0],a=e[1],c=e[2],h=e[3],p=e[4],b=e[5],y=e[6],w=e[7],I=e[8],E=I*p-b*w,R=b*y-I*h,k=w*h-p*y,G=n*E+a*R+c*k;if(G===0)return this.set(0,0,0,0,0,0,0,0,0);const N=1/G;return e[0]=E*N,e[1]=(c*w-I*a)*N,e[2]=(b*a-c*p)*N,e[3]=R*N,e[4]=(I*n-c*y)*N,e[5]=(c*h-b*n)*N,e[6]=k*N,e[7]=(a*y-w*n)*N,e[8]=(p*n-a*h)*N,this}transpose(){let e;const n=this.elements;return e=n[1],n[1]=n[3],n[3]=e,e=n[2],n[2]=n[6],n[6]=e,e=n[5],n[5]=n[7],n[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const n=this.elements;return e[0]=n[0],e[1]=n[3],e[2]=n[6],e[3]=n[1],e[4]=n[4],e[5]=n[7],e[6]=n[2],e[7]=n[5],e[8]=n[8],this}setUvTransform(e,n,a,c,h,p,b){const y=Math.cos(h),w=Math.sin(h);return this.set(a*y,a*w,-a*(y*p+w*b)+p+e,-c*w,c*y,-c*(-w*p+y*b)+b+n,0,0,1),this}scale(e,n){return this.premultiply(gM.makeScale(e,n)),this}rotate(e){return this.premultiply(gM.makeRotation(-e)),this}translate(e,n){return this.premultiply(gM.makeTranslation(e,n)),this}makeTranslation(e,n){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,n,0,0,1),this}makeRotation(e){const n=Math.cos(e),a=Math.sin(e);return this.set(n,-a,0,a,n,0,0,0,1),this}makeScale(e,n){return this.set(e,0,0,0,n,0,0,0,1),this}equals(e){const n=this.elements,a=e.elements;for(let c=0;c<9;c++)if(n[c]!==a[c])return!1;return!0}fromArray(e,n=0){for(let a=0;a<9;a++)this.elements[a]=e[a+n];return this}toArray(e=[],n=0){const a=this.elements;return e[n]=a[0],e[n+1]=a[1],e[n+2]=a[2],e[n+3]=a[3],e[n+4]=a[4],e[n+5]=a[5],e[n+6]=a[6],e[n+7]=a[7],e[n+8]=a[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const gM=new ii;function lz(r){for(let e=r.length-1;e>=0;--e)if(r[e]>=65535)return!0;return!1}const Tce={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function X0(r,e){return new Tce[r](e)}function Cv(r){return document.createElementNS("http://www.w3.org/1999/xhtml",r)}function cz(){const r=Cv("canvas");return r.style.display="block",r}const GF={};function V0(r){r in GF||(GF[r]=!0,console.warn(r))}function Mce(r,e,n){return new Promise(function(a,c){function h(){switch(r.clientWaitSync(e,r.SYNC_FLUSH_COMMANDS_BIT,0)){case r.WAIT_FAILED:c();break;case r.TIMEOUT_EXPIRED:setTimeout(h,n);break;default:a()}}setTimeout(h,n)})}function _ce(r){const e=r.elements;e[2]=.5*e[2]+.5*e[3],e[6]=.5*e[6]+.5*e[7],e[10]=.5*e[10]+.5*e[11],e[14]=.5*e[14]+.5*e[15]}function Rce(r){const e=r.elements;e[11]===-1?(e[10]=-e[10]-1,e[14]=-e[14]):(e[10]=-e[10],e[14]=-e[14]+1)}const UF=new ii().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),PF=new ii().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function kce(){const r={enabled:!0,workingColorSpace:Tm,spaces:{},convert:function(c,h,p){return this.enabled===!1||h===p||!h||!p||(this.spaces[h].transfer===hs&&(c.r=Sh(c.r),c.g=Sh(c.g),c.b=Sh(c.b)),this.spaces[h].primaries!==this.spaces[p].primaries&&(c.applyMatrix3(this.spaces[h].toXYZ),c.applyMatrix3(this.spaces[p].fromXYZ)),this.spaces[p].transfer===hs&&(c.r=Y0(c.r),c.g=Y0(c.g),c.b=Y0(c.b))),c},fromWorkingColorSpace:function(c,h){return this.convert(c,this.workingColorSpace,h)},toWorkingColorSpace:function(c,h){return this.convert(c,h,this.workingColorSpace)},getPrimaries:function(c){return this.spaces[c].primaries},getTransfer:function(c){return c===Ah?vv:this.spaces[c].transfer},getLuminanceCoefficients:function(c,h=this.workingColorSpace){return c.fromArray(this.spaces[h].luminanceCoefficients)},define:function(c){Object.assign(this.spaces,c)},_getMatrix:function(c,h,p){return c.copy(this.spaces[h].toXYZ).multiply(this.spaces[p].fromXYZ)},_getDrawingBufferColorSpace:function(c){return this.spaces[c].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(c=this.workingColorSpace){return this.spaces[c].workingColorSpaceConfig.unpackColorSpace}},e=[.64,.33,.3,.6,.15,.06],n=[.2126,.7152,.0722],a=[.3127,.329];return r.define({[Tm]:{primaries:e,whitePoint:a,transfer:vv,toXYZ:UF,fromXYZ:PF,luminanceCoefficients:n,workingColorSpaceConfig:{unpackColorSpace:Io},outputColorSpaceConfig:{drawingBufferColorSpace:Io}},[Io]:{primaries:e,whitePoint:a,transfer:hs,toXYZ:UF,fromXYZ:PF,luminanceCoefficients:n,outputColorSpaceConfig:{drawingBufferColorSpace:Io}}}),r}const zi=kce();function Sh(r){return r<.04045?r*.0773993808:Math.pow(r*.9478672986+.0521327014,2.4)}function Y0(r){return r<.0031308?r*12.92:1.055*Math.pow(r,.41666)-.055}let A0;class uz{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let n;if(e instanceof HTMLCanvasElement)n=e;else{A0===void 0&&(A0=Cv("canvas")),A0.width=e.width,A0.height=e.height;const a=A0.getContext("2d");e instanceof ImageData?a.putImageData(e,0,0):a.drawImage(e,0,0,e.width,e.height),n=A0}return n.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const n=Cv("canvas");n.width=e.width,n.height=e.height;const a=n.getContext("2d");a.drawImage(e,0,0,e.width,e.height);const c=a.getImageData(0,0,e.width,e.height),h=c.data;for(let p=0;p<h.length;p++)h[p]=Sh(h[p]/255)*255;return a.putImageData(c,0,0),n}else if(e.data){const n=e.data.slice(0);for(let a=0;a<n.length;a++)n instanceof Uint8Array||n instanceof Uint8ClampedArray?n[a]=Math.floor(Sh(n[a]/255)*255):n[a]=Sh(n[a]);return{data:n,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let Bce=0;class vm{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Bce++}),this.uuid=Jo(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const n=e===void 0||typeof e=="string";if(!n&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const a={uuid:this.uuid,url:""},c=this.data;if(c!==null){let h;if(Array.isArray(c)){h=[];for(let p=0,b=c.length;p<b;p++)c[p].isDataTexture?h.push(AM(c[p].image)):h.push(AM(c[p]))}else h=AM(c);a.url=h}return n||(e.images[this.uuid]=a),a}}function AM(r){return typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&r instanceof ImageBitmap?uz.getDataURL(r):r.data?{data:Array.from(r.data),width:r.width,height:r.height,type:r.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Lce=0;class nr extends xu{constructor(e=nr.DEFAULT_IMAGE,n=nr.DEFAULT_MAPPING,a=Rl,c=Rl,h=Dr,p=gu,b=to,y=vu,w=nr.DEFAULT_ANISOTROPY,I=Ah){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Lce++}),this.uuid=Jo(),this.name="",this.source=new vm(e),this.mipmaps=[],this.mapping=n,this.channel=0,this.wrapS=a,this.wrapT=c,this.magFilter=h,this.minFilter=p,this.anisotropy=w,this.format=b,this.internalFormat=null,this.type=y,this.offset=new Dt(0,0),this.repeat=new Dt(1,1),this.center=new Dt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new ii,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=I,this.userData={},this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const n=e===void 0||typeof e=="string";if(!n&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const a={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(a.userData=this.userData),n||(e.textures[this.uuid]=a),a}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==A2)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case gv:e.x=e.x-Math.floor(e.x);break;case Rl:e.x=e.x<0?0:1;break;case Av:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case gv:e.y=e.y-Math.floor(e.y);break;case Rl:e.y=e.y<0?0:1;break;case Av:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}nr.DEFAULT_IMAGE=null;nr.DEFAULT_MAPPING=A2;nr.DEFAULT_ANISOTROPY=1;class Xi{constructor(e=0,n=0,a=0,c=1){Xi.prototype.isVector4=!0,this.x=e,this.y=n,this.z=a,this.w=c}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,n,a,c){return this.x=e,this.y=n,this.z=a,this.w=c,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;case 3:this.w=n;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this.z=e.z+n.z,this.w=e.w+n.w,this}addScaledVector(e,n){return this.x+=e.x*n,this.y+=e.y*n,this.z+=e.z*n,this.w+=e.w*n,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this.z=e.z-n.z,this.w=e.w-n.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const n=this.x,a=this.y,c=this.z,h=this.w,p=e.elements;return this.x=p[0]*n+p[4]*a+p[8]*c+p[12]*h,this.y=p[1]*n+p[5]*a+p[9]*c+p[13]*h,this.z=p[2]*n+p[6]*a+p[10]*c+p[14]*h,this.w=p[3]*n+p[7]*a+p[11]*c+p[15]*h,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const n=Math.sqrt(1-e.w*e.w);return n<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/n,this.y=e.y/n,this.z=e.z/n),this}setAxisAngleFromRotationMatrix(e){let n,a,c,h;const y=e.elements,w=y[0],I=y[4],E=y[8],R=y[1],k=y[5],G=y[9],N=y[2],O=y[6],D=y[10];if(Math.abs(I-R)<.01&&Math.abs(E-N)<.01&&Math.abs(G-O)<.01){if(Math.abs(I+R)<.1&&Math.abs(E+N)<.1&&Math.abs(G+O)<.1&&Math.abs(w+k+D-3)<.1)return this.set(1,0,0,0),this;n=Math.PI;const H=(w+1)/2,K=(k+1)/2,j=(D+1)/2,J=(I+R)/4,ee=(E+N)/4,re=(G+O)/4;return H>K&&H>j?H<.01?(a=0,c=.707106781,h=.707106781):(a=Math.sqrt(H),c=J/a,h=ee/a):K>j?K<.01?(a=.707106781,c=0,h=.707106781):(c=Math.sqrt(K),a=J/c,h=re/c):j<.01?(a=.707106781,c=.707106781,h=0):(h=Math.sqrt(j),a=ee/h,c=re/h),this.set(a,c,h,n),this}let W=Math.sqrt((O-G)*(O-G)+(E-N)*(E-N)+(R-I)*(R-I));return Math.abs(W)<.001&&(W=1),this.x=(O-G)/W,this.y=(E-N)/W,this.z=(R-I)/W,this.w=Math.acos((w+k+D-1)/2),this}setFromMatrixPosition(e){const n=e.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this.w=n[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,n){return this.x=si(this.x,e.x,n.x),this.y=si(this.y,e.y,n.y),this.z=si(this.z,e.z,n.z),this.w=si(this.w,e.w,n.w),this}clampScalar(e,n){return this.x=si(this.x,e,n),this.y=si(this.y,e,n),this.z=si(this.z,e,n),this.w=si(this.w,e,n),this}clampLength(e,n){const a=this.length();return this.divideScalar(a||1).multiplyScalar(si(a,e,n))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this.z+=(e.z-this.z)*n,this.w+=(e.w-this.w)*n,this}lerpVectors(e,n,a){return this.x=e.x+(n.x-e.x)*a,this.y=e.y+(n.y-e.y)*a,this.z=e.z+(n.z-e.z)*a,this.w=e.w+(n.w-e.w)*a,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,n=0){return this.x=e[n],this.y=e[n+1],this.z=e[n+2],this.w=e[n+3],this}toArray(e=[],n=0){return e[n]=this.x,e[n+1]=this.y,e[n+2]=this.z,e[n+3]=this.w,e}fromBufferAttribute(e,n){return this.x=e.getX(n),this.y=e.getY(n),this.z=e.getZ(n),this.w=e.getW(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class S2 extends xu{constructor(e=1,n=1,a={}){super(),this.isRenderTarget=!0,this.width=e,this.height=n,this.depth=1,this.scissor=new Xi(0,0,e,n),this.scissorTest=!1,this.viewport=new Xi(0,0,e,n);const c={width:e,height:n,depth:1};a=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Dr,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},a);const h=new nr(c,a.mapping,a.wrapS,a.wrapT,a.magFilter,a.minFilter,a.format,a.type,a.anisotropy,a.colorSpace);h.flipY=!1,h.generateMipmaps=a.generateMipmaps,h.internalFormat=a.internalFormat,this.textures=[];const p=a.count;for(let b=0;b<p;b++)this.textures[b]=h.clone(),this.textures[b].isRenderTargetTexture=!0,this.textures[b].renderTarget=this;this.depthBuffer=a.depthBuffer,this.stencilBuffer=a.stencilBuffer,this.resolveDepthBuffer=a.resolveDepthBuffer,this.resolveStencilBuffer=a.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=a.depthTexture,this.samples=a.samples}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),e!==null&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,n,a=1){if(this.width!==e||this.height!==n||this.depth!==a){this.width=e,this.height=n,this.depth=a;for(let c=0,h=this.textures.length;c<h;c++)this.textures[c].image.width=e,this.textures[c].image.height=n,this.textures[c].image.depth=a;this.dispose()}this.viewport.set(0,0,e,n),this.scissor.set(0,0,e,n)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let a=0,c=e.textures.length;a<c;a++)this.textures[a]=e.textures[a].clone(),this.textures[a].isRenderTargetTexture=!0,this.textures[a].renderTarget=this;const n=Object.assign({},e.texture.image);return this.texture.source=new vm(n),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Ac extends S2{constructor(e=1,n=1,a={}){super(e,n,a),this.isWebGLRenderTarget=!0}}class Uv extends nr{constructor(e=null,n=1,a=1,c=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:n,height:a,depth:c},this.magFilter=ia,this.minFilter=ia,this.wrapR=Rl,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class Nce extends Ac{constructor(e=1,n=1,a=1,c={}){super(e,n,c),this.isWebGLArrayRenderTarget=!0,this.depth=a,this.texture=new Uv(null,e,n,a),this.texture.isRenderTargetTexture=!0}}class I2 extends nr{constructor(e=null,n=1,a=1,c=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:n,height:a,depth:c},this.magFilter=ia,this.minFilter=ia,this.wrapR=Rl,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Dce extends Ac{constructor(e=1,n=1,a=1,c={}){super(e,n,c),this.isWebGL3DRenderTarget=!0,this.depth=a,this.texture=new I2(null,e,n,a),this.texture.isRenderTargetTexture=!0}}class _o{constructor(e=0,n=0,a=0,c=1){this.isQuaternion=!0,this._x=e,this._y=n,this._z=a,this._w=c}static slerpFlat(e,n,a,c,h,p,b){let y=a[c+0],w=a[c+1],I=a[c+2],E=a[c+3];const R=h[p+0],k=h[p+1],G=h[p+2],N=h[p+3];if(b===0){e[n+0]=y,e[n+1]=w,e[n+2]=I,e[n+3]=E;return}if(b===1){e[n+0]=R,e[n+1]=k,e[n+2]=G,e[n+3]=N;return}if(E!==N||y!==R||w!==k||I!==G){let O=1-b;const D=y*R+w*k+I*G+E*N,W=D>=0?1:-1,H=1-D*D;if(H>Number.EPSILON){const j=Math.sqrt(H),J=Math.atan2(j,D*W);O=Math.sin(O*J)/j,b=Math.sin(b*J)/j}const K=b*W;if(y=y*O+R*K,w=w*O+k*K,I=I*O+G*K,E=E*O+N*K,O===1-b){const j=1/Math.sqrt(y*y+w*w+I*I+E*E);y*=j,w*=j,I*=j,E*=j}}e[n]=y,e[n+1]=w,e[n+2]=I,e[n+3]=E}static multiplyQuaternionsFlat(e,n,a,c,h,p){const b=a[c],y=a[c+1],w=a[c+2],I=a[c+3],E=h[p],R=h[p+1],k=h[p+2],G=h[p+3];return e[n]=b*G+I*E+y*k-w*R,e[n+1]=y*G+I*R+w*E-b*k,e[n+2]=w*G+I*k+b*R-y*E,e[n+3]=I*G-b*E-y*R-w*k,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,n,a,c){return this._x=e,this._y=n,this._z=a,this._w=c,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,n=!0){const a=e._x,c=e._y,h=e._z,p=e._order,b=Math.cos,y=Math.sin,w=b(a/2),I=b(c/2),E=b(h/2),R=y(a/2),k=y(c/2),G=y(h/2);switch(p){case"XYZ":this._x=R*I*E+w*k*G,this._y=w*k*E-R*I*G,this._z=w*I*G+R*k*E,this._w=w*I*E-R*k*G;break;case"YXZ":this._x=R*I*E+w*k*G,this._y=w*k*E-R*I*G,this._z=w*I*G-R*k*E,this._w=w*I*E+R*k*G;break;case"ZXY":this._x=R*I*E-w*k*G,this._y=w*k*E+R*I*G,this._z=w*I*G+R*k*E,this._w=w*I*E-R*k*G;break;case"ZYX":this._x=R*I*E-w*k*G,this._y=w*k*E+R*I*G,this._z=w*I*G-R*k*E,this._w=w*I*E+R*k*G;break;case"YZX":this._x=R*I*E+w*k*G,this._y=w*k*E+R*I*G,this._z=w*I*G-R*k*E,this._w=w*I*E-R*k*G;break;case"XZY":this._x=R*I*E-w*k*G,this._y=w*k*E-R*I*G,this._z=w*I*G+R*k*E,this._w=w*I*E+R*k*G;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+p)}return n===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,n){const a=n/2,c=Math.sin(a);return this._x=e.x*c,this._y=e.y*c,this._z=e.z*c,this._w=Math.cos(a),this._onChangeCallback(),this}setFromRotationMatrix(e){const n=e.elements,a=n[0],c=n[4],h=n[8],p=n[1],b=n[5],y=n[9],w=n[2],I=n[6],E=n[10],R=a+b+E;if(R>0){const k=.5/Math.sqrt(R+1);this._w=.25/k,this._x=(I-y)*k,this._y=(h-w)*k,this._z=(p-c)*k}else if(a>b&&a>E){const k=2*Math.sqrt(1+a-b-E);this._w=(I-y)/k,this._x=.25*k,this._y=(c+p)/k,this._z=(h+w)/k}else if(b>E){const k=2*Math.sqrt(1+b-a-E);this._w=(h-w)/k,this._x=(c+p)/k,this._y=.25*k,this._z=(y+I)/k}else{const k=2*Math.sqrt(1+E-a-b);this._w=(p-c)/k,this._x=(h+w)/k,this._y=(y+I)/k,this._z=.25*k}return this._onChangeCallback(),this}setFromUnitVectors(e,n){let a=e.dot(n)+1;return a<Number.EPSILON?(a=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=a):(this._x=0,this._y=-e.z,this._z=e.y,this._w=a)):(this._x=e.y*n.z-e.z*n.y,this._y=e.z*n.x-e.x*n.z,this._z=e.x*n.y-e.y*n.x,this._w=a),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(si(this.dot(e),-1,1)))}rotateTowards(e,n){const a=this.angleTo(e);if(a===0)return this;const c=Math.min(1,n/a);return this.slerp(e,c),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,n){const a=e._x,c=e._y,h=e._z,p=e._w,b=n._x,y=n._y,w=n._z,I=n._w;return this._x=a*I+p*b+c*w-h*y,this._y=c*I+p*y+h*b-a*w,this._z=h*I+p*w+a*y-c*b,this._w=p*I-a*b-c*y-h*w,this._onChangeCallback(),this}slerp(e,n){if(n===0)return this;if(n===1)return this.copy(e);const a=this._x,c=this._y,h=this._z,p=this._w;let b=p*e._w+a*e._x+c*e._y+h*e._z;if(b<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,b=-b):this.copy(e),b>=1)return this._w=p,this._x=a,this._y=c,this._z=h,this;const y=1-b*b;if(y<=Number.EPSILON){const k=1-n;return this._w=k*p+n*this._w,this._x=k*a+n*this._x,this._y=k*c+n*this._y,this._z=k*h+n*this._z,this.normalize(),this}const w=Math.sqrt(y),I=Math.atan2(w,b),E=Math.sin((1-n)*I)/w,R=Math.sin(n*I)/w;return this._w=p*E+this._w*R,this._x=a*E+this._x*R,this._y=c*E+this._y*R,this._z=h*E+this._z*R,this._onChangeCallback(),this}slerpQuaternions(e,n,a){return this.copy(e).slerp(n,a)}random(){const e=2*Math.PI*Math.random(),n=2*Math.PI*Math.random(),a=Math.random(),c=Math.sqrt(1-a),h=Math.sqrt(a);return this.set(c*Math.sin(e),c*Math.cos(e),h*Math.sin(n),h*Math.cos(n))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,n=0){return this._x=e[n],this._y=e[n+1],this._z=e[n+2],this._w=e[n+3],this._onChangeCallback(),this}toArray(e=[],n=0){return e[n]=this._x,e[n+1]=this._y,e[n+2]=this._z,e[n+3]=this._w,e}fromBufferAttribute(e,n){return this._x=e.getX(n),this._y=e.getY(n),this._z=e.getZ(n),this._w=e.getW(n),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class be{constructor(e=0,n=0,a=0){be.prototype.isVector3=!0,this.x=e,this.y=n,this.z=a}set(e,n,a){return a===void 0&&(a=this.z),this.x=e,this.y=n,this.z=a,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this.z=e.z+n.z,this}addScaledVector(e,n){return this.x+=e.x*n,this.y+=e.y*n,this.z+=e.z*n,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this.z=e.z-n.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,n){return this.x=e.x*n.x,this.y=e.y*n.y,this.z=e.z*n.z,this}applyEuler(e){return this.applyQuaternion(zF.setFromEuler(e))}applyAxisAngle(e,n){return this.applyQuaternion(zF.setFromAxisAngle(e,n))}applyMatrix3(e){const n=this.x,a=this.y,c=this.z,h=e.elements;return this.x=h[0]*n+h[3]*a+h[6]*c,this.y=h[1]*n+h[4]*a+h[7]*c,this.z=h[2]*n+h[5]*a+h[8]*c,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const n=this.x,a=this.y,c=this.z,h=e.elements,p=1/(h[3]*n+h[7]*a+h[11]*c+h[15]);return this.x=(h[0]*n+h[4]*a+h[8]*c+h[12])*p,this.y=(h[1]*n+h[5]*a+h[9]*c+h[13])*p,this.z=(h[2]*n+h[6]*a+h[10]*c+h[14])*p,this}applyQuaternion(e){const n=this.x,a=this.y,c=this.z,h=e.x,p=e.y,b=e.z,y=e.w,w=2*(p*c-b*a),I=2*(b*n-h*c),E=2*(h*a-p*n);return this.x=n+y*w+p*E-b*I,this.y=a+y*I+b*w-h*E,this.z=c+y*E+h*I-p*w,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const n=this.x,a=this.y,c=this.z,h=e.elements;return this.x=h[0]*n+h[4]*a+h[8]*c,this.y=h[1]*n+h[5]*a+h[9]*c,this.z=h[2]*n+h[6]*a+h[10]*c,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,n){return this.x=si(this.x,e.x,n.x),this.y=si(this.y,e.y,n.y),this.z=si(this.z,e.z,n.z),this}clampScalar(e,n){return this.x=si(this.x,e,n),this.y=si(this.y,e,n),this.z=si(this.z,e,n),this}clampLength(e,n){const a=this.length();return this.divideScalar(a||1).multiplyScalar(si(a,e,n))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this.z+=(e.z-this.z)*n,this}lerpVectors(e,n,a){return this.x=e.x+(n.x-e.x)*a,this.y=e.y+(n.y-e.y)*a,this.z=e.z+(n.z-e.z)*a,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,n){const a=e.x,c=e.y,h=e.z,p=n.x,b=n.y,y=n.z;return this.x=c*y-h*b,this.y=h*p-a*y,this.z=a*b-c*p,this}projectOnVector(e){const n=e.lengthSq();if(n===0)return this.set(0,0,0);const a=e.dot(this)/n;return this.copy(e).multiplyScalar(a)}projectOnPlane(e){return bM.copy(this).projectOnVector(e),this.sub(bM)}reflect(e){return this.sub(bM.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const n=Math.sqrt(this.lengthSq()*e.lengthSq());if(n===0)return Math.PI/2;const a=this.dot(e)/n;return Math.acos(si(a,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const n=this.x-e.x,a=this.y-e.y,c=this.z-e.z;return n*n+a*a+c*c}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,n,a){const c=Math.sin(n)*e;return this.x=c*Math.sin(a),this.y=Math.cos(n)*e,this.z=c*Math.cos(a),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,n,a){return this.x=e*Math.sin(n),this.y=a,this.z=e*Math.cos(n),this}setFromMatrixPosition(e){const n=e.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this}setFromMatrixScale(e){const n=this.setFromMatrixColumn(e,0).length(),a=this.setFromMatrixColumn(e,1).length(),c=this.setFromMatrixColumn(e,2).length();return this.x=n,this.y=a,this.z=c,this}setFromMatrixColumn(e,n){return this.fromArray(e.elements,n*4)}setFromMatrix3Column(e,n){return this.fromArray(e.elements,n*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,n=0){return this.x=e[n],this.y=e[n+1],this.z=e[n+2],this}toArray(e=[],n=0){return e[n]=this.x,e[n+1]=this.y,e[n+2]=this.z,e}fromBufferAttribute(e,n){return this.x=e.getX(n),this.y=e.getY(n),this.z=e.getZ(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,n=Math.random()*2-1,a=Math.sqrt(1-n*n);return this.x=a*Math.cos(e),this.y=n,this.z=a*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const bM=new be,zF=new _o;class io{constructor(e=new be(1/0,1/0,1/0),n=new be(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=n}set(e,n){return this.min.copy(e),this.max.copy(n),this}setFromArray(e){this.makeEmpty();for(let n=0,a=e.length;n<a;n+=3)this.expandByPoint(lc.fromArray(e,n));return this}setFromBufferAttribute(e){this.makeEmpty();for(let n=0,a=e.count;n<a;n++)this.expandByPoint(lc.fromBufferAttribute(e,n));return this}setFromPoints(e){this.makeEmpty();for(let n=0,a=e.length;n<a;n++)this.expandByPoint(e[n]);return this}setFromCenterAndSize(e,n){const a=lc.copy(n).multiplyScalar(.5);return this.min.copy(e).sub(a),this.max.copy(e).add(a),this}setFromObject(e,n=!1){return this.makeEmpty(),this.expandByObject(e,n)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,n=!1){e.updateWorldMatrix(!1,!1);const a=e.geometry;if(a!==void 0){const h=a.getAttribute("position");if(n===!0&&h!==void 0&&e.isInstancedMesh!==!0)for(let p=0,b=h.count;p<b;p++)e.isMesh===!0?e.getVertexPosition(p,lc):lc.fromBufferAttribute(h,p),lc.applyMatrix4(e.matrixWorld),this.expandByPoint(lc);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),zw.copy(e.boundingBox)):(a.boundingBox===null&&a.computeBoundingBox(),zw.copy(a.boundingBox)),zw.applyMatrix4(e.matrixWorld),this.union(zw)}const c=e.children;for(let h=0,p=c.length;h<p;h++)this.expandByObject(c[h],n);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,n){return n.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,lc),lc.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let n,a;return e.normal.x>0?(n=e.normal.x*this.min.x,a=e.normal.x*this.max.x):(n=e.normal.x*this.max.x,a=e.normal.x*this.min.x),e.normal.y>0?(n+=e.normal.y*this.min.y,a+=e.normal.y*this.max.y):(n+=e.normal.y*this.max.y,a+=e.normal.y*this.min.y),e.normal.z>0?(n+=e.normal.z*this.min.z,a+=e.normal.z*this.max.z):(n+=e.normal.z*this.max.z,a+=e.normal.z*this.min.z),n<=-e.constant&&a>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(_y),Vw.subVectors(this.max,_y),b0.subVectors(e.a,_y),y0.subVectors(e.b,_y),v0.subVectors(e.c,_y),Dd.subVectors(y0,b0),Fd.subVectors(v0,y0),Kp.subVectors(b0,v0);let n=[0,-Dd.z,Dd.y,0,-Fd.z,Fd.y,0,-Kp.z,Kp.y,Dd.z,0,-Dd.x,Fd.z,0,-Fd.x,Kp.z,0,-Kp.x,-Dd.y,Dd.x,0,-Fd.y,Fd.x,0,-Kp.y,Kp.x,0];return!yM(n,b0,y0,v0,Vw)||(n=[1,0,0,0,1,0,0,0,1],!yM(n,b0,y0,v0,Vw))?!1:(Ww.crossVectors(Dd,Fd),n=[Ww.x,Ww.y,Ww.z],yM(n,b0,y0,v0,Vw))}clampPoint(e,n){return n.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,lc).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(lc).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(oh[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),oh[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),oh[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),oh[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),oh[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),oh[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),oh[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),oh[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(oh),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const oh=[new be,new be,new be,new be,new be,new be,new be,new be],lc=new be,zw=new io,b0=new be,y0=new be,v0=new be,Dd=new be,Fd=new be,Kp=new be,_y=new be,Vw=new be,Ww=new be,Zp=new be;function yM(r,e,n,a,c){for(let h=0,p=r.length-3;h<=p;h+=3){Zp.fromArray(r,h);const b=c.x*Math.abs(Zp.x)+c.y*Math.abs(Zp.y)+c.z*Math.abs(Zp.z),y=e.dot(Zp),w=n.dot(Zp),I=a.dot(Zp);if(Math.max(-Math.max(y,w,I),Math.min(y,w,I))>b)return!1}return!0}const Fce=new io,Ry=new be,vM=new be;class wa{constructor(e=new be,n=-1){this.isSphere=!0,this.center=e,this.radius=n}set(e,n){return this.center.copy(e),this.radius=n,this}setFromPoints(e,n){const a=this.center;n!==void 0?a.copy(n):Fce.setFromPoints(e).getCenter(a);let c=0;for(let h=0,p=e.length;h<p;h++)c=Math.max(c,a.distanceToSquared(e[h]));return this.radius=Math.sqrt(c),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const n=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=n*n}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,n){const a=this.center.distanceToSquared(e);return n.copy(e),a>this.radius*this.radius&&(n.sub(this.center).normalize(),n.multiplyScalar(this.radius).add(this.center)),n}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;Ry.subVectors(e,this.center);const n=Ry.lengthSq();if(n>this.radius*this.radius){const a=Math.sqrt(n),c=(a-this.radius)*.5;this.center.addScaledVector(Ry,c/a),this.radius+=c}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(vM.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(Ry.copy(e.center).add(vM)),this.expandByPoint(Ry.copy(e.center).sub(vM))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const lh=new be,xM=new be,Hw=new be,Od=new be,wM=new be,Xw=new be,CM=new be;class rA{constructor(e=new be,n=new be(0,0,-1)){this.origin=e,this.direction=n}set(e,n){return this.origin.copy(e),this.direction.copy(n),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,n){return n.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,lh)),this}closestPointToPoint(e,n){n.subVectors(e,this.origin);const a=n.dot(this.direction);return a<0?n.copy(this.origin):n.copy(this.origin).addScaledVector(this.direction,a)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const n=lh.subVectors(e,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(e):(lh.copy(this.origin).addScaledVector(this.direction,n),lh.distanceToSquared(e))}distanceSqToSegment(e,n,a,c){xM.copy(e).add(n).multiplyScalar(.5),Hw.copy(n).sub(e).normalize(),Od.copy(this.origin).sub(xM);const h=e.distanceTo(n)*.5,p=-this.direction.dot(Hw),b=Od.dot(this.direction),y=-Od.dot(Hw),w=Od.lengthSq(),I=Math.abs(1-p*p);let E,R,k,G;if(I>0)if(E=p*y-b,R=p*b-y,G=h*I,E>=0)if(R>=-G)if(R<=G){const N=1/I;E*=N,R*=N,k=E*(E+p*R+2*b)+R*(p*E+R+2*y)+w}else R=h,E=Math.max(0,-(p*R+b)),k=-E*E+R*(R+2*y)+w;else R=-h,E=Math.max(0,-(p*R+b)),k=-E*E+R*(R+2*y)+w;else R<=-G?(E=Math.max(0,-(-p*h+b)),R=E>0?-h:Math.min(Math.max(-h,-y),h),k=-E*E+R*(R+2*y)+w):R<=G?(E=0,R=Math.min(Math.max(-h,-y),h),k=R*(R+2*y)+w):(E=Math.max(0,-(p*h+b)),R=E>0?h:Math.min(Math.max(-h,-y),h),k=-E*E+R*(R+2*y)+w);else R=p>0?-h:h,E=Math.max(0,-(p*R+b)),k=-E*E+R*(R+2*y)+w;return a&&a.copy(this.origin).addScaledVector(this.direction,E),c&&c.copy(xM).addScaledVector(Hw,R),k}intersectSphere(e,n){lh.subVectors(e.center,this.origin);const a=lh.dot(this.direction),c=lh.dot(lh)-a*a,h=e.radius*e.radius;if(c>h)return null;const p=Math.sqrt(h-c),b=a-p,y=a+p;return y<0?null:b<0?this.at(y,n):this.at(b,n)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const n=e.normal.dot(this.direction);if(n===0)return e.distanceToPoint(this.origin)===0?0:null;const a=-(this.origin.dot(e.normal)+e.constant)/n;return a>=0?a:null}intersectPlane(e,n){const a=this.distanceToPlane(e);return a===null?null:this.at(a,n)}intersectsPlane(e){const n=e.distanceToPoint(this.origin);return n===0||e.normal.dot(this.direction)*n<0}intersectBox(e,n){let a,c,h,p,b,y;const w=1/this.direction.x,I=1/this.direction.y,E=1/this.direction.z,R=this.origin;return w>=0?(a=(e.min.x-R.x)*w,c=(e.max.x-R.x)*w):(a=(e.max.x-R.x)*w,c=(e.min.x-R.x)*w),I>=0?(h=(e.min.y-R.y)*I,p=(e.max.y-R.y)*I):(h=(e.max.y-R.y)*I,p=(e.min.y-R.y)*I),a>p||h>c||((h>a||isNaN(a))&&(a=h),(p<c||isNaN(c))&&(c=p),E>=0?(b=(e.min.z-R.z)*E,y=(e.max.z-R.z)*E):(b=(e.max.z-R.z)*E,y=(e.min.z-R.z)*E),a>y||b>c)||((b>a||a!==a)&&(a=b),(y<c||c!==c)&&(c=y),c<0)?null:this.at(a>=0?a:c,n)}intersectsBox(e){return this.intersectBox(e,lh)!==null}intersectTriangle(e,n,a,c,h){wM.subVectors(n,e),Xw.subVectors(a,e),CM.crossVectors(wM,Xw);let p=this.direction.dot(CM),b;if(p>0){if(c)return null;b=1}else if(p<0)b=-1,p=-p;else return null;Od.subVectors(this.origin,e);const y=b*this.direction.dot(Xw.crossVectors(Od,Xw));if(y<0)return null;const w=b*this.direction.dot(wM.cross(Od));if(w<0||y+w>p)return null;const I=-b*Od.dot(CM);return I<0?null:this.at(I/p,h)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Zn{constructor(e,n,a,c,h,p,b,y,w,I,E,R,k,G,N,O){Zn.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,n,a,c,h,p,b,y,w,I,E,R,k,G,N,O)}set(e,n,a,c,h,p,b,y,w,I,E,R,k,G,N,O){const D=this.elements;return D[0]=e,D[4]=n,D[8]=a,D[12]=c,D[1]=h,D[5]=p,D[9]=b,D[13]=y,D[2]=w,D[6]=I,D[10]=E,D[14]=R,D[3]=k,D[7]=G,D[11]=N,D[15]=O,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Zn().fromArray(this.elements)}copy(e){const n=this.elements,a=e.elements;return n[0]=a[0],n[1]=a[1],n[2]=a[2],n[3]=a[3],n[4]=a[4],n[5]=a[5],n[6]=a[6],n[7]=a[7],n[8]=a[8],n[9]=a[9],n[10]=a[10],n[11]=a[11],n[12]=a[12],n[13]=a[13],n[14]=a[14],n[15]=a[15],this}copyPosition(e){const n=this.elements,a=e.elements;return n[12]=a[12],n[13]=a[13],n[14]=a[14],this}setFromMatrix3(e){const n=e.elements;return this.set(n[0],n[3],n[6],0,n[1],n[4],n[7],0,n[2],n[5],n[8],0,0,0,0,1),this}extractBasis(e,n,a){return e.setFromMatrixColumn(this,0),n.setFromMatrixColumn(this,1),a.setFromMatrixColumn(this,2),this}makeBasis(e,n,a){return this.set(e.x,n.x,a.x,0,e.y,n.y,a.y,0,e.z,n.z,a.z,0,0,0,0,1),this}extractRotation(e){const n=this.elements,a=e.elements,c=1/x0.setFromMatrixColumn(e,0).length(),h=1/x0.setFromMatrixColumn(e,1).length(),p=1/x0.setFromMatrixColumn(e,2).length();return n[0]=a[0]*c,n[1]=a[1]*c,n[2]=a[2]*c,n[3]=0,n[4]=a[4]*h,n[5]=a[5]*h,n[6]=a[6]*h,n[7]=0,n[8]=a[8]*p,n[9]=a[9]*p,n[10]=a[10]*p,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromEuler(e){const n=this.elements,a=e.x,c=e.y,h=e.z,p=Math.cos(a),b=Math.sin(a),y=Math.cos(c),w=Math.sin(c),I=Math.cos(h),E=Math.sin(h);if(e.order==="XYZ"){const R=p*I,k=p*E,G=b*I,N=b*E;n[0]=y*I,n[4]=-y*E,n[8]=w,n[1]=k+G*w,n[5]=R-N*w,n[9]=-b*y,n[2]=N-R*w,n[6]=G+k*w,n[10]=p*y}else if(e.order==="YXZ"){const R=y*I,k=y*E,G=w*I,N=w*E;n[0]=R+N*b,n[4]=G*b-k,n[8]=p*w,n[1]=p*E,n[5]=p*I,n[9]=-b,n[2]=k*b-G,n[6]=N+R*b,n[10]=p*y}else if(e.order==="ZXY"){const R=y*I,k=y*E,G=w*I,N=w*E;n[0]=R-N*b,n[4]=-p*E,n[8]=G+k*b,n[1]=k+G*b,n[5]=p*I,n[9]=N-R*b,n[2]=-p*w,n[6]=b,n[10]=p*y}else if(e.order==="ZYX"){const R=p*I,k=p*E,G=b*I,N=b*E;n[0]=y*I,n[4]=G*w-k,n[8]=R*w+N,n[1]=y*E,n[5]=N*w+R,n[9]=k*w-G,n[2]=-w,n[6]=b*y,n[10]=p*y}else if(e.order==="YZX"){const R=p*y,k=p*w,G=b*y,N=b*w;n[0]=y*I,n[4]=N-R*E,n[8]=G*E+k,n[1]=E,n[5]=p*I,n[9]=-b*I,n[2]=-w*I,n[6]=k*E+G,n[10]=R-N*E}else if(e.order==="XZY"){const R=p*y,k=p*w,G=b*y,N=b*w;n[0]=y*I,n[4]=-E,n[8]=w*I,n[1]=R*E+N,n[5]=p*I,n[9]=k*E-G,n[2]=G*E-k,n[6]=b*I,n[10]=N*E+R}return n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Oce,e,Gce)}lookAt(e,n,a){const c=this.elements;return $o.subVectors(e,n),$o.lengthSq()===0&&($o.z=1),$o.normalize(),Gd.crossVectors(a,$o),Gd.lengthSq()===0&&(Math.abs(a.z)===1?$o.x+=1e-4:$o.z+=1e-4,$o.normalize(),Gd.crossVectors(a,$o)),Gd.normalize(),Qw.crossVectors($o,Gd),c[0]=Gd.x,c[4]=Qw.x,c[8]=$o.x,c[1]=Gd.y,c[5]=Qw.y,c[9]=$o.y,c[2]=Gd.z,c[6]=Qw.z,c[10]=$o.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,n){const a=e.elements,c=n.elements,h=this.elements,p=a[0],b=a[4],y=a[8],w=a[12],I=a[1],E=a[5],R=a[9],k=a[13],G=a[2],N=a[6],O=a[10],D=a[14],W=a[3],H=a[7],K=a[11],j=a[15],J=c[0],ee=c[4],re=c[8],Y=c[12],ie=c[1],ue=c[5],Re=c[9],_e=c[13],Pe=c[2],rt=c[6],de=c[10],we=c[14],Le=c[3],Je=c[7],fe=c[11],Ve=c[15];return h[0]=p*J+b*ie+y*Pe+w*Le,h[4]=p*ee+b*ue+y*rt+w*Je,h[8]=p*re+b*Re+y*de+w*fe,h[12]=p*Y+b*_e+y*we+w*Ve,h[1]=I*J+E*ie+R*Pe+k*Le,h[5]=I*ee+E*ue+R*rt+k*Je,h[9]=I*re+E*Re+R*de+k*fe,h[13]=I*Y+E*_e+R*we+k*Ve,h[2]=G*J+N*ie+O*Pe+D*Le,h[6]=G*ee+N*ue+O*rt+D*Je,h[10]=G*re+N*Re+O*de+D*fe,h[14]=G*Y+N*_e+O*we+D*Ve,h[3]=W*J+H*ie+K*Pe+j*Le,h[7]=W*ee+H*ue+K*rt+j*Je,h[11]=W*re+H*Re+K*de+j*fe,h[15]=W*Y+H*_e+K*we+j*Ve,this}multiplyScalar(e){const n=this.elements;return n[0]*=e,n[4]*=e,n[8]*=e,n[12]*=e,n[1]*=e,n[5]*=e,n[9]*=e,n[13]*=e,n[2]*=e,n[6]*=e,n[10]*=e,n[14]*=e,n[3]*=e,n[7]*=e,n[11]*=e,n[15]*=e,this}determinant(){const e=this.elements,n=e[0],a=e[4],c=e[8],h=e[12],p=e[1],b=e[5],y=e[9],w=e[13],I=e[2],E=e[6],R=e[10],k=e[14],G=e[3],N=e[7],O=e[11],D=e[15];return G*(+h*y*E-c*w*E-h*b*R+a*w*R+c*b*k-a*y*k)+N*(+n*y*k-n*w*R+h*p*R-c*p*k+c*w*I-h*y*I)+O*(+n*w*E-n*b*k-h*p*E+a*p*k+h*b*I-a*w*I)+D*(-c*b*I-n*y*E+n*b*R+c*p*E-a*p*R+a*y*I)}transpose(){const e=this.elements;let n;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,this}setPosition(e,n,a){const c=this.elements;return e.isVector3?(c[12]=e.x,c[13]=e.y,c[14]=e.z):(c[12]=e,c[13]=n,c[14]=a),this}invert(){const e=this.elements,n=e[0],a=e[1],c=e[2],h=e[3],p=e[4],b=e[5],y=e[6],w=e[7],I=e[8],E=e[9],R=e[10],k=e[11],G=e[12],N=e[13],O=e[14],D=e[15],W=E*O*w-N*R*w+N*y*k-b*O*k-E*y*D+b*R*D,H=G*R*w-I*O*w-G*y*k+p*O*k+I*y*D-p*R*D,K=I*N*w-G*E*w+G*b*k-p*N*k-I*b*D+p*E*D,j=G*E*y-I*N*y-G*b*R+p*N*R+I*b*O-p*E*O,J=n*W+a*H+c*K+h*j;if(J===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const ee=1/J;return e[0]=W*ee,e[1]=(N*R*h-E*O*h-N*c*k+a*O*k+E*c*D-a*R*D)*ee,e[2]=(b*O*h-N*y*h+N*c*w-a*O*w-b*c*D+a*y*D)*ee,e[3]=(E*y*h-b*R*h-E*c*w+a*R*w+b*c*k-a*y*k)*ee,e[4]=H*ee,e[5]=(I*O*h-G*R*h+G*c*k-n*O*k-I*c*D+n*R*D)*ee,e[6]=(G*y*h-p*O*h-G*c*w+n*O*w+p*c*D-n*y*D)*ee,e[7]=(p*R*h-I*y*h+I*c*w-n*R*w-p*c*k+n*y*k)*ee,e[8]=K*ee,e[9]=(G*E*h-I*N*h-G*a*k+n*N*k+I*a*D-n*E*D)*ee,e[10]=(p*N*h-G*b*h+G*a*w-n*N*w-p*a*D+n*b*D)*ee,e[11]=(I*b*h-p*E*h-I*a*w+n*E*w+p*a*k-n*b*k)*ee,e[12]=j*ee,e[13]=(I*N*c-G*E*c+G*a*R-n*N*R-I*a*O+n*E*O)*ee,e[14]=(G*b*c-p*N*c-G*a*y+n*N*y+p*a*O-n*b*O)*ee,e[15]=(p*E*c-I*b*c+I*a*y-n*E*y-p*a*R+n*b*R)*ee,this}scale(e){const n=this.elements,a=e.x,c=e.y,h=e.z;return n[0]*=a,n[4]*=c,n[8]*=h,n[1]*=a,n[5]*=c,n[9]*=h,n[2]*=a,n[6]*=c,n[10]*=h,n[3]*=a,n[7]*=c,n[11]*=h,this}getMaxScaleOnAxis(){const e=this.elements,n=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],a=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],c=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(n,a,c))}makeTranslation(e,n,a){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,n,0,0,1,a,0,0,0,1),this}makeRotationX(e){const n=Math.cos(e),a=Math.sin(e);return this.set(1,0,0,0,0,n,-a,0,0,a,n,0,0,0,0,1),this}makeRotationY(e){const n=Math.cos(e),a=Math.sin(e);return this.set(n,0,a,0,0,1,0,0,-a,0,n,0,0,0,0,1),this}makeRotationZ(e){const n=Math.cos(e),a=Math.sin(e);return this.set(n,-a,0,0,a,n,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,n){const a=Math.cos(n),c=Math.sin(n),h=1-a,p=e.x,b=e.y,y=e.z,w=h*p,I=h*b;return this.set(w*p+a,w*b-c*y,w*y+c*b,0,w*b+c*y,I*b+a,I*y-c*p,0,w*y-c*b,I*y+c*p,h*y*y+a,0,0,0,0,1),this}makeScale(e,n,a){return this.set(e,0,0,0,0,n,0,0,0,0,a,0,0,0,0,1),this}makeShear(e,n,a,c,h,p){return this.set(1,a,h,0,e,1,p,0,n,c,1,0,0,0,0,1),this}compose(e,n,a){const c=this.elements,h=n._x,p=n._y,b=n._z,y=n._w,w=h+h,I=p+p,E=b+b,R=h*w,k=h*I,G=h*E,N=p*I,O=p*E,D=b*E,W=y*w,H=y*I,K=y*E,j=a.x,J=a.y,ee=a.z;return c[0]=(1-(N+D))*j,c[1]=(k+K)*j,c[2]=(G-H)*j,c[3]=0,c[4]=(k-K)*J,c[5]=(1-(R+D))*J,c[6]=(O+W)*J,c[7]=0,c[8]=(G+H)*ee,c[9]=(O-W)*ee,c[10]=(1-(R+N))*ee,c[11]=0,c[12]=e.x,c[13]=e.y,c[14]=e.z,c[15]=1,this}decompose(e,n,a){const c=this.elements;let h=x0.set(c[0],c[1],c[2]).length();const p=x0.set(c[4],c[5],c[6]).length(),b=x0.set(c[8],c[9],c[10]).length();this.determinant()<0&&(h=-h),e.x=c[12],e.y=c[13],e.z=c[14],cc.copy(this);const w=1/h,I=1/p,E=1/b;return cc.elements[0]*=w,cc.elements[1]*=w,cc.elements[2]*=w,cc.elements[4]*=I,cc.elements[5]*=I,cc.elements[6]*=I,cc.elements[8]*=E,cc.elements[9]*=E,cc.elements[10]*=E,n.setFromRotationMatrix(cc),a.x=h,a.y=p,a.z=b,this}makePerspective(e,n,a,c,h,p,b=gc){const y=this.elements,w=2*h/(n-e),I=2*h/(a-c),E=(n+e)/(n-e),R=(a+c)/(a-c);let k,G;if(b===gc)k=-(p+h)/(p-h),G=-2*p*h/(p-h);else if(b===wv)k=-p/(p-h),G=-p*h/(p-h);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+b);return y[0]=w,y[4]=0,y[8]=E,y[12]=0,y[1]=0,y[5]=I,y[9]=R,y[13]=0,y[2]=0,y[6]=0,y[10]=k,y[14]=G,y[3]=0,y[7]=0,y[11]=-1,y[15]=0,this}makeOrthographic(e,n,a,c,h,p,b=gc){const y=this.elements,w=1/(n-e),I=1/(a-c),E=1/(p-h),R=(n+e)*w,k=(a+c)*I;let G,N;if(b===gc)G=(p+h)*E,N=-2*E;else if(b===wv)G=h*E,N=-1*E;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+b);return y[0]=2*w,y[4]=0,y[8]=0,y[12]=-R,y[1]=0,y[5]=2*I,y[9]=0,y[13]=-k,y[2]=0,y[6]=0,y[10]=N,y[14]=-G,y[3]=0,y[7]=0,y[11]=0,y[15]=1,this}equals(e){const n=this.elements,a=e.elements;for(let c=0;c<16;c++)if(n[c]!==a[c])return!1;return!0}fromArray(e,n=0){for(let a=0;a<16;a++)this.elements[a]=e[a+n];return this}toArray(e=[],n=0){const a=this.elements;return e[n]=a[0],e[n+1]=a[1],e[n+2]=a[2],e[n+3]=a[3],e[n+4]=a[4],e[n+5]=a[5],e[n+6]=a[6],e[n+7]=a[7],e[n+8]=a[8],e[n+9]=a[9],e[n+10]=a[10],e[n+11]=a[11],e[n+12]=a[12],e[n+13]=a[13],e[n+14]=a[14],e[n+15]=a[15],e}}const x0=new be,cc=new Zn,Oce=new be(0,0,0),Gce=new be(1,1,1),Gd=new be,Qw=new be,$o=new be,VF=new Zn,WF=new _o;class el{constructor(e=0,n=0,a=0,c=el.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=n,this._z=a,this._order=c}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,n,a,c=this._order){return this._x=e,this._y=n,this._z=a,this._order=c,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,n=this._order,a=!0){const c=e.elements,h=c[0],p=c[4],b=c[8],y=c[1],w=c[5],I=c[9],E=c[2],R=c[6],k=c[10];switch(n){case"XYZ":this._y=Math.asin(si(b,-1,1)),Math.abs(b)<.9999999?(this._x=Math.atan2(-I,k),this._z=Math.atan2(-p,h)):(this._x=Math.atan2(R,w),this._z=0);break;case"YXZ":this._x=Math.asin(-si(I,-1,1)),Math.abs(I)<.9999999?(this._y=Math.atan2(b,k),this._z=Math.atan2(y,w)):(this._y=Math.atan2(-E,h),this._z=0);break;case"ZXY":this._x=Math.asin(si(R,-1,1)),Math.abs(R)<.9999999?(this._y=Math.atan2(-E,k),this._z=Math.atan2(-p,w)):(this._y=0,this._z=Math.atan2(y,h));break;case"ZYX":this._y=Math.asin(-si(E,-1,1)),Math.abs(E)<.9999999?(this._x=Math.atan2(R,k),this._z=Math.atan2(y,h)):(this._x=0,this._z=Math.atan2(-p,w));break;case"YZX":this._z=Math.asin(si(y,-1,1)),Math.abs(y)<.9999999?(this._x=Math.atan2(-I,w),this._y=Math.atan2(-E,h)):(this._x=0,this._y=Math.atan2(b,k));break;case"XZY":this._z=Math.asin(-si(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(R,w),this._y=Math.atan2(b,h)):(this._x=Math.atan2(-I,k),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+n)}return this._order=n,a===!0&&this._onChangeCallback(),this}setFromQuaternion(e,n,a){return VF.makeRotationFromQuaternion(e),this.setFromRotationMatrix(VF,n,a)}setFromVector3(e,n=this._order){return this.set(e.x,e.y,e.z,n)}reorder(e){return WF.setFromEuler(this),this.setFromQuaternion(WF,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],n=0){return e[n]=this._x,e[n+1]=this._y,e[n+2]=this._z,e[n+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}el.DEFAULT_ORDER="XYZ";class T2{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let Uce=0;const HF=new be,w0=new _o,ch=new Zn,Kw=new be,ky=new be,Pce=new be,zce=new _o,XF=new be(1,0,0),QF=new be(0,1,0),KF=new be(0,0,1),ZF={type:"added"},Vce={type:"removed"},C0={type:"childadded",child:null},EM={type:"childremoved",child:null};class Qi extends xu{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Uce++}),this.uuid=Jo(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Qi.DEFAULT_UP.clone();const e=new be,n=new el,a=new _o,c=new be(1,1,1);function h(){a.setFromEuler(n,!1)}function p(){n.setFromQuaternion(a,void 0,!1)}n._onChange(h),a._onChange(p),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:n},quaternion:{configurable:!0,enumerable:!0,value:a},scale:{configurable:!0,enumerable:!0,value:c},modelViewMatrix:{value:new Zn},normalMatrix:{value:new ii}}),this.matrix=new Zn,this.matrixWorld=new Zn,this.matrixAutoUpdate=Qi.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Qi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new T2,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,n){this.quaternion.setFromAxisAngle(e,n)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,n){return w0.setFromAxisAngle(e,n),this.quaternion.multiply(w0),this}rotateOnWorldAxis(e,n){return w0.setFromAxisAngle(e,n),this.quaternion.premultiply(w0),this}rotateX(e){return this.rotateOnAxis(XF,e)}rotateY(e){return this.rotateOnAxis(QF,e)}rotateZ(e){return this.rotateOnAxis(KF,e)}translateOnAxis(e,n){return HF.copy(e).applyQuaternion(this.quaternion),this.position.add(HF.multiplyScalar(n)),this}translateX(e){return this.translateOnAxis(XF,e)}translateY(e){return this.translateOnAxis(QF,e)}translateZ(e){return this.translateOnAxis(KF,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(ch.copy(this.matrixWorld).invert())}lookAt(e,n,a){e.isVector3?Kw.copy(e):Kw.set(e,n,a);const c=this.parent;this.updateWorldMatrix(!0,!1),ky.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ch.lookAt(ky,Kw,this.up):ch.lookAt(Kw,ky,this.up),this.quaternion.setFromRotationMatrix(ch),c&&(ch.extractRotation(c.matrixWorld),w0.setFromRotationMatrix(ch),this.quaternion.premultiply(w0.invert()))}add(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.add(arguments[n]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(ZF),C0.child=e,this.dispatchEvent(C0),C0.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let a=0;a<arguments.length;a++)this.remove(arguments[a]);return this}const n=this.children.indexOf(e);return n!==-1&&(e.parent=null,this.children.splice(n,1),e.dispatchEvent(Vce),EM.child=e,this.dispatchEvent(EM),EM.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),ch.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),ch.multiply(e.parent.matrixWorld)),e.applyMatrix4(ch),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(ZF),C0.child=e,this.dispatchEvent(C0),C0.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,n){if(this[e]===n)return this;for(let a=0,c=this.children.length;a<c;a++){const p=this.children[a].getObjectByProperty(e,n);if(p!==void 0)return p}}getObjectsByProperty(e,n,a=[]){this[e]===n&&a.push(this);const c=this.children;for(let h=0,p=c.length;h<p;h++)c[h].getObjectsByProperty(e,n,a);return a}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ky,e,Pce),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ky,zce,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const n=this.matrixWorld.elements;return e.set(n[8],n[9],n[10]).normalize()}raycast(){}traverse(e){e(this);const n=this.children;for(let a=0,c=n.length;a<c;a++)n[a].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const n=this.children;for(let a=0,c=n.length;a<c;a++)n[a].traverseVisible(e)}traverseAncestors(e){const n=this.parent;n!==null&&(e(n),n.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const n=this.children;for(let a=0,c=n.length;a<c;a++)n[a].updateMatrixWorld(e)}updateWorldMatrix(e,n){const a=this.parent;if(e===!0&&a!==null&&a.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),n===!0){const c=this.children;for(let h=0,p=c.length;h<p;h++)c[h].updateWorldMatrix(!1,!0)}}toJSON(e){const n=e===void 0||typeof e=="string",a={};n&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},a.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const c={};c.uuid=this.uuid,c.type=this.type,this.name!==""&&(c.name=this.name),this.castShadow===!0&&(c.castShadow=!0),this.receiveShadow===!0&&(c.receiveShadow=!0),this.visible===!1&&(c.visible=!1),this.frustumCulled===!1&&(c.frustumCulled=!1),this.renderOrder!==0&&(c.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(c.userData=this.userData),c.layers=this.layers.mask,c.matrix=this.matrix.toArray(),c.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(c.matrixAutoUpdate=!1),this.isInstancedMesh&&(c.type="InstancedMesh",c.count=this.count,c.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(c.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(c.type="BatchedMesh",c.perObjectFrustumCulled=this.perObjectFrustumCulled,c.sortObjects=this.sortObjects,c.drawRanges=this._drawRanges,c.reservedRanges=this._reservedRanges,c.visibility=this._visibility,c.active=this._active,c.bounds=this._bounds.map(b=>({boxInitialized:b.boxInitialized,boxMin:b.box.min.toArray(),boxMax:b.box.max.toArray(),sphereInitialized:b.sphereInitialized,sphereRadius:b.sphere.radius,sphereCenter:b.sphere.center.toArray()})),c.maxInstanceCount=this._maxInstanceCount,c.maxVertexCount=this._maxVertexCount,c.maxIndexCount=this._maxIndexCount,c.geometryInitialized=this._geometryInitialized,c.geometryCount=this._geometryCount,c.matricesTexture=this._matricesTexture.toJSON(e),this._colorsTexture!==null&&(c.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(c.boundingSphere={center:c.boundingSphere.center.toArray(),radius:c.boundingSphere.radius}),this.boundingBox!==null&&(c.boundingBox={min:c.boundingBox.min.toArray(),max:c.boundingBox.max.toArray()}));function h(b,y){return b[y.uuid]===void 0&&(b[y.uuid]=y.toJSON(e)),y.uuid}if(this.isScene)this.background&&(this.background.isColor?c.background=this.background.toJSON():this.background.isTexture&&(c.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(c.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){c.geometry=h(e.geometries,this.geometry);const b=this.geometry.parameters;if(b!==void 0&&b.shapes!==void 0){const y=b.shapes;if(Array.isArray(y))for(let w=0,I=y.length;w<I;w++){const E=y[w];h(e.shapes,E)}else h(e.shapes,y)}}if(this.isSkinnedMesh&&(c.bindMode=this.bindMode,c.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(h(e.skeletons,this.skeleton),c.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const b=[];for(let y=0,w=this.material.length;y<w;y++)b.push(h(e.materials,this.material[y]));c.material=b}else c.material=h(e.materials,this.material);if(this.children.length>0){c.children=[];for(let b=0;b<this.children.length;b++)c.children.push(this.children[b].toJSON(e).object)}if(this.animations.length>0){c.animations=[];for(let b=0;b<this.animations.length;b++){const y=this.animations[b];c.animations.push(h(e.animations,y))}}if(n){const b=p(e.geometries),y=p(e.materials),w=p(e.textures),I=p(e.images),E=p(e.shapes),R=p(e.skeletons),k=p(e.animations),G=p(e.nodes);b.length>0&&(a.geometries=b),y.length>0&&(a.materials=y),w.length>0&&(a.textures=w),I.length>0&&(a.images=I),E.length>0&&(a.shapes=E),R.length>0&&(a.skeletons=R),k.length>0&&(a.animations=k),G.length>0&&(a.nodes=G)}return a.object=c,a;function p(b){const y=[];for(const w in b){const I=b[w];delete I.metadata,y.push(I)}return y}}clone(e){return new this.constructor().copy(this,e)}copy(e,n=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),n===!0)for(let a=0;a<e.children.length;a++){const c=e.children[a];this.add(c.clone())}return this}}Qi.DEFAULT_UP=new be(0,1,0);Qi.DEFAULT_MATRIX_AUTO_UPDATE=!0;Qi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const uc=new be,uh=new be,SM=new be,hh=new be,E0=new be,S0=new be,$F=new be,IM=new be,TM=new be,MM=new be,_M=new Xi,RM=new Xi,kM=new Xi;class To{constructor(e=new be,n=new be,a=new be){this.a=e,this.b=n,this.c=a}static getNormal(e,n,a,c){c.subVectors(a,n),uc.subVectors(e,n),c.cross(uc);const h=c.lengthSq();return h>0?c.multiplyScalar(1/Math.sqrt(h)):c.set(0,0,0)}static getBarycoord(e,n,a,c,h){uc.subVectors(c,n),uh.subVectors(a,n),SM.subVectors(e,n);const p=uc.dot(uc),b=uc.dot(uh),y=uc.dot(SM),w=uh.dot(uh),I=uh.dot(SM),E=p*w-b*b;if(E===0)return h.set(0,0,0),null;const R=1/E,k=(w*y-b*I)*R,G=(p*I-b*y)*R;return h.set(1-k-G,G,k)}static containsPoint(e,n,a,c){return this.getBarycoord(e,n,a,c,hh)===null?!1:hh.x>=0&&hh.y>=0&&hh.x+hh.y<=1}static getInterpolation(e,n,a,c,h,p,b,y){return this.getBarycoord(e,n,a,c,hh)===null?(y.x=0,y.y=0,"z"in y&&(y.z=0),"w"in y&&(y.w=0),null):(y.setScalar(0),y.addScaledVector(h,hh.x),y.addScaledVector(p,hh.y),y.addScaledVector(b,hh.z),y)}static getInterpolatedAttribute(e,n,a,c,h,p){return _M.setScalar(0),RM.setScalar(0),kM.setScalar(0),_M.fromBufferAttribute(e,n),RM.fromBufferAttribute(e,a),kM.fromBufferAttribute(e,c),p.setScalar(0),p.addScaledVector(_M,h.x),p.addScaledVector(RM,h.y),p.addScaledVector(kM,h.z),p}static isFrontFacing(e,n,a,c){return uc.subVectors(a,n),uh.subVectors(e,n),uc.cross(uh).dot(c)<0}set(e,n,a){return this.a.copy(e),this.b.copy(n),this.c.copy(a),this}setFromPointsAndIndices(e,n,a,c){return this.a.copy(e[n]),this.b.copy(e[a]),this.c.copy(e[c]),this}setFromAttributeAndIndices(e,n,a,c){return this.a.fromBufferAttribute(e,n),this.b.fromBufferAttribute(e,a),this.c.fromBufferAttribute(e,c),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return uc.subVectors(this.c,this.b),uh.subVectors(this.a,this.b),uc.cross(uh).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return To.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,n){return To.getBarycoord(e,this.a,this.b,this.c,n)}getInterpolation(e,n,a,c,h){return To.getInterpolation(e,this.a,this.b,this.c,n,a,c,h)}containsPoint(e){return To.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return To.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,n){const a=this.a,c=this.b,h=this.c;let p,b;E0.subVectors(c,a),S0.subVectors(h,a),IM.subVectors(e,a);const y=E0.dot(IM),w=S0.dot(IM);if(y<=0&&w<=0)return n.copy(a);TM.subVectors(e,c);const I=E0.dot(TM),E=S0.dot(TM);if(I>=0&&E<=I)return n.copy(c);const R=y*E-I*w;if(R<=0&&y>=0&&I<=0)return p=y/(y-I),n.copy(a).addScaledVector(E0,p);MM.subVectors(e,h);const k=E0.dot(MM),G=S0.dot(MM);if(G>=0&&k<=G)return n.copy(h);const N=k*w-y*G;if(N<=0&&w>=0&&G<=0)return b=w/(w-G),n.copy(a).addScaledVector(S0,b);const O=I*G-k*E;if(O<=0&&E-I>=0&&k-G>=0)return $F.subVectors(h,c),b=(E-I)/(E-I+(k-G)),n.copy(c).addScaledVector($F,b);const D=1/(O+N+R);return p=N*D,b=R*D,n.copy(a).addScaledVector(E0,p).addScaledVector(S0,b)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const hz={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ud={h:0,s:0,l:0},Zw={h:0,s:0,l:0};function BM(r,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?r+(e-r)*6*n:n<1/2?e:n<2/3?r+(e-r)*6*(2/3-n):r}class pn{constructor(e,n,a){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,n,a)}set(e,n,a){if(n===void 0&&a===void 0){const c=e;c&&c.isColor?this.copy(c):typeof c=="number"?this.setHex(c):typeof c=="string"&&this.setStyle(c)}else this.setRGB(e,n,a);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,n=Io){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,zi.toWorkingColorSpace(this,n),this}setRGB(e,n,a,c=zi.workingColorSpace){return this.r=e,this.g=n,this.b=a,zi.toWorkingColorSpace(this,c),this}setHSL(e,n,a,c=zi.workingColorSpace){if(e=ok(e,1),n=si(n,0,1),a=si(a,0,1),n===0)this.r=this.g=this.b=a;else{const h=a<=.5?a*(1+n):a+n-a*n,p=2*a-h;this.r=BM(p,h,e+1/3),this.g=BM(p,h,e),this.b=BM(p,h,e-1/3)}return zi.toWorkingColorSpace(this,c),this}setStyle(e,n=Io){function a(h){h!==void 0&&parseFloat(h)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let c;if(c=/^(\w+)\(([^\)]*)\)/.exec(e)){let h;const p=c[1],b=c[2];switch(p){case"rgb":case"rgba":if(h=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(b))return a(h[4]),this.setRGB(Math.min(255,parseInt(h[1],10))/255,Math.min(255,parseInt(h[2],10))/255,Math.min(255,parseInt(h[3],10))/255,n);if(h=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(b))return a(h[4]),this.setRGB(Math.min(100,parseInt(h[1],10))/100,Math.min(100,parseInt(h[2],10))/100,Math.min(100,parseInt(h[3],10))/100,n);break;case"hsl":case"hsla":if(h=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(b))return a(h[4]),this.setHSL(parseFloat(h[1])/360,parseFloat(h[2])/100,parseFloat(h[3])/100,n);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(c=/^\#([A-Fa-f\d]+)$/.exec(e)){const h=c[1],p=h.length;if(p===3)return this.setRGB(parseInt(h.charAt(0),16)/15,parseInt(h.charAt(1),16)/15,parseInt(h.charAt(2),16)/15,n);if(p===6)return this.setHex(parseInt(h,16),n);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,n);return this}setColorName(e,n=Io){const a=hz[e.toLowerCase()];return a!==void 0?this.setHex(a,n):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Sh(e.r),this.g=Sh(e.g),this.b=Sh(e.b),this}copyLinearToSRGB(e){return this.r=Y0(e.r),this.g=Y0(e.g),this.b=Y0(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Io){return zi.fromWorkingColorSpace(ya.copy(this),e),Math.round(si(ya.r*255,0,255))*65536+Math.round(si(ya.g*255,0,255))*256+Math.round(si(ya.b*255,0,255))}getHexString(e=Io){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,n=zi.workingColorSpace){zi.fromWorkingColorSpace(ya.copy(this),n);const a=ya.r,c=ya.g,h=ya.b,p=Math.max(a,c,h),b=Math.min(a,c,h);let y,w;const I=(b+p)/2;if(b===p)y=0,w=0;else{const E=p-b;switch(w=I<=.5?E/(p+b):E/(2-p-b),p){case a:y=(c-h)/E+(c<h?6:0);break;case c:y=(h-a)/E+2;break;case h:y=(a-c)/E+4;break}y/=6}return e.h=y,e.s=w,e.l=I,e}getRGB(e,n=zi.workingColorSpace){return zi.fromWorkingColorSpace(ya.copy(this),n),e.r=ya.r,e.g=ya.g,e.b=ya.b,e}getStyle(e=Io){zi.fromWorkingColorSpace(ya.copy(this),e);const n=ya.r,a=ya.g,c=ya.b;return e!==Io?`color(${e} ${n.toFixed(3)} ${a.toFixed(3)} ${c.toFixed(3)})`:`rgb(${Math.round(n*255)},${Math.round(a*255)},${Math.round(c*255)})`}offsetHSL(e,n,a){return this.getHSL(Ud),this.setHSL(Ud.h+e,Ud.s+n,Ud.l+a)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,n){return this.r=e.r+n.r,this.g=e.g+n.g,this.b=e.b+n.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,n){return this.r+=(e.r-this.r)*n,this.g+=(e.g-this.g)*n,this.b+=(e.b-this.b)*n,this}lerpColors(e,n,a){return this.r=e.r+(n.r-e.r)*a,this.g=e.g+(n.g-e.g)*a,this.b=e.b+(n.b-e.b)*a,this}lerpHSL(e,n){this.getHSL(Ud),e.getHSL(Zw);const a=cv(Ud.h,Zw.h,n),c=cv(Ud.s,Zw.s,n),h=cv(Ud.l,Zw.l,n);return this.setHSL(a,c,h),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const n=this.r,a=this.g,c=this.b,h=e.elements;return this.r=h[0]*n+h[3]*a+h[6]*c,this.g=h[1]*n+h[4]*a+h[7]*c,this.b=h[2]*n+h[5]*a+h[8]*c,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,n=0){return this.r=e[n],this.g=e[n+1],this.b=e[n+2],this}toArray(e=[],n=0){return e[n]=this.r,e[n+1]=this.g,e[n+2]=this.b,e}fromBufferAttribute(e,n){return this.r=e.getX(n),this.g=e.getY(n),this.b=e.getZ(n),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ya=new pn;pn.NAMES=hz;let Wce=0;class Ca extends xu{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Wce++}),this.uuid=Jo(),this.name="",this.type="Material",this.blending=wm,this.side=Mh,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=mE,this.blendDst=gE,this.blendEquation=Zd,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new pn(0,0,0),this.blendAlpha=0,this.depthFunc=Im,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=sR,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=mm,this.stencilZFail=mm,this.stencilZPass=mm,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const n in e){const a=e[n];if(a===void 0){console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);continue}const c=this[n];if(c===void 0){console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);continue}c&&c.isColor?c.set(a):c&&c.isVector3&&a&&a.isVector3?c.copy(a):this[n]=a}}toJSON(e){const n=e===void 0||typeof e=="string";n&&(e={textures:{},images:{}});const a={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};a.uuid=this.uuid,a.type=this.type,this.name!==""&&(a.name=this.name),this.color&&this.color.isColor&&(a.color=this.color.getHex()),this.roughness!==void 0&&(a.roughness=this.roughness),this.metalness!==void 0&&(a.metalness=this.metalness),this.sheen!==void 0&&(a.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(a.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(a.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(a.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(a.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(a.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(a.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(a.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(a.shininess=this.shininess),this.clearcoat!==void 0&&(a.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(a.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(a.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(a.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(a.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,a.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(a.dispersion=this.dispersion),this.iridescence!==void 0&&(a.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(a.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(a.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(a.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(a.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(a.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(a.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(a.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(a.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(a.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(a.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(a.lightMap=this.lightMap.toJSON(e).uuid,a.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(a.aoMap=this.aoMap.toJSON(e).uuid,a.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(a.bumpMap=this.bumpMap.toJSON(e).uuid,a.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(a.normalMap=this.normalMap.toJSON(e).uuid,a.normalMapType=this.normalMapType,a.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(a.displacementMap=this.displacementMap.toJSON(e).uuid,a.displacementScale=this.displacementScale,a.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(a.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(a.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(a.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(a.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(a.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(a.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(a.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(a.combine=this.combine)),this.envMapRotation!==void 0&&(a.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(a.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(a.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(a.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(a.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(a.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(a.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(a.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(a.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(a.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(a.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(a.size=this.size),this.shadowSide!==null&&(a.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(a.sizeAttenuation=this.sizeAttenuation),this.blending!==wm&&(a.blending=this.blending),this.side!==Mh&&(a.side=this.side),this.vertexColors===!0&&(a.vertexColors=!0),this.opacity<1&&(a.opacity=this.opacity),this.transparent===!0&&(a.transparent=!0),this.blendSrc!==mE&&(a.blendSrc=this.blendSrc),this.blendDst!==gE&&(a.blendDst=this.blendDst),this.blendEquation!==Zd&&(a.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(a.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(a.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(a.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(a.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(a.blendAlpha=this.blendAlpha),this.depthFunc!==Im&&(a.depthFunc=this.depthFunc),this.depthTest===!1&&(a.depthTest=this.depthTest),this.depthWrite===!1&&(a.depthWrite=this.depthWrite),this.colorWrite===!1&&(a.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(a.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==sR&&(a.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(a.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(a.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==mm&&(a.stencilFail=this.stencilFail),this.stencilZFail!==mm&&(a.stencilZFail=this.stencilZFail),this.stencilZPass!==mm&&(a.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(a.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(a.rotation=this.rotation),this.polygonOffset===!0&&(a.polygonOffset=!0),this.polygonOffsetFactor!==0&&(a.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(a.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(a.linewidth=this.linewidth),this.dashSize!==void 0&&(a.dashSize=this.dashSize),this.gapSize!==void 0&&(a.gapSize=this.gapSize),this.scale!==void 0&&(a.scale=this.scale),this.dithering===!0&&(a.dithering=!0),this.alphaTest>0&&(a.alphaTest=this.alphaTest),this.alphaHash===!0&&(a.alphaHash=!0),this.alphaToCoverage===!0&&(a.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(a.premultipliedAlpha=!0),this.forceSinglePass===!0&&(a.forceSinglePass=!0),this.wireframe===!0&&(a.wireframe=!0),this.wireframeLinewidth>1&&(a.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(a.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(a.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(a.flatShading=!0),this.visible===!1&&(a.visible=!1),this.toneMapped===!1&&(a.toneMapped=!1),this.fog===!1&&(a.fog=!1),Object.keys(this.userData).length>0&&(a.userData=this.userData);function c(h){const p=[];for(const b in h){const y=h[b];delete y.metadata,p.push(y)}return p}if(n){const h=c(e.textures),p=c(e.images);h.length>0&&(a.textures=h),p.length>0&&(a.images=p)}return a}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const n=e.clippingPlanes;let a=null;if(n!==null){const c=n.length;a=new Array(c);for(let h=0;h!==c;++h)a[h]=n[h].clone()}return this.clippingPlanes=a,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class sf extends Ca{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new pn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new el,this.combine=Ov,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const bh=Hce();function Hce(){const r=new ArrayBuffer(4),e=new Float32Array(r),n=new Uint32Array(r),a=new Uint32Array(512),c=new Uint32Array(512);for(let y=0;y<256;++y){const w=y-127;w<-27?(a[y]=0,a[y|256]=32768,c[y]=24,c[y|256]=24):w<-14?(a[y]=1024>>-w-14,a[y|256]=1024>>-w-14|32768,c[y]=-w-1,c[y|256]=-w-1):w<=15?(a[y]=w+15<<10,a[y|256]=w+15<<10|32768,c[y]=13,c[y|256]=13):w<128?(a[y]=31744,a[y|256]=64512,c[y]=24,c[y|256]=24):(a[y]=31744,a[y|256]=64512,c[y]=13,c[y|256]=13)}const h=new Uint32Array(2048),p=new Uint32Array(64),b=new Uint32Array(64);for(let y=1;y<1024;++y){let w=y<<13,I=0;for(;(w&8388608)===0;)w<<=1,I-=8388608;w&=-8388609,I+=947912704,h[y]=w|I}for(let y=1024;y<2048;++y)h[y]=939524096+(y-1024<<13);for(let y=1;y<31;++y)p[y]=y<<23;p[31]=1199570944,p[32]=2147483648;for(let y=33;y<63;++y)p[y]=2147483648+(y-32<<23);p[63]=3347054592;for(let y=1;y<64;++y)y!==32&&(b[y]=1024);return{floatView:e,uint32View:n,baseTable:a,shiftTable:c,mantissaTable:h,exponentTable:p,offsetTable:b}}function Eo(r){Math.abs(r)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),r=si(r,-65504,65504),bh.floatView[0]=r;const e=bh.uint32View[0],n=e>>23&511;return bh.baseTable[n]+((e&8388607)>>bh.shiftTable[n])}function Jy(r){const e=r>>10;return bh.uint32View[0]=bh.mantissaTable[bh.offsetTable[e]+(r&1023)]+bh.exponentTable[e],bh.floatView[0]}const Xce={toHalfFloat:Eo,fromHalfFloat:Jy},wr=new be,$w=new Dt;let Qce=0;class bs{constructor(e,n,a=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:Qce++}),this.name="",this.array=e,this.itemSize=n,this.count=e!==void 0?e.length/n:0,this.normalized=a,this.usage=xv,this.updateRanges=[],this.gpuType=qa,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,n){this.updateRanges.push({start:e,count:n})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,n,a){e*=this.itemSize,a*=n.itemSize;for(let c=0,h=this.itemSize;c<h;c++)this.array[e+c]=n.array[a+c];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let n=0,a=this.count;n<a;n++)$w.fromBufferAttribute(this,n),$w.applyMatrix3(e),this.setXY(n,$w.x,$w.y);else if(this.itemSize===3)for(let n=0,a=this.count;n<a;n++)wr.fromBufferAttribute(this,n),wr.applyMatrix3(e),this.setXYZ(n,wr.x,wr.y,wr.z);return this}applyMatrix4(e){for(let n=0,a=this.count;n<a;n++)wr.fromBufferAttribute(this,n),wr.applyMatrix4(e),this.setXYZ(n,wr.x,wr.y,wr.z);return this}applyNormalMatrix(e){for(let n=0,a=this.count;n<a;n++)wr.fromBufferAttribute(this,n),wr.applyNormalMatrix(e),this.setXYZ(n,wr.x,wr.y,wr.z);return this}transformDirection(e){for(let n=0,a=this.count;n<a;n++)wr.fromBufferAttribute(this,n),wr.transformDirection(e),this.setXYZ(n,wr.x,wr.y,wr.z);return this}set(e,n=0){return this.array.set(e,n),this}getComponent(e,n){let a=this.array[e*this.itemSize+n];return this.normalized&&(a=Ja(a,this.array)),a}setComponent(e,n,a){return this.normalized&&(a=di(a,this.array)),this.array[e*this.itemSize+n]=a,this}getX(e){let n=this.array[e*this.itemSize];return this.normalized&&(n=Ja(n,this.array)),n}setX(e,n){return this.normalized&&(n=di(n,this.array)),this.array[e*this.itemSize]=n,this}getY(e){let n=this.array[e*this.itemSize+1];return this.normalized&&(n=Ja(n,this.array)),n}setY(e,n){return this.normalized&&(n=di(n,this.array)),this.array[e*this.itemSize+1]=n,this}getZ(e){let n=this.array[e*this.itemSize+2];return this.normalized&&(n=Ja(n,this.array)),n}setZ(e,n){return this.normalized&&(n=di(n,this.array)),this.array[e*this.itemSize+2]=n,this}getW(e){let n=this.array[e*this.itemSize+3];return this.normalized&&(n=Ja(n,this.array)),n}setW(e,n){return this.normalized&&(n=di(n,this.array)),this.array[e*this.itemSize+3]=n,this}setXY(e,n,a){return e*=this.itemSize,this.normalized&&(n=di(n,this.array),a=di(a,this.array)),this.array[e+0]=n,this.array[e+1]=a,this}setXYZ(e,n,a,c){return e*=this.itemSize,this.normalized&&(n=di(n,this.array),a=di(a,this.array),c=di(c,this.array)),this.array[e+0]=n,this.array[e+1]=a,this.array[e+2]=c,this}setXYZW(e,n,a,c,h){return e*=this.itemSize,this.normalized&&(n=di(n,this.array),a=di(a,this.array),c=di(c,this.array),h=di(h,this.array)),this.array[e+0]=n,this.array[e+1]=a,this.array[e+2]=c,this.array[e+3]=h,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==xv&&(e.usage=this.usage),e}}class Kce extends bs{constructor(e,n,a){super(new Int8Array(e),n,a)}}class Zce extends bs{constructor(e,n,a){super(new Uint8Array(e),n,a)}}class $ce extends bs{constructor(e,n,a){super(new Uint8ClampedArray(e),n,a)}}class Yce extends bs{constructor(e,n,a){super(new Int16Array(e),n,a)}}class lk extends bs{constructor(e,n,a){super(new Uint16Array(e),n,a)}}class jce extends bs{constructor(e,n,a){super(new Int32Array(e),n,a)}}class ck extends bs{constructor(e,n,a){super(new Uint32Array(e),n,a)}}class qce extends bs{constructor(e,n,a){super(new Uint16Array(e),n,a),this.isFloat16BufferAttribute=!0}getX(e){let n=Jy(this.array[e*this.itemSize]);return this.normalized&&(n=Ja(n,this.array)),n}setX(e,n){return this.normalized&&(n=di(n,this.array)),this.array[e*this.itemSize]=Eo(n),this}getY(e){let n=Jy(this.array[e*this.itemSize+1]);return this.normalized&&(n=Ja(n,this.array)),n}setY(e,n){return this.normalized&&(n=di(n,this.array)),this.array[e*this.itemSize+1]=Eo(n),this}getZ(e){let n=Jy(this.array[e*this.itemSize+2]);return this.normalized&&(n=Ja(n,this.array)),n}setZ(e,n){return this.normalized&&(n=di(n,this.array)),this.array[e*this.itemSize+2]=Eo(n),this}getW(e){let n=Jy(this.array[e*this.itemSize+3]);return this.normalized&&(n=Ja(n,this.array)),n}setW(e,n){return this.normalized&&(n=di(n,this.array)),this.array[e*this.itemSize+3]=Eo(n),this}setXY(e,n,a){return e*=this.itemSize,this.normalized&&(n=di(n,this.array),a=di(a,this.array)),this.array[e+0]=Eo(n),this.array[e+1]=Eo(a),this}setXYZ(e,n,a,c){return e*=this.itemSize,this.normalized&&(n=di(n,this.array),a=di(a,this.array),c=di(c,this.array)),this.array[e+0]=Eo(n),this.array[e+1]=Eo(a),this.array[e+2]=Eo(c),this}setXYZW(e,n,a,c,h){return e*=this.itemSize,this.normalized&&(n=di(n,this.array),a=di(a,this.array),c=di(c,this.array),h=di(h,this.array)),this.array[e+0]=Eo(n),this.array[e+1]=Eo(a),this.array[e+2]=Eo(c),this.array[e+3]=Eo(h),this}}class Tn extends bs{constructor(e,n,a){super(new Float32Array(e),n,a)}}let Jce=0;const Tl=new Zn,LM=new Qi,I0=new be,Yo=new io,By=new io,Hr=new be;class gi extends xu{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Jce++}),this.uuid=Jo(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(lz(e)?ck:lk)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,n){return this.attributes[e]=n,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,n,a=0){this.groups.push({start:e,count:n,materialIndex:a})}clearGroups(){this.groups=[]}setDrawRange(e,n){this.drawRange.start=e,this.drawRange.count=n}applyMatrix4(e){const n=this.attributes.position;n!==void 0&&(n.applyMatrix4(e),n.needsUpdate=!0);const a=this.attributes.normal;if(a!==void 0){const h=new ii().getNormalMatrix(e);a.applyNormalMatrix(h),a.needsUpdate=!0}const c=this.attributes.tangent;return c!==void 0&&(c.transformDirection(e),c.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Tl.makeRotationFromQuaternion(e),this.applyMatrix4(Tl),this}rotateX(e){return Tl.makeRotationX(e),this.applyMatrix4(Tl),this}rotateY(e){return Tl.makeRotationY(e),this.applyMatrix4(Tl),this}rotateZ(e){return Tl.makeRotationZ(e),this.applyMatrix4(Tl),this}translate(e,n,a){return Tl.makeTranslation(e,n,a),this.applyMatrix4(Tl),this}scale(e,n,a){return Tl.makeScale(e,n,a),this.applyMatrix4(Tl),this}lookAt(e){return LM.lookAt(e),LM.updateMatrix(),this.applyMatrix4(LM.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(I0).negate(),this.translate(I0.x,I0.y,I0.z),this}setFromPoints(e){const n=this.getAttribute("position");if(n===void 0){const a=[];for(let c=0,h=e.length;c<h;c++){const p=e[c];a.push(p.x,p.y,p.z||0)}this.setAttribute("position",new Tn(a,3))}else{const a=Math.min(e.length,n.count);for(let c=0;c<a;c++){const h=e[c];n.setXYZ(c,h.x,h.y,h.z||0)}e.length>n.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),n.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new io);const e=this.attributes.position,n=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new be(-1/0,-1/0,-1/0),new be(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),n)for(let a=0,c=n.length;a<c;a++){const h=n[a];Yo.setFromBufferAttribute(h),this.morphTargetsRelative?(Hr.addVectors(this.boundingBox.min,Yo.min),this.boundingBox.expandByPoint(Hr),Hr.addVectors(this.boundingBox.max,Yo.max),this.boundingBox.expandByPoint(Hr)):(this.boundingBox.expandByPoint(Yo.min),this.boundingBox.expandByPoint(Yo.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new wa);const e=this.attributes.position,n=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new be,1/0);return}if(e){const a=this.boundingSphere.center;if(Yo.setFromBufferAttribute(e),n)for(let h=0,p=n.length;h<p;h++){const b=n[h];By.setFromBufferAttribute(b),this.morphTargetsRelative?(Hr.addVectors(Yo.min,By.min),Yo.expandByPoint(Hr),Hr.addVectors(Yo.max,By.max),Yo.expandByPoint(Hr)):(Yo.expandByPoint(By.min),Yo.expandByPoint(By.max))}Yo.getCenter(a);let c=0;for(let h=0,p=e.count;h<p;h++)Hr.fromBufferAttribute(e,h),c=Math.max(c,a.distanceToSquared(Hr));if(n)for(let h=0,p=n.length;h<p;h++){const b=n[h],y=this.morphTargetsRelative;for(let w=0,I=b.count;w<I;w++)Hr.fromBufferAttribute(b,w),y&&(I0.fromBufferAttribute(e,w),Hr.add(I0)),c=Math.max(c,a.distanceToSquared(Hr))}this.boundingSphere.radius=Math.sqrt(c),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,n=this.attributes;if(e===null||n.position===void 0||n.normal===void 0||n.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const a=n.position,c=n.normal,h=n.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new bs(new Float32Array(4*a.count),4));const p=this.getAttribute("tangent"),b=[],y=[];for(let re=0;re<a.count;re++)b[re]=new be,y[re]=new be;const w=new be,I=new be,E=new be,R=new Dt,k=new Dt,G=new Dt,N=new be,O=new be;function D(re,Y,ie){w.fromBufferAttribute(a,re),I.fromBufferAttribute(a,Y),E.fromBufferAttribute(a,ie),R.fromBufferAttribute(h,re),k.fromBufferAttribute(h,Y),G.fromBufferAttribute(h,ie),I.sub(w),E.sub(w),k.sub(R),G.sub(R);const ue=1/(k.x*G.y-G.x*k.y);isFinite(ue)&&(N.copy(I).multiplyScalar(G.y).addScaledVector(E,-k.y).multiplyScalar(ue),O.copy(E).multiplyScalar(k.x).addScaledVector(I,-G.x).multiplyScalar(ue),b[re].add(N),b[Y].add(N),b[ie].add(N),y[re].add(O),y[Y].add(O),y[ie].add(O))}let W=this.groups;W.length===0&&(W=[{start:0,count:e.count}]);for(let re=0,Y=W.length;re<Y;++re){const ie=W[re],ue=ie.start,Re=ie.count;for(let _e=ue,Pe=ue+Re;_e<Pe;_e+=3)D(e.getX(_e+0),e.getX(_e+1),e.getX(_e+2))}const H=new be,K=new be,j=new be,J=new be;function ee(re){j.fromBufferAttribute(c,re),J.copy(j);const Y=b[re];H.copy(Y),H.sub(j.multiplyScalar(j.dot(Y))).normalize(),K.crossVectors(J,Y);const ue=K.dot(y[re])<0?-1:1;p.setXYZW(re,H.x,H.y,H.z,ue)}for(let re=0,Y=W.length;re<Y;++re){const ie=W[re],ue=ie.start,Re=ie.count;for(let _e=ue,Pe=ue+Re;_e<Pe;_e+=3)ee(e.getX(_e+0)),ee(e.getX(_e+1)),ee(e.getX(_e+2))}}computeVertexNormals(){const e=this.index,n=this.getAttribute("position");if(n!==void 0){let a=this.getAttribute("normal");if(a===void 0)a=new bs(new Float32Array(n.count*3),3),this.setAttribute("normal",a);else for(let R=0,k=a.count;R<k;R++)a.setXYZ(R,0,0,0);const c=new be,h=new be,p=new be,b=new be,y=new be,w=new be,I=new be,E=new be;if(e)for(let R=0,k=e.count;R<k;R+=3){const G=e.getX(R+0),N=e.getX(R+1),O=e.getX(R+2);c.fromBufferAttribute(n,G),h.fromBufferAttribute(n,N),p.fromBufferAttribute(n,O),I.subVectors(p,h),E.subVectors(c,h),I.cross(E),b.fromBufferAttribute(a,G),y.fromBufferAttribute(a,N),w.fromBufferAttribute(a,O),b.add(I),y.add(I),w.add(I),a.setXYZ(G,b.x,b.y,b.z),a.setXYZ(N,y.x,y.y,y.z),a.setXYZ(O,w.x,w.y,w.z)}else for(let R=0,k=n.count;R<k;R+=3)c.fromBufferAttribute(n,R+0),h.fromBufferAttribute(n,R+1),p.fromBufferAttribute(n,R+2),I.subVectors(p,h),E.subVectors(c,h),I.cross(E),a.setXYZ(R+0,I.x,I.y,I.z),a.setXYZ(R+1,I.x,I.y,I.z),a.setXYZ(R+2,I.x,I.y,I.z);this.normalizeNormals(),a.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let n=0,a=e.count;n<a;n++)Hr.fromBufferAttribute(e,n),Hr.normalize(),e.setXYZ(n,Hr.x,Hr.y,Hr.z)}toNonIndexed(){function e(b,y){const w=b.array,I=b.itemSize,E=b.normalized,R=new w.constructor(y.length*I);let k=0,G=0;for(let N=0,O=y.length;N<O;N++){b.isInterleavedBufferAttribute?k=y[N]*b.data.stride+b.offset:k=y[N]*I;for(let D=0;D<I;D++)R[G++]=w[k++]}return new bs(R,I,E)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const n=new gi,a=this.index.array,c=this.attributes;for(const b in c){const y=c[b],w=e(y,a);n.setAttribute(b,w)}const h=this.morphAttributes;for(const b in h){const y=[],w=h[b];for(let I=0,E=w.length;I<E;I++){const R=w[I],k=e(R,a);y.push(k)}n.morphAttributes[b]=y}n.morphTargetsRelative=this.morphTargetsRelative;const p=this.groups;for(let b=0,y=p.length;b<y;b++){const w=p[b];n.addGroup(w.start,w.count,w.materialIndex)}return n}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const y=this.parameters;for(const w in y)y[w]!==void 0&&(e[w]=y[w]);return e}e.data={attributes:{}};const n=this.index;n!==null&&(e.data.index={type:n.array.constructor.name,array:Array.prototype.slice.call(n.array)});const a=this.attributes;for(const y in a){const w=a[y];e.data.attributes[y]=w.toJSON(e.data)}const c={};let h=!1;for(const y in this.morphAttributes){const w=this.morphAttributes[y],I=[];for(let E=0,R=w.length;E<R;E++){const k=w[E];I.push(k.toJSON(e.data))}I.length>0&&(c[y]=I,h=!0)}h&&(e.data.morphAttributes=c,e.data.morphTargetsRelative=this.morphTargetsRelative);const p=this.groups;p.length>0&&(e.data.groups=JSON.parse(JSON.stringify(p)));const b=this.boundingSphere;return b!==null&&(e.data.boundingSphere={center:b.center.toArray(),radius:b.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const n={};this.name=e.name;const a=e.index;a!==null&&this.setIndex(a.clone(n));const c=e.attributes;for(const w in c){const I=c[w];this.setAttribute(w,I.clone(n))}const h=e.morphAttributes;for(const w in h){const I=[],E=h[w];for(let R=0,k=E.length;R<k;R++)I.push(E[R].clone(n));this.morphAttributes[w]=I}this.morphTargetsRelative=e.morphTargetsRelative;const p=e.groups;for(let w=0,I=p.length;w<I;w++){const E=p[w];this.addGroup(E.start,E.count,E.materialIndex)}const b=e.boundingBox;b!==null&&(this.boundingBox=b.clone());const y=e.boundingSphere;return y!==null&&(this.boundingSphere=y.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const YF=new Zn,$p=new rA,Yw=new wa,jF=new be,jw=new be,qw=new be,Jw=new be,NM=new be,eC=new be,qF=new be,tC=new be;class Er extends Qi{constructor(e=new gi,n=new sf){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=n,this.updateMorphTargets()}copy(e,n){return super.copy(e,n),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const n=this.geometry.morphAttributes,a=Object.keys(n);if(a.length>0){const c=n[a[0]];if(c!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let h=0,p=c.length;h<p;h++){const b=c[h].name||String(h);this.morphTargetInfluences.push(0),this.morphTargetDictionary[b]=h}}}}getVertexPosition(e,n){const a=this.geometry,c=a.attributes.position,h=a.morphAttributes.position,p=a.morphTargetsRelative;n.fromBufferAttribute(c,e);const b=this.morphTargetInfluences;if(h&&b){eC.set(0,0,0);for(let y=0,w=h.length;y<w;y++){const I=b[y],E=h[y];I!==0&&(NM.fromBufferAttribute(E,e),p?eC.addScaledVector(NM,I):eC.addScaledVector(NM.sub(n),I))}n.add(eC)}return n}raycast(e,n){const a=this.geometry,c=this.material,h=this.matrixWorld;c!==void 0&&(a.boundingSphere===null&&a.computeBoundingSphere(),Yw.copy(a.boundingSphere),Yw.applyMatrix4(h),$p.copy(e.ray).recast(e.near),!(Yw.containsPoint($p.origin)===!1&&($p.intersectSphere(Yw,jF)===null||$p.origin.distanceToSquared(jF)>(e.far-e.near)**2))&&(YF.copy(h).invert(),$p.copy(e.ray).applyMatrix4(YF),!(a.boundingBox!==null&&$p.intersectsBox(a.boundingBox)===!1)&&this._computeIntersections(e,n,$p)))}_computeIntersections(e,n,a){let c;const h=this.geometry,p=this.material,b=h.index,y=h.attributes.position,w=h.attributes.uv,I=h.attributes.uv1,E=h.attributes.normal,R=h.groups,k=h.drawRange;if(b!==null)if(Array.isArray(p))for(let G=0,N=R.length;G<N;G++){const O=R[G],D=p[O.materialIndex],W=Math.max(O.start,k.start),H=Math.min(b.count,Math.min(O.start+O.count,k.start+k.count));for(let K=W,j=H;K<j;K+=3){const J=b.getX(K),ee=b.getX(K+1),re=b.getX(K+2);c=nC(this,D,e,a,w,I,E,J,ee,re),c&&(c.faceIndex=Math.floor(K/3),c.face.materialIndex=O.materialIndex,n.push(c))}}else{const G=Math.max(0,k.start),N=Math.min(b.count,k.start+k.count);for(let O=G,D=N;O<D;O+=3){const W=b.getX(O),H=b.getX(O+1),K=b.getX(O+2);c=nC(this,p,e,a,w,I,E,W,H,K),c&&(c.faceIndex=Math.floor(O/3),n.push(c))}}else if(y!==void 0)if(Array.isArray(p))for(let G=0,N=R.length;G<N;G++){const O=R[G],D=p[O.materialIndex],W=Math.max(O.start,k.start),H=Math.min(y.count,Math.min(O.start+O.count,k.start+k.count));for(let K=W,j=H;K<j;K+=3){const J=K,ee=K+1,re=K+2;c=nC(this,D,e,a,w,I,E,J,ee,re),c&&(c.faceIndex=Math.floor(K/3),c.face.materialIndex=O.materialIndex,n.push(c))}}else{const G=Math.max(0,k.start),N=Math.min(y.count,k.start+k.count);for(let O=G,D=N;O<D;O+=3){const W=O,H=O+1,K=O+2;c=nC(this,p,e,a,w,I,E,W,H,K),c&&(c.faceIndex=Math.floor(O/3),n.push(c))}}}}function eue(r,e,n,a,c,h,p,b){let y;if(e.side===no?y=a.intersectTriangle(p,h,c,!0,b):y=a.intersectTriangle(c,h,p,e.side===Mh,b),y===null)return null;tC.copy(b),tC.applyMatrix4(r.matrixWorld);const w=n.ray.origin.distanceTo(tC);return w<n.near||w>n.far?null:{distance:w,point:tC.clone(),object:r}}function nC(r,e,n,a,c,h,p,b,y,w){r.getVertexPosition(b,jw),r.getVertexPosition(y,qw),r.getVertexPosition(w,Jw);const I=eue(r,e,n,a,jw,qw,Jw,qF);if(I){const E=new be;To.getBarycoord(qF,jw,qw,Jw,E),c&&(I.uv=To.getInterpolatedAttribute(c,b,y,w,E,new Dt)),h&&(I.uv1=To.getInterpolatedAttribute(h,b,y,w,E,new Dt)),p&&(I.normal=To.getInterpolatedAttribute(p,b,y,w,E,new be),I.normal.dot(a.direction)>0&&I.normal.multiplyScalar(-1));const R={a:b,b:y,c:w,normal:new be,materialIndex:0};To.getNormal(jw,qw,Jw,R.normal),I.face=R,I.barycoord=E}return I}class Rm extends gi{constructor(e=1,n=1,a=1,c=1,h=1,p=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:n,depth:a,widthSegments:c,heightSegments:h,depthSegments:p};const b=this;c=Math.floor(c),h=Math.floor(h),p=Math.floor(p);const y=[],w=[],I=[],E=[];let R=0,k=0;G("z","y","x",-1,-1,a,n,e,p,h,0),G("z","y","x",1,-1,a,n,-e,p,h,1),G("x","z","y",1,1,e,a,n,c,p,2),G("x","z","y",1,-1,e,a,-n,c,p,3),G("x","y","z",1,-1,e,n,a,c,h,4),G("x","y","z",-1,-1,e,n,-a,c,h,5),this.setIndex(y),this.setAttribute("position",new Tn(w,3)),this.setAttribute("normal",new Tn(I,3)),this.setAttribute("uv",new Tn(E,2));function G(N,O,D,W,H,K,j,J,ee,re,Y){const ie=K/ee,ue=j/re,Re=K/2,_e=j/2,Pe=J/2,rt=ee+1,de=re+1;let we=0,Le=0;const Je=new be;for(let fe=0;fe<de;fe++){const Ve=fe*ue-_e;for(let Ne=0;Ne<rt;Ne++){const gt=Ne*ie-Re;Je[N]=gt*W,Je[O]=Ve*H,Je[D]=Pe,w.push(Je.x,Je.y,Je.z),Je[N]=0,Je[O]=0,Je[D]=J>0?1:-1,I.push(Je.x,Je.y,Je.z),E.push(Ne/ee),E.push(1-fe/re),we+=1}}for(let fe=0;fe<re;fe++)for(let Ve=0;Ve<ee;Ve++){const Ne=R+Ve+rt*fe,gt=R+Ve+rt*(fe+1),bt=R+(Ve+1)+rt*(fe+1),zt=R+(Ve+1)+rt*fe;y.push(Ne,gt,zt),y.push(gt,bt,zt),Le+=6}b.addGroup(k,Le,Y),k+=Le,R+=we}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Rm(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function eA(r){const e={};for(const n in r){e[n]={};for(const a in r[n]){const c=r[n][a];c&&(c.isColor||c.isMatrix3||c.isMatrix4||c.isVector2||c.isVector3||c.isVector4||c.isTexture||c.isQuaternion)?c.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[n][a]=null):e[n][a]=c.clone():Array.isArray(c)?e[n][a]=c.slice():e[n][a]=c}}return e}function Ya(r){const e={};for(let n=0;n<r.length;n++){const a=eA(r[n]);for(const c in a)e[c]=a[c]}return e}function tue(r){const e=[];for(let n=0;n<r.length;n++)e.push(r[n].clone());return e}function dz(r){const e=r.getRenderTarget();return e===null?r.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:zi.workingColorSpace}const fz={clone:eA,merge:Ya};var nue=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,iue=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class bc extends Ca{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=nue,this.fragmentShader=iue,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=eA(e.uniforms),this.uniformsGroups=tue(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const n=super.toJSON(e);n.glslVersion=this.glslVersion,n.uniforms={};for(const c in this.uniforms){const p=this.uniforms[c].value;p&&p.isTexture?n.uniforms[c]={type:"t",value:p.toJSON(e).uuid}:p&&p.isColor?n.uniforms[c]={type:"c",value:p.getHex()}:p&&p.isVector2?n.uniforms[c]={type:"v2",value:p.toArray()}:p&&p.isVector3?n.uniforms[c]={type:"v3",value:p.toArray()}:p&&p.isVector4?n.uniforms[c]={type:"v4",value:p.toArray()}:p&&p.isMatrix3?n.uniforms[c]={type:"m3",value:p.toArray()}:p&&p.isMatrix4?n.uniforms[c]={type:"m4",value:p.toArray()}:n.uniforms[c]={value:p}}Object.keys(this.defines).length>0&&(n.defines=this.defines),n.vertexShader=this.vertexShader,n.fragmentShader=this.fragmentShader,n.lights=this.lights,n.clipping=this.clipping;const a={};for(const c in this.extensions)this.extensions[c]===!0&&(a[c]=!0);return Object.keys(a).length>0&&(n.extensions=a),n}}class M2 extends Qi{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Zn,this.projectionMatrix=new Zn,this.projectionMatrixInverse=new Zn,this.coordinateSystem=gc}copy(e,n){return super.copy(e,n),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,n){super.updateWorldMatrix(e,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Pd=new be,JF=new Dt,eO=new Dt;class ea extends M2{constructor(e=50,n=1,a=.1,c=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=a,this.far=c,this.focus=10,this.aspect=n,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,n){return super.copy(e,n),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const n=.5*this.getFilmHeight()/e;this.fov=J0*2*Math.atan(n),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Cm*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return J0*2*Math.atan(Math.tan(Cm*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,n,a){Pd.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(Pd.x,Pd.y).multiplyScalar(-e/Pd.z),Pd.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),a.set(Pd.x,Pd.y).multiplyScalar(-e/Pd.z)}getViewSize(e,n){return this.getViewBounds(e,JF,eO),n.subVectors(eO,JF)}setViewOffset(e,n,a,c,h,p){this.aspect=e/n,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=n,this.view.offsetX=a,this.view.offsetY=c,this.view.width=h,this.view.height=p,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let n=e*Math.tan(Cm*.5*this.fov)/this.zoom,a=2*n,c=this.aspect*a,h=-.5*c;const p=this.view;if(this.view!==null&&this.view.enabled){const y=p.fullWidth,w=p.fullHeight;h+=p.offsetX*c/y,n-=p.offsetY*a/w,c*=p.width/y,a*=p.height/w}const b=this.filmOffset;b!==0&&(h+=e*b/this.getFilmWidth()),this.projectionMatrix.makePerspective(h,h+c,n,n-a,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const n=super.toJSON(e);return n.object.fov=this.fov,n.object.zoom=this.zoom,n.object.near=this.near,n.object.far=this.far,n.object.focus=this.focus,n.object.aspect=this.aspect,this.view!==null&&(n.object.view=Object.assign({},this.view)),n.object.filmGauge=this.filmGauge,n.object.filmOffset=this.filmOffset,n}}const T0=-90,M0=1;class pz extends Qi{constructor(e,n,a){super(),this.type="CubeCamera",this.renderTarget=a,this.coordinateSystem=null,this.activeMipmapLevel=0;const c=new ea(T0,M0,e,n);c.layers=this.layers,this.add(c);const h=new ea(T0,M0,e,n);h.layers=this.layers,this.add(h);const p=new ea(T0,M0,e,n);p.layers=this.layers,this.add(p);const b=new ea(T0,M0,e,n);b.layers=this.layers,this.add(b);const y=new ea(T0,M0,e,n);y.layers=this.layers,this.add(y);const w=new ea(T0,M0,e,n);w.layers=this.layers,this.add(w)}updateCoordinateSystem(){const e=this.coordinateSystem,n=this.children.concat(),[a,c,h,p,b,y]=n;for(const w of n)this.remove(w);if(e===gc)a.up.set(0,1,0),a.lookAt(1,0,0),c.up.set(0,1,0),c.lookAt(-1,0,0),h.up.set(0,0,-1),h.lookAt(0,1,0),p.up.set(0,0,1),p.lookAt(0,-1,0),b.up.set(0,1,0),b.lookAt(0,0,1),y.up.set(0,1,0),y.lookAt(0,0,-1);else if(e===wv)a.up.set(0,-1,0),a.lookAt(-1,0,0),c.up.set(0,-1,0),c.lookAt(1,0,0),h.up.set(0,0,1),h.lookAt(0,1,0),p.up.set(0,0,-1),p.lookAt(0,-1,0),b.up.set(0,-1,0),b.lookAt(0,0,1),y.up.set(0,-1,0),y.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const w of n)this.add(w),w.updateMatrixWorld()}update(e,n){this.parent===null&&this.updateMatrixWorld();const{renderTarget:a,activeMipmapLevel:c}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[h,p,b,y,w,I]=this.children,E=e.getRenderTarget(),R=e.getActiveCubeFace(),k=e.getActiveMipmapLevel(),G=e.xr.enabled;e.xr.enabled=!1;const N=a.texture.generateMipmaps;a.texture.generateMipmaps=!1,e.setRenderTarget(a,0,c),e.render(n,h),e.setRenderTarget(a,1,c),e.render(n,p),e.setRenderTarget(a,2,c),e.render(n,b),e.setRenderTarget(a,3,c),e.render(n,y),e.setRenderTarget(a,4,c),e.render(n,w),a.texture.generateMipmaps=N,e.setRenderTarget(a,5,c),e.render(n,I),e.setRenderTarget(E,R,k),e.xr.enabled=G,a.texture.needsPMREMUpdate=!0}}class Pv extends nr{constructor(e,n,a,c,h,p,b,y,w,I){e=e!==void 0?e:[],n=n!==void 0?n:_h,super(e,n,a,c,h,p,b,y,w,I),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class mz extends Ac{constructor(e=1,n={}){super(e,e,n),this.isWebGLCubeRenderTarget=!0;const a={width:e,height:e,depth:1},c=[a,a,a,a,a,a];this.texture=new Pv(c,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Dr}fromEquirectangularTexture(e,n){this.texture.type=n.type,this.texture.colorSpace=n.colorSpace,this.texture.generateMipmaps=n.generateMipmaps,this.texture.minFilter=n.minFilter,this.texture.magFilter=n.magFilter;const a={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},c=new Rm(5,5,5),h=new bc({name:"CubemapFromEquirect",uniforms:eA(a.uniforms),vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,side:no,blending:Ch});h.uniforms.tEquirect.value=n;const p=new Er(c,h),b=n.minFilter;return n.minFilter===gu&&(n.minFilter=Dr),new pz(1,10,this).update(e,p),n.minFilter=b,p.geometry.dispose(),p.material.dispose(),this}clear(e,n,a,c){const h=e.getRenderTarget();for(let p=0;p<6;p++)e.setRenderTarget(this,p),e.clear(n,a,c);e.setRenderTarget(h)}}class Q0 extends Qi{constructor(){super(),this.isGroup=!0,this.type="Group"}}const sue={type:"move"};class aE{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Q0,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Q0,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new be,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new be),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Q0,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new be,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new be),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const n=this._hand;if(n)for(const a of e.hand.values())this._getHandJoint(n,a)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,n,a){let c=null,h=null,p=null;const b=this._targetRay,y=this._grip,w=this._hand;if(e&&n.session.visibilityState!=="visible-blurred"){if(w&&e.hand){p=!0;for(const N of e.hand.values()){const O=n.getJointPose(N,a),D=this._getHandJoint(w,N);O!==null&&(D.matrix.fromArray(O.transform.matrix),D.matrix.decompose(D.position,D.rotation,D.scale),D.matrixWorldNeedsUpdate=!0,D.jointRadius=O.radius),D.visible=O!==null}const I=w.joints["index-finger-tip"],E=w.joints["thumb-tip"],R=I.position.distanceTo(E.position),k=.02,G=.005;w.inputState.pinching&&R>k+G?(w.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!w.inputState.pinching&&R<=k-G&&(w.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else y!==null&&e.gripSpace&&(h=n.getPose(e.gripSpace,a),h!==null&&(y.matrix.fromArray(h.transform.matrix),y.matrix.decompose(y.position,y.rotation,y.scale),y.matrixWorldNeedsUpdate=!0,h.linearVelocity?(y.hasLinearVelocity=!0,y.linearVelocity.copy(h.linearVelocity)):y.hasLinearVelocity=!1,h.angularVelocity?(y.hasAngularVelocity=!0,y.angularVelocity.copy(h.angularVelocity)):y.hasAngularVelocity=!1));b!==null&&(c=n.getPose(e.targetRaySpace,a),c===null&&h!==null&&(c=h),c!==null&&(b.matrix.fromArray(c.transform.matrix),b.matrix.decompose(b.position,b.rotation,b.scale),b.matrixWorldNeedsUpdate=!0,c.linearVelocity?(b.hasLinearVelocity=!0,b.linearVelocity.copy(c.linearVelocity)):b.hasLinearVelocity=!1,c.angularVelocity?(b.hasAngularVelocity=!0,b.angularVelocity.copy(c.angularVelocity)):b.hasAngularVelocity=!1,this.dispatchEvent(sue)))}return b!==null&&(b.visible=c!==null),y!==null&&(y.visible=h!==null),w!==null&&(w.visible=p!==null),this}_getHandJoint(e,n){if(e.joints[n.jointName]===void 0){const a=new Q0;a.matrixAutoUpdate=!1,a.visible=!1,e.joints[n.jointName]=a,e.add(a)}return e.joints[n.jointName]}}class _2{constructor(e,n=25e-5){this.isFogExp2=!0,this.name="",this.color=new pn(e),this.density=n}clone(){return new _2(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class R2{constructor(e,n=1,a=1e3){this.isFog=!0,this.name="",this.color=new pn(e),this.near=n,this.far=a}clone(){return new R2(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class gz extends Qi{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new el,this.environmentIntensity=1,this.environmentRotation=new el,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,n){return super.copy(e,n),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const n=super.toJSON(e);return this.fog!==null&&(n.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(n.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(n.object.backgroundIntensity=this.backgroundIntensity),n.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(n.object.environmentIntensity=this.environmentIntensity),n.object.environmentRotation=this.environmentRotation.toArray(),n}}class k2{constructor(e,n){this.isInterleavedBuffer=!0,this.array=e,this.stride=n,this.count=e!==void 0?e.length/n:0,this.usage=xv,this.updateRanges=[],this.version=0,this.uuid=Jo()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,n){this.updateRanges.push({start:e,count:n})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,n,a){e*=this.stride,a*=n.stride;for(let c=0,h=this.stride;c<h;c++)this.array[e+c]=n.array[a+c];return this}set(e,n=0){return this.array.set(e,n),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Jo()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const n=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),a=new this.constructor(n,this.stride);return a.setUsage(this.usage),a}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Jo()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Za=new be;class Mm{constructor(e,n,a,c=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=n,this.offset=a,this.normalized=c}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let n=0,a=this.data.count;n<a;n++)Za.fromBufferAttribute(this,n),Za.applyMatrix4(e),this.setXYZ(n,Za.x,Za.y,Za.z);return this}applyNormalMatrix(e){for(let n=0,a=this.count;n<a;n++)Za.fromBufferAttribute(this,n),Za.applyNormalMatrix(e),this.setXYZ(n,Za.x,Za.y,Za.z);return this}transformDirection(e){for(let n=0,a=this.count;n<a;n++)Za.fromBufferAttribute(this,n),Za.transformDirection(e),this.setXYZ(n,Za.x,Za.y,Za.z);return this}getComponent(e,n){let a=this.array[e*this.data.stride+this.offset+n];return this.normalized&&(a=Ja(a,this.array)),a}setComponent(e,n,a){return this.normalized&&(a=di(a,this.array)),this.data.array[e*this.data.stride+this.offset+n]=a,this}setX(e,n){return this.normalized&&(n=di(n,this.array)),this.data.array[e*this.data.stride+this.offset]=n,this}setY(e,n){return this.normalized&&(n=di(n,this.array)),this.data.array[e*this.data.stride+this.offset+1]=n,this}setZ(e,n){return this.normalized&&(n=di(n,this.array)),this.data.array[e*this.data.stride+this.offset+2]=n,this}setW(e,n){return this.normalized&&(n=di(n,this.array)),this.data.array[e*this.data.stride+this.offset+3]=n,this}getX(e){let n=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(n=Ja(n,this.array)),n}getY(e){let n=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(n=Ja(n,this.array)),n}getZ(e){let n=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(n=Ja(n,this.array)),n}getW(e){let n=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(n=Ja(n,this.array)),n}setXY(e,n,a){return e=e*this.data.stride+this.offset,this.normalized&&(n=di(n,this.array),a=di(a,this.array)),this.data.array[e+0]=n,this.data.array[e+1]=a,this}setXYZ(e,n,a,c){return e=e*this.data.stride+this.offset,this.normalized&&(n=di(n,this.array),a=di(a,this.array),c=di(c,this.array)),this.data.array[e+0]=n,this.data.array[e+1]=a,this.data.array[e+2]=c,this}setXYZW(e,n,a,c,h){return e=e*this.data.stride+this.offset,this.normalized&&(n=di(n,this.array),a=di(a,this.array),c=di(c,this.array),h=di(h,this.array)),this.data.array[e+0]=n,this.data.array[e+1]=a,this.data.array[e+2]=c,this.data.array[e+3]=h,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const n=[];for(let a=0;a<this.count;a++){const c=a*this.data.stride+this.offset;for(let h=0;h<this.itemSize;h++)n.push(this.data.array[c+h])}return new bs(new this.array.constructor(n),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Mm(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const n=[];for(let a=0;a<this.count;a++){const c=a*this.data.stride+this.offset;for(let h=0;h<this.itemSize;h++)n.push(this.data.array[c+h])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:n,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class uk extends Ca{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new pn(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let _0;const Ly=new be,R0=new be,k0=new be,B0=new Dt,Ny=new Dt,Az=new Zn,iC=new be,Dy=new be,sC=new be,tO=new Dt,DM=new Dt,nO=new Dt;class bz extends Qi{constructor(e=new uk){if(super(),this.isSprite=!0,this.type="Sprite",_0===void 0){_0=new gi;const n=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),a=new k2(n,5);_0.setIndex([0,1,2,0,2,3]),_0.setAttribute("position",new Mm(a,3,0,!1)),_0.setAttribute("uv",new Mm(a,2,3,!1))}this.geometry=_0,this.material=e,this.center=new Dt(.5,.5)}raycast(e,n){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),R0.setFromMatrixScale(this.matrixWorld),Az.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),k0.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&R0.multiplyScalar(-k0.z);const a=this.material.rotation;let c,h;a!==0&&(h=Math.cos(a),c=Math.sin(a));const p=this.center;rC(iC.set(-.5,-.5,0),k0,p,R0,c,h),rC(Dy.set(.5,-.5,0),k0,p,R0,c,h),rC(sC.set(.5,.5,0),k0,p,R0,c,h),tO.set(0,0),DM.set(1,0),nO.set(1,1);let b=e.ray.intersectTriangle(iC,Dy,sC,!1,Ly);if(b===null&&(rC(Dy.set(-.5,.5,0),k0,p,R0,c,h),DM.set(0,1),b=e.ray.intersectTriangle(iC,sC,Dy,!1,Ly),b===null))return;const y=e.ray.origin.distanceTo(Ly);y<e.near||y>e.far||n.push({distance:y,point:Ly.clone(),uv:To.getInterpolation(Ly,iC,Dy,sC,tO,DM,nO,new Dt),face:null,object:this})}copy(e,n){return super.copy(e,n),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function rC(r,e,n,a,c,h){B0.subVectors(r,n).addScalar(.5).multiply(a),c!==void 0?(Ny.x=h*B0.x-c*B0.y,Ny.y=c*B0.x+h*B0.y):Ny.copy(B0),r.copy(e),r.x+=Ny.x,r.y+=Ny.y,r.applyMatrix4(Az)}const aC=new be,iO=new be;class yz extends Qi{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const n=e.levels;for(let a=0,c=n.length;a<c;a++){const h=n[a];this.addLevel(h.object.clone(),h.distance,h.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,n=0,a=0){n=Math.abs(n);const c=this.levels;let h;for(h=0;h<c.length&&!(n<c[h].distance);h++);return c.splice(h,0,{distance:n,hysteresis:a,object:e}),this.add(e),this}removeLevel(e){const n=this.levels;for(let a=0;a<n.length;a++)if(n[a].distance===e){const c=n.splice(a,1);return this.remove(c[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const n=this.levels;if(n.length>0){let a,c;for(a=1,c=n.length;a<c;a++){let h=n[a].distance;if(n[a].object.visible&&(h-=h*n[a].hysteresis),e<h)break}return n[a-1].object}return null}raycast(e,n){if(this.levels.length>0){aC.setFromMatrixPosition(this.matrixWorld);const c=e.ray.origin.distanceTo(aC);this.getObjectForDistance(c).raycast(e,n)}}update(e){const n=this.levels;if(n.length>1){aC.setFromMatrixPosition(e.matrixWorld),iO.setFromMatrixPosition(this.matrixWorld);const a=aC.distanceTo(iO)/e.zoom;n[0].object.visible=!0;let c,h;for(c=1,h=n.length;c<h;c++){let p=n[c].distance;if(n[c].object.visible&&(p-=p*n[c].hysteresis),a>=p)n[c-1].object.visible=!1,n[c].object.visible=!0;else break}for(this._currentLevel=c-1;c<h;c++)n[c].object.visible=!1}}toJSON(e){const n=super.toJSON(e);this.autoUpdate===!1&&(n.object.autoUpdate=!1),n.object.levels=[];const a=this.levels;for(let c=0,h=a.length;c<h;c++){const p=a[c];n.object.levels.push({object:p.object.uuid,distance:p.distance,hysteresis:p.hysteresis})}return n}}const sO=new be,rO=new Xi,aO=new Xi,rue=new be,oO=new Zn,oC=new be,FM=new wa,lO=new Zn,OM=new rA;class vz extends Er{constructor(e,n){super(e,n),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=iR,this.bindMatrix=new Zn,this.bindMatrixInverse=new Zn,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new io),this.boundingBox.makeEmpty();const n=e.getAttribute("position");for(let a=0;a<n.count;a++)this.getVertexPosition(a,oC),this.boundingBox.expandByPoint(oC)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new wa),this.boundingSphere.makeEmpty();const n=e.getAttribute("position");for(let a=0;a<n.count;a++)this.getVertexPosition(a,oC),this.boundingSphere.expandByPoint(oC)}copy(e,n){return super.copy(e,n),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,n){const a=this.material,c=this.matrixWorld;a!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),FM.copy(this.boundingSphere),FM.applyMatrix4(c),e.ray.intersectsSphere(FM)!==!1&&(lO.copy(c).invert(),OM.copy(e.ray).applyMatrix4(lO),!(this.boundingBox!==null&&OM.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,n,OM)))}getVertexPosition(e,n){return super.getVertexPosition(e,n),this.applyBoneTransform(e,n),n}bind(e,n){this.skeleton=e,n===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),n=this.matrixWorld),this.bindMatrix.copy(n),this.bindMatrixInverse.copy(n).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Xi,n=this.geometry.attributes.skinWeight;for(let a=0,c=n.count;a<c;a++){e.fromBufferAttribute(n,a);const h=1/e.manhattanLength();h!==1/0?e.multiplyScalar(h):e.set(1,0,0,0),n.setXYZW(a,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===iR?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===ZP?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,n){const a=this.skeleton,c=this.geometry;rO.fromBufferAttribute(c.attributes.skinIndex,e),aO.fromBufferAttribute(c.attributes.skinWeight,e),sO.copy(n).applyMatrix4(this.bindMatrix),n.set(0,0,0);for(let h=0;h<4;h++){const p=aO.getComponent(h);if(p!==0){const b=rO.getComponent(h);oO.multiplyMatrices(a.bones[b].matrixWorld,a.boneInverses[b]),n.addScaledVector(rue.copy(sO).applyMatrix4(oO),p)}}return n.applyMatrix4(this.bindMatrixInverse)}}class hk extends Qi{constructor(){super(),this.isBone=!0,this.type="Bone"}}class bu extends nr{constructor(e=null,n=1,a=1,c,h,p,b,y,w=ia,I=ia,E,R){super(null,p,b,y,w,I,c,h,E,R),this.isDataTexture=!0,this.image={data:e,width:n,height:a},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const cO=new Zn,aue=new Zn;class B2{constructor(e=[],n=[]){this.uuid=Jo(),this.bones=e.slice(0),this.boneInverses=n,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,n=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),n.length===0)this.calculateInverses();else if(e.length!==n.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let a=0,c=this.bones.length;a<c;a++)this.boneInverses.push(new Zn)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,n=this.bones.length;e<n;e++){const a=new Zn;this.bones[e]&&a.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(a)}}pose(){for(let e=0,n=this.bones.length;e<n;e++){const a=this.bones[e];a&&a.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,n=this.bones.length;e<n;e++){const a=this.bones[e];a&&(a.parent&&a.parent.isBone?(a.matrix.copy(a.parent.matrixWorld).invert(),a.matrix.multiply(a.matrixWorld)):a.matrix.copy(a.matrixWorld),a.matrix.decompose(a.position,a.quaternion,a.scale))}}update(){const e=this.bones,n=this.boneInverses,a=this.boneMatrices,c=this.boneTexture;for(let h=0,p=e.length;h<p;h++){const b=e[h]?e[h].matrixWorld:aue;cO.multiplyMatrices(b,n[h]),cO.toArray(a,h*16)}c!==null&&(c.needsUpdate=!0)}clone(){return new B2(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const n=new Float32Array(e*e*4);n.set(this.boneMatrices);const a=new bu(n,e,e,to,qa);return a.needsUpdate=!0,this.boneMatrices=n,this.boneTexture=a,this}getBoneByName(e){for(let n=0,a=this.bones.length;n<a;n++){const c=this.bones[n];if(c.name===e)return c}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,n){this.uuid=e.uuid;for(let a=0,c=e.bones.length;a<c;a++){const h=e.bones[a];let p=n[h];p===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",h),p=new hk),this.bones.push(p),this.boneInverses.push(new Zn().fromArray(e.boneInverses[a]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const n=this.bones,a=this.boneInverses;for(let c=0,h=n.length;c<h;c++){const p=n[c];e.bones.push(p.uuid);const b=a[c];e.boneInverses.push(b.toArray())}return e}}class tA extends bs{constructor(e,n,a,c=1){super(e,n,a),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=c}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const L0=new Zn,uO=new Zn,lC=[],hO=new io,oue=new Zn,Fy=new Er,Oy=new wa;class xz extends Er{constructor(e,n,a){super(e,n),this.isInstancedMesh=!0,this.instanceMatrix=new tA(new Float32Array(a*16),16),this.instanceColor=null,this.morphTexture=null,this.count=a,this.boundingBox=null,this.boundingSphere=null;for(let c=0;c<a;c++)this.setMatrixAt(c,oue)}computeBoundingBox(){const e=this.geometry,n=this.count;this.boundingBox===null&&(this.boundingBox=new io),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let a=0;a<n;a++)this.getMatrixAt(a,L0),hO.copy(e.boundingBox).applyMatrix4(L0),this.boundingBox.union(hO)}computeBoundingSphere(){const e=this.geometry,n=this.count;this.boundingSphere===null&&(this.boundingSphere=new wa),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let a=0;a<n;a++)this.getMatrixAt(a,L0),Oy.copy(e.boundingSphere).applyMatrix4(L0),this.boundingSphere.union(Oy)}copy(e,n){return super.copy(e,n),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,n){n.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,n){n.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,n){const a=n.morphTargetInfluences,c=this.morphTexture.source.data.data,h=a.length+1,p=e*h+1;for(let b=0;b<a.length;b++)a[b]=c[p+b]}raycast(e,n){const a=this.matrixWorld,c=this.count;if(Fy.geometry=this.geometry,Fy.material=this.material,Fy.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Oy.copy(this.boundingSphere),Oy.applyMatrix4(a),e.ray.intersectsSphere(Oy)!==!1))for(let h=0;h<c;h++){this.getMatrixAt(h,L0),uO.multiplyMatrices(a,L0),Fy.matrixWorld=uO,Fy.raycast(e,lC);for(let p=0,b=lC.length;p<b;p++){const y=lC[p];y.instanceId=h,y.object=this,n.push(y)}lC.length=0}}setColorAt(e,n){this.instanceColor===null&&(this.instanceColor=new tA(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),n.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,n){n.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,n){const a=n.morphTargetInfluences,c=a.length+1;this.morphTexture===null&&(this.morphTexture=new bu(new Float32Array(c*this.count),c,this.count,x2,qa));const h=this.morphTexture.source.data.data;let p=0;for(let w=0;w<a.length;w++)p+=a[w];const b=this.geometry.morphTargetsRelative?1:1-p,y=c*e;h[y]=b,h.set(a,y+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}const GM=new be,lue=new be,cue=new ii;class Qd{constructor(e=new be(1,0,0),n=0){this.isPlane=!0,this.normal=e,this.constant=n}set(e,n){return this.normal.copy(e),this.constant=n,this}setComponents(e,n,a,c){return this.normal.set(e,n,a),this.constant=c,this}setFromNormalAndCoplanarPoint(e,n){return this.normal.copy(e),this.constant=-n.dot(this.normal),this}setFromCoplanarPoints(e,n,a){const c=GM.subVectors(a,n).cross(lue.subVectors(e,n)).normalize();return this.setFromNormalAndCoplanarPoint(c,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,n){return n.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,n){const a=e.delta(GM),c=this.normal.dot(a);if(c===0)return this.distanceToPoint(e.start)===0?n.copy(e.start):null;const h=-(e.start.dot(this.normal)+this.constant)/c;return h<0||h>1?null:n.copy(e.start).addScaledVector(a,h)}intersectsLine(e){const n=this.distanceToPoint(e.start),a=this.distanceToPoint(e.end);return n<0&&a>0||a<0&&n>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,n){const a=n||cue.getNormalMatrix(e),c=this.coplanarPoint(GM).applyMatrix4(e),h=this.normal.applyMatrix3(a).normalize();return this.constant=-c.dot(h),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Yp=new wa,cC=new be;class zv{constructor(e=new Qd,n=new Qd,a=new Qd,c=new Qd,h=new Qd,p=new Qd){this.planes=[e,n,a,c,h,p]}set(e,n,a,c,h,p){const b=this.planes;return b[0].copy(e),b[1].copy(n),b[2].copy(a),b[3].copy(c),b[4].copy(h),b[5].copy(p),this}copy(e){const n=this.planes;for(let a=0;a<6;a++)n[a].copy(e.planes[a]);return this}setFromProjectionMatrix(e,n=gc){const a=this.planes,c=e.elements,h=c[0],p=c[1],b=c[2],y=c[3],w=c[4],I=c[5],E=c[6],R=c[7],k=c[8],G=c[9],N=c[10],O=c[11],D=c[12],W=c[13],H=c[14],K=c[15];if(a[0].setComponents(y-h,R-w,O-k,K-D).normalize(),a[1].setComponents(y+h,R+w,O+k,K+D).normalize(),a[2].setComponents(y+p,R+I,O+G,K+W).normalize(),a[3].setComponents(y-p,R-I,O-G,K-W).normalize(),a[4].setComponents(y-b,R-E,O-N,K-H).normalize(),n===gc)a[5].setComponents(y+b,R+E,O+N,K+H).normalize();else if(n===wv)a[5].setComponents(b,E,N,H).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+n);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),Yp.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const n=e.geometry;n.boundingSphere===null&&n.computeBoundingSphere(),Yp.copy(n.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(Yp)}intersectsSprite(e){return Yp.center.set(0,0,0),Yp.radius=.7071067811865476,Yp.applyMatrix4(e.matrixWorld),this.intersectsSphere(Yp)}intersectsSphere(e){const n=this.planes,a=e.center,c=-e.radius;for(let h=0;h<6;h++)if(n[h].distanceToPoint(a)<c)return!1;return!0}intersectsBox(e){const n=this.planes;for(let a=0;a<6;a++){const c=n[a];if(cC.x=c.normal.x>0?e.max.x:e.min.x,cC.y=c.normal.y>0?e.max.y:e.min.y,cC.z=c.normal.z>0?e.max.z:e.min.z,c.distanceToPoint(cC)<0)return!1}return!0}containsPoint(e){const n=this.planes;for(let a=0;a<6;a++)if(n[a].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function UM(r,e){return r-e}function uue(r,e){return r.z-e.z}function hue(r,e){return e.z-r.z}class due{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,n,a,c){const h=this.pool,p=this.list;this.index>=h.length&&h.push({start:-1,count:-1,z:-1,index:-1});const b=h[this.index];p.push(b),this.index++,b.start=e,b.count=n,b.z=a,b.index=c}reset(){this.list.length=0,this.index=0}}const Co=new Zn,fue=new pn(1,1,1),PM=new zv,uC=new io,jp=new wa,Gy=new be,dO=new be,pue=new be,zM=new due,va=new Er,hC=[];function mue(r,e,n=0){const a=e.itemSize;if(r.isInterleavedBufferAttribute||r.array.constructor!==e.array.constructor){const c=r.count;for(let h=0;h<c;h++)for(let p=0;p<a;p++)e.setComponent(h+n,p,r.getComponent(h,p))}else e.array.set(r.array,n*a);e.needsUpdate=!0}function qp(r,e){if(r.constructor!==e.constructor){const n=Math.min(r.length,e.length);for(let a=0;a<n;a++)e[a]=r[a]}else{const n=Math.min(r.length,e.length);e.set(new r.constructor(r.buffer,0,n))}}class wz extends Er{get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}constructor(e,n,a=n*2,c){super(new gi,c),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=e,this._maxVertexCount=n,this._maxIndexCount=a,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}_initMatricesTexture(){let e=Math.sqrt(this._maxInstanceCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const n=new Float32Array(e*e*4),a=new bu(n,e,e,to,qa);this._matricesTexture=a}_initIndirectTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const n=new Uint32Array(e*e),a=new bu(n,e,e,Gv,Rh);this._indirectTexture=a}_initColorsTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const n=new Float32Array(e*e*4).fill(1),a=new bu(n,e,e,to,qa);a.colorSpace=zi.workingColorSpace,this._colorsTexture=a}_initializeGeometry(e){const n=this.geometry,a=this._maxVertexCount,c=this._maxIndexCount;if(this._geometryInitialized===!1){for(const h in e.attributes){const p=e.getAttribute(h),{array:b,itemSize:y,normalized:w}=p,I=new b.constructor(a*y),E=new bs(I,y,w);n.setAttribute(h,E)}if(e.getIndex()!==null){const h=a>65535?new Uint32Array(c):new Uint16Array(c);n.setIndex(new bs(h,1))}this._geometryInitialized=!0}}_validateGeometry(e){const n=this.geometry;if(!!e.getIndex()!=!!n.getIndex())throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const a in n.attributes){if(!e.hasAttribute(a))throw new Error(`THREE.BatchedMesh: Added geometry missing "${a}". All geometries must have consistent attributes.`);const c=e.getAttribute(a),h=n.getAttribute(a);if(c.itemSize!==h.itemSize||c.normalized!==h.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(e){const n=this._instanceInfo;if(e<0||e>=n.length||n[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)}validateGeometryId(e){const n=this._geometryInfo;if(e<0||e>=n.length||n[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new io);const e=this.boundingBox,n=this._instanceInfo;e.makeEmpty();for(let a=0,c=n.length;a<c;a++){if(n[a].active===!1)continue;const h=n[a].geometryIndex;this.getMatrixAt(a,Co),this.getBoundingBoxAt(h,uC).applyMatrix4(Co),e.union(uC)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new wa);const e=this.boundingSphere,n=this._instanceInfo;e.makeEmpty();for(let a=0,c=n.length;a<c;a++){if(n[a].active===!1)continue;const h=n[a].geometryIndex;this.getMatrixAt(a,Co),this.getBoundingSphereAt(h,jp).applyMatrix4(Co),e.union(jp)}}addInstance(e){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const a={visible:!0,active:!0,geometryIndex:e};let c=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(UM),c=this._availableInstanceIds.shift(),this._instanceInfo[c]=a):(c=this._instanceInfo.length,this._instanceInfo.push(a));const h=this._matricesTexture;Co.identity().toArray(h.image.data,c*16),h.needsUpdate=!0;const p=this._colorsTexture;return p&&(fue.toArray(p.image.data,c*4),p.needsUpdate=!0),this._visibilityChanged=!0,c}addGeometry(e,n=-1,a=-1){this._initializeGeometry(e),this._validateGeometry(e);const c={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},h=this._geometryInfo;c.vertexStart=this._nextVertexStart,c.reservedVertexCount=n===-1?e.getAttribute("position").count:n;const p=e.getIndex();if(p!==null&&(c.indexStart=this._nextIndexStart,c.reservedIndexCount=a===-1?p.count:a),c.indexStart!==-1&&c.indexStart+c.reservedIndexCount>this._maxIndexCount||c.vertexStart+c.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let y;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(UM),y=this._availableGeometryIds.shift(),h[y]=c):(y=this._geometryCount,this._geometryCount++,h.push(c)),this.setGeometryAt(y,e),this._nextIndexStart=c.indexStart+c.reservedIndexCount,this._nextVertexStart=c.vertexStart+c.reservedVertexCount,y}setGeometryAt(e,n){if(e>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(n);const a=this.geometry,c=a.getIndex()!==null,h=a.getIndex(),p=n.getIndex(),b=this._geometryInfo[e];if(c&&p.count>b.reservedIndexCount||n.attributes.position.count>b.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const y=b.vertexStart,w=b.reservedVertexCount;b.vertexCount=n.getAttribute("position").count;for(const I in a.attributes){const E=n.getAttribute(I),R=a.getAttribute(I);mue(E,R,y);const k=E.itemSize;for(let G=E.count,N=w;G<N;G++){const O=y+G;for(let D=0;D<k;D++)R.setComponent(O,D,0)}R.needsUpdate=!0,R.addUpdateRange(y*k,w*k)}if(c){const I=b.indexStart,E=b.reservedIndexCount;b.indexCount=n.getIndex().count;for(let R=0;R<p.count;R++)h.setX(I+R,y+p.getX(R));for(let R=p.count,k=E;R<k;R++)h.setX(I+R,y);h.needsUpdate=!0,h.addUpdateRange(I,b.reservedIndexCount)}return b.start=c?b.indexStart:b.vertexStart,b.count=c?b.indexCount:b.vertexCount,b.boundingBox=null,n.boundingBox!==null&&(b.boundingBox=n.boundingBox.clone()),b.boundingSphere=null,n.boundingSphere!==null&&(b.boundingSphere=n.boundingSphere.clone()),this._visibilityChanged=!0,e}deleteGeometry(e){const n=this._geometryInfo;if(e>=n.length||n[e].active===!1)return this;const a=this._instanceInfo;for(let c=0,h=a.length;c<h;c++)a[c].active&&a[c].geometryIndex===e&&this.deleteInstance(c);return n[e].active=!1,this._availableGeometryIds.push(e),this._visibilityChanged=!0,this}deleteInstance(e){return this.validateInstanceId(e),this._instanceInfo[e].active=!1,this._availableInstanceIds.push(e),this._visibilityChanged=!0,this}optimize(){let e=0,n=0;const a=this._geometryInfo,c=a.map((p,b)=>b).sort((p,b)=>a[p].vertexStart-a[b].vertexStart),h=this.geometry;for(let p=0,b=a.length;p<b;p++){const y=c[p],w=a[y];if(w.active!==!1){if(h.index!==null){if(w.indexStart!==n){const{indexStart:I,vertexStart:E,reservedIndexCount:R}=w,k=h.index,G=k.array,N=e-E;for(let O=I;O<I+R;O++)G[O]=G[O]+N;k.array.copyWithin(n,I,I+R),k.addUpdateRange(n,R),w.indexStart=n}n+=w.reservedIndexCount}if(w.vertexStart!==e){const{vertexStart:I,reservedVertexCount:E}=w,R=h.attributes;for(const k in R){const G=R[k],{array:N,itemSize:O}=G;N.copyWithin(e*O,I*O,(I+E)*O),G.addUpdateRange(e*O,E*O)}w.vertexStart=e}e+=w.reservedVertexCount,w.start=h.index?w.indexStart:w.vertexStart,this._nextIndexStart=h.index?w.indexStart+w.reservedIndexCount:0,this._nextVertexStart=w.vertexStart+w.reservedVertexCount}}return this}getBoundingBoxAt(e,n){if(e>=this._geometryCount)return null;const a=this.geometry,c=this._geometryInfo[e];if(c.boundingBox===null){const h=new io,p=a.index,b=a.attributes.position;for(let y=c.start,w=c.start+c.count;y<w;y++){let I=y;p&&(I=p.getX(I)),h.expandByPoint(Gy.fromBufferAttribute(b,I))}c.boundingBox=h}return n.copy(c.boundingBox),n}getBoundingSphereAt(e,n){if(e>=this._geometryCount)return null;const a=this.geometry,c=this._geometryInfo[e];if(c.boundingSphere===null){const h=new wa;this.getBoundingBoxAt(e,uC),uC.getCenter(h.center);const p=a.index,b=a.attributes.position;let y=0;for(let w=c.start,I=c.start+c.count;w<I;w++){let E=w;p&&(E=p.getX(E)),Gy.fromBufferAttribute(b,E),y=Math.max(y,h.center.distanceToSquared(Gy))}h.radius=Math.sqrt(y),c.boundingSphere=h}return n.copy(c.boundingSphere),n}setMatrixAt(e,n){this.validateInstanceId(e);const a=this._matricesTexture,c=this._matricesTexture.image.data;return n.toArray(c,e*16),a.needsUpdate=!0,this}getMatrixAt(e,n){return this.validateInstanceId(e),n.fromArray(this._matricesTexture.image.data,e*16)}setColorAt(e,n){return this.validateInstanceId(e),this._colorsTexture===null&&this._initColorsTexture(),n.toArray(this._colorsTexture.image.data,e*4),this._colorsTexture.needsUpdate=!0,this}getColorAt(e,n){return this.validateInstanceId(e),n.fromArray(this._colorsTexture.image.data,e*4)}setVisibleAt(e,n){return this.validateInstanceId(e),this._instanceInfo[e].visible===n?this:(this._instanceInfo[e].visible=n,this._visibilityChanged=!0,this)}getVisibleAt(e){return this.validateInstanceId(e),this._instanceInfo[e].visible}setGeometryIdAt(e,n){return this.validateInstanceId(e),this.validateGeometryId(n),this._instanceInfo[e].geometryIndex=n,this}getGeometryIdAt(e){return this.validateInstanceId(e),this._instanceInfo[e].geometryIndex}getGeometryRangeAt(e,n={}){this.validateGeometryId(e);const a=this._geometryInfo[e];return n.vertexStart=a.vertexStart,n.vertexCount=a.vertexCount,n.reservedVertexCount=a.reservedVertexCount,n.indexStart=a.indexStart,n.indexCount=a.indexCount,n.reservedIndexCount=a.reservedIndexCount,n.start=a.start,n.count=a.count,n}setInstanceCount(e){const n=this._availableInstanceIds,a=this._instanceInfo;for(n.sort(UM);n[n.length-1]===a.length;)a.pop(),n.pop();if(e<a.length)throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);const c=new Int32Array(e),h=new Int32Array(e);qp(this._multiDrawCounts,c),qp(this._multiDrawStarts,h),this._multiDrawCounts=c,this._multiDrawStarts=h,this._maxInstanceCount=e;const p=this._indirectTexture,b=this._matricesTexture,y=this._colorsTexture;p.dispose(),this._initIndirectTexture(),qp(p.image.data,this._indirectTexture.image.data),b.dispose(),this._initMatricesTexture(),qp(b.image.data,this._matricesTexture.image.data),y&&(y.dispose(),this._initColorsTexture(),qp(y.image.data,this._colorsTexture.image.data))}setGeometrySize(e,n){const a=[...this._geometryInfo].filter(b=>b.active);if(Math.max(...a.map(b=>b.vertexStart+b.reservedVertexCount))>e)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${n}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...a.map(y=>y.indexStart+y.reservedIndexCount))>n)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${n}. Cannot shrink further.`);const h=this.geometry;h.dispose(),this._maxVertexCount=e,this._maxIndexCount=n,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new gi,this._initializeGeometry(h));const p=this.geometry;h.index&&qp(h.index.array,p.index.array);for(const b in h.attributes)qp(h.attributes[b].array,p.attributes[b].array)}raycast(e,n){const a=this._instanceInfo,c=this._geometryInfo,h=this.matrixWorld,p=this.geometry;va.material=this.material,va.geometry.index=p.index,va.geometry.attributes=p.attributes,va.geometry.boundingBox===null&&(va.geometry.boundingBox=new io),va.geometry.boundingSphere===null&&(va.geometry.boundingSphere=new wa);for(let b=0,y=a.length;b<y;b++){if(!a[b].visible||!a[b].active)continue;const w=a[b].geometryIndex,I=c[w];va.geometry.setDrawRange(I.start,I.count),this.getMatrixAt(b,va.matrixWorld).premultiply(h),this.getBoundingBoxAt(w,va.geometry.boundingBox),this.getBoundingSphereAt(w,va.geometry.boundingSphere),va.raycast(e,hC);for(let E=0,R=hC.length;E<R;E++){const k=hC[E];k.object=this,k.batchId=b,n.push(k)}hC.length=0}va.material=null,va.geometry.index=null,va.geometry.attributes={},va.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._geometryInfo=e._geometryInfo.map(n=>({...n,boundingBox:n.boundingBox!==null?n.boundingBox.clone():null,boundingSphere:n.boundingSphere!==null?n.boundingSphere.clone():null})),this._instanceInfo=e._instanceInfo.map(n=>({...n})),this._maxInstanceCount=e._maxInstanceCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._geometryCount=e._geometryCount,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=e._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null),this}onBeforeRender(e,n,a,c,h){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const p=c.getIndex(),b=p===null?1:p.array.BYTES_PER_ELEMENT,y=this._instanceInfo,w=this._multiDrawStarts,I=this._multiDrawCounts,E=this._geometryInfo,R=this.perObjectFrustumCulled,k=this._indirectTexture,G=k.image.data;R&&(Co.multiplyMatrices(a.projectionMatrix,a.matrixWorldInverse).multiply(this.matrixWorld),PM.setFromProjectionMatrix(Co,e.coordinateSystem));let N=0;if(this.sortObjects){Co.copy(this.matrixWorld).invert(),Gy.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Co),dO.set(0,0,-1).transformDirection(a.matrixWorld).transformDirection(Co);for(let W=0,H=y.length;W<H;W++)if(y[W].visible&&y[W].active){const K=y[W].geometryIndex;this.getMatrixAt(W,Co),this.getBoundingSphereAt(K,jp).applyMatrix4(Co);let j=!1;if(R&&(j=!PM.intersectsSphere(jp)),!j){const J=E[K],ee=pue.subVectors(jp.center,Gy).dot(dO);zM.push(J.start,J.count,ee,W)}}const O=zM.list,D=this.customSort;D===null?O.sort(h.transparent?hue:uue):D.call(this,O,a);for(let W=0,H=O.length;W<H;W++){const K=O[W];w[N]=K.start*b,I[N]=K.count,G[N]=K.index,N++}zM.reset()}else for(let O=0,D=y.length;O<D;O++)if(y[O].visible&&y[O].active){const W=y[O].geometryIndex;let H=!1;if(R&&(this.getMatrixAt(O,Co),this.getBoundingSphereAt(W,jp).applyMatrix4(Co),H=!PM.intersectsSphere(jp)),!H){const K=E[W];w[N]=K.start*b,I[N]=K.count,G[N]=O,N++}}k.needsUpdate=!0,this._multiDrawCount=N,this._visibilityChanged=!1}onBeforeShadow(e,n,a,c,h,p){this.onBeforeRender(e,null,c,h,p)}}class so extends Ca{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new pn(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const jE=new be,qE=new be,fO=new Zn,Uy=new rA,dC=new wa,VM=new be,pO=new be;class Jd extends Qi{constructor(e=new gi,n=new so){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=n,this.updateMorphTargets()}copy(e,n){return super.copy(e,n),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const n=e.attributes.position,a=[0];for(let c=1,h=n.count;c<h;c++)jE.fromBufferAttribute(n,c-1),qE.fromBufferAttribute(n,c),a[c]=a[c-1],a[c]+=jE.distanceTo(qE);e.setAttribute("lineDistance",new Tn(a,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,n){const a=this.geometry,c=this.matrixWorld,h=e.params.Line.threshold,p=a.drawRange;if(a.boundingSphere===null&&a.computeBoundingSphere(),dC.copy(a.boundingSphere),dC.applyMatrix4(c),dC.radius+=h,e.ray.intersectsSphere(dC)===!1)return;fO.copy(c).invert(),Uy.copy(e.ray).applyMatrix4(fO);const b=h/((this.scale.x+this.scale.y+this.scale.z)/3),y=b*b,w=this.isLineSegments?2:1,I=a.index,R=a.attributes.position;if(I!==null){const k=Math.max(0,p.start),G=Math.min(I.count,p.start+p.count);for(let N=k,O=G-1;N<O;N+=w){const D=I.getX(N),W=I.getX(N+1),H=fC(this,e,Uy,y,D,W,N);H&&n.push(H)}if(this.isLineLoop){const N=I.getX(G-1),O=I.getX(k),D=fC(this,e,Uy,y,N,O,G-1);D&&n.push(D)}}else{const k=Math.max(0,p.start),G=Math.min(R.count,p.start+p.count);for(let N=k,O=G-1;N<O;N+=w){const D=fC(this,e,Uy,y,N,N+1,N);D&&n.push(D)}if(this.isLineLoop){const N=fC(this,e,Uy,y,G-1,k,G-1);N&&n.push(N)}}}updateMorphTargets(){const n=this.geometry.morphAttributes,a=Object.keys(n);if(a.length>0){const c=n[a[0]];if(c!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let h=0,p=c.length;h<p;h++){const b=c[h].name||String(h);this.morphTargetInfluences.push(0),this.morphTargetDictionary[b]=h}}}}}function fC(r,e,n,a,c,h,p){const b=r.geometry.attributes.position;if(jE.fromBufferAttribute(b,c),qE.fromBufferAttribute(b,h),n.distanceSqToSegment(jE,qE,VM,pO)>a)return;VM.applyMatrix4(r.matrixWorld);const w=e.ray.origin.distanceTo(VM);if(!(w<e.near||w>e.far))return{distance:w,point:pO.clone().applyMatrix4(r.matrixWorld),index:p,face:null,faceIndex:null,barycoord:null,object:r}}const mO=new be,gO=new be;class wu extends Jd{constructor(e,n){super(e,n),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const n=e.attributes.position,a=[];for(let c=0,h=n.count;c<h;c+=2)mO.fromBufferAttribute(n,c),gO.fromBufferAttribute(n,c+1),a[c]=c===0?0:a[c-1],a[c+1]=a[c]+mO.distanceTo(gO);e.setAttribute("lineDistance",new Tn(a,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Cz extends Jd{constructor(e,n){super(e,n),this.isLineLoop=!0,this.type="LineLoop"}}class dk extends Ca{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new pn(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const AO=new Zn,aR=new rA,pC=new wa,mC=new be;class Ez extends Qi{constructor(e=new gi,n=new dk){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=n,this.updateMorphTargets()}copy(e,n){return super.copy(e,n),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,n){const a=this.geometry,c=this.matrixWorld,h=e.params.Points.threshold,p=a.drawRange;if(a.boundingSphere===null&&a.computeBoundingSphere(),pC.copy(a.boundingSphere),pC.applyMatrix4(c),pC.radius+=h,e.ray.intersectsSphere(pC)===!1)return;AO.copy(c).invert(),aR.copy(e.ray).applyMatrix4(AO);const b=h/((this.scale.x+this.scale.y+this.scale.z)/3),y=b*b,w=a.index,E=a.attributes.position;if(w!==null){const R=Math.max(0,p.start),k=Math.min(w.count,p.start+p.count);for(let G=R,N=k;G<N;G++){const O=w.getX(G);mC.fromBufferAttribute(E,O),bO(mC,O,y,c,e,n,this)}}else{const R=Math.max(0,p.start),k=Math.min(E.count,p.start+p.count);for(let G=R,N=k;G<N;G++)mC.fromBufferAttribute(E,G),bO(mC,G,y,c,e,n,this)}}updateMorphTargets(){const n=this.geometry.morphAttributes,a=Object.keys(n);if(a.length>0){const c=n[a[0]];if(c!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let h=0,p=c.length;h<p;h++){const b=c[h].name||String(h);this.morphTargetInfluences.push(0),this.morphTargetDictionary[b]=h}}}}}function bO(r,e,n,a,c,h,p){const b=aR.distanceSqToPoint(r);if(b<n){const y=new be;aR.closestPointToPoint(r,y),y.applyMatrix4(a);const w=c.ray.origin.distanceTo(y);if(w<c.near||w>c.far)return;h.push({distance:w,distanceToRay:Math.sqrt(b),point:y,index:e,face:null,faceIndex:null,barycoord:null,object:p})}}class Sz extends nr{constructor(e,n,a,c,h,p,b,y,w){super(e,n,a,c,h,p,b,y,w),this.isVideoTexture=!0,this.minFilter=p!==void 0?p:Dr,this.magFilter=h!==void 0?h:Dr,this.generateMipmaps=!1;const I=this;function E(){I.needsUpdate=!0,e.requestVideoFrameCallback(E)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(E)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class gue extends Sz{constructor(e,n,a,c,h,p,b,y){super({},e,n,a,c,h,p,b,y),this.isVideoFrameTexture=!0}update(){}clone(){return new this.constructor().copy(this)}setFrame(e){this.image=e,this.needsUpdate=!0}}class Aue extends nr{constructor(e,n){super({width:e,height:n}),this.isFramebufferTexture=!0,this.magFilter=ia,this.minFilter=ia,this.generateMipmaps=!1,this.needsUpdate=!0}}class L2 extends nr{constructor(e,n,a,c,h,p,b,y,w,I,E,R){super(null,p,b,y,w,I,c,h,E,R),this.isCompressedTexture=!0,this.image={width:n,height:a},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class bue extends L2{constructor(e,n,a,c,h,p){super(e,n,a,h,p),this.isCompressedArrayTexture=!0,this.image.depth=c,this.wrapR=Rl,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class yue extends L2{constructor(e,n,a){super(void 0,e[0].width,e[0].height,n,a,_h),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class vue extends nr{constructor(e,n,a,c,h,p,b,y,w){super(e,n,a,c,h,p,b,y,w),this.isCanvasTexture=!0,this.needsUpdate=!0}}class fk extends nr{constructor(e,n,a,c,h,p,b,y,w,I=Yd){if(I!==Yd&&I!==jd)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");a===void 0&&I===Yd&&(a=Rh),a===void 0&&I===jd&&(a=$d),super(null,c,h,p,b,y,I,a,w),this.isDepthTexture=!0,this.image={width:e,height:n},this.magFilter=b!==void 0?b:ia,this.minFilter=y!==void 0?y:ia,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const n=super.toJSON(e);return this.compareFunction!==null&&(n.compareFunction=this.compareFunction),n}}class yc{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,n){const a=this.getUtoTmapping(e);return this.getPoint(a,n)}getPoints(e=5){const n=[];for(let a=0;a<=e;a++)n.push(this.getPoint(a/e));return n}getSpacedPoints(e=5){const n=[];for(let a=0;a<=e;a++)n.push(this.getPointAt(a/e));return n}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const n=[];let a,c=this.getPoint(0),h=0;n.push(0);for(let p=1;p<=e;p++)a=this.getPoint(p/e),h+=a.distanceTo(c),n.push(h),c=a;return this.cacheArcLengths=n,n}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,n){const a=this.getLengths();let c=0;const h=a.length;let p;n?p=n:p=e*a[h-1];let b=0,y=h-1,w;for(;b<=y;)if(c=Math.floor(b+(y-b)/2),w=a[c]-p,w<0)b=c+1;else if(w>0)y=c-1;else{y=c;break}if(c=y,a[c]===p)return c/(h-1);const I=a[c],R=a[c+1]-I,k=(p-I)/R;return(c+k)/(h-1)}getTangent(e,n){let c=e-1e-4,h=e+1e-4;c<0&&(c=0),h>1&&(h=1);const p=this.getPoint(c),b=this.getPoint(h),y=n||(p.isVector2?new Dt:new be);return y.copy(b).sub(p).normalize(),y}getTangentAt(e,n){const a=this.getUtoTmapping(e);return this.getTangent(a,n)}computeFrenetFrames(e,n){const a=new be,c=[],h=[],p=[],b=new be,y=new Zn;for(let k=0;k<=e;k++){const G=k/e;c[k]=this.getTangentAt(G,new be)}h[0]=new be,p[0]=new be;let w=Number.MAX_VALUE;const I=Math.abs(c[0].x),E=Math.abs(c[0].y),R=Math.abs(c[0].z);I<=w&&(w=I,a.set(1,0,0)),E<=w&&(w=E,a.set(0,1,0)),R<=w&&a.set(0,0,1),b.crossVectors(c[0],a).normalize(),h[0].crossVectors(c[0],b),p[0].crossVectors(c[0],h[0]);for(let k=1;k<=e;k++){if(h[k]=h[k-1].clone(),p[k]=p[k-1].clone(),b.crossVectors(c[k-1],c[k]),b.length()>Number.EPSILON){b.normalize();const G=Math.acos(si(c[k-1].dot(c[k]),-1,1));h[k].applyMatrix4(y.makeRotationAxis(b,G))}p[k].crossVectors(c[k],h[k])}if(n===!0){let k=Math.acos(si(h[0].dot(h[e]),-1,1));k/=e,c[0].dot(b.crossVectors(h[0],h[e]))>0&&(k=-k);for(let G=1;G<=e;G++)h[G].applyMatrix4(y.makeRotationAxis(c[G],k*G)),p[G].crossVectors(c[G],h[G])}return{tangents:c,normals:h,binormals:p}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class N2 extends yc{constructor(e=0,n=0,a=1,c=1,h=0,p=Math.PI*2,b=!1,y=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=n,this.xRadius=a,this.yRadius=c,this.aStartAngle=h,this.aEndAngle=p,this.aClockwise=b,this.aRotation=y}getPoint(e,n=new Dt){const a=n,c=Math.PI*2;let h=this.aEndAngle-this.aStartAngle;const p=Math.abs(h)<Number.EPSILON;for(;h<0;)h+=c;for(;h>c;)h-=c;h<Number.EPSILON&&(p?h=0:h=c),this.aClockwise===!0&&!p&&(h===c?h=-c:h=h-c);const b=this.aStartAngle+e*h;let y=this.aX+this.xRadius*Math.cos(b),w=this.aY+this.yRadius*Math.sin(b);if(this.aRotation!==0){const I=Math.cos(this.aRotation),E=Math.sin(this.aRotation),R=y-this.aX,k=w-this.aY;y=R*I-k*E+this.aX,w=R*E+k*I+this.aY}return a.set(y,w)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class Iz extends N2{constructor(e,n,a,c,h,p){super(e,n,a,a,c,h,p),this.isArcCurve=!0,this.type="ArcCurve"}}function pk(){let r=0,e=0,n=0,a=0;function c(h,p,b,y){r=h,e=b,n=-3*h+3*p-2*b-y,a=2*h-2*p+b+y}return{initCatmullRom:function(h,p,b,y,w){c(p,b,w*(b-h),w*(y-p))},initNonuniformCatmullRom:function(h,p,b,y,w,I,E){let R=(p-h)/w-(b-h)/(w+I)+(b-p)/I,k=(b-p)/I-(y-p)/(I+E)+(y-b)/E;R*=I,k*=I,c(p,b,R,k)},calc:function(h){const p=h*h,b=p*h;return r+e*h+n*p+a*b}}}const gC=new be,WM=new pk,HM=new pk,XM=new pk;class Tz extends yc{constructor(e=[],n=!1,a="centripetal",c=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=n,this.curveType=a,this.tension=c}getPoint(e,n=new be){const a=n,c=this.points,h=c.length,p=(h-(this.closed?0:1))*e;let b=Math.floor(p),y=p-b;this.closed?b+=b>0?0:(Math.floor(Math.abs(b)/h)+1)*h:y===0&&b===h-1&&(b=h-2,y=1);let w,I;this.closed||b>0?w=c[(b-1)%h]:(gC.subVectors(c[0],c[1]).add(c[0]),w=gC);const E=c[b%h],R=c[(b+1)%h];if(this.closed||b+2<h?I=c[(b+2)%h]:(gC.subVectors(c[h-1],c[h-2]).add(c[h-1]),I=gC),this.curveType==="centripetal"||this.curveType==="chordal"){const k=this.curveType==="chordal"?.5:.25;let G=Math.pow(w.distanceToSquared(E),k),N=Math.pow(E.distanceToSquared(R),k),O=Math.pow(R.distanceToSquared(I),k);N<1e-4&&(N=1),G<1e-4&&(G=N),O<1e-4&&(O=N),WM.initNonuniformCatmullRom(w.x,E.x,R.x,I.x,G,N,O),HM.initNonuniformCatmullRom(w.y,E.y,R.y,I.y,G,N,O),XM.initNonuniformCatmullRom(w.z,E.z,R.z,I.z,G,N,O)}else this.curveType==="catmullrom"&&(WM.initCatmullRom(w.x,E.x,R.x,I.x,this.tension),HM.initCatmullRom(w.y,E.y,R.y,I.y,this.tension),XM.initCatmullRom(w.z,E.z,R.z,I.z,this.tension));return a.set(WM.calc(y),HM.calc(y),XM.calc(y)),a}copy(e){super.copy(e),this.points=[];for(let n=0,a=e.points.length;n<a;n++){const c=e.points[n];this.points.push(c.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let n=0,a=this.points.length;n<a;n++){const c=this.points[n];e.points.push(c.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let n=0,a=e.points.length;n<a;n++){const c=e.points[n];this.points.push(new be().fromArray(c))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function yO(r,e,n,a,c){const h=(a-e)*.5,p=(c-n)*.5,b=r*r,y=r*b;return(2*n-2*a+h+p)*y+(-3*n+3*a-2*h-p)*b+h*r+n}function xue(r,e){const n=1-r;return n*n*e}function wue(r,e){return 2*(1-r)*r*e}function Cue(r,e){return r*r*e}function uv(r,e,n,a){return xue(r,e)+wue(r,n)+Cue(r,a)}function Eue(r,e){const n=1-r;return n*n*n*e}function Sue(r,e){const n=1-r;return 3*n*n*r*e}function Iue(r,e){return 3*(1-r)*r*r*e}function Tue(r,e){return r*r*r*e}function hv(r,e,n,a,c){return Eue(r,e)+Sue(r,n)+Iue(r,a)+Tue(r,c)}class mk extends yc{constructor(e=new Dt,n=new Dt,a=new Dt,c=new Dt){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=n,this.v2=a,this.v3=c}getPoint(e,n=new Dt){const a=n,c=this.v0,h=this.v1,p=this.v2,b=this.v3;return a.set(hv(e,c.x,h.x,p.x,b.x),hv(e,c.y,h.y,p.y,b.y)),a}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class Mz extends yc{constructor(e=new be,n=new be,a=new be,c=new be){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=n,this.v2=a,this.v3=c}getPoint(e,n=new be){const a=n,c=this.v0,h=this.v1,p=this.v2,b=this.v3;return a.set(hv(e,c.x,h.x,p.x,b.x),hv(e,c.y,h.y,p.y,b.y),hv(e,c.z,h.z,p.z,b.z)),a}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class gk extends yc{constructor(e=new Dt,n=new Dt){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=n}getPoint(e,n=new Dt){const a=n;return e===1?a.copy(this.v2):(a.copy(this.v2).sub(this.v1),a.multiplyScalar(e).add(this.v1)),a}getPointAt(e,n){return this.getPoint(e,n)}getTangent(e,n=new Dt){return n.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,n){return this.getTangent(e,n)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class _z extends yc{constructor(e=new be,n=new be){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=n}getPoint(e,n=new be){const a=n;return e===1?a.copy(this.v2):(a.copy(this.v2).sub(this.v1),a.multiplyScalar(e).add(this.v1)),a}getPointAt(e,n){return this.getPoint(e,n)}getTangent(e,n=new be){return n.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,n){return this.getTangent(e,n)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Ak extends yc{constructor(e=new Dt,n=new Dt,a=new Dt){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=n,this.v2=a}getPoint(e,n=new Dt){const a=n,c=this.v0,h=this.v1,p=this.v2;return a.set(uv(e,c.x,h.x,p.x),uv(e,c.y,h.y,p.y)),a}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class bk extends yc{constructor(e=new be,n=new be,a=new be){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=n,this.v2=a}getPoint(e,n=new be){const a=n,c=this.v0,h=this.v1,p=this.v2;return a.set(uv(e,c.x,h.x,p.x),uv(e,c.y,h.y,p.y),uv(e,c.z,h.z,p.z)),a}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class yk extends yc{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,n=new Dt){const a=n,c=this.points,h=(c.length-1)*e,p=Math.floor(h),b=h-p,y=c[p===0?p:p-1],w=c[p],I=c[p>c.length-2?c.length-1:p+1],E=c[p>c.length-3?c.length-1:p+2];return a.set(yO(b,y.x,w.x,I.x,E.x),yO(b,y.y,w.y,I.y,E.y)),a}copy(e){super.copy(e),this.points=[];for(let n=0,a=e.points.length;n<a;n++){const c=e.points[n];this.points.push(c.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let n=0,a=this.points.length;n<a;n++){const c=this.points[n];e.points.push(c.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let n=0,a=e.points.length;n<a;n++){const c=e.points[n];this.points.push(new Dt().fromArray(c))}return this}}var JE=Object.freeze({__proto__:null,ArcCurve:Iz,CatmullRomCurve3:Tz,CubicBezierCurve:mk,CubicBezierCurve3:Mz,EllipseCurve:N2,LineCurve:gk,LineCurve3:_z,QuadraticBezierCurve:Ak,QuadraticBezierCurve3:bk,SplineCurve:yk});class Rz extends yc{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),n=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(n)){const a=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new JE[a](n,e))}return this}getPoint(e,n){const a=e*this.getLength(),c=this.getCurveLengths();let h=0;for(;h<c.length;){if(c[h]>=a){const p=c[h]-a,b=this.curves[h],y=b.getLength(),w=y===0?0:1-p/y;return b.getPointAt(w,n)}h++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let n=0;for(let a=0,c=this.curves.length;a<c;a++)n+=this.curves[a].getLength(),e.push(n);return this.cacheLengths=e,e}getSpacedPoints(e=40){const n=[];for(let a=0;a<=e;a++)n.push(this.getPoint(a/e));return this.autoClose&&n.push(n[0]),n}getPoints(e=12){const n=[];let a;for(let c=0,h=this.curves;c<h.length;c++){const p=h[c],b=p.isEllipseCurve?e*2:p.isLineCurve||p.isLineCurve3?1:p.isSplineCurve?e*p.points.length:e,y=p.getPoints(b);for(let w=0;w<y.length;w++){const I=y[w];a&&a.equals(I)||(n.push(I),a=I)}}return this.autoClose&&n.length>1&&!n[n.length-1].equals(n[0])&&n.push(n[0]),n}copy(e){super.copy(e),this.curves=[];for(let n=0,a=e.curves.length;n<a;n++){const c=e.curves[n];this.curves.push(c.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let n=0,a=this.curves.length;n<a;n++){const c=this.curves[n];e.curves.push(c.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let n=0,a=e.curves.length;n<a;n++){const c=e.curves[n];this.curves.push(new JE[c.type]().fromJSON(c))}return this}}class Ev extends Rz{constructor(e){super(),this.type="Path",this.currentPoint=new Dt,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let n=1,a=e.length;n<a;n++)this.lineTo(e[n].x,e[n].y);return this}moveTo(e,n){return this.currentPoint.set(e,n),this}lineTo(e,n){const a=new gk(this.currentPoint.clone(),new Dt(e,n));return this.curves.push(a),this.currentPoint.set(e,n),this}quadraticCurveTo(e,n,a,c){const h=new Ak(this.currentPoint.clone(),new Dt(e,n),new Dt(a,c));return this.curves.push(h),this.currentPoint.set(a,c),this}bezierCurveTo(e,n,a,c,h,p){const b=new mk(this.currentPoint.clone(),new Dt(e,n),new Dt(a,c),new Dt(h,p));return this.curves.push(b),this.currentPoint.set(h,p),this}splineThru(e){const n=[this.currentPoint.clone()].concat(e),a=new yk(n);return this.curves.push(a),this.currentPoint.copy(e[e.length-1]),this}arc(e,n,a,c,h,p){const b=this.currentPoint.x,y=this.currentPoint.y;return this.absarc(e+b,n+y,a,c,h,p),this}absarc(e,n,a,c,h,p){return this.absellipse(e,n,a,a,c,h,p),this}ellipse(e,n,a,c,h,p,b,y){const w=this.currentPoint.x,I=this.currentPoint.y;return this.absellipse(e+w,n+I,a,c,h,p,b,y),this}absellipse(e,n,a,c,h,p,b,y){const w=new N2(e,n,a,c,h,p,b,y);if(this.curves.length>0){const E=w.getPoint(0);E.equals(this.currentPoint)||this.lineTo(E.x,E.y)}this.curves.push(w);const I=w.getPoint(1);return this.currentPoint.copy(I),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Vv extends gi{constructor(e=[new Dt(0,-.5),new Dt(.5,0),new Dt(0,.5)],n=12,a=0,c=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:n,phiStart:a,phiLength:c},n=Math.floor(n),c=si(c,0,Math.PI*2);const h=[],p=[],b=[],y=[],w=[],I=1/n,E=new be,R=new Dt,k=new be,G=new be,N=new be;let O=0,D=0;for(let W=0;W<=e.length-1;W++)switch(W){case 0:O=e[W+1].x-e[W].x,D=e[W+1].y-e[W].y,k.x=D*1,k.y=-O,k.z=D*0,N.copy(k),k.normalize(),y.push(k.x,k.y,k.z);break;case e.length-1:y.push(N.x,N.y,N.z);break;default:O=e[W+1].x-e[W].x,D=e[W+1].y-e[W].y,k.x=D*1,k.y=-O,k.z=D*0,G.copy(k),k.x+=N.x,k.y+=N.y,k.z+=N.z,k.normalize(),y.push(k.x,k.y,k.z),N.copy(G)}for(let W=0;W<=n;W++){const H=a+W*I*c,K=Math.sin(H),j=Math.cos(H);for(let J=0;J<=e.length-1;J++){E.x=e[J].x*K,E.y=e[J].y,E.z=e[J].x*j,p.push(E.x,E.y,E.z),R.x=W/n,R.y=J/(e.length-1),b.push(R.x,R.y);const ee=y[3*J+0]*K,re=y[3*J+1],Y=y[3*J+0]*j;w.push(ee,re,Y)}}for(let W=0;W<n;W++)for(let H=0;H<e.length-1;H++){const K=H+W*e.length,j=K,J=K+e.length,ee=K+e.length+1,re=K+1;h.push(j,J,re),h.push(ee,re,J)}this.setIndex(h),this.setAttribute("position",new Tn(p,3)),this.setAttribute("uv",new Tn(b,2)),this.setAttribute("normal",new Tn(w,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Vv(e.points,e.segments,e.phiStart,e.phiLength)}}class D2 extends Vv{constructor(e=1,n=1,a=4,c=8){const h=new Ev;h.absarc(0,-n/2,e,Math.PI*1.5,0),h.absarc(0,n/2,e,0,Math.PI*.5),super(h.getPoints(a),c),this.type="CapsuleGeometry",this.parameters={radius:e,length:n,capSegments:a,radialSegments:c}}static fromJSON(e){return new D2(e.radius,e.length,e.capSegments,e.radialSegments)}}class F2 extends gi{constructor(e=1,n=32,a=0,c=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:n,thetaStart:a,thetaLength:c},n=Math.max(3,n);const h=[],p=[],b=[],y=[],w=new be,I=new Dt;p.push(0,0,0),b.push(0,0,1),y.push(.5,.5);for(let E=0,R=3;E<=n;E++,R+=3){const k=a+E/n*c;w.x=e*Math.cos(k),w.y=e*Math.sin(k),p.push(w.x,w.y,w.z),b.push(0,0,1),I.x=(p[R]/e+1)/2,I.y=(p[R+1]/e+1)/2,y.push(I.x,I.y)}for(let E=1;E<=n;E++)h.push(E,E+1,0);this.setIndex(h),this.setAttribute("position",new Tn(p,3)),this.setAttribute("normal",new Tn(b,3)),this.setAttribute("uv",new Tn(y,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new F2(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class aA extends gi{constructor(e=1,n=1,a=1,c=32,h=1,p=!1,b=0,y=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:n,height:a,radialSegments:c,heightSegments:h,openEnded:p,thetaStart:b,thetaLength:y};const w=this;c=Math.floor(c),h=Math.floor(h);const I=[],E=[],R=[],k=[];let G=0;const N=[],O=a/2;let D=0;W(),p===!1&&(e>0&&H(!0),n>0&&H(!1)),this.setIndex(I),this.setAttribute("position",new Tn(E,3)),this.setAttribute("normal",new Tn(R,3)),this.setAttribute("uv",new Tn(k,2));function W(){const K=new be,j=new be;let J=0;const ee=(n-e)/a;for(let re=0;re<=h;re++){const Y=[],ie=re/h,ue=ie*(n-e)+e;for(let Re=0;Re<=c;Re++){const _e=Re/c,Pe=_e*y+b,rt=Math.sin(Pe),de=Math.cos(Pe);j.x=ue*rt,j.y=-ie*a+O,j.z=ue*de,E.push(j.x,j.y,j.z),K.set(rt,ee,de).normalize(),R.push(K.x,K.y,K.z),k.push(_e,1-ie),Y.push(G++)}N.push(Y)}for(let re=0;re<c;re++)for(let Y=0;Y<h;Y++){const ie=N[Y][re],ue=N[Y+1][re],Re=N[Y+1][re+1],_e=N[Y][re+1];(e>0||Y!==0)&&(I.push(ie,ue,_e),J+=3),(n>0||Y!==h-1)&&(I.push(ue,Re,_e),J+=3)}w.addGroup(D,J,0),D+=J}function H(K){const j=G,J=new Dt,ee=new be;let re=0;const Y=K===!0?e:n,ie=K===!0?1:-1;for(let Re=1;Re<=c;Re++)E.push(0,O*ie,0),R.push(0,ie,0),k.push(.5,.5),G++;const ue=G;for(let Re=0;Re<=c;Re++){const Pe=Re/c*y+b,rt=Math.cos(Pe),de=Math.sin(Pe);ee.x=Y*de,ee.y=O*ie,ee.z=Y*rt,E.push(ee.x,ee.y,ee.z),R.push(0,ie,0),J.x=rt*.5+.5,J.y=de*.5*ie+.5,k.push(J.x,J.y),G++}for(let Re=0;Re<c;Re++){const _e=j+Re,Pe=ue+Re;K===!0?I.push(Pe,Pe+1,_e):I.push(Pe+1,Pe,_e),re+=3}w.addGroup(D,re,K===!0?1:2),D+=re}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new aA(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class O2 extends aA{constructor(e=1,n=1,a=32,c=1,h=!1,p=0,b=Math.PI*2){super(0,e,n,a,c,h,p,b),this.type="ConeGeometry",this.parameters={radius:e,height:n,radialSegments:a,heightSegments:c,openEnded:h,thetaStart:p,thetaLength:b}}static fromJSON(e){return new O2(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class rf extends gi{constructor(e=[],n=[],a=1,c=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:n,radius:a,detail:c};const h=[],p=[];b(c),w(a),I(),this.setAttribute("position",new Tn(h,3)),this.setAttribute("normal",new Tn(h.slice(),3)),this.setAttribute("uv",new Tn(p,2)),c===0?this.computeVertexNormals():this.normalizeNormals();function b(W){const H=new be,K=new be,j=new be;for(let J=0;J<n.length;J+=3)k(n[J+0],H),k(n[J+1],K),k(n[J+2],j),y(H,K,j,W)}function y(W,H,K,j){const J=j+1,ee=[];for(let re=0;re<=J;re++){ee[re]=[];const Y=W.clone().lerp(K,re/J),ie=H.clone().lerp(K,re/J),ue=J-re;for(let Re=0;Re<=ue;Re++)Re===0&&re===J?ee[re][Re]=Y:ee[re][Re]=Y.clone().lerp(ie,Re/ue)}for(let re=0;re<J;re++)for(let Y=0;Y<2*(J-re)-1;Y++){const ie=Math.floor(Y/2);Y%2===0?(R(ee[re][ie+1]),R(ee[re+1][ie]),R(ee[re][ie])):(R(ee[re][ie+1]),R(ee[re+1][ie+1]),R(ee[re+1][ie]))}}function w(W){const H=new be;for(let K=0;K<h.length;K+=3)H.x=h[K+0],H.y=h[K+1],H.z=h[K+2],H.normalize().multiplyScalar(W),h[K+0]=H.x,h[K+1]=H.y,h[K+2]=H.z}function I(){const W=new be;for(let H=0;H<h.length;H+=3){W.x=h[H+0],W.y=h[H+1],W.z=h[H+2];const K=O(W)/2/Math.PI+.5,j=D(W)/Math.PI+.5;p.push(K,1-j)}G(),E()}function E(){for(let W=0;W<p.length;W+=6){const H=p[W+0],K=p[W+2],j=p[W+4],J=Math.max(H,K,j),ee=Math.min(H,K,j);J>.9&&ee<.1&&(H<.2&&(p[W+0]+=1),K<.2&&(p[W+2]+=1),j<.2&&(p[W+4]+=1))}}function R(W){h.push(W.x,W.y,W.z)}function k(W,H){const K=W*3;H.x=e[K+0],H.y=e[K+1],H.z=e[K+2]}function G(){const W=new be,H=new be,K=new be,j=new be,J=new Dt,ee=new Dt,re=new Dt;for(let Y=0,ie=0;Y<h.length;Y+=9,ie+=6){W.set(h[Y+0],h[Y+1],h[Y+2]),H.set(h[Y+3],h[Y+4],h[Y+5]),K.set(h[Y+6],h[Y+7],h[Y+8]),J.set(p[ie+0],p[ie+1]),ee.set(p[ie+2],p[ie+3]),re.set(p[ie+4],p[ie+5]),j.copy(W).add(H).add(K).divideScalar(3);const ue=O(j);N(J,ie+0,W,ue),N(ee,ie+2,H,ue),N(re,ie+4,K,ue)}}function N(W,H,K,j){j<0&&W.x===1&&(p[H]=W.x-1),K.x===0&&K.z===0&&(p[H]=j/2/Math.PI+.5)}function O(W){return Math.atan2(W.z,-W.x)}function D(W){return Math.atan2(-W.y,Math.sqrt(W.x*W.x+W.z*W.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new rf(e.vertices,e.indices,e.radius,e.details)}}class G2 extends rf{constructor(e=1,n=0){const a=(1+Math.sqrt(5))/2,c=1/a,h=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-c,-a,0,-c,a,0,c,-a,0,c,a,-c,-a,0,-c,a,0,c,-a,0,c,a,0,-a,0,-c,a,0,-c,-a,0,c,a,0,c],p=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(h,p,e,n),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new G2(e.radius,e.detail)}}const AC=new be,bC=new be,QM=new be,yC=new To;class kz extends gi{constructor(e=null,n=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:n},e!==null){const c=Math.pow(10,4),h=Math.cos(Cm*n),p=e.getIndex(),b=e.getAttribute("position"),y=p?p.count:b.count,w=[0,0,0],I=["a","b","c"],E=new Array(3),R={},k=[];for(let G=0;G<y;G+=3){p?(w[0]=p.getX(G),w[1]=p.getX(G+1),w[2]=p.getX(G+2)):(w[0]=G,w[1]=G+1,w[2]=G+2);const{a:N,b:O,c:D}=yC;if(N.fromBufferAttribute(b,w[0]),O.fromBufferAttribute(b,w[1]),D.fromBufferAttribute(b,w[2]),yC.getNormal(QM),E[0]=`${Math.round(N.x*c)},${Math.round(N.y*c)},${Math.round(N.z*c)}`,E[1]=`${Math.round(O.x*c)},${Math.round(O.y*c)},${Math.round(O.z*c)}`,E[2]=`${Math.round(D.x*c)},${Math.round(D.y*c)},${Math.round(D.z*c)}`,!(E[0]===E[1]||E[1]===E[2]||E[2]===E[0]))for(let W=0;W<3;W++){const H=(W+1)%3,K=E[W],j=E[H],J=yC[I[W]],ee=yC[I[H]],re=`${K}_${j}`,Y=`${j}_${K}`;Y in R&&R[Y]?(QM.dot(R[Y].normal)<=h&&(k.push(J.x,J.y,J.z),k.push(ee.x,ee.y,ee.z)),R[Y]=null):re in R||(R[re]={index0:w[W],index1:w[H],normal:QM.clone()})}}for(const G in R)if(R[G]){const{index0:N,index1:O}=R[G];AC.fromBufferAttribute(b,N),bC.fromBufferAttribute(b,O),k.push(AC.x,AC.y,AC.z),k.push(bC.x,bC.y,bC.z)}this.setAttribute("position",new Tn(k,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class Em extends Ev{constructor(e){super(e),this.uuid=Jo(),this.type="Shape",this.holes=[]}getPointsHoles(e){const n=[];for(let a=0,c=this.holes.length;a<c;a++)n[a]=this.holes[a].getPoints(e);return n}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let n=0,a=e.holes.length;n<a;n++){const c=e.holes[n];this.holes.push(c.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let n=0,a=this.holes.length;n<a;n++){const c=this.holes[n];e.holes.push(c.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let n=0,a=e.holes.length;n<a;n++){const c=e.holes[n];this.holes.push(new Ev().fromJSON(c))}return this}}const Mue={triangulate:function(r,e,n=2){const a=e&&e.length,c=a?e[0]*n:r.length;let h=Bz(r,0,c,n,!0);const p=[];if(!h||h.next===h.prev)return p;let b,y,w,I,E,R,k;if(a&&(h=Lue(r,e,h,n)),r.length>80*n){b=w=r[0],y=I=r[1];for(let G=n;G<c;G+=n)E=r[G],R=r[G+1],E<b&&(b=E),R<y&&(y=R),E>w&&(w=E),R>I&&(I=R);k=Math.max(w-b,I-y),k=k!==0?32767/k:0}return Sv(h,p,n,b,y,k,0),p}};function Bz(r,e,n,a,c){let h,p;if(c===Hue(r,e,n,a)>0)for(h=e;h<n;h+=a)p=vO(h,r[h],r[h+1],p);else for(h=n-a;h>=e;h-=a)p=vO(h,r[h],r[h+1],p);return p&&U2(p,p.next)&&(Tv(p),p=p.next),p}function _m(r,e){if(!r)return r;e||(e=r);let n=r,a;do if(a=!1,!n.steiner&&(U2(n,n.next)||Ys(n.prev,n,n.next)===0)){if(Tv(n),n=e=n.prev,n===n.next)break;a=!0}else n=n.next;while(a||n!==e);return e}function Sv(r,e,n,a,c,h,p){if(!r)return;!p&&h&&Gue(r,a,c,h);let b=r,y,w;for(;r.prev!==r.next;){if(y=r.prev,w=r.next,h?Rue(r,a,c,h):_ue(r)){e.push(y.i/n|0),e.push(r.i/n|0),e.push(w.i/n|0),Tv(r),r=w.next,b=w.next;continue}if(r=w,r===b){p?p===1?(r=kue(_m(r),e,n),Sv(r,e,n,a,c,h,2)):p===2&&Bue(r,e,n,a,c,h):Sv(_m(r),e,n,a,c,h,1);break}}}function _ue(r){const e=r.prev,n=r,a=r.next;if(Ys(e,n,a)>=0)return!1;const c=e.x,h=n.x,p=a.x,b=e.y,y=n.y,w=a.y,I=c<h?c<p?c:p:h<p?h:p,E=b<y?b<w?b:w:y<w?y:w,R=c>h?c>p?c:p:h>p?h:p,k=b>y?b>w?b:w:y>w?y:w;let G=a.next;for(;G!==e;){if(G.x>=I&&G.x<=R&&G.y>=E&&G.y<=k&&K0(c,b,h,y,p,w,G.x,G.y)&&Ys(G.prev,G,G.next)>=0)return!1;G=G.next}return!0}function Rue(r,e,n,a){const c=r.prev,h=r,p=r.next;if(Ys(c,h,p)>=0)return!1;const b=c.x,y=h.x,w=p.x,I=c.y,E=h.y,R=p.y,k=b<y?b<w?b:w:y<w?y:w,G=I<E?I<R?I:R:E<R?E:R,N=b>y?b>w?b:w:y>w?y:w,O=I>E?I>R?I:R:E>R?E:R,D=oR(k,G,e,n,a),W=oR(N,O,e,n,a);let H=r.prevZ,K=r.nextZ;for(;H&&H.z>=D&&K&&K.z<=W;){if(H.x>=k&&H.x<=N&&H.y>=G&&H.y<=O&&H!==c&&H!==p&&K0(b,I,y,E,w,R,H.x,H.y)&&Ys(H.prev,H,H.next)>=0||(H=H.prevZ,K.x>=k&&K.x<=N&&K.y>=G&&K.y<=O&&K!==c&&K!==p&&K0(b,I,y,E,w,R,K.x,K.y)&&Ys(K.prev,K,K.next)>=0))return!1;K=K.nextZ}for(;H&&H.z>=D;){if(H.x>=k&&H.x<=N&&H.y>=G&&H.y<=O&&H!==c&&H!==p&&K0(b,I,y,E,w,R,H.x,H.y)&&Ys(H.prev,H,H.next)>=0)return!1;H=H.prevZ}for(;K&&K.z<=W;){if(K.x>=k&&K.x<=N&&K.y>=G&&K.y<=O&&K!==c&&K!==p&&K0(b,I,y,E,w,R,K.x,K.y)&&Ys(K.prev,K,K.next)>=0)return!1;K=K.nextZ}return!0}function kue(r,e,n){let a=r;do{const c=a.prev,h=a.next.next;!U2(c,h)&&Lz(c,a,a.next,h)&&Iv(c,h)&&Iv(h,c)&&(e.push(c.i/n|0),e.push(a.i/n|0),e.push(h.i/n|0),Tv(a),Tv(a.next),a=r=h),a=a.next}while(a!==r);return _m(a)}function Bue(r,e,n,a,c,h){let p=r;do{let b=p.next.next;for(;b!==p.prev;){if(p.i!==b.i&&zue(p,b)){let y=Nz(p,b);p=_m(p,p.next),y=_m(y,y.next),Sv(p,e,n,a,c,h,0),Sv(y,e,n,a,c,h,0);return}b=b.next}p=p.next}while(p!==r)}function Lue(r,e,n,a){const c=[];let h,p,b,y,w;for(h=0,p=e.length;h<p;h++)b=e[h]*a,y=h<p-1?e[h+1]*a:r.length,w=Bz(r,b,y,a,!1),w===w.next&&(w.steiner=!0),c.push(Pue(w));for(c.sort(Nue),h=0;h<c.length;h++)n=Due(c[h],n);return n}function Nue(r,e){return r.x-e.x}function Due(r,e){const n=Fue(r,e);if(!n)return e;const a=Nz(n,r);return _m(a,a.next),_m(n,n.next)}function Fue(r,e){let n=e,a=-1/0,c;const h=r.x,p=r.y;do{if(p<=n.y&&p>=n.next.y&&n.next.y!==n.y){const R=n.x+(p-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(R<=h&&R>a&&(a=R,c=n.x<n.next.x?n:n.next,R===h))return c}n=n.next}while(n!==e);if(!c)return null;const b=c,y=c.x,w=c.y;let I=1/0,E;n=c;do h>=n.x&&n.x>=y&&h!==n.x&&K0(p<w?h:a,p,y,w,p<w?a:h,p,n.x,n.y)&&(E=Math.abs(p-n.y)/(h-n.x),Iv(n,r)&&(E<I||E===I&&(n.x>c.x||n.x===c.x&&Oue(c,n)))&&(c=n,I=E)),n=n.next;while(n!==b);return c}function Oue(r,e){return Ys(r.prev,r,e.prev)<0&&Ys(e.next,r,r.next)<0}function Gue(r,e,n,a){let c=r;do c.z===0&&(c.z=oR(c.x,c.y,e,n,a)),c.prevZ=c.prev,c.nextZ=c.next,c=c.next;while(c!==r);c.prevZ.nextZ=null,c.prevZ=null,Uue(c)}function Uue(r){let e,n,a,c,h,p,b,y,w=1;do{for(n=r,r=null,h=null,p=0;n;){for(p++,a=n,b=0,e=0;e<w&&(b++,a=a.nextZ,!!a);e++);for(y=w;b>0||y>0&&a;)b!==0&&(y===0||!a||n.z<=a.z)?(c=n,n=n.nextZ,b--):(c=a,a=a.nextZ,y--),h?h.nextZ=c:r=c,c.prevZ=h,h=c;n=a}h.nextZ=null,w*=2}while(p>1);return r}function oR(r,e,n,a,c){return r=(r-n)*c|0,e=(e-a)*c|0,r=(r|r<<8)&16711935,r=(r|r<<4)&252645135,r=(r|r<<2)&858993459,r=(r|r<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,r|e<<1}function Pue(r){let e=r,n=r;do(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next;while(e!==r);return n}function K0(r,e,n,a,c,h,p,b){return(c-p)*(e-b)>=(r-p)*(h-b)&&(r-p)*(a-b)>=(n-p)*(e-b)&&(n-p)*(h-b)>=(c-p)*(a-b)}function zue(r,e){return r.next.i!==e.i&&r.prev.i!==e.i&&!Vue(r,e)&&(Iv(r,e)&&Iv(e,r)&&Wue(r,e)&&(Ys(r.prev,r,e.prev)||Ys(r,e.prev,e))||U2(r,e)&&Ys(r.prev,r,r.next)>0&&Ys(e.prev,e,e.next)>0)}function Ys(r,e,n){return(e.y-r.y)*(n.x-e.x)-(e.x-r.x)*(n.y-e.y)}function U2(r,e){return r.x===e.x&&r.y===e.y}function Lz(r,e,n,a){const c=xC(Ys(r,e,n)),h=xC(Ys(r,e,a)),p=xC(Ys(n,a,r)),b=xC(Ys(n,a,e));return!!(c!==h&&p!==b||c===0&&vC(r,n,e)||h===0&&vC(r,a,e)||p===0&&vC(n,r,a)||b===0&&vC(n,e,a))}function vC(r,e,n){return e.x<=Math.max(r.x,n.x)&&e.x>=Math.min(r.x,n.x)&&e.y<=Math.max(r.y,n.y)&&e.y>=Math.min(r.y,n.y)}function xC(r){return r>0?1:r<0?-1:0}function Vue(r,e){let n=r;do{if(n.i!==r.i&&n.next.i!==r.i&&n.i!==e.i&&n.next.i!==e.i&&Lz(n,n.next,r,e))return!0;n=n.next}while(n!==r);return!1}function Iv(r,e){return Ys(r.prev,r,r.next)<0?Ys(r,e,r.next)>=0&&Ys(r,r.prev,e)>=0:Ys(r,e,r.prev)<0||Ys(r,r.next,e)<0}function Wue(r,e){let n=r,a=!1;const c=(r.x+e.x)/2,h=(r.y+e.y)/2;do n.y>h!=n.next.y>h&&n.next.y!==n.y&&c<(n.next.x-n.x)*(h-n.y)/(n.next.y-n.y)+n.x&&(a=!a),n=n.next;while(n!==r);return a}function Nz(r,e){const n=new lR(r.i,r.x,r.y),a=new lR(e.i,e.x,e.y),c=r.next,h=e.prev;return r.next=e,e.prev=r,n.next=c,c.prev=n,a.next=n,n.prev=a,h.next=a,a.prev=h,a}function vO(r,e,n,a){const c=new lR(r,e,n);return a?(c.next=a.next,c.prev=a,a.next.prev=c,a.next=c):(c.prev=c,c.next=c),c}function Tv(r){r.next.prev=r.prev,r.prev.next=r.next,r.prevZ&&(r.prevZ.nextZ=r.nextZ),r.nextZ&&(r.nextZ.prevZ=r.prevZ)}function lR(r,e,n){this.i=r,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Hue(r,e,n,a){let c=0;for(let h=e,p=n-a;h<n;h+=a)c+=(r[p]-r[h])*(r[h+1]+r[p+1]),p=h;return c}class yu{static area(e){const n=e.length;let a=0;for(let c=n-1,h=0;h<n;c=h++)a+=e[c].x*e[h].y-e[h].x*e[c].y;return a*.5}static isClockWise(e){return yu.area(e)<0}static triangulateShape(e,n){const a=[],c=[],h=[];xO(e),wO(a,e);let p=e.length;n.forEach(xO);for(let y=0;y<n.length;y++)c.push(p),p+=n[y].length,wO(a,n[y]);const b=Mue.triangulate(a,c);for(let y=0;y<b.length;y+=3)h.push(b.slice(y,y+3));return h}}function xO(r){const e=r.length;e>2&&r[e-1].equals(r[0])&&r.pop()}function wO(r,e){for(let n=0;n<e.length;n++)r.push(e[n].x),r.push(e[n].y)}class P2 extends gi{constructor(e=new Em([new Dt(.5,.5),new Dt(-.5,.5),new Dt(-.5,-.5),new Dt(.5,-.5)]),n={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:n},e=Array.isArray(e)?e:[e];const a=this,c=[],h=[];for(let b=0,y=e.length;b<y;b++){const w=e[b];p(w)}this.setAttribute("position",new Tn(c,3)),this.setAttribute("uv",new Tn(h,2)),this.computeVertexNormals();function p(b){const y=[],w=n.curveSegments!==void 0?n.curveSegments:12,I=n.steps!==void 0?n.steps:1,E=n.depth!==void 0?n.depth:1;let R=n.bevelEnabled!==void 0?n.bevelEnabled:!0,k=n.bevelThickness!==void 0?n.bevelThickness:.2,G=n.bevelSize!==void 0?n.bevelSize:k-.1,N=n.bevelOffset!==void 0?n.bevelOffset:0,O=n.bevelSegments!==void 0?n.bevelSegments:3;const D=n.extrudePath,W=n.UVGenerator!==void 0?n.UVGenerator:Xue;let H,K=!1,j,J,ee,re;D&&(H=D.getSpacedPoints(I),K=!0,R=!1,j=D.computeFrenetFrames(I,!1),J=new be,ee=new be,re=new be),R||(O=0,k=0,G=0,N=0);const Y=b.extractPoints(w);let ie=Y.shape;const ue=Y.holes;if(!yu.isClockWise(ie)){ie=ie.reverse();for(let vt=0,Mt=ue.length;vt<Mt;vt++){const Bt=ue[vt];yu.isClockWise(Bt)&&(ue[vt]=Bt.reverse())}}const _e=yu.triangulateShape(ie,ue),Pe=ie;for(let vt=0,Mt=ue.length;vt<Mt;vt++){const Bt=ue[vt];ie=ie.concat(Bt)}function rt(vt,Mt,Bt){return Mt||console.error("THREE.ExtrudeGeometry: vec does not exist"),vt.clone().addScaledVector(Mt,Bt)}const de=ie.length,we=_e.length;function Le(vt,Mt,Bt){let ve,Kt,Ee;const Q=vt.x-Mt.x,Z=vt.y-Mt.y,ae=Bt.x-vt.x,Ae=Bt.y-vt.y,Ie=Q*Q+Z*Z,Ze=Q*Ae-Z*ae;if(Math.abs(Ze)>Number.EPSILON){const At=Math.sqrt(Ie),dn=Math.sqrt(ae*ae+Ae*Ae),ge=Mt.x-Z/At,se=Mt.y+Q/At,Ge=Bt.x-Ae/dn,ut=Bt.y+ae/dn,kt=((Ge-ge)*Ae-(ut-se)*ae)/(Q*Ae-Z*ae);ve=ge+Q*kt-vt.x,Kt=se+Z*kt-vt.y;const xt=ve*ve+Kt*Kt;if(xt<=2)return new Dt(ve,Kt);Ee=Math.sqrt(xt/2)}else{let At=!1;Q>Number.EPSILON?ae>Number.EPSILON&&(At=!0):Q<-Number.EPSILON?ae<-Number.EPSILON&&(At=!0):Math.sign(Z)===Math.sign(Ae)&&(At=!0),At?(ve=-Z,Kt=Q,Ee=Math.sqrt(Ie)):(ve=Q,Kt=Z,Ee=Math.sqrt(Ie/2))}return new Dt(ve/Ee,Kt/Ee)}const Je=[];for(let vt=0,Mt=Pe.length,Bt=Mt-1,ve=vt+1;vt<Mt;vt++,Bt++,ve++)Bt===Mt&&(Bt=0),ve===Mt&&(ve=0),Je[vt]=Le(Pe[vt],Pe[Bt],Pe[ve]);const fe=[];let Ve,Ne=Je.concat();for(let vt=0,Mt=ue.length;vt<Mt;vt++){const Bt=ue[vt];Ve=[];for(let ve=0,Kt=Bt.length,Ee=Kt-1,Q=ve+1;ve<Kt;ve++,Ee++,Q++)Ee===Kt&&(Ee=0),Q===Kt&&(Q=0),Ve[ve]=Le(Bt[ve],Bt[Ee],Bt[Q]);fe.push(Ve),Ne=Ne.concat(Ve)}for(let vt=0;vt<O;vt++){const Mt=vt/O,Bt=k*Math.cos(Mt*Math.PI/2),ve=G*Math.sin(Mt*Math.PI/2)+N;for(let Kt=0,Ee=Pe.length;Kt<Ee;Kt++){const Q=rt(Pe[Kt],Je[Kt],ve);Vt(Q.x,Q.y,-Bt)}for(let Kt=0,Ee=ue.length;Kt<Ee;Kt++){const Q=ue[Kt];Ve=fe[Kt];for(let Z=0,ae=Q.length;Z<ae;Z++){const Ae=rt(Q[Z],Ve[Z],ve);Vt(Ae.x,Ae.y,-Bt)}}}const gt=G+N;for(let vt=0;vt<de;vt++){const Mt=R?rt(ie[vt],Ne[vt],gt):ie[vt];K?(ee.copy(j.normals[0]).multiplyScalar(Mt.x),J.copy(j.binormals[0]).multiplyScalar(Mt.y),re.copy(H[0]).add(ee).add(J),Vt(re.x,re.y,re.z)):Vt(Mt.x,Mt.y,0)}for(let vt=1;vt<=I;vt++)for(let Mt=0;Mt<de;Mt++){const Bt=R?rt(ie[Mt],Ne[Mt],gt):ie[Mt];K?(ee.copy(j.normals[vt]).multiplyScalar(Bt.x),J.copy(j.binormals[vt]).multiplyScalar(Bt.y),re.copy(H[vt]).add(ee).add(J),Vt(re.x,re.y,re.z)):Vt(Bt.x,Bt.y,E/I*vt)}for(let vt=O-1;vt>=0;vt--){const Mt=vt/O,Bt=k*Math.cos(Mt*Math.PI/2),ve=G*Math.sin(Mt*Math.PI/2)+N;for(let Kt=0,Ee=Pe.length;Kt<Ee;Kt++){const Q=rt(Pe[Kt],Je[Kt],ve);Vt(Q.x,Q.y,E+Bt)}for(let Kt=0,Ee=ue.length;Kt<Ee;Kt++){const Q=ue[Kt];Ve=fe[Kt];for(let Z=0,ae=Q.length;Z<ae;Z++){const Ae=rt(Q[Z],Ve[Z],ve);K?Vt(Ae.x,Ae.y+H[I-1].y,H[I-1].x+Bt):Vt(Ae.x,Ae.y,E+Bt)}}}bt(),zt();function bt(){const vt=c.length/3;if(R){let Mt=0,Bt=de*Mt;for(let ve=0;ve<we;ve++){const Kt=_e[ve];je(Kt[2]+Bt,Kt[1]+Bt,Kt[0]+Bt)}Mt=I+O*2,Bt=de*Mt;for(let ve=0;ve<we;ve++){const Kt=_e[ve];je(Kt[0]+Bt,Kt[1]+Bt,Kt[2]+Bt)}}else{for(let Mt=0;Mt<we;Mt++){const Bt=_e[Mt];je(Bt[2],Bt[1],Bt[0])}for(let Mt=0;Mt<we;Mt++){const Bt=_e[Mt];je(Bt[0]+de*I,Bt[1]+de*I,Bt[2]+de*I)}}a.addGroup(vt,c.length/3-vt,0)}function zt(){const vt=c.length/3;let Mt=0;Tt(Pe,Mt),Mt+=Pe.length;for(let Bt=0,ve=ue.length;Bt<ve;Bt++){const Kt=ue[Bt];Tt(Kt,Mt),Mt+=Kt.length}a.addGroup(vt,c.length/3-vt,1)}function Tt(vt,Mt){let Bt=vt.length;for(;--Bt>=0;){const ve=Bt;let Kt=Bt-1;Kt<0&&(Kt=vt.length-1);for(let Ee=0,Q=I+O*2;Ee<Q;Ee++){const Z=de*Ee,ae=de*(Ee+1),Ae=Mt+ve+Z,Ie=Mt+Kt+Z,Ze=Mt+Kt+ae,At=Mt+ve+ae;_t(Ae,Ie,Ze,At)}}}function Vt(vt,Mt,Bt){y.push(vt),y.push(Mt),y.push(Bt)}function je(vt,Mt,Bt){Ot(vt),Ot(Mt),Ot(Bt);const ve=c.length/3,Kt=W.generateTopUV(a,c,ve-3,ve-2,ve-1);on(Kt[0]),on(Kt[1]),on(Kt[2])}function _t(vt,Mt,Bt,ve){Ot(vt),Ot(Mt),Ot(ve),Ot(Mt),Ot(Bt),Ot(ve);const Kt=c.length/3,Ee=W.generateSideWallUV(a,c,Kt-6,Kt-3,Kt-2,Kt-1);on(Ee[0]),on(Ee[1]),on(Ee[3]),on(Ee[1]),on(Ee[2]),on(Ee[3])}function Ot(vt){c.push(y[vt*3+0]),c.push(y[vt*3+1]),c.push(y[vt*3+2])}function on(vt){h.push(vt.x),h.push(vt.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),n=this.parameters.shapes,a=this.parameters.options;return Que(n,a,e)}static fromJSON(e,n){const a=[];for(let h=0,p=e.shapes.length;h<p;h++){const b=n[e.shapes[h]];a.push(b)}const c=e.options.extrudePath;return c!==void 0&&(e.options.extrudePath=new JE[c.type]().fromJSON(c)),new P2(a,e.options)}}const Xue={generateTopUV:function(r,e,n,a,c){const h=e[n*3],p=e[n*3+1],b=e[a*3],y=e[a*3+1],w=e[c*3],I=e[c*3+1];return[new Dt(h,p),new Dt(b,y),new Dt(w,I)]},generateSideWallUV:function(r,e,n,a,c,h){const p=e[n*3],b=e[n*3+1],y=e[n*3+2],w=e[a*3],I=e[a*3+1],E=e[a*3+2],R=e[c*3],k=e[c*3+1],G=e[c*3+2],N=e[h*3],O=e[h*3+1],D=e[h*3+2];return Math.abs(b-I)<Math.abs(p-w)?[new Dt(p,1-y),new Dt(w,1-E),new Dt(R,1-G),new Dt(N,1-D)]:[new Dt(b,1-y),new Dt(I,1-E),new Dt(k,1-G),new Dt(O,1-D)]}};function Que(r,e,n){if(n.shapes=[],Array.isArray(r))for(let a=0,c=r.length;a<c;a++){const h=r[a];n.shapes.push(h.uuid)}else n.shapes.push(r.uuid);return n.options=Object.assign({},e),e.extrudePath!==void 0&&(n.options.extrudePath=e.extrudePath.toJSON()),n}class z2 extends rf{constructor(e=1,n=0){const a=(1+Math.sqrt(5))/2,c=[-1,a,0,1,a,0,-1,-a,0,1,-a,0,0,-1,a,0,1,a,0,-1,-a,0,1,-a,a,0,-1,a,0,1,-a,0,-1,-a,0,1],h=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(c,h,e,n),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new z2(e.radius,e.detail)}}class Wv extends rf{constructor(e=1,n=0){const a=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],c=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(a,c,e,n),this.type="OctahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new Wv(e.radius,e.detail)}}class oA extends gi{constructor(e=1,n=1,a=1,c=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:n,widthSegments:a,heightSegments:c};const h=e/2,p=n/2,b=Math.floor(a),y=Math.floor(c),w=b+1,I=y+1,E=e/b,R=n/y,k=[],G=[],N=[],O=[];for(let D=0;D<I;D++){const W=D*R-p;for(let H=0;H<w;H++){const K=H*E-h;G.push(K,-W,0),N.push(0,0,1),O.push(H/b),O.push(1-D/y)}}for(let D=0;D<y;D++)for(let W=0;W<b;W++){const H=W+w*D,K=W+w*(D+1),j=W+1+w*(D+1),J=W+1+w*D;k.push(H,K,J),k.push(K,j,J)}this.setIndex(k),this.setAttribute("position",new Tn(G,3)),this.setAttribute("normal",new Tn(N,3)),this.setAttribute("uv",new Tn(O,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new oA(e.width,e.height,e.widthSegments,e.heightSegments)}}class V2 extends gi{constructor(e=.5,n=1,a=32,c=1,h=0,p=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:n,thetaSegments:a,phiSegments:c,thetaStart:h,thetaLength:p},a=Math.max(3,a),c=Math.max(1,c);const b=[],y=[],w=[],I=[];let E=e;const R=(n-e)/c,k=new be,G=new Dt;for(let N=0;N<=c;N++){for(let O=0;O<=a;O++){const D=h+O/a*p;k.x=E*Math.cos(D),k.y=E*Math.sin(D),y.push(k.x,k.y,k.z),w.push(0,0,1),G.x=(k.x/n+1)/2,G.y=(k.y/n+1)/2,I.push(G.x,G.y)}E+=R}for(let N=0;N<c;N++){const O=N*(a+1);for(let D=0;D<a;D++){const W=D+O,H=W,K=W+a+1,j=W+a+2,J=W+1;b.push(H,K,J),b.push(K,j,J)}}this.setIndex(b),this.setAttribute("position",new Tn(y,3)),this.setAttribute("normal",new Tn(w,3)),this.setAttribute("uv",new Tn(I,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new V2(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class W2 extends gi{constructor(e=new Em([new Dt(0,.5),new Dt(-.5,-.5),new Dt(.5,-.5)]),n=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:n};const a=[],c=[],h=[],p=[];let b=0,y=0;if(Array.isArray(e)===!1)w(e);else for(let I=0;I<e.length;I++)w(e[I]),this.addGroup(b,y,I),b+=y,y=0;this.setIndex(a),this.setAttribute("position",new Tn(c,3)),this.setAttribute("normal",new Tn(h,3)),this.setAttribute("uv",new Tn(p,2));function w(I){const E=c.length/3,R=I.extractPoints(n);let k=R.shape;const G=R.holes;yu.isClockWise(k)===!1&&(k=k.reverse());for(let O=0,D=G.length;O<D;O++){const W=G[O];yu.isClockWise(W)===!0&&(G[O]=W.reverse())}const N=yu.triangulateShape(k,G);for(let O=0,D=G.length;O<D;O++){const W=G[O];k=k.concat(W)}for(let O=0,D=k.length;O<D;O++){const W=k[O];c.push(W.x,W.y,0),h.push(0,0,1),p.push(W.x,W.y)}for(let O=0,D=N.length;O<D;O++){const W=N[O],H=W[0]+E,K=W[1]+E,j=W[2]+E;a.push(H,K,j),y+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),n=this.parameters.shapes;return Kue(n,e)}static fromJSON(e,n){const a=[];for(let c=0,h=e.shapes.length;c<h;c++){const p=n[e.shapes[c]];a.push(p)}return new W2(a,e.curveSegments)}}function Kue(r,e){if(e.shapes=[],Array.isArray(r))for(let n=0,a=r.length;n<a;n++){const c=r[n];e.shapes.push(c.uuid)}else e.shapes.push(r.uuid);return e}class Hv extends gi{constructor(e=1,n=32,a=16,c=0,h=Math.PI*2,p=0,b=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:n,heightSegments:a,phiStart:c,phiLength:h,thetaStart:p,thetaLength:b},n=Math.max(3,Math.floor(n)),a=Math.max(2,Math.floor(a));const y=Math.min(p+b,Math.PI);let w=0;const I=[],E=new be,R=new be,k=[],G=[],N=[],O=[];for(let D=0;D<=a;D++){const W=[],H=D/a;let K=0;D===0&&p===0?K=.5/n:D===a&&y===Math.PI&&(K=-.5/n);for(let j=0;j<=n;j++){const J=j/n;E.x=-e*Math.cos(c+J*h)*Math.sin(p+H*b),E.y=e*Math.cos(p+H*b),E.z=e*Math.sin(c+J*h)*Math.sin(p+H*b),G.push(E.x,E.y,E.z),R.copy(E).normalize(),N.push(R.x,R.y,R.z),O.push(J+K,1-H),W.push(w++)}I.push(W)}for(let D=0;D<a;D++)for(let W=0;W<n;W++){const H=I[D][W+1],K=I[D][W],j=I[D+1][W],J=I[D+1][W+1];(D!==0||p>0)&&k.push(H,K,J),(D!==a-1||y<Math.PI)&&k.push(K,j,J)}this.setIndex(k),this.setAttribute("position",new Tn(G,3)),this.setAttribute("normal",new Tn(N,3)),this.setAttribute("uv",new Tn(O,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Hv(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class H2 extends rf{constructor(e=1,n=0){const a=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],c=[2,1,0,0,3,2,1,3,0,2,3,1];super(a,c,e,n),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new H2(e.radius,e.detail)}}class X2 extends gi{constructor(e=1,n=.4,a=12,c=48,h=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:n,radialSegments:a,tubularSegments:c,arc:h},a=Math.floor(a),c=Math.floor(c);const p=[],b=[],y=[],w=[],I=new be,E=new be,R=new be;for(let k=0;k<=a;k++)for(let G=0;G<=c;G++){const N=G/c*h,O=k/a*Math.PI*2;E.x=(e+n*Math.cos(O))*Math.cos(N),E.y=(e+n*Math.cos(O))*Math.sin(N),E.z=n*Math.sin(O),b.push(E.x,E.y,E.z),I.x=e*Math.cos(N),I.y=e*Math.sin(N),R.subVectors(E,I).normalize(),y.push(R.x,R.y,R.z),w.push(G/c),w.push(k/a)}for(let k=1;k<=a;k++)for(let G=1;G<=c;G++){const N=(c+1)*k+G-1,O=(c+1)*(k-1)+G-1,D=(c+1)*(k-1)+G,W=(c+1)*k+G;p.push(N,O,W),p.push(O,D,W)}this.setIndex(p),this.setAttribute("position",new Tn(b,3)),this.setAttribute("normal",new Tn(y,3)),this.setAttribute("uv",new Tn(w,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new X2(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class Q2 extends gi{constructor(e=1,n=.4,a=64,c=8,h=2,p=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:n,tubularSegments:a,radialSegments:c,p:h,q:p},a=Math.floor(a),c=Math.floor(c);const b=[],y=[],w=[],I=[],E=new be,R=new be,k=new be,G=new be,N=new be,O=new be,D=new be;for(let H=0;H<=a;++H){const K=H/a*h*Math.PI*2;W(K,h,p,e,k),W(K+.01,h,p,e,G),O.subVectors(G,k),D.addVectors(G,k),N.crossVectors(O,D),D.crossVectors(N,O),N.normalize(),D.normalize();for(let j=0;j<=c;++j){const J=j/c*Math.PI*2,ee=-n*Math.cos(J),re=n*Math.sin(J);E.x=k.x+(ee*D.x+re*N.x),E.y=k.y+(ee*D.y+re*N.y),E.z=k.z+(ee*D.z+re*N.z),y.push(E.x,E.y,E.z),R.subVectors(E,k).normalize(),w.push(R.x,R.y,R.z),I.push(H/a),I.push(j/c)}}for(let H=1;H<=a;H++)for(let K=1;K<=c;K++){const j=(c+1)*(H-1)+(K-1),J=(c+1)*H+(K-1),ee=(c+1)*H+K,re=(c+1)*(H-1)+K;b.push(j,J,re),b.push(J,ee,re)}this.setIndex(b),this.setAttribute("position",new Tn(y,3)),this.setAttribute("normal",new Tn(w,3)),this.setAttribute("uv",new Tn(I,2));function W(H,K,j,J,ee){const re=Math.cos(H),Y=Math.sin(H),ie=j/K*H,ue=Math.cos(ie);ee.x=J*(2+ue)*.5*re,ee.y=J*(2+ue)*Y*.5,ee.z=J*Math.sin(ie)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Q2(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class K2 extends gi{constructor(e=new bk(new be(-1,-1,0),new be(-1,1,0),new be(1,1,0)),n=64,a=1,c=8,h=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:n,radius:a,radialSegments:c,closed:h};const p=e.computeFrenetFrames(n,h);this.tangents=p.tangents,this.normals=p.normals,this.binormals=p.binormals;const b=new be,y=new be,w=new Dt;let I=new be;const E=[],R=[],k=[],G=[];N(),this.setIndex(G),this.setAttribute("position",new Tn(E,3)),this.setAttribute("normal",new Tn(R,3)),this.setAttribute("uv",new Tn(k,2));function N(){for(let H=0;H<n;H++)O(H);O(h===!1?n:0),W(),D()}function O(H){I=e.getPointAt(H/n,I);const K=p.normals[H],j=p.binormals[H];for(let J=0;J<=c;J++){const ee=J/c*Math.PI*2,re=Math.sin(ee),Y=-Math.cos(ee);y.x=Y*K.x+re*j.x,y.y=Y*K.y+re*j.y,y.z=Y*K.z+re*j.z,y.normalize(),R.push(y.x,y.y,y.z),b.x=I.x+a*y.x,b.y=I.y+a*y.y,b.z=I.z+a*y.z,E.push(b.x,b.y,b.z)}}function D(){for(let H=1;H<=n;H++)for(let K=1;K<=c;K++){const j=(c+1)*(H-1)+(K-1),J=(c+1)*H+(K-1),ee=(c+1)*H+K,re=(c+1)*(H-1)+K;G.push(j,J,re),G.push(J,ee,re)}}function W(){for(let H=0;H<=n;H++)for(let K=0;K<=c;K++)w.x=H/n,w.y=K/c,k.push(w.x,w.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new K2(new JE[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class Dz extends gi{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const n=[],a=new Set,c=new be,h=new be;if(e.index!==null){const p=e.attributes.position,b=e.index;let y=e.groups;y.length===0&&(y=[{start:0,count:b.count,materialIndex:0}]);for(let w=0,I=y.length;w<I;++w){const E=y[w],R=E.start,k=E.count;for(let G=R,N=R+k;G<N;G+=3)for(let O=0;O<3;O++){const D=b.getX(G+O),W=b.getX(G+(O+1)%3);c.fromBufferAttribute(p,D),h.fromBufferAttribute(p,W),CO(c,h,a)===!0&&(n.push(c.x,c.y,c.z),n.push(h.x,h.y,h.z))}}}else{const p=e.attributes.position;for(let b=0,y=p.count/3;b<y;b++)for(let w=0;w<3;w++){const I=3*b+w,E=3*b+(w+1)%3;c.fromBufferAttribute(p,I),h.fromBufferAttribute(p,E),CO(c,h,a)===!0&&(n.push(c.x,c.y,c.z),n.push(h.x,h.y,h.z))}}this.setAttribute("position",new Tn(n,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function CO(r,e,n){const a=`${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`,c=`${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;return n.has(a)===!0||n.has(c)===!0?!1:(n.add(a),n.add(c),!0)}var EO=Object.freeze({__proto__:null,BoxGeometry:Rm,CapsuleGeometry:D2,CircleGeometry:F2,ConeGeometry:O2,CylinderGeometry:aA,DodecahedronGeometry:G2,EdgesGeometry:kz,ExtrudeGeometry:P2,IcosahedronGeometry:z2,LatheGeometry:Vv,OctahedronGeometry:Wv,PlaneGeometry:oA,PolyhedronGeometry:rf,RingGeometry:V2,ShapeGeometry:W2,SphereGeometry:Hv,TetrahedronGeometry:H2,TorusGeometry:X2,TorusKnotGeometry:Q2,TubeGeometry:K2,WireframeGeometry:Dz});class Fz extends Ca{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new pn(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class Oz extends bc{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class vk extends Ca{constructor(e){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new pn(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new pn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=nf,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new el,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Gz extends vk{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Dt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return si(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(n){this.ior=(1+.4*n)/(1-.4*n)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new pn(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new pn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new pn(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class Uz extends Ca{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new pn(16777215),this.specular=new pn(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new pn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=nf,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new el,this.combine=Ov,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Pz extends Ca{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new pn(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new pn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=nf,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class zz extends Ca{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=nf,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class Vz extends Ca{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new pn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new pn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=nf,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new el,this.combine=Ov,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class xk extends Ca{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=qP,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class wk extends Ca{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}class Wz extends Ca{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new pn(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=nf,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Hz extends so{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function xm(r,e,n){return!r||!n&&r.constructor===e?r:typeof e.BYTES_PER_ELEMENT=="number"?new e(r):Array.prototype.slice.call(r)}function Xz(r){return ArrayBuffer.isView(r)&&!(r instanceof DataView)}function Qz(r){function e(c,h){return r[c]-r[h]}const n=r.length,a=new Array(n);for(let c=0;c!==n;++c)a[c]=c;return a.sort(e),a}function cR(r,e,n){const a=r.length,c=new r.constructor(a);for(let h=0,p=0;p!==a;++h){const b=n[h]*e;for(let y=0;y!==e;++y)c[p++]=r[b+y]}return c}function Ck(r,e,n,a){let c=1,h=r[0];for(;h!==void 0&&h[a]===void 0;)h=r[c++];if(h===void 0)return;let p=h[a];if(p!==void 0)if(Array.isArray(p))do p=h[a],p!==void 0&&(e.push(h.time),n.push.apply(n,p)),h=r[c++];while(h!==void 0);else if(p.toArray!==void 0)do p=h[a],p!==void 0&&(e.push(h.time),p.toArray(n,n.length)),h=r[c++];while(h!==void 0);else do p=h[a],p!==void 0&&(e.push(h.time),n.push(p)),h=r[c++];while(h!==void 0)}function Zue(r,e,n,a,c=30){const h=r.clone();h.name=e;const p=[];for(let y=0;y<h.tracks.length;++y){const w=h.tracks[y],I=w.getValueSize(),E=[],R=[];for(let k=0;k<w.times.length;++k){const G=w.times[k]*c;if(!(G<n||G>=a)){E.push(w.times[k]);for(let N=0;N<I;++N)R.push(w.values[k*I+N])}}E.length!==0&&(w.times=xm(E,w.times.constructor),w.values=xm(R,w.values.constructor),p.push(w))}h.tracks=p;let b=1/0;for(let y=0;y<h.tracks.length;++y)b>h.tracks[y].times[0]&&(b=h.tracks[y].times[0]);for(let y=0;y<h.tracks.length;++y)h.tracks[y].shift(-1*b);return h.resetDuration(),h}function $ue(r,e=0,n=r,a=30){a<=0&&(a=30);const c=n.tracks.length,h=e/a;for(let p=0;p<c;++p){const b=n.tracks[p],y=b.ValueTypeName;if(y==="bool"||y==="string")continue;const w=r.tracks.find(function(D){return D.name===b.name&&D.ValueTypeName===y});if(w===void 0)continue;let I=0;const E=b.getValueSize();b.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(I=E/3);let R=0;const k=w.getValueSize();w.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(R=k/3);const G=b.times.length-1;let N;if(h<=b.times[0]){const D=I,W=E-I;N=b.values.slice(D,W)}else if(h>=b.times[G]){const D=G*E+I,W=D+E-I;N=b.values.slice(D,W)}else{const D=b.createInterpolant(),W=I,H=E-I;D.evaluate(h),N=D.resultBuffer.slice(W,H)}y==="quaternion"&&new _o().fromArray(N).normalize().conjugate().toArray(N);const O=w.times.length;for(let D=0;D<O;++D){const W=D*k+R;if(y==="quaternion")_o.multiplyQuaternionsFlat(w.values,W,N,0,w.values,W);else{const H=k-R*2;for(let K=0;K<H;++K)w.values[W+K]-=N[K]}}}return r.blendMode=rk,r}const Yue={convertArray:xm,isTypedArray:Xz,getKeyframeOrder:Qz,sortedArray:cR,flattenJSON:Ck,subclip:Zue,makeClipAdditive:$ue};class Xv{constructor(e,n,a,c){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=c!==void 0?c:new n.constructor(a),this.sampleValues=n,this.valueSize=a,this.settings=null,this.DefaultSettings_={}}evaluate(e){const n=this.parameterPositions;let a=this._cachedIndex,c=n[a],h=n[a-1];e:{t:{let p;n:{i:if(!(e<c)){for(let b=a+2;;){if(c===void 0){if(e<h)break i;return a=n.length,this._cachedIndex=a,this.copySampleValue_(a-1)}if(a===b)break;if(h=c,c=n[++a],e<c)break t}p=n.length;break n}if(!(e>=h)){const b=n[1];e<b&&(a=2,h=b);for(let y=a-2;;){if(h===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(a===y)break;if(c=h,h=n[--a-1],e>=h)break t}p=a,a=0;break n}break e}for(;a<p;){const b=a+p>>>1;e<n[b]?p=b:a=b+1}if(c=n[a],h=n[a-1],h===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(c===void 0)return a=n.length,this._cachedIndex=a,this.copySampleValue_(a-1)}this._cachedIndex=a,this.intervalChanged_(a,h,c)}return this.interpolate_(a,h,e,c)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const n=this.resultBuffer,a=this.sampleValues,c=this.valueSize,h=e*c;for(let p=0;p!==c;++p)n[p]=a[h+p];return n}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Kz extends Xv{constructor(e,n,a,c){super(e,n,a,c),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:bm,endingEnd:bm}}intervalChanged_(e,n,a){const c=this.parameterPositions;let h=e-2,p=e+1,b=c[h],y=c[p];if(b===void 0)switch(this.getSettings_().endingStart){case ym:h=e,b=2*n-a;break;case yv:h=c.length-2,b=n+c[h]-c[h+1];break;default:h=e,b=a}if(y===void 0)switch(this.getSettings_().endingEnd){case ym:p=e,y=2*a-n;break;case yv:p=1,y=a+c[1]-c[0];break;default:p=e-1,y=n}const w=(a-n)*.5,I=this.valueSize;this._weightPrev=w/(n-b),this._weightNext=w/(y-a),this._offsetPrev=h*I,this._offsetNext=p*I}interpolate_(e,n,a,c){const h=this.resultBuffer,p=this.sampleValues,b=this.valueSize,y=e*b,w=y-b,I=this._offsetPrev,E=this._offsetNext,R=this._weightPrev,k=this._weightNext,G=(a-n)/(c-n),N=G*G,O=N*G,D=-R*O+2*R*N-R*G,W=(1+R)*O+(-1.5-2*R)*N+(-.5+R)*G+1,H=(-1-k)*O+(1.5+k)*N+.5*G,K=k*O-k*N;for(let j=0;j!==b;++j)h[j]=D*p[I+j]+W*p[w+j]+H*p[y+j]+K*p[E+j];return h}}class Ek extends Xv{constructor(e,n,a,c){super(e,n,a,c)}interpolate_(e,n,a,c){const h=this.resultBuffer,p=this.sampleValues,b=this.valueSize,y=e*b,w=y-b,I=(a-n)/(c-n),E=1-I;for(let R=0;R!==b;++R)h[R]=p[w+R]*E+p[y+R]*I;return h}}class Zz extends Xv{constructor(e,n,a,c){super(e,n,a,c)}interpolate_(e){return this.copySampleValue_(e-1)}}class vc{constructor(e,n,a,c){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(n===void 0||n.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=xm(n,this.TimeBufferType),this.values=xm(a,this.ValueBufferType),this.setInterpolation(c||this.DefaultInterpolation)}static toJSON(e){const n=e.constructor;let a;if(n.toJSON!==this.toJSON)a=n.toJSON(e);else{a={name:e.name,times:xm(e.times,Array),values:xm(e.values,Array)};const c=e.getInterpolation();c!==e.DefaultInterpolation&&(a.interpolation=c)}return a.type=e.ValueTypeName,a}InterpolantFactoryMethodDiscrete(e){return new Zz(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new Ek(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new Kz(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let n;switch(e){case bv:n=this.InterpolantFactoryMethodDiscrete;break;case YE:n=this.InterpolantFactoryMethodLinear;break;case rE:n=this.InterpolantFactoryMethodSmooth;break}if(n===void 0){const a="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(a);return console.warn("THREE.KeyframeTrack:",a),this}return this.createInterpolant=n,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return bv;case this.InterpolantFactoryMethodLinear:return YE;case this.InterpolantFactoryMethodSmooth:return rE}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const n=this.times;for(let a=0,c=n.length;a!==c;++a)n[a]+=e}return this}scale(e){if(e!==1){const n=this.times;for(let a=0,c=n.length;a!==c;++a)n[a]*=e}return this}trim(e,n){const a=this.times,c=a.length;let h=0,p=c-1;for(;h!==c&&a[h]<e;)++h;for(;p!==-1&&a[p]>n;)--p;if(++p,h!==0||p!==c){h>=p&&(p=Math.max(p,1),h=p-1);const b=this.getValueSize();this.times=a.slice(h,p),this.values=this.values.slice(h*b,p*b)}return this}validate(){let e=!0;const n=this.getValueSize();n-Math.floor(n)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const a=this.times,c=this.values,h=a.length;h===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let p=null;for(let b=0;b!==h;b++){const y=a[b];if(typeof y=="number"&&isNaN(y)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,b,y),e=!1;break}if(p!==null&&p>y){console.error("THREE.KeyframeTrack: Out of order keys.",this,b,y,p),e=!1;break}p=y}if(c!==void 0&&Xz(c))for(let b=0,y=c.length;b!==y;++b){const w=c[b];if(isNaN(w)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,b,w),e=!1;break}}return e}optimize(){const e=this.times.slice(),n=this.values.slice(),a=this.getValueSize(),c=this.getInterpolation()===rE,h=e.length-1;let p=1;for(let b=1;b<h;++b){let y=!1;const w=e[b],I=e[b+1];if(w!==I&&(b!==1||w!==e[0]))if(c)y=!0;else{const E=b*a,R=E-a,k=E+a;for(let G=0;G!==a;++G){const N=n[E+G];if(N!==n[R+G]||N!==n[k+G]){y=!0;break}}}if(y){if(b!==p){e[p]=e[b];const E=b*a,R=p*a;for(let k=0;k!==a;++k)n[R+k]=n[E+k]}++p}}if(h>0){e[p]=e[h];for(let b=h*a,y=p*a,w=0;w!==a;++w)n[y+w]=n[b+w];++p}return p!==e.length?(this.times=e.slice(0,p),this.values=n.slice(0,p*a)):(this.times=e,this.values=n),this}clone(){const e=this.times.slice(),n=this.values.slice(),a=this.constructor,c=new a(this.name,e,n);return c.createInterpolant=this.createInterpolant,c}}vc.prototype.TimeBufferType=Float32Array;vc.prototype.ValueBufferType=Float32Array;vc.prototype.DefaultInterpolation=YE;class km extends vc{constructor(e,n,a){super(e,n,a)}}km.prototype.ValueTypeName="bool";km.prototype.ValueBufferType=Array;km.prototype.DefaultInterpolation=bv;km.prototype.InterpolantFactoryMethodLinear=void 0;km.prototype.InterpolantFactoryMethodSmooth=void 0;class Sk extends vc{}Sk.prototype.ValueTypeName="color";class Mv extends vc{}Mv.prototype.ValueTypeName="number";class $z extends Xv{constructor(e,n,a,c){super(e,n,a,c)}interpolate_(e,n,a,c){const h=this.resultBuffer,p=this.sampleValues,b=this.valueSize,y=(a-n)/(c-n);let w=e*b;for(let I=w+b;w!==I;w+=4)_o.slerpFlat(h,0,p,w-b,p,w,y);return h}}class Qv extends vc{InterpolantFactoryMethodLinear(e){return new $z(this.times,this.values,this.getValueSize(),e)}}Qv.prototype.ValueTypeName="quaternion";Qv.prototype.InterpolantFactoryMethodSmooth=void 0;class Bm extends vc{constructor(e,n,a){super(e,n,a)}}Bm.prototype.ValueTypeName="string";Bm.prototype.ValueBufferType=Array;Bm.prototype.DefaultInterpolation=bv;Bm.prototype.InterpolantFactoryMethodLinear=void 0;Bm.prototype.InterpolantFactoryMethodSmooth=void 0;class _v extends vc{}_v.prototype.ValueTypeName="vector";class Rv{constructor(e="",n=-1,a=[],c=E2){this.name=e,this.tracks=a,this.duration=n,this.blendMode=c,this.uuid=Jo(),this.duration<0&&this.resetDuration()}static parse(e){const n=[],a=e.tracks,c=1/(e.fps||1);for(let p=0,b=a.length;p!==b;++p)n.push(que(a[p]).scale(c));const h=new this(e.name,e.duration,n,e.blendMode);return h.uuid=e.uuid,h}static toJSON(e){const n=[],a=e.tracks,c={name:e.name,duration:e.duration,tracks:n,uuid:e.uuid,blendMode:e.blendMode};for(let h=0,p=a.length;h!==p;++h)n.push(vc.toJSON(a[h]));return c}static CreateFromMorphTargetSequence(e,n,a,c){const h=n.length,p=[];for(let b=0;b<h;b++){let y=[],w=[];y.push((b+h-1)%h,b,(b+1)%h),w.push(0,1,0);const I=Qz(y);y=cR(y,1,I),w=cR(w,1,I),!c&&y[0]===0&&(y.push(h),w.push(w[0])),p.push(new Mv(".morphTargetInfluences["+n[b].name+"]",y,w).scale(1/a))}return new this(e,-1,p)}static findByName(e,n){let a=e;if(!Array.isArray(e)){const c=e;a=c.geometry&&c.geometry.animations||c.animations}for(let c=0;c<a.length;c++)if(a[c].name===n)return a[c];return null}static CreateClipsFromMorphTargetSequences(e,n,a){const c={},h=/^([\w-]*?)([\d]+)$/;for(let b=0,y=e.length;b<y;b++){const w=e[b],I=w.name.match(h);if(I&&I.length>1){const E=I[1];let R=c[E];R||(c[E]=R=[]),R.push(w)}}const p=[];for(const b in c)p.push(this.CreateFromMorphTargetSequence(b,c[b],n,a));return p}static parseAnimation(e,n){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const a=function(E,R,k,G,N){if(k.length!==0){const O=[],D=[];Ck(k,O,D,G),O.length!==0&&N.push(new E(R,O,D))}},c=[],h=e.name||"default",p=e.fps||30,b=e.blendMode;let y=e.length||-1;const w=e.hierarchy||[];for(let E=0;E<w.length;E++){const R=w[E].keys;if(!(!R||R.length===0))if(R[0].morphTargets){const k={};let G;for(G=0;G<R.length;G++)if(R[G].morphTargets)for(let N=0;N<R[G].morphTargets.length;N++)k[R[G].morphTargets[N]]=-1;for(const N in k){const O=[],D=[];for(let W=0;W!==R[G].morphTargets.length;++W){const H=R[G];O.push(H.time),D.push(H.morphTarget===N?1:0)}c.push(new Mv(".morphTargetInfluence["+N+"]",O,D))}y=k.length*p}else{const k=".bones["+n[E].name+"]";a(_v,k+".position",R,"pos",c),a(Qv,k+".quaternion",R,"rot",c),a(_v,k+".scale",R,"scl",c)}}return c.length===0?null:new this(h,y,c,b)}resetDuration(){const e=this.tracks;let n=0;for(let a=0,c=e.length;a!==c;++a){const h=this.tracks[a];n=Math.max(n,h.times[h.times.length-1])}return this.duration=n,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let n=0;n<this.tracks.length;n++)e=e&&this.tracks[n].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let n=0;n<this.tracks.length;n++)e.push(this.tracks[n].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function jue(r){switch(r.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Mv;case"vector":case"vector2":case"vector3":case"vector4":return _v;case"color":return Sk;case"quaternion":return Qv;case"bool":case"boolean":return km;case"string":return Bm}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+r)}function que(r){if(r.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=jue(r.type);if(r.times===void 0){const n=[],a=[];Ck(r.keys,n,a,"value"),r.times=n,r.values=a}return e.parse!==void 0?e.parse(r):new e(r.name,r.times,r.values,r.interpolation)}const yh={enabled:!1,files:{},add:function(r,e){this.enabled!==!1&&(this.files[r]=e)},get:function(r){if(this.enabled!==!1)return this.files[r]},remove:function(r){delete this.files[r]},clear:function(){this.files={}}};class Ik{constructor(e,n,a){const c=this;let h=!1,p=0,b=0,y;const w=[];this.onStart=void 0,this.onLoad=e,this.onProgress=n,this.onError=a,this.itemStart=function(I){b++,h===!1&&c.onStart!==void 0&&c.onStart(I,p,b),h=!0},this.itemEnd=function(I){p++,c.onProgress!==void 0&&c.onProgress(I,p,b),p===b&&(h=!1,c.onLoad!==void 0&&c.onLoad())},this.itemError=function(I){c.onError!==void 0&&c.onError(I)},this.resolveURL=function(I){return y?y(I):I},this.setURLModifier=function(I){return y=I,this},this.addHandler=function(I,E){return w.push(I,E),this},this.removeHandler=function(I){const E=w.indexOf(I);return E!==-1&&w.splice(E,2),this},this.getHandler=function(I){for(let E=0,R=w.length;E<R;E+=2){const k=w[E],G=w[E+1];if(k.global&&(k.lastIndex=0),k.test(I))return G}return null}}}const Yz=new Ik;class Ro{constructor(e){this.manager=e!==void 0?e:Yz,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,n){const a=this;return new Promise(function(c,h){a.load(e,c,n,h)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}Ro.DEFAULT_MATERIAL_NAME="__DEFAULT";const dh={};class Jue extends Error{constructor(e,n){super(e),this.response=n}}class kh extends Ro{constructor(e){super(e)}load(e,n,a,c){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const h=yh.get(e);if(h!==void 0)return this.manager.itemStart(e),setTimeout(()=>{n&&n(h),this.manager.itemEnd(e)},0),h;if(dh[e]!==void 0){dh[e].push({onLoad:n,onProgress:a,onError:c});return}dh[e]=[],dh[e].push({onLoad:n,onProgress:a,onError:c});const p=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),b=this.mimeType,y=this.responseType;fetch(p).then(w=>{if(w.status===200||w.status===0){if(w.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||w.body===void 0||w.body.getReader===void 0)return w;const I=dh[e],E=w.body.getReader(),R=w.headers.get("X-File-Size")||w.headers.get("Content-Length"),k=R?parseInt(R):0,G=k!==0;let N=0;const O=new ReadableStream({start(D){W();function W(){E.read().then(({done:H,value:K})=>{if(H)D.close();else{N+=K.byteLength;const j=new ProgressEvent("progress",{lengthComputable:G,loaded:N,total:k});for(let J=0,ee=I.length;J<ee;J++){const re=I[J];re.onProgress&&re.onProgress(j)}D.enqueue(K),W()}},H=>{D.error(H)})}}});return new Response(O)}else throw new Jue(`fetch for "${w.url}" responded with ${w.status}: ${w.statusText}`,w)}).then(w=>{switch(y){case"arraybuffer":return w.arrayBuffer();case"blob":return w.blob();case"document":return w.text().then(I=>new DOMParser().parseFromString(I,b));case"json":return w.json();default:if(b===void 0)return w.text();{const E=/charset="?([^;"\s]*)"?/i.exec(b),R=E&&E[1]?E[1].toLowerCase():void 0,k=new TextDecoder(R);return w.arrayBuffer().then(G=>k.decode(G))}}}).then(w=>{yh.add(e,w);const I=dh[e];delete dh[e];for(let E=0,R=I.length;E<R;E++){const k=I[E];k.onLoad&&k.onLoad(w)}}).catch(w=>{const I=dh[e];if(I===void 0)throw this.manager.itemError(e),w;delete dh[e];for(let E=0,R=I.length;E<R;E++){const k=I[E];k.onError&&k.onError(w)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class ehe extends Ro{constructor(e){super(e)}load(e,n,a,c){const h=this,p=new kh(this.manager);p.setPath(this.path),p.setRequestHeader(this.requestHeader),p.setWithCredentials(this.withCredentials),p.load(e,function(b){try{n(h.parse(JSON.parse(b)))}catch(y){c?c(y):console.error(y),h.manager.itemError(e)}},a,c)}parse(e){const n=[];for(let a=0;a<e.length;a++){const c=Rv.parse(e[a]);n.push(c)}return n}}class the extends Ro{constructor(e){super(e)}load(e,n,a,c){const h=this,p=[],b=new L2,y=new kh(this.manager);y.setPath(this.path),y.setResponseType("arraybuffer"),y.setRequestHeader(this.requestHeader),y.setWithCredentials(h.withCredentials);let w=0;function I(E){y.load(e[E],function(R){const k=h.parse(R,!0);p[E]={width:k.width,height:k.height,format:k.format,mipmaps:k.mipmaps},w+=1,w===6&&(k.mipmapCount===1&&(b.minFilter=Dr),b.image=p,b.format=k.format,b.needsUpdate=!0,n&&n(b))},a,c)}if(Array.isArray(e))for(let E=0,R=e.length;E<R;++E)I(E);else y.load(e,function(E){const R=h.parse(E,!0);if(R.isCubemap){const k=R.mipmaps.length/R.mipmapCount;for(let G=0;G<k;G++){p[G]={mipmaps:[]};for(let N=0;N<R.mipmapCount;N++)p[G].mipmaps.push(R.mipmaps[G*R.mipmapCount+N]),p[G].format=R.format,p[G].width=R.width,p[G].height=R.height}b.image=p}else b.image.width=R.width,b.image.height=R.height,b.mipmaps=R.mipmaps;R.mipmapCount===1&&(b.minFilter=Dr),b.format=R.format,b.needsUpdate=!0,n&&n(b)},a,c);return b}}class kv extends Ro{constructor(e){super(e)}load(e,n,a,c){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const h=this,p=yh.get(e);if(p!==void 0)return h.manager.itemStart(e),setTimeout(function(){n&&n(p),h.manager.itemEnd(e)},0),p;const b=Cv("img");function y(){I(),yh.add(e,this),n&&n(this),h.manager.itemEnd(e)}function w(E){I(),c&&c(E),h.manager.itemError(e),h.manager.itemEnd(e)}function I(){b.removeEventListener("load",y,!1),b.removeEventListener("error",w,!1)}return b.addEventListener("load",y,!1),b.addEventListener("error",w,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(b.crossOrigin=this.crossOrigin),h.manager.itemStart(e),b.src=e,b}}class nhe extends Ro{constructor(e){super(e)}load(e,n,a,c){const h=new Pv;h.colorSpace=Io;const p=new kv(this.manager);p.setCrossOrigin(this.crossOrigin),p.setPath(this.path);let b=0;function y(w){p.load(e[w],function(I){h.images[w]=I,b++,b===6&&(h.needsUpdate=!0,n&&n(h))},void 0,c)}for(let w=0;w<e.length;++w)y(w);return h}}class ihe extends Ro{constructor(e){super(e)}load(e,n,a,c){const h=this,p=new bu,b=new kh(this.manager);return b.setResponseType("arraybuffer"),b.setRequestHeader(this.requestHeader),b.setPath(this.path),b.setWithCredentials(h.withCredentials),b.load(e,function(y){let w;try{w=h.parse(y)}catch(I){if(c!==void 0)c(I);else{console.error(I);return}}w.image!==void 0?p.image=w.image:w.data!==void 0&&(p.image.width=w.width,p.image.height=w.height,p.image.data=w.data),p.wrapS=w.wrapS!==void 0?w.wrapS:Rl,p.wrapT=w.wrapT!==void 0?w.wrapT:Rl,p.magFilter=w.magFilter!==void 0?w.magFilter:Dr,p.minFilter=w.minFilter!==void 0?w.minFilter:Dr,p.anisotropy=w.anisotropy!==void 0?w.anisotropy:1,w.colorSpace!==void 0&&(p.colorSpace=w.colorSpace),w.flipY!==void 0&&(p.flipY=w.flipY),w.format!==void 0&&(p.format=w.format),w.type!==void 0&&(p.type=w.type),w.mipmaps!==void 0&&(p.mipmaps=w.mipmaps,p.minFilter=gu),w.mipmapCount===1&&(p.minFilter=Dr),w.generateMipmaps!==void 0&&(p.generateMipmaps=w.generateMipmaps),p.needsUpdate=!0,n&&n(p,w)},a,c),p}}class she extends Ro{constructor(e){super(e)}load(e,n,a,c){const h=new nr,p=new kv(this.manager);return p.setCrossOrigin(this.crossOrigin),p.setPath(this.path),p.load(e,function(b){h.image=b,h.needsUpdate=!0,n!==void 0&&n(h)},a,c),h}}class af extends Qi{constructor(e,n=1){super(),this.isLight=!0,this.type="Light",this.color=new pn(e),this.intensity=n}dispose(){}copy(e,n){return super.copy(e,n),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const n=super.toJSON(e);return n.object.color=this.color.getHex(),n.object.intensity=this.intensity,this.groundColor!==void 0&&(n.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(n.object.distance=this.distance),this.angle!==void 0&&(n.object.angle=this.angle),this.decay!==void 0&&(n.object.decay=this.decay),this.penumbra!==void 0&&(n.object.penumbra=this.penumbra),this.shadow!==void 0&&(n.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(n.object.target=this.target.uuid),n}}class jz extends af{constructor(e,n,a){super(e,a),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Qi.DEFAULT_UP),this.updateMatrix(),this.groundColor=new pn(n)}copy(e,n){return super.copy(e,n),this.groundColor.copy(e.groundColor),this}}const KM=new Zn,SO=new be,IO=new be;class Tk{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Dt(512,512),this.map=null,this.mapPass=null,this.matrix=new Zn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new zv,this._frameExtents=new Dt(1,1),this._viewportCount=1,this._viewports=[new Xi(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const n=this.camera,a=this.matrix;SO.setFromMatrixPosition(e.matrixWorld),n.position.copy(SO),IO.setFromMatrixPosition(e.target.matrixWorld),n.lookAt(IO),n.updateMatrixWorld(),KM.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(KM),a.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),a.multiply(KM)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class rhe extends Tk{constructor(){super(new ea(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const n=this.camera,a=J0*2*e.angle*this.focus,c=this.mapSize.width/this.mapSize.height,h=e.distance||n.far;(a!==n.fov||c!==n.aspect||h!==n.far)&&(n.fov=a,n.aspect=c,n.far=h,n.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class qz extends af{constructor(e,n,a=0,c=Math.PI/3,h=0,p=2){super(e,n),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Qi.DEFAULT_UP),this.updateMatrix(),this.target=new Qi,this.distance=a,this.angle=c,this.penumbra=h,this.decay=p,this.map=null,this.shadow=new rhe}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,n){return super.copy(e,n),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const TO=new Zn,Py=new be,ZM=new be;class ahe extends Tk{constructor(){super(new ea(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Dt(4,2),this._viewportCount=6,this._viewports=[new Xi(2,1,1,1),new Xi(0,1,1,1),new Xi(3,1,1,1),new Xi(1,1,1,1),new Xi(3,0,1,1),new Xi(1,0,1,1)],this._cubeDirections=[new be(1,0,0),new be(-1,0,0),new be(0,0,1),new be(0,0,-1),new be(0,1,0),new be(0,-1,0)],this._cubeUps=[new be(0,1,0),new be(0,1,0),new be(0,1,0),new be(0,1,0),new be(0,0,1),new be(0,0,-1)]}updateMatrices(e,n=0){const a=this.camera,c=this.matrix,h=e.distance||a.far;h!==a.far&&(a.far=h,a.updateProjectionMatrix()),Py.setFromMatrixPosition(e.matrixWorld),a.position.copy(Py),ZM.copy(a.position),ZM.add(this._cubeDirections[n]),a.up.copy(this._cubeUps[n]),a.lookAt(ZM),a.updateMatrixWorld(),c.makeTranslation(-Py.x,-Py.y,-Py.z),TO.multiplyMatrices(a.projectionMatrix,a.matrixWorldInverse),this._frustum.setFromProjectionMatrix(TO)}}class Jz extends af{constructor(e,n,a=0,c=2){super(e,n),this.isPointLight=!0,this.type="PointLight",this.distance=a,this.decay=c,this.shadow=new ahe}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,n){return super.copy(e,n),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class Z2 extends M2{constructor(e=-1,n=1,a=1,c=-1,h=.1,p=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=n,this.top=a,this.bottom=c,this.near=h,this.far=p,this.updateProjectionMatrix()}copy(e,n){return super.copy(e,n),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,n,a,c,h,p){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=n,this.view.offsetX=a,this.view.offsetY=c,this.view.width=h,this.view.height=p,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),n=(this.top-this.bottom)/(2*this.zoom),a=(this.right+this.left)/2,c=(this.top+this.bottom)/2;let h=a-e,p=a+e,b=c+n,y=c-n;if(this.view!==null&&this.view.enabled){const w=(this.right-this.left)/this.view.fullWidth/this.zoom,I=(this.top-this.bottom)/this.view.fullHeight/this.zoom;h+=w*this.view.offsetX,p=h+w*this.view.width,b-=I*this.view.offsetY,y=b-I*this.view.height}this.projectionMatrix.makeOrthographic(h,p,b,y,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const n=super.toJSON(e);return n.object.zoom=this.zoom,n.object.left=this.left,n.object.right=this.right,n.object.top=this.top,n.object.bottom=this.bottom,n.object.near=this.near,n.object.far=this.far,this.view!==null&&(n.object.view=Object.assign({},this.view)),n}}class ohe extends Tk{constructor(){super(new Z2(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class eV extends af{constructor(e,n){super(e,n),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Qi.DEFAULT_UP),this.updateMatrix(),this.target=new Qi,this.shadow=new ohe}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class tV extends af{constructor(e,n){super(e,n),this.isAmbientLight=!0,this.type="AmbientLight"}}class nV extends af{constructor(e,n,a=10,c=10){super(e,n),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=a,this.height=c}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const n=super.toJSON(e);return n.object.width=this.width,n.object.height=this.height,n}}class iV{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new be)}set(e){for(let n=0;n<9;n++)this.coefficients[n].copy(e[n]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,n){const a=e.x,c=e.y,h=e.z,p=this.coefficients;return n.copy(p[0]).multiplyScalar(.282095),n.addScaledVector(p[1],.488603*c),n.addScaledVector(p[2],.488603*h),n.addScaledVector(p[3],.488603*a),n.addScaledVector(p[4],1.092548*(a*c)),n.addScaledVector(p[5],1.092548*(c*h)),n.addScaledVector(p[6],.315392*(3*h*h-1)),n.addScaledVector(p[7],1.092548*(a*h)),n.addScaledVector(p[8],.546274*(a*a-c*c)),n}getIrradianceAt(e,n){const a=e.x,c=e.y,h=e.z,p=this.coefficients;return n.copy(p[0]).multiplyScalar(.886227),n.addScaledVector(p[1],2*.511664*c),n.addScaledVector(p[2],2*.511664*h),n.addScaledVector(p[3],2*.511664*a),n.addScaledVector(p[4],2*.429043*a*c),n.addScaledVector(p[5],2*.429043*c*h),n.addScaledVector(p[6],.743125*h*h-.247708),n.addScaledVector(p[7],2*.429043*a*h),n.addScaledVector(p[8],.429043*(a*a-c*c)),n}add(e){for(let n=0;n<9;n++)this.coefficients[n].add(e.coefficients[n]);return this}addScaledSH(e,n){for(let a=0;a<9;a++)this.coefficients[a].addScaledVector(e.coefficients[a],n);return this}scale(e){for(let n=0;n<9;n++)this.coefficients[n].multiplyScalar(e);return this}lerp(e,n){for(let a=0;a<9;a++)this.coefficients[a].lerp(e.coefficients[a],n);return this}equals(e){for(let n=0;n<9;n++)if(!this.coefficients[n].equals(e.coefficients[n]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,n=0){const a=this.coefficients;for(let c=0;c<9;c++)a[c].fromArray(e,n+c*3);return this}toArray(e=[],n=0){const a=this.coefficients;for(let c=0;c<9;c++)a[c].toArray(e,n+c*3);return e}static getBasisAt(e,n){const a=e.x,c=e.y,h=e.z;n[0]=.282095,n[1]=.488603*c,n[2]=.488603*h,n[3]=.488603*a,n[4]=1.092548*a*c,n[5]=1.092548*c*h,n[6]=.315392*(3*h*h-1),n[7]=1.092548*a*h,n[8]=.546274*(a*a-c*c)}}class sV extends af{constructor(e=new iV,n=1){super(void 0,n),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const n=super.toJSON(e);return n.object.sh=this.sh.toArray(),n}}class $2 extends Ro{constructor(e){super(e),this.textures={}}load(e,n,a,c){const h=this,p=new kh(h.manager);p.setPath(h.path),p.setRequestHeader(h.requestHeader),p.setWithCredentials(h.withCredentials),p.load(e,function(b){try{n(h.parse(JSON.parse(b)))}catch(y){c?c(y):console.error(y),h.manager.itemError(e)}},a,c)}parse(e){const n=this.textures;function a(h){return n[h]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",h),n[h]}const c=this.createMaterialFromType(e.type);if(e.uuid!==void 0&&(c.uuid=e.uuid),e.name!==void 0&&(c.name=e.name),e.color!==void 0&&c.color!==void 0&&c.color.setHex(e.color),e.roughness!==void 0&&(c.roughness=e.roughness),e.metalness!==void 0&&(c.metalness=e.metalness),e.sheen!==void 0&&(c.sheen=e.sheen),e.sheenColor!==void 0&&(c.sheenColor=new pn().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(c.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&c.emissive!==void 0&&c.emissive.setHex(e.emissive),e.specular!==void 0&&c.specular!==void 0&&c.specular.setHex(e.specular),e.specularIntensity!==void 0&&(c.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&c.specularColor!==void 0&&c.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(c.shininess=e.shininess),e.clearcoat!==void 0&&(c.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(c.clearcoatRoughness=e.clearcoatRoughness),e.dispersion!==void 0&&(c.dispersion=e.dispersion),e.iridescence!==void 0&&(c.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(c.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(c.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(c.transmission=e.transmission),e.thickness!==void 0&&(c.thickness=e.thickness),e.attenuationDistance!==void 0&&(c.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&c.attenuationColor!==void 0&&c.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(c.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(c.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(c.fog=e.fog),e.flatShading!==void 0&&(c.flatShading=e.flatShading),e.blending!==void 0&&(c.blending=e.blending),e.combine!==void 0&&(c.combine=e.combine),e.side!==void 0&&(c.side=e.side),e.shadowSide!==void 0&&(c.shadowSide=e.shadowSide),e.opacity!==void 0&&(c.opacity=e.opacity),e.transparent!==void 0&&(c.transparent=e.transparent),e.alphaTest!==void 0&&(c.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(c.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(c.depthFunc=e.depthFunc),e.depthTest!==void 0&&(c.depthTest=e.depthTest),e.depthWrite!==void 0&&(c.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(c.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(c.blendSrc=e.blendSrc),e.blendDst!==void 0&&(c.blendDst=e.blendDst),e.blendEquation!==void 0&&(c.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(c.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(c.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(c.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&c.blendColor!==void 0&&c.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(c.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(c.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(c.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(c.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(c.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(c.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(c.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(c.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(c.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(c.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(c.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(c.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(c.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(c.rotation=e.rotation),e.linewidth!==void 0&&(c.linewidth=e.linewidth),e.dashSize!==void 0&&(c.dashSize=e.dashSize),e.gapSize!==void 0&&(c.gapSize=e.gapSize),e.scale!==void 0&&(c.scale=e.scale),e.polygonOffset!==void 0&&(c.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(c.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(c.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(c.dithering=e.dithering),e.alphaToCoverage!==void 0&&(c.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(c.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(c.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(c.visible=e.visible),e.toneMapped!==void 0&&(c.toneMapped=e.toneMapped),e.userData!==void 0&&(c.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?c.vertexColors=e.vertexColors>0:c.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const h in e.uniforms){const p=e.uniforms[h];switch(c.uniforms[h]={},p.type){case"t":c.uniforms[h].value=a(p.value);break;case"c":c.uniforms[h].value=new pn().setHex(p.value);break;case"v2":c.uniforms[h].value=new Dt().fromArray(p.value);break;case"v3":c.uniforms[h].value=new be().fromArray(p.value);break;case"v4":c.uniforms[h].value=new Xi().fromArray(p.value);break;case"m3":c.uniforms[h].value=new ii().fromArray(p.value);break;case"m4":c.uniforms[h].value=new Zn().fromArray(p.value);break;default:c.uniforms[h].value=p.value}}if(e.defines!==void 0&&(c.defines=e.defines),e.vertexShader!==void 0&&(c.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(c.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(c.glslVersion=e.glslVersion),e.extensions!==void 0)for(const h in e.extensions)c.extensions[h]=e.extensions[h];if(e.lights!==void 0&&(c.lights=e.lights),e.clipping!==void 0&&(c.clipping=e.clipping),e.size!==void 0&&(c.size=e.size),e.sizeAttenuation!==void 0&&(c.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(c.map=a(e.map)),e.matcap!==void 0&&(c.matcap=a(e.matcap)),e.alphaMap!==void 0&&(c.alphaMap=a(e.alphaMap)),e.bumpMap!==void 0&&(c.bumpMap=a(e.bumpMap)),e.bumpScale!==void 0&&(c.bumpScale=e.bumpScale),e.normalMap!==void 0&&(c.normalMap=a(e.normalMap)),e.normalMapType!==void 0&&(c.normalMapType=e.normalMapType),e.normalScale!==void 0){let h=e.normalScale;Array.isArray(h)===!1&&(h=[h,h]),c.normalScale=new Dt().fromArray(h)}return e.displacementMap!==void 0&&(c.displacementMap=a(e.displacementMap)),e.displacementScale!==void 0&&(c.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(c.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(c.roughnessMap=a(e.roughnessMap)),e.metalnessMap!==void 0&&(c.metalnessMap=a(e.metalnessMap)),e.emissiveMap!==void 0&&(c.emissiveMap=a(e.emissiveMap)),e.emissiveIntensity!==void 0&&(c.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(c.specularMap=a(e.specularMap)),e.specularIntensityMap!==void 0&&(c.specularIntensityMap=a(e.specularIntensityMap)),e.specularColorMap!==void 0&&(c.specularColorMap=a(e.specularColorMap)),e.envMap!==void 0&&(c.envMap=a(e.envMap)),e.envMapRotation!==void 0&&c.envMapRotation.fromArray(e.envMapRotation),e.envMapIntensity!==void 0&&(c.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(c.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(c.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(c.lightMap=a(e.lightMap)),e.lightMapIntensity!==void 0&&(c.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(c.aoMap=a(e.aoMap)),e.aoMapIntensity!==void 0&&(c.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(c.gradientMap=a(e.gradientMap)),e.clearcoatMap!==void 0&&(c.clearcoatMap=a(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(c.clearcoatRoughnessMap=a(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(c.clearcoatNormalMap=a(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(c.clearcoatNormalScale=new Dt().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(c.iridescenceMap=a(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(c.iridescenceThicknessMap=a(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(c.transmissionMap=a(e.transmissionMap)),e.thicknessMap!==void 0&&(c.thicknessMap=a(e.thicknessMap)),e.anisotropyMap!==void 0&&(c.anisotropyMap=a(e.anisotropyMap)),e.sheenColorMap!==void 0&&(c.sheenColorMap=a(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(c.sheenRoughnessMap=a(e.sheenRoughnessMap)),c}setTextures(e){return this.textures=e,this}createMaterialFromType(e){return $2.createMaterialFromType(e)}static createMaterialFromType(e){const n={ShadowMaterial:Fz,SpriteMaterial:uk,RawShaderMaterial:Oz,ShaderMaterial:bc,PointsMaterial:dk,MeshPhysicalMaterial:Gz,MeshStandardMaterial:vk,MeshPhongMaterial:Uz,MeshToonMaterial:Pz,MeshNormalMaterial:zz,MeshLambertMaterial:Vz,MeshDepthMaterial:xk,MeshDistanceMaterial:wk,MeshBasicMaterial:sf,MeshMatcapMaterial:Wz,LineDashedMaterial:Hz,LineBasicMaterial:so,Material:Ca};return new n[e]}}class uR{static decodeText(e){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(e);let n="";for(let a=0,c=e.length;a<c;a++)n+=String.fromCharCode(e[a]);try{return decodeURIComponent(escape(n))}catch{return n}}static extractUrlBase(e){const n=e.lastIndexOf("/");return n===-1?"./":e.slice(0,n+1)}static resolveURL(e,n){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(n)&&/^\//.test(e)&&(n=n.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:n+e)}}class rV extends gi{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class aV extends Ro{constructor(e){super(e)}load(e,n,a,c){const h=this,p=new kh(h.manager);p.setPath(h.path),p.setRequestHeader(h.requestHeader),p.setWithCredentials(h.withCredentials),p.load(e,function(b){try{n(h.parse(JSON.parse(b)))}catch(y){c?c(y):console.error(y),h.manager.itemError(e)}},a,c)}parse(e){const n={},a={};function c(k,G){if(n[G]!==void 0)return n[G];const O=k.interleavedBuffers[G],D=h(k,O.buffer),W=X0(O.type,D),H=new k2(W,O.stride);return H.uuid=O.uuid,n[G]=H,H}function h(k,G){if(a[G]!==void 0)return a[G];const O=k.arrayBuffers[G],D=new Uint32Array(O).buffer;return a[G]=D,D}const p=e.isInstancedBufferGeometry?new rV:new gi,b=e.data.index;if(b!==void 0){const k=X0(b.type,b.array);p.setIndex(new bs(k,1))}const y=e.data.attributes;for(const k in y){const G=y[k];let N;if(G.isInterleavedBufferAttribute){const O=c(e.data,G.data);N=new Mm(O,G.itemSize,G.offset,G.normalized)}else{const O=X0(G.type,G.array),D=G.isInstancedBufferAttribute?tA:bs;N=new D(O,G.itemSize,G.normalized)}G.name!==void 0&&(N.name=G.name),G.usage!==void 0&&N.setUsage(G.usage),p.setAttribute(k,N)}const w=e.data.morphAttributes;if(w)for(const k in w){const G=w[k],N=[];for(let O=0,D=G.length;O<D;O++){const W=G[O];let H;if(W.isInterleavedBufferAttribute){const K=c(e.data,W.data);H=new Mm(K,W.itemSize,W.offset,W.normalized)}else{const K=X0(W.type,W.array);H=new bs(K,W.itemSize,W.normalized)}W.name!==void 0&&(H.name=W.name),N.push(H)}p.morphAttributes[k]=N}e.data.morphTargetsRelative&&(p.morphTargetsRelative=!0);const E=e.data.groups||e.data.drawcalls||e.data.offsets;if(E!==void 0)for(let k=0,G=E.length;k!==G;++k){const N=E[k];p.addGroup(N.start,N.count,N.materialIndex)}const R=e.data.boundingSphere;if(R!==void 0){const k=new be;R.center!==void 0&&k.fromArray(R.center),p.boundingSphere=new wa(k,R.radius)}return e.name&&(p.name=e.name),e.userData&&(p.userData=e.userData),p}}class lhe extends Ro{constructor(e){super(e)}load(e,n,a,c){const h=this,p=this.path===""?uR.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||p;const b=new kh(this.manager);b.setPath(this.path),b.setRequestHeader(this.requestHeader),b.setWithCredentials(this.withCredentials),b.load(e,function(y){let w=null;try{w=JSON.parse(y)}catch(E){c!==void 0&&c(E),console.error("THREE:ObjectLoader: Can't parse "+e+".",E.message);return}const I=w.metadata;if(I===void 0||I.type===void 0||I.type.toLowerCase()==="geometry"){c!==void 0&&c(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}h.parse(w,n)},a,c)}async loadAsync(e,n){const a=this,c=this.path===""?uR.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||c;const h=new kh(this.manager);h.setPath(this.path),h.setRequestHeader(this.requestHeader),h.setWithCredentials(this.withCredentials);const p=await h.loadAsync(e,n),b=JSON.parse(p),y=b.metadata;if(y===void 0||y.type===void 0||y.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await a.parseAsync(b)}parse(e,n){const a=this.parseAnimations(e.animations),c=this.parseShapes(e.shapes),h=this.parseGeometries(e.geometries,c),p=this.parseImages(e.images,function(){n!==void 0&&n(w)}),b=this.parseTextures(e.textures,p),y=this.parseMaterials(e.materials,b),w=this.parseObject(e.object,h,y,b,a),I=this.parseSkeletons(e.skeletons,w);if(this.bindSkeletons(w,I),this.bindLightTargets(w),n!==void 0){let E=!1;for(const R in p)if(p[R].data instanceof HTMLImageElement){E=!0;break}E===!1&&n(w)}return w}async parseAsync(e){const n=this.parseAnimations(e.animations),a=this.parseShapes(e.shapes),c=this.parseGeometries(e.geometries,a),h=await this.parseImagesAsync(e.images),p=this.parseTextures(e.textures,h),b=this.parseMaterials(e.materials,p),y=this.parseObject(e.object,c,b,p,n),w=this.parseSkeletons(e.skeletons,y);return this.bindSkeletons(y,w),this.bindLightTargets(y),y}parseShapes(e){const n={};if(e!==void 0)for(let a=0,c=e.length;a<c;a++){const h=new Em().fromJSON(e[a]);n[h.uuid]=h}return n}parseSkeletons(e,n){const a={},c={};if(n.traverse(function(h){h.isBone&&(c[h.uuid]=h)}),e!==void 0)for(let h=0,p=e.length;h<p;h++){const b=new B2().fromJSON(e[h],c);a[b.uuid]=b}return a}parseGeometries(e,n){const a={};if(e!==void 0){const h=new aV;for(let p=0,b=e.length;p<b;p++){let y;const w=e[p];switch(w.type){case"BufferGeometry":case"InstancedBufferGeometry":y=h.parse(w);break;case"Geometry":if("THREE"in window&&"LegacyJSONLoader"in THREE){var c=new THREE.LegacyJSONLoader;y=c.parse(w,this.resourcePath).geometry}else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');break;default:w.type in EO?y=EO[w.type].fromJSON(w,n):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${w.type}"`)}y.uuid=w.uuid,w.name!==void 0&&(y.name=w.name),w.userData!==void 0&&(y.userData=w.userData),a[w.uuid]=y}}return a}parseMaterials(e,n){const a={},c={};if(e!==void 0){const h=new $2;h.setTextures(n);for(let p=0,b=e.length;p<b;p++){const y=e[p];a[y.uuid]===void 0&&(a[y.uuid]=h.parse(y)),c[y.uuid]=a[y.uuid]}}return c}parseAnimations(e){const n={};if(e!==void 0)for(let a=0;a<e.length;a++){const c=e[a],h=Rv.parse(c);n[h.uuid]=h}return n}parseImages(e,n){const a=this,c={};let h;function p(y){return a.manager.itemStart(y),h.load(y,function(){a.manager.itemEnd(y)},void 0,function(){a.manager.itemError(y),a.manager.itemEnd(y)})}function b(y){if(typeof y=="string"){const w=y,I=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(w)?w:a.resourcePath+w;return p(I)}else return y.data?{data:X0(y.type,y.data),width:y.width,height:y.height}:null}if(e!==void 0&&e.length>0){const y=new Ik(n);h=new kv(y),h.setCrossOrigin(this.crossOrigin);for(let w=0,I=e.length;w<I;w++){const E=e[w],R=E.url;if(Array.isArray(R)){const k=[];for(let G=0,N=R.length;G<N;G++){const O=R[G],D=b(O);D!==null&&(D instanceof HTMLImageElement?k.push(D):k.push(new bu(D.data,D.width,D.height)))}c[E.uuid]=new vm(k)}else{const k=b(E.url);c[E.uuid]=new vm(k)}}}return c}async parseImagesAsync(e){const n=this,a={};let c;async function h(p){if(typeof p=="string"){const b=p,y=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(b)?b:n.resourcePath+b;return await c.loadAsync(y)}else return p.data?{data:X0(p.type,p.data),width:p.width,height:p.height}:null}if(e!==void 0&&e.length>0){c=new kv(this.manager),c.setCrossOrigin(this.crossOrigin);for(let p=0,b=e.length;p<b;p++){const y=e[p],w=y.url;if(Array.isArray(w)){const I=[];for(let E=0,R=w.length;E<R;E++){const k=w[E],G=await h(k);G!==null&&(G instanceof HTMLImageElement?I.push(G):I.push(new bu(G.data,G.width,G.height)))}a[y.uuid]=new vm(I)}else{const I=await h(y.url);a[y.uuid]=new vm(I)}}}return a}parseTextures(e,n){function a(h,p){return typeof h=="number"?h:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",h),p[h])}const c={};if(e!==void 0)for(let h=0,p=e.length;h<p;h++){const b=e[h];b.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',b.uuid),n[b.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",b.image);const y=n[b.image],w=y.data;let I;Array.isArray(w)?(I=new Pv,w.length===6&&(I.needsUpdate=!0)):(w&&w.data?I=new bu:I=new nr,w&&(I.needsUpdate=!0)),I.source=y,I.uuid=b.uuid,b.name!==void 0&&(I.name=b.name),b.mapping!==void 0&&(I.mapping=a(b.mapping,che)),b.channel!==void 0&&(I.channel=b.channel),b.offset!==void 0&&I.offset.fromArray(b.offset),b.repeat!==void 0&&I.repeat.fromArray(b.repeat),b.center!==void 0&&I.center.fromArray(b.center),b.rotation!==void 0&&(I.rotation=b.rotation),b.wrap!==void 0&&(I.wrapS=a(b.wrap[0],MO),I.wrapT=a(b.wrap[1],MO)),b.format!==void 0&&(I.format=b.format),b.internalFormat!==void 0&&(I.internalFormat=b.internalFormat),b.type!==void 0&&(I.type=b.type),b.colorSpace!==void 0&&(I.colorSpace=b.colorSpace),b.minFilter!==void 0&&(I.minFilter=a(b.minFilter,_O)),b.magFilter!==void 0&&(I.magFilter=a(b.magFilter,_O)),b.anisotropy!==void 0&&(I.anisotropy=b.anisotropy),b.flipY!==void 0&&(I.flipY=b.flipY),b.generateMipmaps!==void 0&&(I.generateMipmaps=b.generateMipmaps),b.premultiplyAlpha!==void 0&&(I.premultiplyAlpha=b.premultiplyAlpha),b.unpackAlignment!==void 0&&(I.unpackAlignment=b.unpackAlignment),b.compareFunction!==void 0&&(I.compareFunction=b.compareFunction),b.userData!==void 0&&(I.userData=b.userData),c[b.uuid]=I}return c}parseObject(e,n,a,c,h){let p;function b(R){return n[R]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",R),n[R]}function y(R){if(R!==void 0){if(Array.isArray(R)){const k=[];for(let G=0,N=R.length;G<N;G++){const O=R[G];a[O]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",O),k.push(a[O])}return k}return a[R]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",R),a[R]}}function w(R){return c[R]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",R),c[R]}let I,E;switch(e.type){case"Scene":p=new gz,e.background!==void 0&&(Number.isInteger(e.background)?p.background=new pn(e.background):p.background=w(e.background)),e.environment!==void 0&&(p.environment=w(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?p.fog=new R2(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(p.fog=new _2(e.fog.color,e.fog.density)),e.fog.name!==""&&(p.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(p.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(p.backgroundIntensity=e.backgroundIntensity),e.backgroundRotation!==void 0&&p.backgroundRotation.fromArray(e.backgroundRotation),e.environmentIntensity!==void 0&&(p.environmentIntensity=e.environmentIntensity),e.environmentRotation!==void 0&&p.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":p=new ea(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(p.focus=e.focus),e.zoom!==void 0&&(p.zoom=e.zoom),e.filmGauge!==void 0&&(p.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(p.filmOffset=e.filmOffset),e.view!==void 0&&(p.view=Object.assign({},e.view));break;case"OrthographicCamera":p=new Z2(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(p.zoom=e.zoom),e.view!==void 0&&(p.view=Object.assign({},e.view));break;case"AmbientLight":p=new tV(e.color,e.intensity);break;case"DirectionalLight":p=new eV(e.color,e.intensity),p.target=e.target||"";break;case"PointLight":p=new Jz(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":p=new nV(e.color,e.intensity,e.width,e.height);break;case"SpotLight":p=new qz(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),p.target=e.target||"";break;case"HemisphereLight":p=new jz(e.color,e.groundColor,e.intensity);break;case"LightProbe":p=new sV().fromJSON(e);break;case"SkinnedMesh":I=b(e.geometry),E=y(e.material),p=new vz(I,E),e.bindMode!==void 0&&(p.bindMode=e.bindMode),e.bindMatrix!==void 0&&p.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(p.skeleton=e.skeleton);break;case"Mesh":I=b(e.geometry),E=y(e.material),p=new Er(I,E);break;case"InstancedMesh":I=b(e.geometry),E=y(e.material);const R=e.count,k=e.instanceMatrix,G=e.instanceColor;p=new xz(I,E,R),p.instanceMatrix=new tA(new Float32Array(k.array),16),G!==void 0&&(p.instanceColor=new tA(new Float32Array(G.array),G.itemSize));break;case"BatchedMesh":I=b(e.geometry),E=y(e.material),p=new wz(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,E),p.geometry=I,p.perObjectFrustumCulled=e.perObjectFrustumCulled,p.sortObjects=e.sortObjects,p._drawRanges=e.drawRanges,p._reservedRanges=e.reservedRanges,p._visibility=e.visibility,p._active=e.active,p._bounds=e.bounds.map(N=>{const O=new io;O.min.fromArray(N.boxMin),O.max.fromArray(N.boxMax);const D=new wa;return D.radius=N.sphereRadius,D.center.fromArray(N.sphereCenter),{boxInitialized:N.boxInitialized,box:O,sphereInitialized:N.sphereInitialized,sphere:D}}),p._maxInstanceCount=e.maxInstanceCount,p._maxVertexCount=e.maxVertexCount,p._maxIndexCount=e.maxIndexCount,p._geometryInitialized=e.geometryInitialized,p._geometryCount=e.geometryCount,p._matricesTexture=w(e.matricesTexture.uuid),e.colorsTexture!==void 0&&(p._colorsTexture=w(e.colorsTexture.uuid));break;case"LOD":p=new yz;break;case"Line":p=new Jd(b(e.geometry),y(e.material));break;case"LineLoop":p=new Cz(b(e.geometry),y(e.material));break;case"LineSegments":p=new wu(b(e.geometry),y(e.material));break;case"PointCloud":case"Points":p=new Ez(b(e.geometry),y(e.material));break;case"Sprite":p=new bz(y(e.material));break;case"Group":p=new Q0;break;case"Bone":p=new hk;break;default:p=new Qi}if(p.uuid=e.uuid,e.name!==void 0&&(p.name=e.name),e.matrix!==void 0?(p.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(p.matrixAutoUpdate=e.matrixAutoUpdate),p.matrixAutoUpdate&&p.matrix.decompose(p.position,p.quaternion,p.scale)):(e.position!==void 0&&p.position.fromArray(e.position),e.rotation!==void 0&&p.rotation.fromArray(e.rotation),e.quaternion!==void 0&&p.quaternion.fromArray(e.quaternion),e.scale!==void 0&&p.scale.fromArray(e.scale)),e.up!==void 0&&p.up.fromArray(e.up),e.castShadow!==void 0&&(p.castShadow=e.castShadow),e.receiveShadow!==void 0&&(p.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.intensity!==void 0&&(p.shadow.intensity=e.shadow.intensity),e.shadow.bias!==void 0&&(p.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(p.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(p.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&p.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(p.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(p.visible=e.visible),e.frustumCulled!==void 0&&(p.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(p.renderOrder=e.renderOrder),e.userData!==void 0&&(p.userData=e.userData),e.layers!==void 0&&(p.layers.mask=e.layers),e.children!==void 0){const R=e.children;for(let k=0;k<R.length;k++)p.add(this.parseObject(R[k],n,a,c,h))}if(e.animations!==void 0){const R=e.animations;for(let k=0;k<R.length;k++){const G=R[k];p.animations.push(h[G])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(p.autoUpdate=e.autoUpdate);const R=e.levels;for(let k=0;k<R.length;k++){const G=R[k],N=p.getObjectByProperty("uuid",G.object);N!==void 0&&p.addLevel(N,G.distance,G.hysteresis)}}return p}bindSkeletons(e,n){Object.keys(n).length!==0&&e.traverse(function(a){if(a.isSkinnedMesh===!0&&a.skeleton!==void 0){const c=n[a.skeleton];c===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",a.skeleton):a.bind(c,a.bindMatrix)}})}bindLightTargets(e){e.traverse(function(n){if(n.isDirectionalLight||n.isSpotLight){const a=n.target,c=e.getObjectByProperty("uuid",a);c!==void 0?n.target=c:n.target=new Qi}})}}const che={UVMapping:A2,CubeReflectionMapping:_h,CubeRefractionMapping:qd,EquirectangularReflectionMapping:pv,EquirectangularRefractionMapping:mv,CubeUVReflectionMapping:iA},MO={RepeatWrapping:gv,ClampToEdgeWrapping:Rl,MirroredRepeatWrapping:Av},_O={NearestFilter:ia,NearestMipmapNearestFilter:$R,NearestMipmapLinearFilter:H0,LinearFilter:Dr,LinearMipmapNearestFilter:iv,LinearMipmapLinearFilter:gu};class uhe extends Ro{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,n,a,c){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const h=this,p=yh.get(e);if(p!==void 0){if(h.manager.itemStart(e),p.then){p.then(w=>{n&&n(w),h.manager.itemEnd(e)}).catch(w=>{c&&c(w)});return}return setTimeout(function(){n&&n(p),h.manager.itemEnd(e)},0),p}const b={};b.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",b.headers=this.requestHeader;const y=fetch(e,b).then(function(w){return w.blob()}).then(function(w){return createImageBitmap(w,Object.assign(h.options,{colorSpaceConversion:"none"}))}).then(function(w){return yh.add(e,w),n&&n(w),h.manager.itemEnd(e),w}).catch(function(w){c&&c(w),yh.remove(e),h.manager.itemError(e),h.manager.itemEnd(e)});yh.add(e,y),h.manager.itemStart(e)}}let wC;class Mk{static getContext(){return wC===void 0&&(wC=new(window.AudioContext||window.webkitAudioContext)),wC}static setContext(e){wC=e}}class hhe extends Ro{constructor(e){super(e)}load(e,n,a,c){const h=this,p=new kh(this.manager);p.setResponseType("arraybuffer"),p.setPath(this.path),p.setRequestHeader(this.requestHeader),p.setWithCredentials(this.withCredentials),p.load(e,function(y){try{const w=y.slice(0);Mk.getContext().decodeAudioData(w,function(E){n(E)}).catch(b)}catch(w){b(w)}},a,c);function b(y){c?c(y):console.error(y),h.manager.itemError(e)}}}const RO=new Zn,kO=new Zn,Jp=new Zn;class dhe{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ea,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ea,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const n=this._cache;if(n.focus!==e.focus||n.fov!==e.fov||n.aspect!==e.aspect*this.aspect||n.near!==e.near||n.far!==e.far||n.zoom!==e.zoom||n.eyeSep!==this.eyeSep){n.focus=e.focus,n.fov=e.fov,n.aspect=e.aspect*this.aspect,n.near=e.near,n.far=e.far,n.zoom=e.zoom,n.eyeSep=this.eyeSep,Jp.copy(e.projectionMatrix);const c=n.eyeSep/2,h=c*n.near/n.focus,p=n.near*Math.tan(Cm*n.fov*.5)/n.zoom;let b,y;kO.elements[12]=-c,RO.elements[12]=c,b=-p*n.aspect+h,y=p*n.aspect+h,Jp.elements[0]=2*n.near/(y-b),Jp.elements[8]=(y+b)/(y-b),this.cameraL.projectionMatrix.copy(Jp),b=-p*n.aspect-h,y=p*n.aspect-h,Jp.elements[0]=2*n.near/(y-b),Jp.elements[8]=(y+b)/(y-b),this.cameraR.projectionMatrix.copy(Jp)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(kO),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(RO)}}class oV extends ea{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e,this.index=0}}class lV{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=BO(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const n=BO();e=(n-this.oldTime)/1e3,this.oldTime=n,this.elapsedTime+=e}return e}}function BO(){return performance.now()}const em=new be,LO=new _o,fhe=new be,tm=new be;class phe extends Qi{constructor(){super(),this.type="AudioListener",this.context=Mk.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new lV}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const n=this.context.listener,a=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(em,LO,fhe),tm.set(0,0,-1).applyQuaternion(LO),n.positionX){const c=this.context.currentTime+this.timeDelta;n.positionX.linearRampToValueAtTime(em.x,c),n.positionY.linearRampToValueAtTime(em.y,c),n.positionZ.linearRampToValueAtTime(em.z,c),n.forwardX.linearRampToValueAtTime(tm.x,c),n.forwardY.linearRampToValueAtTime(tm.y,c),n.forwardZ.linearRampToValueAtTime(tm.z,c),n.upX.linearRampToValueAtTime(a.x,c),n.upY.linearRampToValueAtTime(a.y,c),n.upZ.linearRampToValueAtTime(a.z,c)}else n.setPosition(em.x,em.y,em.z),n.setOrientation(tm.x,tm.y,tm.z,a.x,a.y,a.z)}}class cV extends Qi{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const n=this.context.createBufferSource();return n.buffer=this.buffer,n.loop=this.loop,n.loopStart=this.loopStart,n.loopEnd=this.loopEnd,n.onended=this.onEnded.bind(this),n.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=n,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(e=0){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(this.context.currentTime+e),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,n=this.filters.length;e<n;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,n=this.filters.length;e<n;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){return this.detune=e,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}copy(e,n){return super.copy(e,n),e.sourceType!=="buffer"?(console.warn("THREE.Audio: Audio source type cannot be copied."),this):(this.autoplay=e.autoplay,this.buffer=e.buffer,this.detune=e.detune,this.loop=e.loop,this.loopStart=e.loopStart,this.loopEnd=e.loopEnd,this.offset=e.offset,this.duration=e.duration,this.playbackRate=e.playbackRate,this.hasPlaybackControl=e.hasPlaybackControl,this.sourceType=e.sourceType,this.filters=e.filters.slice(),this)}clone(e){return new this.constructor(this.listener).copy(this,e)}}const nm=new be,NO=new _o,mhe=new be,im=new be;class ghe extends cV{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,n,a){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=n,this.panner.coneOuterGain=a,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(nm,NO,mhe),im.set(0,0,1).applyQuaternion(NO);const n=this.panner;if(n.positionX){const a=this.context.currentTime+this.listener.timeDelta;n.positionX.linearRampToValueAtTime(nm.x,a),n.positionY.linearRampToValueAtTime(nm.y,a),n.positionZ.linearRampToValueAtTime(nm.z,a),n.orientationX.linearRampToValueAtTime(im.x,a),n.orientationY.linearRampToValueAtTime(im.y,a),n.orientationZ.linearRampToValueAtTime(im.z,a)}else n.setPosition(nm.x,nm.y,nm.z),n.setOrientation(im.x,im.y,im.z)}}class Ahe{constructor(e,n=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=n,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const n=this.getFrequencyData();for(let a=0;a<n.length;a++)e+=n[a];return e/n.length}}class uV{constructor(e,n,a){this.binding=e,this.valueSize=a;let c,h,p;switch(n){case"quaternion":c=this._slerp,h=this._slerpAdditive,p=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(a*6),this._workIndex=5;break;case"string":case"bool":c=this._select,h=this._select,p=this._setAdditiveIdentityOther,this.buffer=new Array(a*5);break;default:c=this._lerp,h=this._lerpAdditive,p=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(a*5)}this._mixBufferRegion=c,this._mixBufferRegionAdditive=h,this._setIdentity=p,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,n){const a=this.buffer,c=this.valueSize,h=e*c+c;let p=this.cumulativeWeight;if(p===0){for(let b=0;b!==c;++b)a[h+b]=a[b];p=n}else{p+=n;const b=n/p;this._mixBufferRegion(a,h,0,b,c)}this.cumulativeWeight=p}accumulateAdditive(e){const n=this.buffer,a=this.valueSize,c=a*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(n,c,0,e,a),this.cumulativeWeightAdditive+=e}apply(e){const n=this.valueSize,a=this.buffer,c=e*n+n,h=this.cumulativeWeight,p=this.cumulativeWeightAdditive,b=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,h<1){const y=n*this._origIndex;this._mixBufferRegion(a,c,y,1-h,n)}p>0&&this._mixBufferRegionAdditive(a,c,this._addIndex*n,1,n);for(let y=n,w=n+n;y!==w;++y)if(a[y]!==a[y+n]){b.setValue(a,c);break}}saveOriginalState(){const e=this.binding,n=this.buffer,a=this.valueSize,c=a*this._origIndex;e.getValue(n,c);for(let h=a,p=c;h!==p;++h)n[h]=n[c+h%a];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,n=e+this.valueSize;for(let a=e;a<n;a++)this.buffer[a]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,n=this._addIndex*this.valueSize;for(let a=0;a<this.valueSize;a++)this.buffer[n+a]=this.buffer[e+a]}_select(e,n,a,c,h){if(c>=.5)for(let p=0;p!==h;++p)e[n+p]=e[a+p]}_slerp(e,n,a,c){_o.slerpFlat(e,n,e,n,e,a,c)}_slerpAdditive(e,n,a,c,h){const p=this._workIndex*h;_o.multiplyQuaternionsFlat(e,p,e,n,e,a),_o.slerpFlat(e,n,e,n,e,p,c)}_lerp(e,n,a,c,h){const p=1-c;for(let b=0;b!==h;++b){const y=n+b;e[y]=e[y]*p+e[a+b]*c}}_lerpAdditive(e,n,a,c,h){for(let p=0;p!==h;++p){const b=n+p;e[b]=e[b]+e[a+p]*c}}}const _k="\\[\\]\\.:\\/",bhe=new RegExp("["+_k+"]","g"),Rk="[^"+_k+"]",yhe="[^"+_k.replace("\\.","")+"]",vhe=/((?:WC+[\/:])*)/.source.replace("WC",Rk),xhe=/(WCOD+)?/.source.replace("WCOD",yhe),whe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Rk),Che=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Rk),Ehe=new RegExp("^"+vhe+xhe+whe+Che+"$"),She=["material","materials","bones","map"];class Ihe{constructor(e,n,a){const c=a||Hi.parseTrackName(n);this._targetGroup=e,this._bindings=e.subscribe_(n,c)}getValue(e,n){this.bind();const a=this._targetGroup.nCachedObjects_,c=this._bindings[a];c!==void 0&&c.getValue(e,n)}setValue(e,n){const a=this._bindings;for(let c=this._targetGroup.nCachedObjects_,h=a.length;c!==h;++c)a[c].setValue(e,n)}bind(){const e=this._bindings;for(let n=this._targetGroup.nCachedObjects_,a=e.length;n!==a;++n)e[n].bind()}unbind(){const e=this._bindings;for(let n=this._targetGroup.nCachedObjects_,a=e.length;n!==a;++n)e[n].unbind()}}class Hi{constructor(e,n,a){this.path=n,this.parsedPath=a||Hi.parseTrackName(n),this.node=Hi.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,n,a){return e&&e.isAnimationObjectGroup?new Hi.Composite(e,n,a):new Hi(e,n,a)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(bhe,"")}static parseTrackName(e){const n=Ehe.exec(e);if(n===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const a={nodeName:n[2],objectName:n[3],objectIndex:n[4],propertyName:n[5],propertyIndex:n[6]},c=a.nodeName&&a.nodeName.lastIndexOf(".");if(c!==void 0&&c!==-1){const h=a.nodeName.substring(c+1);She.indexOf(h)!==-1&&(a.nodeName=a.nodeName.substring(0,c),a.objectName=h)}if(a.propertyName===null||a.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return a}static findNode(e,n){if(n===void 0||n===""||n==="."||n===-1||n===e.name||n===e.uuid)return e;if(e.skeleton){const a=e.skeleton.getBoneByName(n);if(a!==void 0)return a}if(e.children){const a=function(h){for(let p=0;p<h.length;p++){const b=h[p];if(b.name===n||b.uuid===n)return b;const y=a(b.children);if(y)return y}return null},c=a(e.children);if(c)return c}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,n){e[n]=this.targetObject[this.propertyName]}_getValue_array(e,n){const a=this.resolvedProperty;for(let c=0,h=a.length;c!==h;++c)e[n++]=a[c]}_getValue_arrayElement(e,n){e[n]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,n){this.resolvedProperty.toArray(e,n)}_setValue_direct(e,n){this.targetObject[this.propertyName]=e[n]}_setValue_direct_setNeedsUpdate(e,n){this.targetObject[this.propertyName]=e[n],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,n){this.targetObject[this.propertyName]=e[n],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,n){const a=this.resolvedProperty;for(let c=0,h=a.length;c!==h;++c)a[c]=e[n++]}_setValue_array_setNeedsUpdate(e,n){const a=this.resolvedProperty;for(let c=0,h=a.length;c!==h;++c)a[c]=e[n++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,n){const a=this.resolvedProperty;for(let c=0,h=a.length;c!==h;++c)a[c]=e[n++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,n){this.resolvedProperty[this.propertyIndex]=e[n]}_setValue_arrayElement_setNeedsUpdate(e,n){this.resolvedProperty[this.propertyIndex]=e[n],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,n){this.resolvedProperty[this.propertyIndex]=e[n],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,n){this.resolvedProperty.fromArray(e,n)}_setValue_fromArray_setNeedsUpdate(e,n){this.resolvedProperty.fromArray(e,n),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,n){this.resolvedProperty.fromArray(e,n),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,n){this.bind(),this.getValue(e,n)}_setValue_unbound(e,n){this.bind(),this.setValue(e,n)}bind(){let e=this.node;const n=this.parsedPath,a=n.objectName,c=n.propertyName;let h=n.propertyIndex;if(e||(e=Hi.findNode(this.rootNode,n.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(a){let w=n.objectIndex;switch(a){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let I=0;I<e.length;I++)if(e[I].name===w){w=I;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[a]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[a]}if(w!==void 0){if(e[w]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[w]}}const p=e[c];if(p===void 0){const w=n.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+w+"."+c+" but it wasn't found.",e);return}let b=this.Versioning.None;this.targetObject=e,e.isMaterial===!0?b=this.Versioning.NeedsUpdate:e.isObject3D===!0&&(b=this.Versioning.MatrixWorldNeedsUpdate);let y=this.BindingType.Direct;if(h!==void 0){if(c==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[h]!==void 0&&(h=e.morphTargetDictionary[h])}y=this.BindingType.ArrayElement,this.resolvedProperty=p,this.propertyIndex=h}else p.fromArray!==void 0&&p.toArray!==void 0?(y=this.BindingType.HasFromToArray,this.resolvedProperty=p):Array.isArray(p)?(y=this.BindingType.EntireArray,this.resolvedProperty=p):this.propertyName=c;this.getValue=this.GetterByBindingType[y],this.setValue=this.SetterByBindingTypeAndVersioning[y][b]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Hi.Composite=Ihe;Hi.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Hi.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Hi.prototype.GetterByBindingType=[Hi.prototype._getValue_direct,Hi.prototype._getValue_array,Hi.prototype._getValue_arrayElement,Hi.prototype._getValue_toArray];Hi.prototype.SetterByBindingTypeAndVersioning=[[Hi.prototype._setValue_direct,Hi.prototype._setValue_direct_setNeedsUpdate,Hi.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Hi.prototype._setValue_array,Hi.prototype._setValue_array_setNeedsUpdate,Hi.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Hi.prototype._setValue_arrayElement,Hi.prototype._setValue_arrayElement_setNeedsUpdate,Hi.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Hi.prototype._setValue_fromArray,Hi.prototype._setValue_fromArray_setNeedsUpdate,Hi.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class The{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Jo(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let a=0,c=arguments.length;a!==c;++a)e[arguments[a].uuid]=a;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const n=this;this.stats={objects:{get total(){return n._objects.length},get inUse(){return this.total-n.nCachedObjects_}},get bindingsPerObject(){return n._bindings.length}}}add(){const e=this._objects,n=this._indicesByUUID,a=this._paths,c=this._parsedPaths,h=this._bindings,p=h.length;let b,y=e.length,w=this.nCachedObjects_;for(let I=0,E=arguments.length;I!==E;++I){const R=arguments[I],k=R.uuid;let G=n[k];if(G===void 0){G=y++,n[k]=G,e.push(R);for(let N=0,O=p;N!==O;++N)h[N].push(new Hi(R,a[N],c[N]))}else if(G<w){b=e[G];const N=--w,O=e[N];n[O.uuid]=G,e[G]=O,n[k]=N,e[N]=R;for(let D=0,W=p;D!==W;++D){const H=h[D],K=H[N];let j=H[G];H[G]=K,j===void 0&&(j=new Hi(R,a[D],c[D])),H[N]=j}}else e[G]!==b&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=w}remove(){const e=this._objects,n=this._indicesByUUID,a=this._bindings,c=a.length;let h=this.nCachedObjects_;for(let p=0,b=arguments.length;p!==b;++p){const y=arguments[p],w=y.uuid,I=n[w];if(I!==void 0&&I>=h){const E=h++,R=e[E];n[R.uuid]=I,e[I]=R,n[w]=E,e[E]=y;for(let k=0,G=c;k!==G;++k){const N=a[k],O=N[E],D=N[I];N[I]=O,N[E]=D}}}this.nCachedObjects_=h}uncache(){const e=this._objects,n=this._indicesByUUID,a=this._bindings,c=a.length;let h=this.nCachedObjects_,p=e.length;for(let b=0,y=arguments.length;b!==y;++b){const w=arguments[b],I=w.uuid,E=n[I];if(E!==void 0)if(delete n[I],E<h){const R=--h,k=e[R],G=--p,N=e[G];n[k.uuid]=E,e[E]=k,n[N.uuid]=R,e[R]=N,e.pop();for(let O=0,D=c;O!==D;++O){const W=a[O],H=W[R],K=W[G];W[E]=H,W[R]=K,W.pop()}}else{const R=--p,k=e[R];R>0&&(n[k.uuid]=E),e[E]=k,e.pop();for(let G=0,N=c;G!==N;++G){const O=a[G];O[E]=O[R],O.pop()}}}this.nCachedObjects_=h}subscribe_(e,n){const a=this._bindingsIndicesByPath;let c=a[e];const h=this._bindings;if(c!==void 0)return h[c];const p=this._paths,b=this._parsedPaths,y=this._objects,w=y.length,I=this.nCachedObjects_,E=new Array(w);c=h.length,a[e]=c,p.push(e),b.push(n),h.push(E);for(let R=I,k=y.length;R!==k;++R){const G=y[R];E[R]=new Hi(G,e,n)}return E}unsubscribe_(e){const n=this._bindingsIndicesByPath,a=n[e];if(a!==void 0){const c=this._paths,h=this._parsedPaths,p=this._bindings,b=p.length-1,y=p[b],w=e[b];n[w]=a,p[a]=y,p.pop(),h[a]=h[b],h.pop(),c[a]=c[b],c.pop()}}}class hV{constructor(e,n,a=null,c=n.blendMode){this._mixer=e,this._clip=n,this._localRoot=a,this.blendMode=c;const h=n.tracks,p=h.length,b=new Array(p),y={endingStart:bm,endingEnd:bm};for(let w=0;w!==p;++w){const I=h[w].createInterpolant(null);b[w]=I,I.settings=y}this._interpolantSettings=y,this._interpolants=b,this._propertyBindings=new Array(p),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=YP,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,n){return this.loop=e,this.repetitions=n,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,n,a){if(e.fadeOut(n),this.fadeIn(n),a){const c=this._clip.duration,h=e._clip.duration,p=h/c,b=c/h;e.warp(1,p,n),this.warp(b,1,n)}return this}crossFadeTo(e,n,a){return e.crossFadeFrom(this,n,a)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,n,a){const c=this._mixer,h=c.time,p=this.timeScale;let b=this._timeScaleInterpolant;b===null&&(b=c._lendControlInterpolant(),this._timeScaleInterpolant=b);const y=b.parameterPositions,w=b.sampleValues;return y[0]=h,y[1]=h+a,w[0]=e/p,w[1]=n/p,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,n,a,c){if(!this.enabled){this._updateWeight(e);return}const h=this._startTime;if(h!==null){const y=(e-h)*a;y<0||a===0?n=0:(this._startTime=null,n=a*y)}n*=this._updateTimeScale(e);const p=this._updateTime(n),b=this._updateWeight(e);if(b>0){const y=this._interpolants,w=this._propertyBindings;switch(this.blendMode){case rk:for(let I=0,E=y.length;I!==E;++I)y[I].evaluate(p),w[I].accumulateAdditive(b);break;case E2:default:for(let I=0,E=y.length;I!==E;++I)y[I].evaluate(p),w[I].accumulate(c,b)}}}_updateWeight(e){let n=0;if(this.enabled){n=this.weight;const a=this._weightInterpolant;if(a!==null){const c=a.evaluate(e)[0];n*=c,e>a.parameterPositions[1]&&(this.stopFading(),c===0&&(this.enabled=!1))}}return this._effectiveWeight=n,n}_updateTimeScale(e){let n=0;if(!this.paused){n=this.timeScale;const a=this._timeScaleInterpolant;if(a!==null){const c=a.evaluate(e)[0];n*=c,e>a.parameterPositions[1]&&(this.stopWarping(),n===0?this.paused=!0:this.timeScale=n)}}return this._effectiveTimeScale=n,n}_updateTime(e){const n=this._clip.duration,a=this.loop;let c=this.time+e,h=this._loopCount;const p=a===jP;if(e===0)return h===-1?c:p&&(h&1)===1?n-c:c;if(a===$P){h===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(c>=n)c=n;else if(c<0)c=0;else{this.time=c;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=c,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(h===-1&&(e>=0?(h=0,this._setEndings(!0,this.repetitions===0,p)):this._setEndings(this.repetitions===0,!0,p)),c>=n||c<0){const b=Math.floor(c/n);c-=n*b,h+=Math.abs(b);const y=this.repetitions-h;if(y<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,c=e>0?n:0,this.time=c,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(y===1){const w=e<0;this._setEndings(w,!w,p)}else this._setEndings(!1,!1,p);this._loopCount=h,this.time=c,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:b})}}else this.time=c;if(p&&(h&1)===1)return n-c}return c}_setEndings(e,n,a){const c=this._interpolantSettings;a?(c.endingStart=ym,c.endingEnd=ym):(e?c.endingStart=this.zeroSlopeAtStart?ym:bm:c.endingStart=yv,n?c.endingEnd=this.zeroSlopeAtEnd?ym:bm:c.endingEnd=yv)}_scheduleFading(e,n,a){const c=this._mixer,h=c.time;let p=this._weightInterpolant;p===null&&(p=c._lendControlInterpolant(),this._weightInterpolant=p);const b=p.parameterPositions,y=p.sampleValues;return b[0]=h,y[0]=n,b[1]=h+e,y[1]=a,this}}const Mhe=new Float32Array(1);class _he extends xu{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,n){const a=e._localRoot||this._root,c=e._clip.tracks,h=c.length,p=e._propertyBindings,b=e._interpolants,y=a.uuid,w=this._bindingsByRootAndName;let I=w[y];I===void 0&&(I={},w[y]=I);for(let E=0;E!==h;++E){const R=c[E],k=R.name;let G=I[k];if(G!==void 0)++G.referenceCount,p[E]=G;else{if(G=p[E],G!==void 0){G._cacheIndex===null&&(++G.referenceCount,this._addInactiveBinding(G,y,k));continue}const N=n&&n._propertyBindings[E].binding.parsedPath;G=new uV(Hi.create(a,k,N),R.ValueTypeName,R.getValueSize()),++G.referenceCount,this._addInactiveBinding(G,y,k),p[E]=G}b[E].resultBuffer=G.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const a=(e._localRoot||this._root).uuid,c=e._clip.uuid,h=this._actionsByClip[c];this._bindAction(e,h&&h.knownActions[0]),this._addInactiveAction(e,c,a)}const n=e._propertyBindings;for(let a=0,c=n.length;a!==c;++a){const h=n[a];h.useCount++===0&&(this._lendBinding(h),h.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const n=e._propertyBindings;for(let a=0,c=n.length;a!==c;++a){const h=n[a];--h.useCount===0&&(h.restoreOriginalState(),this._takeBackBinding(h))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const n=e._cacheIndex;return n!==null&&n<this._nActiveActions}_addInactiveAction(e,n,a){const c=this._actions,h=this._actionsByClip;let p=h[n];if(p===void 0)p={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,h[n]=p;else{const b=p.knownActions;e._byClipCacheIndex=b.length,b.push(e)}e._cacheIndex=c.length,c.push(e),p.actionByRoot[a]=e}_removeInactiveAction(e){const n=this._actions,a=n[n.length-1],c=e._cacheIndex;a._cacheIndex=c,n[c]=a,n.pop(),e._cacheIndex=null;const h=e._clip.uuid,p=this._actionsByClip,b=p[h],y=b.knownActions,w=y[y.length-1],I=e._byClipCacheIndex;w._byClipCacheIndex=I,y[I]=w,y.pop(),e._byClipCacheIndex=null;const E=b.actionByRoot,R=(e._localRoot||this._root).uuid;delete E[R],y.length===0&&delete p[h],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const n=e._propertyBindings;for(let a=0,c=n.length;a!==c;++a){const h=n[a];--h.referenceCount===0&&this._removeInactiveBinding(h)}}_lendAction(e){const n=this._actions,a=e._cacheIndex,c=this._nActiveActions++,h=n[c];e._cacheIndex=c,n[c]=e,h._cacheIndex=a,n[a]=h}_takeBackAction(e){const n=this._actions,a=e._cacheIndex,c=--this._nActiveActions,h=n[c];e._cacheIndex=c,n[c]=e,h._cacheIndex=a,n[a]=h}_addInactiveBinding(e,n,a){const c=this._bindingsByRootAndName,h=this._bindings;let p=c[n];p===void 0&&(p={},c[n]=p),p[a]=e,e._cacheIndex=h.length,h.push(e)}_removeInactiveBinding(e){const n=this._bindings,a=e.binding,c=a.rootNode.uuid,h=a.path,p=this._bindingsByRootAndName,b=p[c],y=n[n.length-1],w=e._cacheIndex;y._cacheIndex=w,n[w]=y,n.pop(),delete b[h],Object.keys(b).length===0&&delete p[c]}_lendBinding(e){const n=this._bindings,a=e._cacheIndex,c=this._nActiveBindings++,h=n[c];e._cacheIndex=c,n[c]=e,h._cacheIndex=a,n[a]=h}_takeBackBinding(e){const n=this._bindings,a=e._cacheIndex,c=--this._nActiveBindings,h=n[c];e._cacheIndex=c,n[c]=e,h._cacheIndex=a,n[a]=h}_lendControlInterpolant(){const e=this._controlInterpolants,n=this._nActiveControlInterpolants++;let a=e[n];return a===void 0&&(a=new Ek(new Float32Array(2),new Float32Array(2),1,Mhe),a.__cacheIndex=n,e[n]=a),a}_takeBackControlInterpolant(e){const n=this._controlInterpolants,a=e.__cacheIndex,c=--this._nActiveControlInterpolants,h=n[c];e.__cacheIndex=c,n[c]=e,h.__cacheIndex=a,n[a]=h}clipAction(e,n,a){const c=n||this._root,h=c.uuid;let p=typeof e=="string"?Rv.findByName(c,e):e;const b=p!==null?p.uuid:e,y=this._actionsByClip[b];let w=null;if(a===void 0&&(p!==null?a=p.blendMode:a=E2),y!==void 0){const E=y.actionByRoot[h];if(E!==void 0&&E.blendMode===a)return E;w=y.knownActions[0],p===null&&(p=w._clip)}if(p===null)return null;const I=new hV(this,p,n,a);return this._bindAction(I,w),this._addInactiveAction(I,b,h),I}existingAction(e,n){const a=n||this._root,c=a.uuid,h=typeof e=="string"?Rv.findByName(a,e):e,p=h?h.uuid:e,b=this._actionsByClip[p];return b!==void 0&&b.actionByRoot[c]||null}stopAllAction(){const e=this._actions,n=this._nActiveActions;for(let a=n-1;a>=0;--a)e[a].stop();return this}update(e){e*=this.timeScale;const n=this._actions,a=this._nActiveActions,c=this.time+=e,h=Math.sign(e),p=this._accuIndex^=1;for(let w=0;w!==a;++w)n[w]._update(c,e,h,p);const b=this._bindings,y=this._nActiveBindings;for(let w=0;w!==y;++w)b[w].apply(p);return this}setTime(e){this.time=0;for(let n=0;n<this._actions.length;n++)this._actions[n].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const n=this._actions,a=e.uuid,c=this._actionsByClip,h=c[a];if(h!==void 0){const p=h.knownActions;for(let b=0,y=p.length;b!==y;++b){const w=p[b];this._deactivateAction(w);const I=w._cacheIndex,E=n[n.length-1];w._cacheIndex=null,w._byClipCacheIndex=null,E._cacheIndex=I,n[I]=E,n.pop(),this._removeInactiveBindingsForAction(w)}delete c[a]}}uncacheRoot(e){const n=e.uuid,a=this._actionsByClip;for(const p in a){const b=a[p].actionByRoot,y=b[n];y!==void 0&&(this._deactivateAction(y),this._removeInactiveAction(y))}const c=this._bindingsByRootAndName,h=c[n];if(h!==void 0)for(const p in h){const b=h[p];b.restoreOriginalState(),this._removeInactiveBinding(b)}}uncacheAction(e,n){const a=this.existingAction(e,n);a!==null&&(this._deactivateAction(a),this._removeInactiveAction(a))}}class Rhe extends S2{constructor(e=1,n=1,a=1,c={}){super(e,n,c),this.isRenderTarget3D=!0,this.depth=a,this.texture=new I2(null,e,n,a),this.texture.isRenderTargetTexture=!0}}class khe extends S2{constructor(e=1,n=1,a=1,c={}){super(e,n,c),this.isRenderTargetArray=!0,this.depth=a,this.texture=new Uv(null,e,n,a),this.texture.isRenderTargetTexture=!0}}class kk{constructor(e){this.value=e}clone(){return new kk(this.value.clone===void 0?this.value:this.value.clone())}}let Bhe=0;class Lhe extends xu{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:Bhe++}),this.name="",this.usage=xv,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const n=this.uniforms.indexOf(e);return n!==-1&&this.uniforms.splice(n,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const n=e.uniforms;this.uniforms.length=0;for(let a=0,c=n.length;a<c;a++){const h=Array.isArray(n[a])?n[a]:[n[a]];for(let p=0;p<h.length;p++)this.uniforms.push(h[p].clone())}return this}clone(){return new this.constructor().copy(this)}}class Nhe extends k2{constructor(e,n,a=1){super(e,n),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=a}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const n=super.clone(e);return n.meshPerAttribute=this.meshPerAttribute,n}toJSON(e){const n=super.toJSON(e);return n.isInstancedInterleavedBuffer=!0,n.meshPerAttribute=this.meshPerAttribute,n}}class Dhe{constructor(e,n,a,c,h){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=n,this.itemSize=a,this.elementSize=c,this.count=h,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,n){return this.type=e,this.elementSize=n,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}const DO=new Zn;class Fhe{constructor(e,n,a=0,c=1/0){this.ray=new rA(e,n),this.near=a,this.far=c,this.camera=null,this.layers=new T2,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,n){this.ray.set(e,n)}setFromCamera(e,n){n.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(n.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(n).sub(this.ray.origin).normalize(),this.camera=n):n.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(n.near+n.far)/(n.near-n.far)).unproject(n),this.ray.direction.set(0,0,-1).transformDirection(n.matrixWorld),this.camera=n):console.error("THREE.Raycaster: Unsupported camera type: "+n.type)}setFromXRController(e){return DO.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(DO),this}intersectObject(e,n=!0,a=[]){return hR(e,this,a,n),a.sort(FO),a}intersectObjects(e,n=!0,a=[]){for(let c=0,h=e.length;c<h;c++)hR(e[c],this,a,n);return a.sort(FO),a}}function FO(r,e){return r.distance-e.distance}function hR(r,e,n,a){let c=!0;if(r.layers.test(e.layers)&&r.raycast(e,n)===!1&&(c=!1),c===!0&&a===!0){const h=r.children;for(let p=0,b=h.length;p<b;p++)hR(h[p],e,n,!0)}}class Ohe{constructor(e=1,n=0,a=0){return this.radius=e,this.phi=n,this.theta=a,this}set(e,n,a){return this.radius=e,this.phi=n,this.theta=a,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=si(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,n,a){return this.radius=Math.sqrt(e*e+n*n+a*a),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,a),this.phi=Math.acos(si(n/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Ghe{constructor(e=1,n=0,a=0){return this.radius=e,this.theta=n,this.y=a,this}set(e,n,a){return this.radius=e,this.theta=n,this.y=a,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,n,a){return this.radius=Math.sqrt(e*e+a*a),this.theta=Math.atan2(e,a),this.y=n,this}clone(){return new this.constructor().copy(this)}}class Bk{constructor(e,n,a,c){Bk.prototype.isMatrix2=!0,this.elements=[1,0,0,1],e!==void 0&&this.set(e,n,a,c)}identity(){return this.set(1,0,0,1),this}fromArray(e,n=0){for(let a=0;a<4;a++)this.elements[a]=e[a+n];return this}set(e,n,a,c){const h=this.elements;return h[0]=e,h[2]=n,h[1]=a,h[3]=c,this}}const OO=new Dt;class Uhe{constructor(e=new Dt(1/0,1/0),n=new Dt(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=n}set(e,n){return this.min.copy(e),this.max.copy(n),this}setFromPoints(e){this.makeEmpty();for(let n=0,a=e.length;n<a;n++)this.expandByPoint(e[n]);return this}setFromCenterAndSize(e,n){const a=OO.copy(n).multiplyScalar(.5);return this.min.copy(e).sub(a),this.max.copy(e).add(a),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,n){return n.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y}clampPoint(e,n){return n.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,OO).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const GO=new be,CC=new be;class Phe{constructor(e=new be,n=new be){this.start=e,this.end=n}set(e,n){return this.start.copy(e),this.end.copy(n),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,n){return this.delta(n).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,n){GO.subVectors(e,this.start),CC.subVectors(this.end,this.start);const a=CC.dot(CC);let h=CC.dot(GO)/a;return n&&(h=si(h,0,1)),h}closestPointToPoint(e,n,a){const c=this.closestPointToPointParameter(e,n);return this.delta(a).multiplyScalar(c).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const UO=new be;class zhe extends Qi{constructor(e,n){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=n,this.type="SpotLightHelper";const a=new gi,c=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let p=0,b=1,y=32;p<y;p++,b++){const w=p/y*Math.PI*2,I=b/y*Math.PI*2;c.push(Math.cos(w),Math.sin(w),1,Math.cos(I),Math.sin(I),1)}a.setAttribute("position",new Tn(c,3));const h=new so({fog:!1,toneMapped:!1});this.cone=new wu(a,h),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const e=this.light.distance?this.light.distance:1e3,n=e*Math.tan(this.light.angle);this.cone.scale.set(n,n,e),UO.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(UO),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const zd=new be,EC=new Zn,$M=new Zn;class Vhe extends wu{constructor(e){const n=dV(e),a=new gi,c=[],h=[],p=new pn(0,0,1),b=new pn(0,1,0);for(let w=0;w<n.length;w++){const I=n[w];I.parent&&I.parent.isBone&&(c.push(0,0,0),c.push(0,0,0),h.push(p.r,p.g,p.b),h.push(b.r,b.g,b.b))}a.setAttribute("position",new Tn(c,3)),a.setAttribute("color",new Tn(h,3));const y=new so({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(a,y),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=n,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const n=this.bones,a=this.geometry,c=a.getAttribute("position");$M.copy(this.root.matrixWorld).invert();for(let h=0,p=0;h<n.length;h++){const b=n[h];b.parent&&b.parent.isBone&&(EC.multiplyMatrices($M,b.matrixWorld),zd.setFromMatrixPosition(EC),c.setXYZ(p,zd.x,zd.y,zd.z),EC.multiplyMatrices($M,b.parent.matrixWorld),zd.setFromMatrixPosition(EC),c.setXYZ(p+1,zd.x,zd.y,zd.z),p+=2)}a.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function dV(r){const e=[];r.isBone===!0&&e.push(r);for(let n=0;n<r.children.length;n++)e.push.apply(e,dV(r.children[n]));return e}class Whe extends Er{constructor(e,n,a){const c=new Hv(n,4,2),h=new sf({wireframe:!0,fog:!1,toneMapped:!1});super(c,h),this.light=e,this.color=a,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const Hhe=new be,PO=new pn,zO=new pn;class Xhe extends Qi{constructor(e,n,a){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=a,this.type="HemisphereLightHelper";const c=new Wv(n);c.rotateY(Math.PI*.5),this.material=new sf({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const h=c.getAttribute("position"),p=new Float32Array(h.count*3);c.setAttribute("color",new bs(p,3)),this.add(new Er(c,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const n=e.geometry.getAttribute("color");PO.copy(this.light.color),zO.copy(this.light.groundColor);for(let a=0,c=n.count;a<c;a++){const h=a<c/2?PO:zO;n.setXYZ(a,h.r,h.g,h.b)}n.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(Hhe.setFromMatrixPosition(this.light.matrixWorld).negate())}}class Qhe extends wu{constructor(e=10,n=10,a=4473924,c=8947848){a=new pn(a),c=new pn(c);const h=n/2,p=e/n,b=e/2,y=[],w=[];for(let R=0,k=0,G=-b;R<=n;R++,G+=p){y.push(-b,0,G,b,0,G),y.push(G,0,-b,G,0,b);const N=R===h?a:c;N.toArray(w,k),k+=3,N.toArray(w,k),k+=3,N.toArray(w,k),k+=3,N.toArray(w,k),k+=3}const I=new gi;I.setAttribute("position",new Tn(y,3)),I.setAttribute("color",new Tn(w,3));const E=new so({vertexColors:!0,toneMapped:!1});super(I,E),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class Khe extends wu{constructor(e=10,n=16,a=8,c=64,h=4473924,p=8947848){h=new pn(h),p=new pn(p);const b=[],y=[];if(n>1)for(let E=0;E<n;E++){const R=E/n*(Math.PI*2),k=Math.sin(R)*e,G=Math.cos(R)*e;b.push(0,0,0),b.push(k,0,G);const N=E&1?h:p;y.push(N.r,N.g,N.b),y.push(N.r,N.g,N.b)}for(let E=0;E<a;E++){const R=E&1?h:p,k=e-e/a*E;for(let G=0;G<c;G++){let N=G/c*(Math.PI*2),O=Math.sin(N)*k,D=Math.cos(N)*k;b.push(O,0,D),y.push(R.r,R.g,R.b),N=(G+1)/c*(Math.PI*2),O=Math.sin(N)*k,D=Math.cos(N)*k,b.push(O,0,D),y.push(R.r,R.g,R.b)}}const w=new gi;w.setAttribute("position",new Tn(b,3)),w.setAttribute("color",new Tn(y,3));const I=new so({vertexColors:!0,toneMapped:!1});super(w,I),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const VO=new be,SC=new be,WO=new be;class Zhe extends Qi{constructor(e,n,a){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=a,this.type="DirectionalLightHelper",n===void 0&&(n=1);let c=new gi;c.setAttribute("position",new Tn([-n,n,0,n,n,0,n,-n,0,-n,-n,0,-n,n,0],3));const h=new so({fog:!1,toneMapped:!1});this.lightPlane=new Jd(c,h),this.add(this.lightPlane),c=new gi,c.setAttribute("position",new Tn([0,0,0,0,0,1],3)),this.targetLine=new Jd(c,h),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),VO.setFromMatrixPosition(this.light.matrixWorld),SC.setFromMatrixPosition(this.light.target.matrixWorld),WO.subVectors(SC,VO),this.lightPlane.lookAt(SC),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(SC),this.targetLine.scale.z=WO.length()}}const IC=new be,tr=new M2;class $he extends wu{constructor(e){const n=new gi,a=new so({color:16777215,vertexColors:!0,toneMapped:!1}),c=[],h=[],p={};b("n1","n2"),b("n2","n4"),b("n4","n3"),b("n3","n1"),b("f1","f2"),b("f2","f4"),b("f4","f3"),b("f3","f1"),b("n1","f1"),b("n2","f2"),b("n3","f3"),b("n4","f4"),b("p","n1"),b("p","n2"),b("p","n3"),b("p","n4"),b("u1","u2"),b("u2","u3"),b("u3","u1"),b("c","t"),b("p","c"),b("cn1","cn2"),b("cn3","cn4"),b("cf1","cf2"),b("cf3","cf4");function b(G,N){y(G),y(N)}function y(G){c.push(0,0,0),h.push(0,0,0),p[G]===void 0&&(p[G]=[]),p[G].push(c.length/3-1)}n.setAttribute("position",new Tn(c,3)),n.setAttribute("color",new Tn(h,3)),super(n,a),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=p,this.update();const w=new pn(16755200),I=new pn(16711680),E=new pn(43775),R=new pn(16777215),k=new pn(3355443);this.setColors(w,I,E,R,k)}setColors(e,n,a,c,h){const b=this.geometry.getAttribute("color");b.setXYZ(0,e.r,e.g,e.b),b.setXYZ(1,e.r,e.g,e.b),b.setXYZ(2,e.r,e.g,e.b),b.setXYZ(3,e.r,e.g,e.b),b.setXYZ(4,e.r,e.g,e.b),b.setXYZ(5,e.r,e.g,e.b),b.setXYZ(6,e.r,e.g,e.b),b.setXYZ(7,e.r,e.g,e.b),b.setXYZ(8,e.r,e.g,e.b),b.setXYZ(9,e.r,e.g,e.b),b.setXYZ(10,e.r,e.g,e.b),b.setXYZ(11,e.r,e.g,e.b),b.setXYZ(12,e.r,e.g,e.b),b.setXYZ(13,e.r,e.g,e.b),b.setXYZ(14,e.r,e.g,e.b),b.setXYZ(15,e.r,e.g,e.b),b.setXYZ(16,e.r,e.g,e.b),b.setXYZ(17,e.r,e.g,e.b),b.setXYZ(18,e.r,e.g,e.b),b.setXYZ(19,e.r,e.g,e.b),b.setXYZ(20,e.r,e.g,e.b),b.setXYZ(21,e.r,e.g,e.b),b.setXYZ(22,e.r,e.g,e.b),b.setXYZ(23,e.r,e.g,e.b),b.setXYZ(24,n.r,n.g,n.b),b.setXYZ(25,n.r,n.g,n.b),b.setXYZ(26,n.r,n.g,n.b),b.setXYZ(27,n.r,n.g,n.b),b.setXYZ(28,n.r,n.g,n.b),b.setXYZ(29,n.r,n.g,n.b),b.setXYZ(30,n.r,n.g,n.b),b.setXYZ(31,n.r,n.g,n.b),b.setXYZ(32,a.r,a.g,a.b),b.setXYZ(33,a.r,a.g,a.b),b.setXYZ(34,a.r,a.g,a.b),b.setXYZ(35,a.r,a.g,a.b),b.setXYZ(36,a.r,a.g,a.b),b.setXYZ(37,a.r,a.g,a.b),b.setXYZ(38,c.r,c.g,c.b),b.setXYZ(39,c.r,c.g,c.b),b.setXYZ(40,h.r,h.g,h.b),b.setXYZ(41,h.r,h.g,h.b),b.setXYZ(42,h.r,h.g,h.b),b.setXYZ(43,h.r,h.g,h.b),b.setXYZ(44,h.r,h.g,h.b),b.setXYZ(45,h.r,h.g,h.b),b.setXYZ(46,h.r,h.g,h.b),b.setXYZ(47,h.r,h.g,h.b),b.setXYZ(48,h.r,h.g,h.b),b.setXYZ(49,h.r,h.g,h.b),b.needsUpdate=!0}update(){const e=this.geometry,n=this.pointMap,a=1,c=1;tr.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);const h=this.camera.coordinateSystem===gc?-1:0;cr("c",n,e,tr,0,0,h),cr("t",n,e,tr,0,0,1),cr("n1",n,e,tr,-1,-1,h),cr("n2",n,e,tr,a,-1,h),cr("n3",n,e,tr,-1,c,h),cr("n4",n,e,tr,a,c,h),cr("f1",n,e,tr,-1,-1,1),cr("f2",n,e,tr,a,-1,1),cr("f3",n,e,tr,-1,c,1),cr("f4",n,e,tr,a,c,1),cr("u1",n,e,tr,a*.7,c*1.1,h),cr("u2",n,e,tr,-1*.7,c*1.1,h),cr("u3",n,e,tr,0,c*2,h),cr("cf1",n,e,tr,-1,0,1),cr("cf2",n,e,tr,a,0,1),cr("cf3",n,e,tr,0,-1,1),cr("cf4",n,e,tr,0,c,1),cr("cn1",n,e,tr,-1,0,h),cr("cn2",n,e,tr,a,0,h),cr("cn3",n,e,tr,0,-1,h),cr("cn4",n,e,tr,0,c,h),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function cr(r,e,n,a,c,h,p){IC.set(c,h,p).unproject(a);const b=e[r];if(b!==void 0){const y=n.getAttribute("position");for(let w=0,I=b.length;w<I;w++)y.setXYZ(b[w],IC.x,IC.y,IC.z)}}const TC=new io;class Yhe extends wu{constructor(e,n=16776960){const a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),c=new Float32Array(24),h=new gi;h.setIndex(new bs(a,1)),h.setAttribute("position",new bs(c,3)),super(h,new so({color:n,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&TC.setFromObject(this.object),TC.isEmpty())return;const n=TC.min,a=TC.max,c=this.geometry.attributes.position,h=c.array;h[0]=a.x,h[1]=a.y,h[2]=a.z,h[3]=n.x,h[4]=a.y,h[5]=a.z,h[6]=n.x,h[7]=n.y,h[8]=a.z,h[9]=a.x,h[10]=n.y,h[11]=a.z,h[12]=a.x,h[13]=a.y,h[14]=n.z,h[15]=n.x,h[16]=a.y,h[17]=n.z,h[18]=n.x,h[19]=n.y,h[20]=n.z,h[21]=a.x,h[22]=n.y,h[23]=n.z,c.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,n){return super.copy(e,n),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class jhe extends wu{constructor(e,n=16776960){const a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),c=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],h=new gi;h.setIndex(new bs(a,1)),h.setAttribute("position",new Tn(c,3)),super(h,new so({color:n,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const n=this.box;n.isEmpty()||(n.getCenter(this.position),n.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class qhe extends Jd{constructor(e,n=1,a=16776960){const c=a,h=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],p=new gi;p.setAttribute("position",new Tn(h,3)),p.computeBoundingSphere(),super(p,new so({color:c,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=n;const b=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],y=new gi;y.setAttribute("position",new Tn(b,3)),y.computeBoundingSphere(),this.add(new Er(y,new sf({color:c,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const HO=new be;let MC,YM;class Jhe extends Qi{constructor(e=new be(0,0,1),n=new be(0,0,0),a=1,c=16776960,h=a*.2,p=h*.2){super(),this.type="ArrowHelper",MC===void 0&&(MC=new gi,MC.setAttribute("position",new Tn([0,0,0,0,1,0],3)),YM=new aA(0,.5,1,5,1),YM.translate(0,-.5,0)),this.position.copy(n),this.line=new Jd(MC,new so({color:c,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Er(YM,new sf({color:c,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(a,h,p)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{HO.set(e.z,0,-e.x).normalize();const n=Math.acos(e.y);this.quaternion.setFromAxisAngle(HO,n)}}setLength(e,n=e*.2,a=n*.2){this.line.scale.set(1,Math.max(1e-4,e-n),1),this.line.updateMatrix(),this.cone.scale.set(a,n,a),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class ede extends wu{constructor(e=1){const n=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],a=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],c=new gi;c.setAttribute("position",new Tn(n,3)),c.setAttribute("color",new Tn(a,3));const h=new so({vertexColors:!0,toneMapped:!1});super(c,h),this.type="AxesHelper"}setColors(e,n,a){const c=new pn,h=this.geometry.attributes.color.array;return c.set(e),c.toArray(h,0),c.toArray(h,3),c.set(n),c.toArray(h,6),c.toArray(h,9),c.set(a),c.toArray(h,12),c.toArray(h,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class tde{constructor(){this.type="ShapePath",this.color=new pn,this.subPaths=[],this.currentPath=null}moveTo(e,n){return this.currentPath=new Ev,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,n),this}lineTo(e,n){return this.currentPath.lineTo(e,n),this}quadraticCurveTo(e,n,a,c){return this.currentPath.quadraticCurveTo(e,n,a,c),this}bezierCurveTo(e,n,a,c,h,p){return this.currentPath.bezierCurveTo(e,n,a,c,h,p),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function n(D){const W=[];for(let H=0,K=D.length;H<K;H++){const j=D[H],J=new Em;J.curves=j.curves,W.push(J)}return W}function a(D,W){const H=W.length;let K=!1;for(let j=H-1,J=0;J<H;j=J++){let ee=W[j],re=W[J],Y=re.x-ee.x,ie=re.y-ee.y;if(Math.abs(ie)>Number.EPSILON){if(ie<0&&(ee=W[J],Y=-Y,re=W[j],ie=-ie),D.y<ee.y||D.y>re.y)continue;if(D.y===ee.y){if(D.x===ee.x)return!0}else{const ue=ie*(D.x-ee.x)-Y*(D.y-ee.y);if(ue===0)return!0;if(ue<0)continue;K=!K}}else{if(D.y!==ee.y)continue;if(re.x<=D.x&&D.x<=ee.x||ee.x<=D.x&&D.x<=re.x)return!0}}return K}const c=yu.isClockWise,h=this.subPaths;if(h.length===0)return[];let p,b,y;const w=[];if(h.length===1)return b=h[0],y=new Em,y.curves=b.curves,w.push(y),w;let I=!c(h[0].getPoints());I=e?!I:I;const E=[],R=[];let k=[],G=0,N;R[G]=void 0,k[G]=[];for(let D=0,W=h.length;D<W;D++)b=h[D],N=b.getPoints(),p=c(N),p=e?!p:p,p?(!I&&R[G]&&G++,R[G]={s:new Em,p:N},R[G].s.curves=b.curves,I&&G++,k[G]=[]):k[G].push({h:b,p:N[0]});if(!R[0])return n(h);if(R.length>1){let D=!1,W=0;for(let H=0,K=R.length;H<K;H++)E[H]=[];for(let H=0,K=R.length;H<K;H++){const j=k[H];for(let J=0;J<j.length;J++){const ee=j[J];let re=!0;for(let Y=0;Y<R.length;Y++)a(ee.p,R[Y].p)&&(H!==Y&&W++,re?(re=!1,E[Y].push(ee)):D=!0);re&&E[H].push(ee)}}W>0&&D===!1&&(k=E)}let O;for(let D=0,W=R.length;D<W;D++){y=R[D].s,w.push(y),O=k[D];for(let H=0,K=O.length;H<K;H++)y.holes.push(O[H].h)}return w}}class nde extends xu{constructor(e,n=null){super(),this.object=e,this.domElement=n,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(){}disconnect(){}dispose(){}update(){}}function ide(r,e){const n=r.image&&r.image.width?r.image.width/r.image.height:1;return n>e?(r.repeat.x=1,r.repeat.y=n/e,r.offset.x=0,r.offset.y=(1-r.repeat.y)/2):(r.repeat.x=e/n,r.repeat.y=1,r.offset.x=(1-r.repeat.x)/2,r.offset.y=0),r}function sde(r,e){const n=r.image&&r.image.width?r.image.width/r.image.height:1;return n>e?(r.repeat.x=e/n,r.repeat.y=1,r.offset.x=(1-r.repeat.x)/2,r.offset.y=0):(r.repeat.x=1,r.repeat.y=n/e,r.offset.x=0,r.offset.y=(1-r.repeat.y)/2),r}function rde(r){return r.repeat.x=1,r.repeat.y=1,r.offset.x=0,r.offset.y=0,r}function dR(r,e,n,a){const c=ade(a);switch(n){case JR:return r*e;case tk:return r*e;case nk:return r*e*2;case x2:return r*e/c.components*c.byteLength;case Gv:return r*e/c.components*c.byteLength;case ik:return r*e*2/c.components*c.byteLength;case w2:return r*e*2/c.components*c.byteLength;case ek:return r*e*3/c.components*c.byteLength;case to:return r*e*4/c.components*c.byteLength;case C2:return r*e*4/c.components*c.byteLength;case sv:case rv:return Math.floor((r+3)/4)*Math.floor((e+3)/4)*8;case av:case ov:return Math.floor((r+3)/4)*Math.floor((e+3)/4)*16;case SE:case TE:return Math.max(r,16)*Math.max(e,8)/4;case EE:case IE:return Math.max(r,8)*Math.max(e,8)/2;case ME:case _E:return Math.floor((r+3)/4)*Math.floor((e+3)/4)*8;case RE:return Math.floor((r+3)/4)*Math.floor((e+3)/4)*16;case kE:return Math.floor((r+3)/4)*Math.floor((e+3)/4)*16;case BE:return Math.floor((r+4)/5)*Math.floor((e+3)/4)*16;case LE:return Math.floor((r+4)/5)*Math.floor((e+4)/5)*16;case NE:return Math.floor((r+5)/6)*Math.floor((e+4)/5)*16;case DE:return Math.floor((r+5)/6)*Math.floor((e+5)/6)*16;case FE:return Math.floor((r+7)/8)*Math.floor((e+4)/5)*16;case OE:return Math.floor((r+7)/8)*Math.floor((e+5)/6)*16;case GE:return Math.floor((r+7)/8)*Math.floor((e+7)/8)*16;case UE:return Math.floor((r+9)/10)*Math.floor((e+4)/5)*16;case PE:return Math.floor((r+9)/10)*Math.floor((e+5)/6)*16;case zE:return Math.floor((r+9)/10)*Math.floor((e+7)/8)*16;case VE:return Math.floor((r+9)/10)*Math.floor((e+9)/10)*16;case WE:return Math.floor((r+11)/12)*Math.floor((e+9)/10)*16;case HE:return Math.floor((r+11)/12)*Math.floor((e+11)/12)*16;case lv:case XE:case QE:return Math.ceil(r/4)*Math.ceil(e/4)*16;case sk:case KE:return Math.ceil(r/4)*Math.ceil(e/4)*8;case ZE:case $E:return Math.ceil(r/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${n} format.`)}function ade(r){switch(r){case vu:case YR:return{byteLength:1,components:1};case q0:case jR:case sA:return{byteLength:2,components:1};case y2:case v2:return{byteLength:2,components:4};case Rh:case b2:case qa:return{byteLength:4,components:1};case qR:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${r}.`)}const ode={contain:ide,cover:sde,fill:rde,getByteLength:dR};typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:g2}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=g2);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function fV(){let r=null,e=!1,n=null,a=null;function c(h,p){n(h,p),a=r.requestAnimationFrame(c)}return{start:function(){e!==!0&&n!==null&&(a=r.requestAnimationFrame(c),e=!0)},stop:function(){r.cancelAnimationFrame(a),e=!1},setAnimationLoop:function(h){n=h},setContext:function(h){r=h}}}function lde(r){const e=new WeakMap;function n(b,y){const w=b.array,I=b.usage,E=w.byteLength,R=r.createBuffer();r.bindBuffer(y,R),r.bufferData(y,w,I),b.onUploadCallback();let k;if(w instanceof Float32Array)k=r.FLOAT;else if(w instanceof Uint16Array)b.isFloat16BufferAttribute?k=r.HALF_FLOAT:k=r.UNSIGNED_SHORT;else if(w instanceof Int16Array)k=r.SHORT;else if(w instanceof Uint32Array)k=r.UNSIGNED_INT;else if(w instanceof Int32Array)k=r.INT;else if(w instanceof Int8Array)k=r.BYTE;else if(w instanceof Uint8Array)k=r.UNSIGNED_BYTE;else if(w instanceof Uint8ClampedArray)k=r.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+w);return{buffer:R,type:k,bytesPerElement:w.BYTES_PER_ELEMENT,version:b.version,size:E}}function a(b,y,w){const I=y.array,E=y.updateRanges;if(r.bindBuffer(w,b),E.length===0)r.bufferSubData(w,0,I);else{E.sort((k,G)=>k.start-G.start);let R=0;for(let k=1;k<E.length;k++){const G=E[R],N=E[k];N.start<=G.start+G.count+1?G.count=Math.max(G.count,N.start+N.count-G.start):(++R,E[R]=N)}E.length=R+1;for(let k=0,G=E.length;k<G;k++){const N=E[k];r.bufferSubData(w,N.start*I.BYTES_PER_ELEMENT,I,N.start,N.count)}y.clearUpdateRanges()}y.onUploadCallback()}function c(b){return b.isInterleavedBufferAttribute&&(b=b.data),e.get(b)}function h(b){b.isInterleavedBufferAttribute&&(b=b.data);const y=e.get(b);y&&(r.deleteBuffer(y.buffer),e.delete(b))}function p(b,y){if(b.isInterleavedBufferAttribute&&(b=b.data),b.isGLBufferAttribute){const I=e.get(b);(!I||I.version<b.version)&&e.set(b,{buffer:b.buffer,type:b.type,bytesPerElement:b.elementSize,version:b.version});return}const w=e.get(b);if(w===void 0)e.set(b,n(b,y));else if(w.version<b.version){if(w.size!==b.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");a(w.buffer,b,y),w.version=b.version}}return{get:c,remove:h,update:p}}var cde=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,ude=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,hde=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,dde=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,fde=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,pde=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,mde=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,gde=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Ade=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,bde=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,yde=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,vde=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,xde=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,wde=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,Cde=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Ede=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,Sde=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,Ide=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Tde=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Mde=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,_de=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Rde=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,kde=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,Bde=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,Lde=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Nde=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Dde=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Fde=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,Ode=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Gde=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Ude="gl_FragColor = linearToOutputTexel( gl_FragColor );",Pde=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,zde=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Vde=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Wde=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Hde=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Xde=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Qde=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Kde=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Zde=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,$de=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Yde=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,jde=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,qde=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Jde=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,efe=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,tfe=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,nfe=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,ife=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,sfe=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,rfe=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,afe=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,ofe=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lfe=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,cfe=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,ufe=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,hfe=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,dfe=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,ffe=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,pfe=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,mfe=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,gfe=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Afe=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,bfe=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,yfe=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,vfe=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,xfe=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,wfe=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,Cfe=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,Efe=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,Sfe=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,Ife=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,Tfe=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,Mfe=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,_fe=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Rfe=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,kfe=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,Bfe=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,Lfe=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,Nfe=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,Dfe=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,Ffe=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Ofe=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,Gfe=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Ufe=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Pfe=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,zfe=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Vfe=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Wfe=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Hfe=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,Xfe=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Qfe=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,Kfe=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Zfe=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,$fe=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,Yfe=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,jfe=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,qfe=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Jfe=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,epe=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tpe=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,npe=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,ipe=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,spe=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,rpe=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,ape=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,ope=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const lpe=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,cpe=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,upe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,hpe=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,dpe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fpe=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,ppe=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,mpe=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,gpe=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,Ape=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,bpe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,ype=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vpe=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,xpe=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,wpe=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Cpe=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Epe=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Spe=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ipe=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Tpe=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Mpe=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,_pe=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Rpe=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,kpe=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Bpe=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Lpe=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Npe=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Dpe=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Fpe=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Ope=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Gpe=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Upe=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Ppe=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,zpe=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,mi={alphahash_fragment:cde,alphahash_pars_fragment:ude,alphamap_fragment:hde,alphamap_pars_fragment:dde,alphatest_fragment:fde,alphatest_pars_fragment:pde,aomap_fragment:mde,aomap_pars_fragment:gde,batching_pars_vertex:Ade,batching_vertex:bde,begin_vertex:yde,beginnormal_vertex:vde,bsdfs:xde,iridescence_fragment:wde,bumpmap_pars_fragment:Cde,clipping_planes_fragment:Ede,clipping_planes_pars_fragment:Sde,clipping_planes_pars_vertex:Ide,clipping_planes_vertex:Tde,color_fragment:Mde,color_pars_fragment:_de,color_pars_vertex:Rde,color_vertex:kde,common:Bde,cube_uv_reflection_fragment:Lde,defaultnormal_vertex:Nde,displacementmap_pars_vertex:Dde,displacementmap_vertex:Fde,emissivemap_fragment:Ode,emissivemap_pars_fragment:Gde,colorspace_fragment:Ude,colorspace_pars_fragment:Pde,envmap_fragment:zde,envmap_common_pars_fragment:Vde,envmap_pars_fragment:Wde,envmap_pars_vertex:Hde,envmap_physical_pars_fragment:tfe,envmap_vertex:Xde,fog_vertex:Qde,fog_pars_vertex:Kde,fog_fragment:Zde,fog_pars_fragment:$de,gradientmap_pars_fragment:Yde,lightmap_pars_fragment:jde,lights_lambert_fragment:qde,lights_lambert_pars_fragment:Jde,lights_pars_begin:efe,lights_toon_fragment:nfe,lights_toon_pars_fragment:ife,lights_phong_fragment:sfe,lights_phong_pars_fragment:rfe,lights_physical_fragment:afe,lights_physical_pars_fragment:ofe,lights_fragment_begin:lfe,lights_fragment_maps:cfe,lights_fragment_end:ufe,logdepthbuf_fragment:hfe,logdepthbuf_pars_fragment:dfe,logdepthbuf_pars_vertex:ffe,logdepthbuf_vertex:pfe,map_fragment:mfe,map_pars_fragment:gfe,map_particle_fragment:Afe,map_particle_pars_fragment:bfe,metalnessmap_fragment:yfe,metalnessmap_pars_fragment:vfe,morphinstance_vertex:xfe,morphcolor_vertex:wfe,morphnormal_vertex:Cfe,morphtarget_pars_vertex:Efe,morphtarget_vertex:Sfe,normal_fragment_begin:Ife,normal_fragment_maps:Tfe,normal_pars_fragment:Mfe,normal_pars_vertex:_fe,normal_vertex:Rfe,normalmap_pars_fragment:kfe,clearcoat_normal_fragment_begin:Bfe,clearcoat_normal_fragment_maps:Lfe,clearcoat_pars_fragment:Nfe,iridescence_pars_fragment:Dfe,opaque_fragment:Ffe,packing:Ofe,premultiplied_alpha_fragment:Gfe,project_vertex:Ufe,dithering_fragment:Pfe,dithering_pars_fragment:zfe,roughnessmap_fragment:Vfe,roughnessmap_pars_fragment:Wfe,shadowmap_pars_fragment:Hfe,shadowmap_pars_vertex:Xfe,shadowmap_vertex:Qfe,shadowmask_pars_fragment:Kfe,skinbase_vertex:Zfe,skinning_pars_vertex:$fe,skinning_vertex:Yfe,skinnormal_vertex:jfe,specularmap_fragment:qfe,specularmap_pars_fragment:Jfe,tonemapping_fragment:epe,tonemapping_pars_fragment:tpe,transmission_fragment:npe,transmission_pars_fragment:ipe,uv_pars_fragment:spe,uv_pars_vertex:rpe,uv_vertex:ape,worldpos_vertex:ope,background_vert:lpe,background_frag:cpe,backgroundCube_vert:upe,backgroundCube_frag:hpe,cube_vert:dpe,cube_frag:fpe,depth_vert:ppe,depth_frag:mpe,distanceRGBA_vert:gpe,distanceRGBA_frag:Ape,equirect_vert:bpe,equirect_frag:ype,linedashed_vert:vpe,linedashed_frag:xpe,meshbasic_vert:wpe,meshbasic_frag:Cpe,meshlambert_vert:Epe,meshlambert_frag:Spe,meshmatcap_vert:Ipe,meshmatcap_frag:Tpe,meshnormal_vert:Mpe,meshnormal_frag:_pe,meshphong_vert:Rpe,meshphong_frag:kpe,meshphysical_vert:Bpe,meshphysical_frag:Lpe,meshtoon_vert:Npe,meshtoon_frag:Dpe,points_vert:Fpe,points_frag:Ope,shadow_vert:Gpe,shadow_frag:Upe,sprite_vert:Ppe,sprite_frag:zpe},an={common:{diffuse:{value:new pn(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new ii},alphaMap:{value:null},alphaMapTransform:{value:new ii},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new ii}},envmap:{envMap:{value:null},envMapRotation:{value:new ii},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new ii}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new ii}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new ii},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new ii},normalScale:{value:new Dt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new ii},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new ii}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new ii}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new ii}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new pn(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new pn(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new ii},alphaTest:{value:0},uvTransform:{value:new ii}},sprite:{diffuse:{value:new pn(16777215)},opacity:{value:1},center:{value:new Dt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new ii},alphaMap:{value:null},alphaMapTransform:{value:new ii},alphaTest:{value:0}}},pc={basic:{uniforms:Ya([an.common,an.specularmap,an.envmap,an.aomap,an.lightmap,an.fog]),vertexShader:mi.meshbasic_vert,fragmentShader:mi.meshbasic_frag},lambert:{uniforms:Ya([an.common,an.specularmap,an.envmap,an.aomap,an.lightmap,an.emissivemap,an.bumpmap,an.normalmap,an.displacementmap,an.fog,an.lights,{emissive:{value:new pn(0)}}]),vertexShader:mi.meshlambert_vert,fragmentShader:mi.meshlambert_frag},phong:{uniforms:Ya([an.common,an.specularmap,an.envmap,an.aomap,an.lightmap,an.emissivemap,an.bumpmap,an.normalmap,an.displacementmap,an.fog,an.lights,{emissive:{value:new pn(0)},specular:{value:new pn(1118481)},shininess:{value:30}}]),vertexShader:mi.meshphong_vert,fragmentShader:mi.meshphong_frag},standard:{uniforms:Ya([an.common,an.envmap,an.aomap,an.lightmap,an.emissivemap,an.bumpmap,an.normalmap,an.displacementmap,an.roughnessmap,an.metalnessmap,an.fog,an.lights,{emissive:{value:new pn(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:mi.meshphysical_vert,fragmentShader:mi.meshphysical_frag},toon:{uniforms:Ya([an.common,an.aomap,an.lightmap,an.emissivemap,an.bumpmap,an.normalmap,an.displacementmap,an.gradientmap,an.fog,an.lights,{emissive:{value:new pn(0)}}]),vertexShader:mi.meshtoon_vert,fragmentShader:mi.meshtoon_frag},matcap:{uniforms:Ya([an.common,an.bumpmap,an.normalmap,an.displacementmap,an.fog,{matcap:{value:null}}]),vertexShader:mi.meshmatcap_vert,fragmentShader:mi.meshmatcap_frag},points:{uniforms:Ya([an.points,an.fog]),vertexShader:mi.points_vert,fragmentShader:mi.points_frag},dashed:{uniforms:Ya([an.common,an.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:mi.linedashed_vert,fragmentShader:mi.linedashed_frag},depth:{uniforms:Ya([an.common,an.displacementmap]),vertexShader:mi.depth_vert,fragmentShader:mi.depth_frag},normal:{uniforms:Ya([an.common,an.bumpmap,an.normalmap,an.displacementmap,{opacity:{value:1}}]),vertexShader:mi.meshnormal_vert,fragmentShader:mi.meshnormal_frag},sprite:{uniforms:Ya([an.sprite,an.fog]),vertexShader:mi.sprite_vert,fragmentShader:mi.sprite_frag},background:{uniforms:{uvTransform:{value:new ii},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:mi.background_vert,fragmentShader:mi.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new ii}},vertexShader:mi.backgroundCube_vert,fragmentShader:mi.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:mi.cube_vert,fragmentShader:mi.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:mi.equirect_vert,fragmentShader:mi.equirect_frag},distanceRGBA:{uniforms:Ya([an.common,an.displacementmap,{referencePosition:{value:new be},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:mi.distanceRGBA_vert,fragmentShader:mi.distanceRGBA_frag},shadow:{uniforms:Ya([an.lights,an.fog,{color:{value:new pn(0)},opacity:{value:1}}]),vertexShader:mi.shadow_vert,fragmentShader:mi.shadow_frag}};pc.physical={uniforms:Ya([pc.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new ii},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new ii},clearcoatNormalScale:{value:new Dt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new ii},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new ii},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new ii},sheen:{value:0},sheenColor:{value:new pn(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new ii},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new ii},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new ii},transmissionSamplerSize:{value:new Dt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new ii},attenuationDistance:{value:0},attenuationColor:{value:new pn(0)},specularColor:{value:new pn(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new ii},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new ii},anisotropyVector:{value:new Dt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new ii}}]),vertexShader:mi.meshphysical_vert,fragmentShader:mi.meshphysical_frag};const _C={r:0,b:0,g:0},sm=new el,Vpe=new Zn;function Wpe(r,e,n,a,c,h,p){const b=new pn(0);let y=h===!0?0:1,w,I,E=null,R=0,k=null;function G(H){let K=H.isScene===!0?H.background:null;return K&&K.isTexture&&(K=(H.backgroundBlurriness>0?n:e).get(K)),K}function N(H){let K=!1;const j=G(H);j===null?D(b,y):j&&j.isColor&&(D(j,1),K=!0);const J=r.xr.getEnvironmentBlendMode();J==="additive"?a.buffers.color.setClear(0,0,0,1,p):J==="alpha-blend"&&a.buffers.color.setClear(0,0,0,0,p),(r.autoClear||K)&&(a.buffers.depth.setTest(!0),a.buffers.depth.setMask(!0),a.buffers.color.setMask(!0),r.clear(r.autoClearColor,r.autoClearDepth,r.autoClearStencil))}function O(H,K){const j=G(K);j&&(j.isCubeTexture||j.mapping===iA)?(I===void 0&&(I=new Er(new Rm(1e4,1e4,1e4),new bc({name:"BackgroundCubeMaterial",uniforms:eA(pc.backgroundCube.uniforms),vertexShader:pc.backgroundCube.vertexShader,fragmentShader:pc.backgroundCube.fragmentShader,side:no,depthTest:!1,depthWrite:!1,fog:!1})),I.geometry.deleteAttribute("normal"),I.geometry.deleteAttribute("uv"),I.onBeforeRender=function(J,ee,re){this.matrixWorld.copyPosition(re.matrixWorld)},Object.defineProperty(I.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),c.update(I)),sm.copy(K.backgroundRotation),sm.x*=-1,sm.y*=-1,sm.z*=-1,j.isCubeTexture&&j.isRenderTargetTexture===!1&&(sm.y*=-1,sm.z*=-1),I.material.uniforms.envMap.value=j,I.material.uniforms.flipEnvMap.value=j.isCubeTexture&&j.isRenderTargetTexture===!1?-1:1,I.material.uniforms.backgroundBlurriness.value=K.backgroundBlurriness,I.material.uniforms.backgroundIntensity.value=K.backgroundIntensity,I.material.uniforms.backgroundRotation.value.setFromMatrix4(Vpe.makeRotationFromEuler(sm)),I.material.toneMapped=zi.getTransfer(j.colorSpace)!==hs,(E!==j||R!==j.version||k!==r.toneMapping)&&(I.material.needsUpdate=!0,E=j,R=j.version,k=r.toneMapping),I.layers.enableAll(),H.unshift(I,I.geometry,I.material,0,0,null)):j&&j.isTexture&&(w===void 0&&(w=new Er(new oA(2,2),new bc({name:"BackgroundMaterial",uniforms:eA(pc.background.uniforms),vertexShader:pc.background.vertexShader,fragmentShader:pc.background.fragmentShader,side:Mh,depthTest:!1,depthWrite:!1,fog:!1})),w.geometry.deleteAttribute("normal"),Object.defineProperty(w.material,"map",{get:function(){return this.uniforms.t2D.value}}),c.update(w)),w.material.uniforms.t2D.value=j,w.material.uniforms.backgroundIntensity.value=K.backgroundIntensity,w.material.toneMapped=zi.getTransfer(j.colorSpace)!==hs,j.matrixAutoUpdate===!0&&j.updateMatrix(),w.material.uniforms.uvTransform.value.copy(j.matrix),(E!==j||R!==j.version||k!==r.toneMapping)&&(w.material.needsUpdate=!0,E=j,R=j.version,k=r.toneMapping),w.layers.enableAll(),H.unshift(w,w.geometry,w.material,0,0,null))}function D(H,K){H.getRGB(_C,dz(r)),a.buffers.color.setClear(_C.r,_C.g,_C.b,K,p)}function W(){I!==void 0&&(I.geometry.dispose(),I.material.dispose(),I=void 0),w!==void 0&&(w.geometry.dispose(),w.material.dispose(),w=void 0)}return{getClearColor:function(){return b},setClearColor:function(H,K=1){b.set(H),y=K,D(b,y)},getClearAlpha:function(){return y},setClearAlpha:function(H){y=H,D(b,y)},render:N,addToRenderList:O,dispose:W}}function Hpe(r,e){const n=r.getParameter(r.MAX_VERTEX_ATTRIBS),a={},c=R(null);let h=c,p=!1;function b(ie,ue,Re,_e,Pe){let rt=!1;const de=E(_e,Re,ue);h!==de&&(h=de,w(h.object)),rt=k(ie,_e,Re,Pe),rt&&G(ie,_e,Re,Pe),Pe!==null&&e.update(Pe,r.ELEMENT_ARRAY_BUFFER),(rt||p)&&(p=!1,K(ie,ue,Re,_e),Pe!==null&&r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e.get(Pe).buffer))}function y(){return r.createVertexArray()}function w(ie){return r.bindVertexArray(ie)}function I(ie){return r.deleteVertexArray(ie)}function E(ie,ue,Re){const _e=Re.wireframe===!0;let Pe=a[ie.id];Pe===void 0&&(Pe={},a[ie.id]=Pe);let rt=Pe[ue.id];rt===void 0&&(rt={},Pe[ue.id]=rt);let de=rt[_e];return de===void 0&&(de=R(y()),rt[_e]=de),de}function R(ie){const ue=[],Re=[],_e=[];for(let Pe=0;Pe<n;Pe++)ue[Pe]=0,Re[Pe]=0,_e[Pe]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:ue,enabledAttributes:Re,attributeDivisors:_e,object:ie,attributes:{},index:null}}function k(ie,ue,Re,_e){const Pe=h.attributes,rt=ue.attributes;let de=0;const we=Re.getAttributes();for(const Le in we)if(we[Le].location>=0){const fe=Pe[Le];let Ve=rt[Le];if(Ve===void 0&&(Le==="instanceMatrix"&&ie.instanceMatrix&&(Ve=ie.instanceMatrix),Le==="instanceColor"&&ie.instanceColor&&(Ve=ie.instanceColor)),fe===void 0||fe.attribute!==Ve||Ve&&fe.data!==Ve.data)return!0;de++}return h.attributesNum!==de||h.index!==_e}function G(ie,ue,Re,_e){const Pe={},rt=ue.attributes;let de=0;const we=Re.getAttributes();for(const Le in we)if(we[Le].location>=0){let fe=rt[Le];fe===void 0&&(Le==="instanceMatrix"&&ie.instanceMatrix&&(fe=ie.instanceMatrix),Le==="instanceColor"&&ie.instanceColor&&(fe=ie.instanceColor));const Ve={};Ve.attribute=fe,fe&&fe.data&&(Ve.data=fe.data),Pe[Le]=Ve,de++}h.attributes=Pe,h.attributesNum=de,h.index=_e}function N(){const ie=h.newAttributes;for(let ue=0,Re=ie.length;ue<Re;ue++)ie[ue]=0}function O(ie){D(ie,0)}function D(ie,ue){const Re=h.newAttributes,_e=h.enabledAttributes,Pe=h.attributeDivisors;Re[ie]=1,_e[ie]===0&&(r.enableVertexAttribArray(ie),_e[ie]=1),Pe[ie]!==ue&&(r.vertexAttribDivisor(ie,ue),Pe[ie]=ue)}function W(){const ie=h.newAttributes,ue=h.enabledAttributes;for(let Re=0,_e=ue.length;Re<_e;Re++)ue[Re]!==ie[Re]&&(r.disableVertexAttribArray(Re),ue[Re]=0)}function H(ie,ue,Re,_e,Pe,rt,de){de===!0?r.vertexAttribIPointer(ie,ue,Re,Pe,rt):r.vertexAttribPointer(ie,ue,Re,_e,Pe,rt)}function K(ie,ue,Re,_e){N();const Pe=_e.attributes,rt=Re.getAttributes(),de=ue.defaultAttributeValues;for(const we in rt){const Le=rt[we];if(Le.location>=0){let Je=Pe[we];if(Je===void 0&&(we==="instanceMatrix"&&ie.instanceMatrix&&(Je=ie.instanceMatrix),we==="instanceColor"&&ie.instanceColor&&(Je=ie.instanceColor)),Je!==void 0){const fe=Je.normalized,Ve=Je.itemSize,Ne=e.get(Je);if(Ne===void 0)continue;const gt=Ne.buffer,bt=Ne.type,zt=Ne.bytesPerElement,Tt=bt===r.INT||bt===r.UNSIGNED_INT||Je.gpuType===b2;if(Je.isInterleavedBufferAttribute){const Vt=Je.data,je=Vt.stride,_t=Je.offset;if(Vt.isInstancedInterleavedBuffer){for(let Ot=0;Ot<Le.locationSize;Ot++)D(Le.location+Ot,Vt.meshPerAttribute);ie.isInstancedMesh!==!0&&_e._maxInstanceCount===void 0&&(_e._maxInstanceCount=Vt.meshPerAttribute*Vt.count)}else for(let Ot=0;Ot<Le.locationSize;Ot++)O(Le.location+Ot);r.bindBuffer(r.ARRAY_BUFFER,gt);for(let Ot=0;Ot<Le.locationSize;Ot++)H(Le.location+Ot,Ve/Le.locationSize,bt,fe,je*zt,(_t+Ve/Le.locationSize*Ot)*zt,Tt)}else{if(Je.isInstancedBufferAttribute){for(let Vt=0;Vt<Le.locationSize;Vt++)D(Le.location+Vt,Je.meshPerAttribute);ie.isInstancedMesh!==!0&&_e._maxInstanceCount===void 0&&(_e._maxInstanceCount=Je.meshPerAttribute*Je.count)}else for(let Vt=0;Vt<Le.locationSize;Vt++)O(Le.location+Vt);r.bindBuffer(r.ARRAY_BUFFER,gt);for(let Vt=0;Vt<Le.locationSize;Vt++)H(Le.location+Vt,Ve/Le.locationSize,bt,fe,Ve*zt,Ve/Le.locationSize*Vt*zt,Tt)}}else if(de!==void 0){const fe=de[we];if(fe!==void 0)switch(fe.length){case 2:r.vertexAttrib2fv(Le.location,fe);break;case 3:r.vertexAttrib3fv(Le.location,fe);break;case 4:r.vertexAttrib4fv(Le.location,fe);break;default:r.vertexAttrib1fv(Le.location,fe)}}}}W()}function j(){re();for(const ie in a){const ue=a[ie];for(const Re in ue){const _e=ue[Re];for(const Pe in _e)I(_e[Pe].object),delete _e[Pe];delete ue[Re]}delete a[ie]}}function J(ie){if(a[ie.id]===void 0)return;const ue=a[ie.id];for(const Re in ue){const _e=ue[Re];for(const Pe in _e)I(_e[Pe].object),delete _e[Pe];delete ue[Re]}delete a[ie.id]}function ee(ie){for(const ue in a){const Re=a[ue];if(Re[ie.id]===void 0)continue;const _e=Re[ie.id];for(const Pe in _e)I(_e[Pe].object),delete _e[Pe];delete Re[ie.id]}}function re(){Y(),p=!0,h!==c&&(h=c,w(h.object))}function Y(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:b,reset:re,resetDefaultState:Y,dispose:j,releaseStatesOfGeometry:J,releaseStatesOfProgram:ee,initAttributes:N,enableAttribute:O,disableUnusedAttributes:W}}function Xpe(r,e,n){let a;function c(w){a=w}function h(w,I){r.drawArrays(a,w,I),n.update(I,a,1)}function p(w,I,E){E!==0&&(r.drawArraysInstanced(a,w,I,E),n.update(I,a,E))}function b(w,I,E){if(E===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(a,w,0,I,0,E);let k=0;for(let G=0;G<E;G++)k+=I[G];n.update(k,a,1)}function y(w,I,E,R){if(E===0)return;const k=e.get("WEBGL_multi_draw");if(k===null)for(let G=0;G<w.length;G++)p(w[G],I[G],R[G]);else{k.multiDrawArraysInstancedWEBGL(a,w,0,I,0,R,0,E);let G=0;for(let N=0;N<E;N++)G+=I[N]*R[N];n.update(G,a,1)}}this.setMode=c,this.render=h,this.renderInstances=p,this.renderMultiDraw=b,this.renderMultiDrawInstances=y}function Qpe(r,e,n,a){let c;function h(){if(c!==void 0)return c;if(e.has("EXT_texture_filter_anisotropic")===!0){const ee=e.get("EXT_texture_filter_anisotropic");c=r.getParameter(ee.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else c=0;return c}function p(ee){return!(ee!==to&&a.convert(ee)!==r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT))}function b(ee){const re=ee===sA&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(ee!==vu&&a.convert(ee)!==r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE)&&ee!==qa&&!re)}function y(ee){if(ee==="highp"){if(r.getShaderPrecisionFormat(r.VERTEX_SHADER,r.HIGH_FLOAT).precision>0&&r.getShaderPrecisionFormat(r.FRAGMENT_SHADER,r.HIGH_FLOAT).precision>0)return"highp";ee="mediump"}return ee==="mediump"&&r.getShaderPrecisionFormat(r.VERTEX_SHADER,r.MEDIUM_FLOAT).precision>0&&r.getShaderPrecisionFormat(r.FRAGMENT_SHADER,r.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let w=n.precision!==void 0?n.precision:"highp";const I=y(w);I!==w&&(console.warn("THREE.WebGLRenderer:",w,"not supported, using",I,"instead."),w=I);const E=n.logarithmicDepthBuffer===!0,R=n.reverseDepthBuffer===!0&&e.has("EXT_clip_control"),k=r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),G=r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),N=r.getParameter(r.MAX_TEXTURE_SIZE),O=r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),D=r.getParameter(r.MAX_VERTEX_ATTRIBS),W=r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),H=r.getParameter(r.MAX_VARYING_VECTORS),K=r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),j=G>0,J=r.getParameter(r.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:h,getMaxPrecision:y,textureFormatReadable:p,textureTypeReadable:b,precision:w,logarithmicDepthBuffer:E,reverseDepthBuffer:R,maxTextures:k,maxVertexTextures:G,maxTextureSize:N,maxCubemapSize:O,maxAttributes:D,maxVertexUniforms:W,maxVaryings:H,maxFragmentUniforms:K,vertexTextures:j,maxSamples:J}}function Kpe(r){const e=this;let n=null,a=0,c=!1,h=!1;const p=new Qd,b=new ii,y={value:null,needsUpdate:!1};this.uniform=y,this.numPlanes=0,this.numIntersection=0,this.init=function(E,R){const k=E.length!==0||R||a!==0||c;return c=R,a=E.length,k},this.beginShadows=function(){h=!0,I(null)},this.endShadows=function(){h=!1},this.setGlobalState=function(E,R){n=I(E,R,0)},this.setState=function(E,R,k){const G=E.clippingPlanes,N=E.clipIntersection,O=E.clipShadows,D=r.get(E);if(!c||G===null||G.length===0||h&&!O)h?I(null):w();else{const W=h?0:a,H=W*4;let K=D.clippingState||null;y.value=K,K=I(G,R,H,k);for(let j=0;j!==H;++j)K[j]=n[j];D.clippingState=K,this.numIntersection=N?this.numPlanes:0,this.numPlanes+=W}};function w(){y.value!==n&&(y.value=n,y.needsUpdate=a>0),e.numPlanes=a,e.numIntersection=0}function I(E,R,k,G){const N=E!==null?E.length:0;let O=null;if(N!==0){if(O=y.value,G!==!0||O===null){const D=k+N*4,W=R.matrixWorldInverse;b.getNormalMatrix(W),(O===null||O.length<D)&&(O=new Float32Array(D));for(let H=0,K=k;H!==N;++H,K+=4)p.copy(E[H]).applyMatrix4(W,b),p.normal.toArray(O,K),O[K+3]=p.constant}y.value=O,y.needsUpdate=!0}return e.numPlanes=N,e.numIntersection=0,O}}function Zpe(r){let e=new WeakMap;function n(p,b){return b===pv?p.mapping=_h:b===mv&&(p.mapping=qd),p}function a(p){if(p&&p.isTexture){const b=p.mapping;if(b===pv||b===mv)if(e.has(p)){const y=e.get(p).texture;return n(y,p.mapping)}else{const y=p.image;if(y&&y.height>0){const w=new mz(y.height);return w.fromEquirectangularTexture(r,p),e.set(p,w),p.addEventListener("dispose",c),n(w.texture,p.mapping)}else return null}}return p}function c(p){const b=p.target;b.removeEventListener("dispose",c);const y=e.get(b);y!==void 0&&(e.delete(b),y.dispose())}function h(){e=new WeakMap}return{get:a,dispose:h}}const Z0=4,XO=[.125,.215,.35,.446,.526,.582],Am=20,jM=new Z2,QO=new pn;let qM=null,JM=0,e_=0,t_=!1;const gm=(1+Math.sqrt(5))/2,N0=1/gm,KO=[new be(-gm,N0,0),new be(gm,N0,0),new be(-N0,0,gm),new be(N0,0,gm),new be(0,gm,-N0),new be(0,gm,N0),new be(-1,1,-1),new be(1,1,-1),new be(-1,1,1),new be(1,1,1)];class fR{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,n=0,a=.1,c=100){qM=this._renderer.getRenderTarget(),JM=this._renderer.getActiveCubeFace(),e_=this._renderer.getActiveMipmapLevel(),t_=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const h=this._allocateTargets();return h.depthBuffer=!0,this._sceneToCubeUV(e,a,c,h),n>0&&this._blur(h,0,0,n),this._applyPMREM(h),this._cleanup(h),h}fromEquirectangular(e,n=null){return this._fromTexture(e,n)}fromCubemap(e,n=null){return this._fromTexture(e,n)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=YO(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=$O(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(qM,JM,e_),this._renderer.xr.enabled=t_,e.scissorTest=!1,RC(e,0,0,e.width,e.height)}_fromTexture(e,n){e.mapping===_h||e.mapping===qd?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),qM=this._renderer.getRenderTarget(),JM=this._renderer.getActiveCubeFace(),e_=this._renderer.getActiveMipmapLevel(),t_=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const a=n||this._allocateTargets();return this._textureToCubeUV(e,a),this._applyPMREM(a),this._cleanup(a),a}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),n=4*this._cubeSize,a={magFilter:Dr,minFilter:Dr,generateMipmaps:!1,type:sA,format:to,colorSpace:Tm,depthBuffer:!1},c=ZO(e,n,a);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==n){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=ZO(e,n,a);const{_lodMax:h}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=$pe(h)),this._blurMaterial=Ype(h,e,n)}return c}_compileMaterial(e){const n=new Er(this._lodPlanes[0],e);this._renderer.compile(n,jM)}_sceneToCubeUV(e,n,a,c){const b=new ea(90,1,n,a),y=[1,-1,1,1,1,1],w=[1,1,1,-1,-1,-1],I=this._renderer,E=I.autoClear,R=I.toneMapping;I.getClearColor(QO),I.toneMapping=Eh,I.autoClear=!1;const k=new sf({name:"PMREM.Background",side:no,depthWrite:!1,depthTest:!1}),G=new Er(new Rm,k);let N=!1;const O=e.background;O?O.isColor&&(k.color.copy(O),e.background=null,N=!0):(k.color.copy(QO),N=!0);for(let D=0;D<6;D++){const W=D%3;W===0?(b.up.set(0,y[D],0),b.lookAt(w[D],0,0)):W===1?(b.up.set(0,0,y[D]),b.lookAt(0,w[D],0)):(b.up.set(0,y[D],0),b.lookAt(0,0,w[D]));const H=this._cubeSize;RC(c,W*H,D>2?H:0,H,H),I.setRenderTarget(c),N&&I.render(G,b),I.render(e,b)}G.geometry.dispose(),G.material.dispose(),I.toneMapping=R,I.autoClear=E,e.background=O}_textureToCubeUV(e,n){const a=this._renderer,c=e.mapping===_h||e.mapping===qd;c?(this._cubemapMaterial===null&&(this._cubemapMaterial=YO()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=$O());const h=c?this._cubemapMaterial:this._equirectMaterial,p=new Er(this._lodPlanes[0],h),b=h.uniforms;b.envMap.value=e;const y=this._cubeSize;RC(n,0,0,3*y,2*y),a.setRenderTarget(n),a.render(p,jM)}_applyPMREM(e){const n=this._renderer,a=n.autoClear;n.autoClear=!1;const c=this._lodPlanes.length;for(let h=1;h<c;h++){const p=Math.sqrt(this._sigmas[h]*this._sigmas[h]-this._sigmas[h-1]*this._sigmas[h-1]),b=KO[(c-h-1)%KO.length];this._blur(e,h-1,h,p,b)}n.autoClear=a}_blur(e,n,a,c,h){const p=this._pingPongRenderTarget;this._halfBlur(e,p,n,a,c,"latitudinal",h),this._halfBlur(p,e,a,a,c,"longitudinal",h)}_halfBlur(e,n,a,c,h,p,b){const y=this._renderer,w=this._blurMaterial;p!=="latitudinal"&&p!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const I=3,E=new Er(this._lodPlanes[c],w),R=w.uniforms,k=this._sizeLods[a]-1,G=isFinite(h)?Math.PI/(2*k):2*Math.PI/(2*Am-1),N=h/G,O=isFinite(h)?1+Math.floor(I*N):Am;O>Am&&console.warn(`sigmaRadians, ${h}, is too large and will clip, as it requested ${O} samples when the maximum is set to ${Am}`);const D=[];let W=0;for(let ee=0;ee<Am;++ee){const re=ee/N,Y=Math.exp(-re*re/2);D.push(Y),ee===0?W+=Y:ee<O&&(W+=2*Y)}for(let ee=0;ee<D.length;ee++)D[ee]=D[ee]/W;R.envMap.value=e.texture,R.samples.value=O,R.weights.value=D,R.latitudinal.value=p==="latitudinal",b&&(R.poleAxis.value=b);const{_lodMax:H}=this;R.dTheta.value=G,R.mipInt.value=H-a;const K=this._sizeLods[c],j=3*K*(c>H-Z0?c-H+Z0:0),J=4*(this._cubeSize-K);RC(n,j,J,3*K,2*K),y.setRenderTarget(n),y.render(E,jM)}}function $pe(r){const e=[],n=[],a=[];let c=r;const h=r-Z0+1+XO.length;for(let p=0;p<h;p++){const b=Math.pow(2,c);n.push(b);let y=1/b;p>r-Z0?y=XO[p-r+Z0-1]:p===0&&(y=0),a.push(y);const w=1/(b-2),I=-w,E=1+w,R=[I,I,E,I,E,E,I,I,E,E,I,E],k=6,G=6,N=3,O=2,D=1,W=new Float32Array(N*G*k),H=new Float32Array(O*G*k),K=new Float32Array(D*G*k);for(let J=0;J<k;J++){const ee=J%3*2/3-1,re=J>2?0:-1,Y=[ee,re,0,ee+2/3,re,0,ee+2/3,re+1,0,ee,re,0,ee+2/3,re+1,0,ee,re+1,0];W.set(Y,N*G*J),H.set(R,O*G*J);const ie=[J,J,J,J,J,J];K.set(ie,D*G*J)}const j=new gi;j.setAttribute("position",new bs(W,N)),j.setAttribute("uv",new bs(H,O)),j.setAttribute("faceIndex",new bs(K,D)),e.push(j),c>Z0&&c--}return{lodPlanes:e,sizeLods:n,sigmas:a}}function ZO(r,e,n){const a=new Ac(r,e,n);return a.texture.mapping=iA,a.texture.name="PMREM.cubeUv",a.scissorTest=!0,a}function RC(r,e,n,a,c){r.viewport.set(e,n,a,c),r.scissor.set(e,n,a,c)}function Ype(r,e,n){const a=new Float32Array(Am),c=new be(0,1,0);return new bc({name:"SphericalGaussianBlur",defines:{n:Am,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${r}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:a},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:c}},vertexShader:Lk(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Ch,depthTest:!1,depthWrite:!1})}function $O(){return new bc({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:Lk(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Ch,depthTest:!1,depthWrite:!1})}function YO(){return new bc({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:Lk(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Ch,depthTest:!1,depthWrite:!1})}function Lk(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function jpe(r){let e=new WeakMap,n=null;function a(b){if(b&&b.isTexture){const y=b.mapping,w=y===pv||y===mv,I=y===_h||y===qd;if(w||I){let E=e.get(b);const R=E!==void 0?E.texture.pmremVersion:0;if(b.isRenderTargetTexture&&b.pmremVersion!==R)return n===null&&(n=new fR(r)),E=w?n.fromEquirectangular(b,E):n.fromCubemap(b,E),E.texture.pmremVersion=b.pmremVersion,e.set(b,E),E.texture;if(E!==void 0)return E.texture;{const k=b.image;return w&&k&&k.height>0||I&&k&&c(k)?(n===null&&(n=new fR(r)),E=w?n.fromEquirectangular(b):n.fromCubemap(b),E.texture.pmremVersion=b.pmremVersion,e.set(b,E),b.addEventListener("dispose",h),E.texture):null}}}return b}function c(b){let y=0;const w=6;for(let I=0;I<w;I++)b[I]!==void 0&&y++;return y===w}function h(b){const y=b.target;y.removeEventListener("dispose",h);const w=e.get(y);w!==void 0&&(e.delete(y),w.dispose())}function p(){e=new WeakMap,n!==null&&(n.dispose(),n=null)}return{get:a,dispose:p}}function qpe(r){const e={};function n(a){if(e[a]!==void 0)return e[a];let c;switch(a){case"WEBGL_depth_texture":c=r.getExtension("WEBGL_depth_texture")||r.getExtension("MOZ_WEBGL_depth_texture")||r.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":c=r.getExtension("EXT_texture_filter_anisotropic")||r.getExtension("MOZ_EXT_texture_filter_anisotropic")||r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":c=r.getExtension("WEBGL_compressed_texture_s3tc")||r.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":c=r.getExtension("WEBGL_compressed_texture_pvrtc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:c=r.getExtension(a)}return e[a]=c,c}return{has:function(a){return n(a)!==null},init:function(){n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance"),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture"),n("WEBGL_render_shared_exponent")},get:function(a){const c=n(a);return c===null&&V0("THREE.WebGLRenderer: "+a+" extension not supported."),c}}}function Jpe(r,e,n,a){const c={},h=new WeakMap;function p(E){const R=E.target;R.index!==null&&e.remove(R.index);for(const G in R.attributes)e.remove(R.attributes[G]);R.removeEventListener("dispose",p),delete c[R.id];const k=h.get(R);k&&(e.remove(k),h.delete(R)),a.releaseStatesOfGeometry(R),R.isInstancedBufferGeometry===!0&&delete R._maxInstanceCount,n.memory.geometries--}function b(E,R){return c[R.id]===!0||(R.addEventListener("dispose",p),c[R.id]=!0,n.memory.geometries++),R}function y(E){const R=E.attributes;for(const k in R)e.update(R[k],r.ARRAY_BUFFER)}function w(E){const R=[],k=E.index,G=E.attributes.position;let N=0;if(k!==null){const W=k.array;N=k.version;for(let H=0,K=W.length;H<K;H+=3){const j=W[H+0],J=W[H+1],ee=W[H+2];R.push(j,J,J,ee,ee,j)}}else if(G!==void 0){const W=G.array;N=G.version;for(let H=0,K=W.length/3-1;H<K;H+=3){const j=H+0,J=H+1,ee=H+2;R.push(j,J,J,ee,ee,j)}}else return;const O=new(lz(R)?ck:lk)(R,1);O.version=N;const D=h.get(E);D&&e.remove(D),h.set(E,O)}function I(E){const R=h.get(E);if(R){const k=E.index;k!==null&&R.version<k.version&&w(E)}else w(E);return h.get(E)}return{get:b,update:y,getWireframeAttribute:I}}function eme(r,e,n){let a;function c(R){a=R}let h,p;function b(R){h=R.type,p=R.bytesPerElement}function y(R,k){r.drawElements(a,k,h,R*p),n.update(k,a,1)}function w(R,k,G){G!==0&&(r.drawElementsInstanced(a,k,h,R*p,G),n.update(k,a,G))}function I(R,k,G){if(G===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(a,k,0,h,R,0,G);let O=0;for(let D=0;D<G;D++)O+=k[D];n.update(O,a,1)}function E(R,k,G,N){if(G===0)return;const O=e.get("WEBGL_multi_draw");if(O===null)for(let D=0;D<R.length;D++)w(R[D]/p,k[D],N[D]);else{O.multiDrawElementsInstancedWEBGL(a,k,0,h,R,0,N,0,G);let D=0;for(let W=0;W<G;W++)D+=k[W]*N[W];n.update(D,a,1)}}this.setMode=c,this.setIndex=b,this.render=y,this.renderInstances=w,this.renderMultiDraw=I,this.renderMultiDrawInstances=E}function tme(r){const e={geometries:0,textures:0},n={frame:0,calls:0,triangles:0,points:0,lines:0};function a(h,p,b){switch(n.calls++,p){case r.TRIANGLES:n.triangles+=b*(h/3);break;case r.LINES:n.lines+=b*(h/2);break;case r.LINE_STRIP:n.lines+=b*(h-1);break;case r.LINE_LOOP:n.lines+=b*h;break;case r.POINTS:n.points+=b*h;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",p);break}}function c(){n.calls=0,n.triangles=0,n.points=0,n.lines=0}return{memory:e,render:n,programs:null,autoReset:!0,reset:c,update:a}}function nme(r,e,n){const a=new WeakMap,c=new Xi;function h(p,b,y){const w=p.morphTargetInfluences,I=b.morphAttributes.position||b.morphAttributes.normal||b.morphAttributes.color,E=I!==void 0?I.length:0;let R=a.get(b);if(R===void 0||R.count!==E){let ie=function(){re.dispose(),a.delete(b),b.removeEventListener("dispose",ie)};var k=ie;R!==void 0&&R.texture.dispose();const G=b.morphAttributes.position!==void 0,N=b.morphAttributes.normal!==void 0,O=b.morphAttributes.color!==void 0,D=b.morphAttributes.position||[],W=b.morphAttributes.normal||[],H=b.morphAttributes.color||[];let K=0;G===!0&&(K=1),N===!0&&(K=2),O===!0&&(K=3);let j=b.attributes.position.count*K,J=1;j>e.maxTextureSize&&(J=Math.ceil(j/e.maxTextureSize),j=e.maxTextureSize);const ee=new Float32Array(j*J*4*E),re=new Uv(ee,j,J,E);re.type=qa,re.needsUpdate=!0;const Y=K*4;for(let ue=0;ue<E;ue++){const Re=D[ue],_e=W[ue],Pe=H[ue],rt=j*J*4*ue;for(let de=0;de<Re.count;de++){const we=de*Y;G===!0&&(c.fromBufferAttribute(Re,de),ee[rt+we+0]=c.x,ee[rt+we+1]=c.y,ee[rt+we+2]=c.z,ee[rt+we+3]=0),N===!0&&(c.fromBufferAttribute(_e,de),ee[rt+we+4]=c.x,ee[rt+we+5]=c.y,ee[rt+we+6]=c.z,ee[rt+we+7]=0),O===!0&&(c.fromBufferAttribute(Pe,de),ee[rt+we+8]=c.x,ee[rt+we+9]=c.y,ee[rt+we+10]=c.z,ee[rt+we+11]=Pe.itemSize===4?c.w:1)}}R={count:E,texture:re,size:new Dt(j,J)},a.set(b,R),b.addEventListener("dispose",ie)}if(p.isInstancedMesh===!0&&p.morphTexture!==null)y.getUniforms().setValue(r,"morphTexture",p.morphTexture,n);else{let G=0;for(let O=0;O<w.length;O++)G+=w[O];const N=b.morphTargetsRelative?1:1-G;y.getUniforms().setValue(r,"morphTargetBaseInfluence",N),y.getUniforms().setValue(r,"morphTargetInfluences",w)}y.getUniforms().setValue(r,"morphTargetsTexture",R.texture,n),y.getUniforms().setValue(r,"morphTargetsTextureSize",R.size)}return{update:h}}class ime{constructor(e,n,a){if(this.renderer=e,this.DEFAULT_NUMVIEWS=2,this.maxNumViews=0,this.gl=a,this.extensions=n,this.available=this.extensions.has("OCULUS_multiview"),this.available){const h=this.extensions.get("OCULUS_multiview");this.maxNumViews=this.gl.getParameter(h.MAX_VIEWS_OVR),this.mat4=[],this.mat3=[],this.cameraArray=[];for(var c=0;c<this.maxNumViews;c++)this.mat4[c]=new Zn,this.mat3[c]=new ii}}getCameraArray(e){return e.isArrayCamera?e.cameras:(this.cameraArray[0]=e,this.cameraArray)}updateCameraProjectionMatricesUniform(e,n){for(var a=this.getCameraArray(e),c=0;c<a.length;c++)this.mat4[c].copy(a[c].projectionMatrix);n.setValue(this.gl,"projectionMatrices",this.mat4)}updateCameraViewMatricesUniform(e,n){for(var a=this.getCameraArray(e),c=0;c<a.length;c++)this.mat4[c].copy(a[c].matrixWorldInverse);n.setValue(this.gl,"viewMatrices",this.mat4)}updateObjectMatricesUniforms(e,n,a){for(var c=this.getCameraArray(n),h=0;h<c.length;h++)this.mat4[h].multiplyMatrices(c[h].matrixWorldInverse,e.matrixWorld),this.mat3[h].getNormalMatrix(this.mat4[h]);a.setValue(this.gl,"modelViewMatrices",this.mat4),a.setValue(this.gl,"normalMatrices",this.mat3)}}function sme(r,e,n,a){let c=new WeakMap;function h(y){const w=a.render.frame,I=y.geometry,E=e.get(y,I);if(c.get(E)!==w&&(e.update(E),c.set(E,w)),y.isInstancedMesh&&(y.hasEventListener("dispose",b)===!1&&y.addEventListener("dispose",b),c.get(y)!==w&&(n.update(y.instanceMatrix,r.ARRAY_BUFFER),y.instanceColor!==null&&n.update(y.instanceColor,r.ARRAY_BUFFER),c.set(y,w))),y.isSkinnedMesh){const R=y.skeleton;c.get(R)!==w&&(R.update(),c.set(R,w))}return E}function p(){c=new WeakMap}function b(y){const w=y.target;w.removeEventListener("dispose",b),n.remove(w.instanceMatrix),w.instanceColor!==null&&n.remove(w.instanceColor)}return{update:h,dispose:p}}const pV=new nr,jO=new fk(1,1),mV=new Uv,gV=new I2,AV=new Pv,qO=[],JO=[],eG=new Float32Array(16),tG=new Float32Array(9),nG=new Float32Array(4);function lA(r,e,n){const a=r[0];if(a<=0||a>0)return r;const c=e*n;let h=qO[c];if(h===void 0&&(h=new Float32Array(c),qO[c]=h),e!==0){a.toArray(h,0);for(let p=1,b=0;p!==e;++p)b+=n,r[p].toArray(h,b)}return h}function Fr(r,e){if(r.length!==e.length)return!1;for(let n=0,a=r.length;n<a;n++)if(r[n]!==e[n])return!1;return!0}function Or(r,e){for(let n=0,a=e.length;n<a;n++)r[n]=e[n]}function Y2(r,e){let n=JO[e];n===void 0&&(n=new Int32Array(e),JO[e]=n);for(let a=0;a!==e;++a)n[a]=r.allocateTextureUnit();return n}function rme(r,e){const n=this.cache;n[0]!==e&&(r.uniform1f(this.addr,e),n[0]=e)}function ame(r,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y)&&(r.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Fr(n,e))return;r.uniform2fv(this.addr,e),Or(n,e)}}function ome(r,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z)&&(r.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(e.r!==void 0)(n[0]!==e.r||n[1]!==e.g||n[2]!==e.b)&&(r.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(Fr(n,e))return;r.uniform3fv(this.addr,e),Or(n,e)}}function lme(r,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z||n[3]!==e.w)&&(r.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Fr(n,e))return;r.uniform4fv(this.addr,e),Or(n,e)}}function cme(r,e){const n=this.cache,a=e.elements;if(a===void 0){if(Fr(n,e))return;r.uniformMatrix2fv(this.addr,!1,e),Or(n,e)}else{if(Fr(n,a))return;nG.set(a),r.uniformMatrix2fv(this.addr,!1,nG),Or(n,a)}}function ume(r,e){const n=this.cache,a=e.elements;if(a===void 0){if(Fr(n,e))return;r.uniformMatrix3fv(this.addr,!1,e),Or(n,e)}else{if(Fr(n,a))return;tG.set(a),r.uniformMatrix3fv(this.addr,!1,tG),Or(n,a)}}function hme(r,e){const n=this.cache,a=e.elements;if(a===void 0){if(Fr(n,e))return;r.uniformMatrix4fv(this.addr,!1,e),Or(n,e)}else{if(Fr(n,a))return;eG.set(a),r.uniformMatrix4fv(this.addr,!1,eG),Or(n,a)}}function dme(r,e){const n=this.cache;n[0]!==e&&(r.uniform1i(this.addr,e),n[0]=e)}function fme(r,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y)&&(r.uniform2i(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Fr(n,e))return;r.uniform2iv(this.addr,e),Or(n,e)}}function pme(r,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z)&&(r.uniform3i(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(Fr(n,e))return;r.uniform3iv(this.addr,e),Or(n,e)}}function mme(r,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z||n[3]!==e.w)&&(r.uniform4i(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Fr(n,e))return;r.uniform4iv(this.addr,e),Or(n,e)}}function gme(r,e){const n=this.cache;n[0]!==e&&(r.uniform1ui(this.addr,e),n[0]=e)}function Ame(r,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y)&&(r.uniform2ui(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Fr(n,e))return;r.uniform2uiv(this.addr,e),Or(n,e)}}function bme(r,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z)&&(r.uniform3ui(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(Fr(n,e))return;r.uniform3uiv(this.addr,e),Or(n,e)}}function yme(r,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z||n[3]!==e.w)&&(r.uniform4ui(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Fr(n,e))return;r.uniform4uiv(this.addr,e),Or(n,e)}}function vme(r,e,n){const a=this.cache,c=n.allocateTextureUnit();a[0]!==c&&(r.uniform1i(this.addr,c),a[0]=c);let h;this.type===r.SAMPLER_2D_SHADOW?(jO.compareFunction=ak,h=jO):h=pV,n.setTexture2D(e||h,c)}function xme(r,e,n){const a=this.cache,c=n.allocateTextureUnit();a[0]!==c&&(r.uniform1i(this.addr,c),a[0]=c),n.setTexture3D(e||gV,c)}function wme(r,e,n){const a=this.cache,c=n.allocateTextureUnit();a[0]!==c&&(r.uniform1i(this.addr,c),a[0]=c),n.setTextureCube(e||AV,c)}function Cme(r,e,n){const a=this.cache,c=n.allocateTextureUnit();a[0]!==c&&(r.uniform1i(this.addr,c),a[0]=c),n.setTexture2DArray(e||mV,c)}function Eme(r){switch(r){case 5126:return rme;case 35664:return ame;case 35665:return ome;case 35666:return lme;case 35674:return cme;case 35675:return ume;case 35676:return hme;case 5124:case 35670:return dme;case 35667:case 35671:return fme;case 35668:case 35672:return pme;case 35669:case 35673:return mme;case 5125:return gme;case 36294:return Ame;case 36295:return bme;case 36296:return yme;case 35678:case 36198:case 36298:case 36306:case 35682:return vme;case 35679:case 36299:case 36307:return xme;case 35680:case 36300:case 36308:case 36293:return wme;case 36289:case 36303:case 36311:case 36292:return Cme}}function Sme(r,e){r.uniform1fv(this.addr,e)}function Ime(r,e){const n=lA(e,this.size,2);r.uniform2fv(this.addr,n)}function Tme(r,e){const n=lA(e,this.size,3);r.uniform3fv(this.addr,n)}function Mme(r,e){const n=lA(e,this.size,4);r.uniform4fv(this.addr,n)}function _me(r,e){const n=lA(e,this.size,4);r.uniformMatrix2fv(this.addr,!1,n)}function Rme(r,e){const n=lA(e,this.size,9);r.uniformMatrix3fv(this.addr,!1,n)}function kme(r,e){const n=lA(e,this.size,16);r.uniformMatrix4fv(this.addr,!1,n)}function Bme(r,e){r.uniform1iv(this.addr,e)}function Lme(r,e){r.uniform2iv(this.addr,e)}function Nme(r,e){r.uniform3iv(this.addr,e)}function Dme(r,e){r.uniform4iv(this.addr,e)}function Fme(r,e){r.uniform1uiv(this.addr,e)}function Ome(r,e){r.uniform2uiv(this.addr,e)}function Gme(r,e){r.uniform3uiv(this.addr,e)}function Ume(r,e){r.uniform4uiv(this.addr,e)}function Pme(r,e,n){const a=this.cache,c=e.length,h=Y2(n,c);Fr(a,h)||(r.uniform1iv(this.addr,h),Or(a,h));for(let p=0;p!==c;++p)n.setTexture2D(e[p]||pV,h[p])}function zme(r,e,n){const a=this.cache,c=e.length,h=Y2(n,c);Fr(a,h)||(r.uniform1iv(this.addr,h),Or(a,h));for(let p=0;p!==c;++p)n.setTexture3D(e[p]||gV,h[p])}function Vme(r,e,n){const a=this.cache,c=e.length,h=Y2(n,c);Fr(a,h)||(r.uniform1iv(this.addr,h),Or(a,h));for(let p=0;p!==c;++p)n.setTextureCube(e[p]||AV,h[p])}function Wme(r,e,n){const a=this.cache,c=e.length,h=Y2(n,c);Fr(a,h)||(r.uniform1iv(this.addr,h),Or(a,h));for(let p=0;p!==c;++p)n.setTexture2DArray(e[p]||mV,h[p])}function Hme(r){switch(r){case 5126:return Sme;case 35664:return Ime;case 35665:return Tme;case 35666:return Mme;case 35674:return _me;case 35675:return Rme;case 35676:return kme;case 5124:case 35670:return Bme;case 35667:case 35671:return Lme;case 35668:case 35672:return Nme;case 35669:case 35673:return Dme;case 5125:return Fme;case 36294:return Ome;case 36295:return Gme;case 36296:return Ume;case 35678:case 36198:case 36298:case 36306:case 35682:return Pme;case 35679:case 36299:case 36307:return zme;case 35680:case 36300:case 36308:case 36293:return Vme;case 36289:case 36303:case 36311:case 36292:return Wme}}class Xme{constructor(e,n,a){this.id=e,this.addr=a,this.cache=[],this.type=n.type,this.setValue=Eme(n.type)}}class Qme{constructor(e,n,a){this.id=e,this.addr=a,this.cache=[],this.type=n.type,this.size=n.size,this.setValue=Hme(n.type)}}class Kme{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,n,a){const c=this.seq;for(let h=0,p=c.length;h!==p;++h){const b=c[h];b.setValue(e,n[b.id],a)}}}const n_=/(\w+)(\])?(\[|\.)?/g;function iG(r,e){r.seq.push(e),r.map[e.id]=e}function Zme(r,e,n){const a=r.name,c=a.length;for(n_.lastIndex=0;;){const h=n_.exec(a),p=n_.lastIndex;let b=h[1];const y=h[2]==="]",w=h[3];if(y&&(b=b|0),w===void 0||w==="["&&p+2===c){iG(n,w===void 0?new Xme(b,r,e):new Qme(b,r,e));break}else{let E=n.map[b];E===void 0&&(E=new Kme(b),iG(n,E)),n=E}}}class oE{constructor(e,n){this.seq=[],this.map={};const a=e.getProgramParameter(n,e.ACTIVE_UNIFORMS);for(let c=0;c<a;++c){const h=e.getActiveUniform(n,c),p=e.getUniformLocation(n,h.name);Zme(h,p,this)}}setValue(e,n,a,c){const h=this.map[n];h!==void 0&&h.setValue(e,a,c)}setOptional(e,n,a){const c=n[a];c!==void 0&&this.setValue(e,a,c)}static upload(e,n,a,c){for(let h=0,p=n.length;h!==p;++h){const b=n[h],y=a[b.id];y.needsUpdate!==!1&&b.setValue(e,y.value,c)}}static seqWithValue(e,n){const a=[];for(let c=0,h=e.length;c!==h;++c){const p=e[c];p.id in n&&a.push(p)}return a}}function sG(r,e,n){const a=r.createShader(e);return r.shaderSource(a,n),r.compileShader(a),a}const $me=37297;let Yme=0;function jme(r,e){const n=r.split(`
`),a=[],c=Math.max(e-6,0),h=Math.min(e+6,n.length);for(let p=c;p<h;p++){const b=p+1;a.push(`${b===e?">":" "} ${b}: ${n[p]}`)}return a.join(`
`)}const rG=new ii;function qme(r){zi._getMatrix(rG,zi.workingColorSpace,r);const e=`mat3( ${rG.elements.map(n=>n.toFixed(4))} )`;switch(zi.getTransfer(r)){case vv:return[e,"LinearTransferOETF"];case hs:return[e,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",r),[e,"LinearTransferOETF"]}}function aG(r,e,n){const a=r.getShaderParameter(e,r.COMPILE_STATUS),c=r.getShaderInfoLog(e).trim();if(a&&c==="")return"";const h=/ERROR: 0:(\d+)/.exec(c);if(h){const p=parseInt(h[1]);return n.toUpperCase()+`

`+c+`

`+jme(r.getShaderSource(e),p)}else return c}function Jme(r,e){const n=qme(e);return[`vec4 ${r}( vec4 value ) {`,`	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,"}"].join(`
`)}function ege(r,e){let n;switch(e){case zP:n="Linear";break;case VP:n="Reinhard";break;case WP:n="Cineon";break;case HP:n="ACESFilmic";break;case QP:n="AgX";break;case KP:n="Neutral";break;case XP:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+r+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}const kC=new be;function tge(){zi.getLuminanceCoefficients(kC);const r=kC.x.toFixed(4),e=kC.y.toFixed(4),n=kC.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${r}, ${e}, ${n} );`,"	return dot( weights, rgb );","}"].join(`
`)}function nge(r){return[r.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",r.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(ev).join(`
`)}function ige(r){const e=[];for(const n in r){const a=r[n];a!==!1&&e.push("#define "+n+" "+a)}return e.join(`
`)}function sge(r,e){const n={},a=r.getProgramParameter(e,r.ACTIVE_ATTRIBUTES);for(let c=0;c<a;c++){const h=r.getActiveAttrib(e,c),p=h.name;let b=1;h.type===r.FLOAT_MAT2&&(b=2),h.type===r.FLOAT_MAT3&&(b=3),h.type===r.FLOAT_MAT4&&(b=4),n[p]={type:h.type,location:r.getAttribLocation(e,p),locationSize:b}}return n}function ev(r){return r!==""}function oG(r,e){const n=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return r.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,n).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function lG(r,e){return r.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const rge=/^[ \t]*#include +<([\w\d./]+)>/gm;function pR(r){return r.replace(rge,oge)}const age=new Map;function oge(r,e){let n=mi[e];if(n===void 0){const a=age.get(e);if(a!==void 0)n=mi[a],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,a);else throw new Error("Can not resolve #include <"+e+">")}return pR(n)}const lge=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function cG(r){return r.replace(lge,cge)}function cge(r,e,n,a){let c="";for(let h=parseInt(e);h<parseInt(n);h++)c+=a.replace(/\[\s*i\s*\]/g,"[ "+h+" ]").replace(/UNROLLED_LOOP_INDEX/g,h);return c}function uG(r){let e=`precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;return r.precision==="highp"?e+=`
#define HIGH_PRECISION`:r.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:r.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function uge(r){let e="SHADOWMAP_TYPE_BASIC";return r.shadowMapType===ZR?e="SHADOWMAP_TYPE_PCF":r.shadowMapType===vP?e="SHADOWMAP_TYPE_PCF_SOFT":r.shadowMapType===fu&&(e="SHADOWMAP_TYPE_VSM"),e}function hge(r){let e="ENVMAP_TYPE_CUBE";if(r.envMap)switch(r.envMapMode){case _h:case qd:e="ENVMAP_TYPE_CUBE";break;case iA:e="ENVMAP_TYPE_CUBE_UV";break}return e}function dge(r){let e="ENVMAP_MODE_REFLECTION";if(r.envMap)switch(r.envMapMode){case qd:e="ENVMAP_MODE_REFRACTION";break}return e}function fge(r){let e="ENVMAP_BLENDING_NONE";if(r.envMap)switch(r.combine){case Ov:e="ENVMAP_BLENDING_MULTIPLY";break;case UP:e="ENVMAP_BLENDING_MIX";break;case PP:e="ENVMAP_BLENDING_ADD";break}return e}function pge(r){const e=r.envMapCubeUVHeight;if(e===null)return null;const n=Math.log2(e)-2,a=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:a,maxMip:n}}function mge(r,e,n,a){const c=r.getContext(),h=n.defines;let p=n.vertexShader,b=n.fragmentShader;const y=uge(n),w=hge(n),I=dge(n),E=fge(n),R=pge(n),k=nge(n),G=ige(h),N=c.createProgram();let O,D,W=n.glslVersion?"#version "+n.glslVersion+`
`:"";const H=n.numMultiviewViews;n.isRawShaderMaterial?(O=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,G].filter(ev).join(`
`),O.length>0&&(O+=`
`),D=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,G].filter(ev).join(`
`),D.length>0&&(D+=`
`)):(O=[uG(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,G,n.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",n.batching?"#define USE_BATCHING":"",n.batchingColor?"#define USE_BATCHING_COLOR":"",n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.instancingMorph?"#define USE_INSTANCING_MORPH":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+I:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.displacementMap?"#define USE_DISPLACEMENTMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.mapUv?"#define MAP_UV "+n.mapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.lightMapUv?"#define LIGHTMAP_UV "+n.lightMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.bumpMapUv?"#define BUMPMAP_UV "+n.bumpMapUv:"",n.normalMapUv?"#define NORMALMAP_UV "+n.normalMapUv:"",n.displacementMapUv?"#define DISPLACEMENTMAP_UV "+n.displacementMapUv:"",n.metalnessMapUv?"#define METALNESSMAP_UV "+n.metalnessMapUv:"",n.roughnessMapUv?"#define ROUGHNESSMAP_UV "+n.roughnessMapUv:"",n.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+n.anisotropyMapUv:"",n.clearcoatMapUv?"#define CLEARCOATMAP_UV "+n.clearcoatMapUv:"",n.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+n.clearcoatNormalMapUv:"",n.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+n.clearcoatRoughnessMapUv:"",n.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+n.iridescenceMapUv:"",n.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+n.iridescenceThicknessMapUv:"",n.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+n.sheenColorMapUv:"",n.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+n.sheenRoughnessMapUv:"",n.specularMapUv?"#define SPECULARMAP_UV "+n.specularMapUv:"",n.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+n.specularColorMapUv:"",n.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+n.specularIntensityMapUv:"",n.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+n.transmissionMapUv:"",n.thicknessMapUv?"#define THICKNESSMAP_UV "+n.thicknessMapUv:"",n.vertexTangents&&n.flatShading===!1?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&n.flatShading===!1?"#define USE_MORPHNORMALS":"",n.morphColors?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+y:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(ev).join(`
`),D=[uG(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,G,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+w:"",n.envMap?"#define "+I:"",n.envMap?"#define "+E:"",R?"#define CUBEUV_TEXEL_WIDTH "+R.texelWidth:"",R?"#define CUBEUV_TEXEL_HEIGHT "+R.texelHeight:"",R?"#define CUBEUV_MAX_MIP "+R.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.dispersion?"#define USE_DISPERSION":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents&&n.flatShading===!1?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor||n.batchingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+y:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==Eh?"#define TONE_MAPPING":"",n.toneMapping!==Eh?mi.tonemapping_pars_fragment:"",n.toneMapping!==Eh?ege("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",mi.colorspace_pars_fragment,Jme("linearToOutputTexel",n.outputColorSpace),tge(),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"",`
`].filter(ev).join(`
`)),p=pR(p),p=oG(p,n),p=lG(p,n),b=pR(b),b=oG(b,n),b=lG(b,n),p=cG(p),b=cG(b),n.isRawShaderMaterial!==!0&&(W=`#version 300 es
`,O=[k,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+O,D=["#define varying in",n.glslVersion===rR?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===rR?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+D,H>0&&(O=["#extension GL_OVR_multiview : require","layout(num_views = "+H+") in;","#define VIEW_ID gl_ViewID_OVR"].join(`
`)+`
`+O,O=O.replace(["uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;"].join(`
`),["uniform mat4 modelViewMatrices["+H+"];","uniform mat4 projectionMatrices["+H+"];","uniform mat4 viewMatrices["+H+"];","uniform mat3 normalMatrices["+H+"];","#define modelViewMatrix modelViewMatrices[VIEW_ID]","#define projectionMatrix projectionMatrices[VIEW_ID]","#define viewMatrix viewMatrices[VIEW_ID]","#define normalMatrix normalMatrices[VIEW_ID]"].join(`
`)),D=["#extension GL_OVR_multiview : require","#define VIEW_ID gl_ViewID_OVR"].join(`
`)+`
`+D,D=D.replace("uniform mat4 viewMatrix;",["uniform mat4 viewMatrices["+H+"];","#define viewMatrix viewMatrices[VIEW_ID]"].join(`
`))));const K=W+O+p,j=W+D+b,J=sG(c,c.VERTEX_SHADER,K),ee=sG(c,c.FRAGMENT_SHADER,j);c.attachShader(N,J),c.attachShader(N,ee),n.index0AttributeName!==void 0?c.bindAttribLocation(N,0,n.index0AttributeName):n.morphTargets===!0&&c.bindAttribLocation(N,0,"position"),c.linkProgram(N);function re(Re){if(r.debug.checkShaderErrors){const _e=c.getProgramInfoLog(N).trim(),Pe=c.getShaderInfoLog(J).trim(),rt=c.getShaderInfoLog(ee).trim();let de=!0,we=!0;if(c.getProgramParameter(N,c.LINK_STATUS)===!1)if(de=!1,typeof r.debug.onShaderError=="function")r.debug.onShaderError(c,N,J,ee);else{const Le=aG(c,J,"vertex"),Je=aG(c,ee,"fragment");console.error("THREE.WebGLProgram: Shader Error "+c.getError()+" - VALIDATE_STATUS "+c.getProgramParameter(N,c.VALIDATE_STATUS)+`

Material Name: `+Re.name+`
Material Type: `+Re.type+`

Program Info Log: `+_e+`
`+Le+`
`+Je)}else _e!==""?console.warn("THREE.WebGLProgram: Program Info Log:",_e):(Pe===""||rt==="")&&(we=!1);we&&(Re.diagnostics={runnable:de,programLog:_e,vertexShader:{log:Pe,prefix:O},fragmentShader:{log:rt,prefix:D}})}c.deleteShader(J),c.deleteShader(ee),Y=new oE(c,N),ie=sge(c,N)}let Y;this.getUniforms=function(){return Y===void 0&&re(this),Y};let ie;this.getAttributes=function(){return ie===void 0&&re(this),ie};let ue=n.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return ue===!1&&(ue=c.getProgramParameter(N,$me)),ue},this.destroy=function(){a.releaseStatesOfProgram(this),c.deleteProgram(N),this.program=void 0},this.type=n.shaderType,this.name=n.shaderName,this.id=Yme++,this.cacheKey=e,this.usedTimes=1,this.program=N,this.vertexShader=J,this.fragmentShader=ee,this.numMultiviewViews=H,this}let gge=0;class Age{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const n=e.vertexShader,a=e.fragmentShader,c=this._getShaderStage(n),h=this._getShaderStage(a),p=this._getShaderCacheForMaterial(e);return p.has(c)===!1&&(p.add(c),c.usedTimes++),p.has(h)===!1&&(p.add(h),h.usedTimes++),this}remove(e){const n=this.materialCache.get(e);for(const a of n)a.usedTimes--,a.usedTimes===0&&this.shaderCache.delete(a.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const n=this.materialCache;let a=n.get(e);return a===void 0&&(a=new Set,n.set(e,a)),a}_getShaderStage(e){const n=this.shaderCache;let a=n.get(e);return a===void 0&&(a=new bge(e),n.set(e,a)),a}}class bge{constructor(e){this.id=gge++,this.code=e,this.usedTimes=0}}function yge(r,e,n,a,c,h,p){const b=new T2,y=new Age,w=new Set,I=[],E=c.logarithmicDepthBuffer,R=c.vertexTextures;let k=c.precision;const G={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function N(Y){return w.add(Y),Y===0?"uv":`uv${Y}`}function O(Y,ie,ue,Re,_e){const Pe=Re.fog,rt=_e.geometry,de=Y.isMeshStandardMaterial?Re.environment:null,we=(Y.isMeshStandardMaterial?n:e).get(Y.envMap||de),Le=we&&we.mapping===iA?we.image.height:null,Je=G[Y.type];Y.precision!==null&&(k=c.getMaxPrecision(Y.precision),k!==Y.precision&&console.warn("THREE.WebGLProgram.getParameters:",Y.precision,"not supported, using",k,"instead."));const fe=rt.morphAttributes.position||rt.morphAttributes.normal||rt.morphAttributes.color,Ve=fe!==void 0?fe.length:0;let Ne=0;rt.morphAttributes.position!==void 0&&(Ne=1),rt.morphAttributes.normal!==void 0&&(Ne=2),rt.morphAttributes.color!==void 0&&(Ne=3);let gt,bt,zt,Tt;if(Je){const fi=pc[Je];gt=fi.vertexShader,bt=fi.fragmentShader}else gt=Y.vertexShader,bt=Y.fragmentShader,y.update(Y),zt=y.getVertexShaderID(Y),Tt=y.getFragmentShaderID(Y);const Vt=r.getRenderTarget(),je=r.state.buffers.depth.getReversed(),_t=Vt&&Vt.isWebGLMultiviewRenderTarget?Vt.numViews:0,Ot=_e.isInstancedMesh===!0,on=_e.isBatchedMesh===!0,vt=!!Y.map,Mt=!!Y.matcap,Bt=!!we,ve=!!Y.aoMap,Kt=!!Y.lightMap,Ee=!!Y.bumpMap,Q=!!Y.normalMap,Z=!!Y.displacementMap,ae=!!Y.emissiveMap,Ae=!!Y.metalnessMap,Ie=!!Y.roughnessMap,Ze=Y.anisotropy>0,At=Y.clearcoat>0,dn=Y.dispersion>0,ge=Y.iridescence>0,se=Y.sheen>0,Ge=Y.transmission>0,ut=Ze&&!!Y.anisotropyMap,kt=At&&!!Y.clearcoatMap,xt=At&&!!Y.clearcoatNormalMap,fn=At&&!!Y.clearcoatRoughnessMap,Gt=ge&&!!Y.iridescenceMap,Jt=ge&&!!Y.iridescenceThicknessMap,Ln=se&&!!Y.sheenColorMap,Zt=se&&!!Y.sheenRoughnessMap,bn=!!Y.specularMap,Jn=!!Y.specularColorMap,ke=!!Y.specularIntensityMap,wt=Ge&&!!Y.transmissionMap,Wt=Ge&&!!Y.thicknessMap,jt=!!Y.gradientMap,tn=!!Y.alphaMap,cn=Y.alphaTest>0,Vn=!!Y.alphaHash,nn=!!Y.extensions;let qt=Eh;Y.toneMapped&&(Vt===null||Vt.isXRRenderTarget===!0)&&(qt=r.toneMapping);const mn={shaderID:Je,shaderType:Y.type,shaderName:Y.name,vertexShader:gt,fragmentShader:bt,defines:Y.defines,customVertexShaderID:zt,customFragmentShaderID:Tt,isRawShaderMaterial:Y.isRawShaderMaterial===!0,glslVersion:Y.glslVersion,precision:k,batching:on,batchingColor:on&&_e._colorsTexture!==null,instancing:Ot,instancingColor:Ot&&_e.instanceColor!==null,instancingMorph:Ot&&_e.morphTexture!==null,supportsVertexTextures:R,numMultiviewViews:_t,outputColorSpace:Vt===null?r.outputColorSpace:Vt.isXRRenderTarget===!0?Vt.texture.colorSpace:Tm,alphaToCoverage:!!Y.alphaToCoverage,map:vt,matcap:Mt,envMap:Bt,envMapMode:Bt&&we.mapping,envMapCubeUVHeight:Le,aoMap:ve,lightMap:Kt,bumpMap:Ee,normalMap:Q,displacementMap:R&&Z,emissiveMap:ae,normalMapObjectSpace:Q&&Y.normalMapType===ez,normalMapTangentSpace:Q&&Y.normalMapType===nf,metalnessMap:Ae,roughnessMap:Ie,anisotropy:Ze,anisotropyMap:ut,clearcoat:At,clearcoatMap:kt,clearcoatNormalMap:xt,clearcoatRoughnessMap:fn,dispersion:dn,iridescence:ge,iridescenceMap:Gt,iridescenceThicknessMap:Jt,sheen:se,sheenColorMap:Ln,sheenRoughnessMap:Zt,specularMap:bn,specularColorMap:Jn,specularIntensityMap:ke,transmission:Ge,transmissionMap:wt,thicknessMap:Wt,gradientMap:jt,opaque:Y.transparent===!1&&Y.blending===wm&&Y.alphaToCoverage===!1,alphaMap:tn,alphaTest:cn,alphaHash:Vn,combine:Y.combine,mapUv:vt&&N(Y.map.channel),aoMapUv:ve&&N(Y.aoMap.channel),lightMapUv:Kt&&N(Y.lightMap.channel),bumpMapUv:Ee&&N(Y.bumpMap.channel),normalMapUv:Q&&N(Y.normalMap.channel),displacementMapUv:Z&&N(Y.displacementMap.channel),emissiveMapUv:ae&&N(Y.emissiveMap.channel),metalnessMapUv:Ae&&N(Y.metalnessMap.channel),roughnessMapUv:Ie&&N(Y.roughnessMap.channel),anisotropyMapUv:ut&&N(Y.anisotropyMap.channel),clearcoatMapUv:kt&&N(Y.clearcoatMap.channel),clearcoatNormalMapUv:xt&&N(Y.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:fn&&N(Y.clearcoatRoughnessMap.channel),iridescenceMapUv:Gt&&N(Y.iridescenceMap.channel),iridescenceThicknessMapUv:Jt&&N(Y.iridescenceThicknessMap.channel),sheenColorMapUv:Ln&&N(Y.sheenColorMap.channel),sheenRoughnessMapUv:Zt&&N(Y.sheenRoughnessMap.channel),specularMapUv:bn&&N(Y.specularMap.channel),specularColorMapUv:Jn&&N(Y.specularColorMap.channel),specularIntensityMapUv:ke&&N(Y.specularIntensityMap.channel),transmissionMapUv:wt&&N(Y.transmissionMap.channel),thicknessMapUv:Wt&&N(Y.thicknessMap.channel),alphaMapUv:tn&&N(Y.alphaMap.channel),vertexTangents:!!rt.attributes.tangent&&(Q||Ze),vertexColors:Y.vertexColors,vertexAlphas:Y.vertexColors===!0&&!!rt.attributes.color&&rt.attributes.color.itemSize===4,pointsUvs:_e.isPoints===!0&&!!rt.attributes.uv&&(vt||tn),fog:!!Pe,useFog:Y.fog===!0,fogExp2:!!Pe&&Pe.isFogExp2,flatShading:Y.flatShading===!0,sizeAttenuation:Y.sizeAttenuation===!0,logarithmicDepthBuffer:E,reverseDepthBuffer:je,skinning:_e.isSkinnedMesh===!0,morphTargets:rt.morphAttributes.position!==void 0,morphNormals:rt.morphAttributes.normal!==void 0,morphColors:rt.morphAttributes.color!==void 0,morphTargetsCount:Ve,morphTextureStride:Ne,numDirLights:ie.directional.length,numPointLights:ie.point.length,numSpotLights:ie.spot.length,numSpotLightMaps:ie.spotLightMap.length,numRectAreaLights:ie.rectArea.length,numHemiLights:ie.hemi.length,numDirLightShadows:ie.directionalShadowMap.length,numPointLightShadows:ie.pointShadowMap.length,numSpotLightShadows:ie.spotShadowMap.length,numSpotLightShadowsWithMaps:ie.numSpotLightShadowsWithMaps,numLightProbes:ie.numLightProbes,numClippingPlanes:p.numPlanes,numClipIntersection:p.numIntersection,dithering:Y.dithering,shadowMapEnabled:r.shadowMap.enabled&&ue.length>0,shadowMapType:r.shadowMap.type,toneMapping:qt,decodeVideoTexture:vt&&Y.map.isVideoTexture===!0&&zi.getTransfer(Y.map.colorSpace)===hs,decodeVideoTextureEmissive:ae&&Y.emissiveMap.isVideoTexture===!0&&zi.getTransfer(Y.emissiveMap.colorSpace)===hs,premultipliedAlpha:Y.premultipliedAlpha,doubleSided:Y.side===mu,flipSided:Y.side===no,useDepthPacking:Y.depthPacking>=0,depthPacking:Y.depthPacking||0,index0AttributeName:Y.index0AttributeName,extensionClipCullDistance:nn&&Y.extensions.clipCullDistance===!0&&a.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(nn&&Y.extensions.multiDraw===!0||on)&&a.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:a.has("KHR_parallel_shader_compile"),customProgramCacheKey:Y.customProgramCacheKey()};return mn.vertexUv1s=w.has(1),mn.vertexUv2s=w.has(2),mn.vertexUv3s=w.has(3),w.clear(),mn}function D(Y){const ie=[];if(Y.shaderID?ie.push(Y.shaderID):(ie.push(Y.customVertexShaderID),ie.push(Y.customFragmentShaderID)),Y.defines!==void 0)for(const ue in Y.defines)ie.push(ue),ie.push(Y.defines[ue]);return Y.isRawShaderMaterial===!1&&(W(ie,Y),H(ie,Y),ie.push(r.outputColorSpace)),ie.push(Y.customProgramCacheKey),ie.join()}function W(Y,ie){Y.push(ie.precision),Y.push(ie.outputColorSpace),Y.push(ie.envMapMode),Y.push(ie.envMapCubeUVHeight),Y.push(ie.mapUv),Y.push(ie.alphaMapUv),Y.push(ie.lightMapUv),Y.push(ie.aoMapUv),Y.push(ie.bumpMapUv),Y.push(ie.normalMapUv),Y.push(ie.displacementMapUv),Y.push(ie.emissiveMapUv),Y.push(ie.metalnessMapUv),Y.push(ie.roughnessMapUv),Y.push(ie.anisotropyMapUv),Y.push(ie.clearcoatMapUv),Y.push(ie.clearcoatNormalMapUv),Y.push(ie.clearcoatRoughnessMapUv),Y.push(ie.iridescenceMapUv),Y.push(ie.iridescenceThicknessMapUv),Y.push(ie.sheenColorMapUv),Y.push(ie.sheenRoughnessMapUv),Y.push(ie.specularMapUv),Y.push(ie.specularColorMapUv),Y.push(ie.specularIntensityMapUv),Y.push(ie.transmissionMapUv),Y.push(ie.thicknessMapUv),Y.push(ie.combine),Y.push(ie.fogExp2),Y.push(ie.sizeAttenuation),Y.push(ie.morphTargetsCount),Y.push(ie.morphAttributeCount),Y.push(ie.numDirLights),Y.push(ie.numPointLights),Y.push(ie.numSpotLights),Y.push(ie.numSpotLightMaps),Y.push(ie.numHemiLights),Y.push(ie.numRectAreaLights),Y.push(ie.numDirLightShadows),Y.push(ie.numPointLightShadows),Y.push(ie.numSpotLightShadows),Y.push(ie.numSpotLightShadowsWithMaps),Y.push(ie.numLightProbes),Y.push(ie.shadowMapType),Y.push(ie.toneMapping),Y.push(ie.numClippingPlanes),Y.push(ie.numClipIntersection),Y.push(ie.depthPacking)}function H(Y,ie){b.disableAll(),ie.supportsVertexTextures&&b.enable(0),ie.instancing&&b.enable(1),ie.instancingColor&&b.enable(2),ie.instancingMorph&&b.enable(3),ie.matcap&&b.enable(4),ie.envMap&&b.enable(5),ie.normalMapObjectSpace&&b.enable(6),ie.normalMapTangentSpace&&b.enable(7),ie.clearcoat&&b.enable(8),ie.iridescence&&b.enable(9),ie.alphaTest&&b.enable(10),ie.vertexColors&&b.enable(11),ie.vertexAlphas&&b.enable(12),ie.vertexUv1s&&b.enable(13),ie.vertexUv2s&&b.enable(14),ie.vertexUv3s&&b.enable(15),ie.vertexTangents&&b.enable(16),ie.anisotropy&&b.enable(17),ie.alphaHash&&b.enable(18),ie.batching&&b.enable(19),ie.dispersion&&b.enable(20),ie.batchingColor&&b.enable(21),Y.push(b.mask),b.disableAll(),ie.fog&&b.enable(0),ie.useFog&&b.enable(1),ie.flatShading&&b.enable(2),ie.logarithmicDepthBuffer&&b.enable(3),ie.reverseDepthBuffer&&b.enable(4),ie.skinning&&b.enable(5),ie.morphTargets&&b.enable(6),ie.morphNormals&&b.enable(7),ie.morphColors&&b.enable(8),ie.premultipliedAlpha&&b.enable(9),ie.shadowMapEnabled&&b.enable(10),ie.doubleSided&&b.enable(11),ie.flipSided&&b.enable(12),ie.useDepthPacking&&b.enable(13),ie.dithering&&b.enable(14),ie.transmission&&b.enable(15),ie.sheen&&b.enable(16),ie.opaque&&b.enable(17),ie.pointsUvs&&b.enable(18),ie.decodeVideoTexture&&b.enable(19),ie.decodeVideoTextureEmissive&&b.enable(20),ie.alphaToCoverage&&b.enable(21),ie.numMultiviewViews&&b.enable(21),Y.push(b.mask)}function K(Y){const ie=G[Y.type];let ue;if(ie){const Re=pc[ie];ue=fz.clone(Re.uniforms)}else ue=Y.uniforms;return ue}function j(Y,ie){let ue;for(let Re=0,_e=I.length;Re<_e;Re++){const Pe=I[Re];if(Pe.cacheKey===ie){ue=Pe,++ue.usedTimes;break}}return ue===void 0&&(ue=new mge(r,ie,Y,h),I.push(ue)),ue}function J(Y){if(--Y.usedTimes===0){const ie=I.indexOf(Y);I[ie]=I[I.length-1],I.pop(),Y.destroy()}}function ee(Y){y.remove(Y)}function re(){y.dispose()}return{getParameters:O,getProgramCacheKey:D,getUniforms:K,acquireProgram:j,releaseProgram:J,releaseShaderCache:ee,programs:I,dispose:re}}function vge(){let r=new WeakMap;function e(p){return r.has(p)}function n(p){let b=r.get(p);return b===void 0&&(b={},r.set(p,b)),b}function a(p){r.delete(p)}function c(p,b,y){r.get(p)[b]=y}function h(){r=new WeakMap}return{has:e,get:n,remove:a,update:c,dispose:h}}function xge(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.material.id!==e.material.id?r.material.id-e.material.id:r.z!==e.z?r.z-e.z:r.id-e.id}function hG(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.z!==e.z?e.z-r.z:r.id-e.id}function dG(){const r=[];let e=0;const n=[],a=[],c=[];function h(){e=0,n.length=0,a.length=0,c.length=0}function p(E,R,k,G,N,O){let D=r[e];return D===void 0?(D={id:E.id,object:E,geometry:R,material:k,groupOrder:G,renderOrder:E.renderOrder,z:N,group:O},r[e]=D):(D.id=E.id,D.object=E,D.geometry=R,D.material=k,D.groupOrder=G,D.renderOrder=E.renderOrder,D.z=N,D.group=O),e++,D}function b(E,R,k,G,N,O){const D=p(E,R,k,G,N,O);k.transmission>0?a.push(D):k.transparent===!0?c.push(D):n.push(D)}function y(E,R,k,G,N,O){const D=p(E,R,k,G,N,O);k.transmission>0?a.unshift(D):k.transparent===!0?c.unshift(D):n.unshift(D)}function w(E,R){n.length>1&&n.sort(E||xge),a.length>1&&a.sort(R||hG),c.length>1&&c.sort(R||hG)}function I(){for(let E=e,R=r.length;E<R;E++){const k=r[E];if(k.id===null)break;k.id=null,k.object=null,k.geometry=null,k.material=null,k.group=null}}return{opaque:n,transmissive:a,transparent:c,init:h,push:b,unshift:y,finish:I,sort:w}}function wge(){let r=new WeakMap;function e(a,c){const h=r.get(a);let p;return h===void 0?(p=new dG,r.set(a,[p])):c>=h.length?(p=new dG,h.push(p)):p=h[c],p}function n(){r=new WeakMap}return{get:e,dispose:n}}function Cge(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new be,color:new pn};break;case"SpotLight":n={position:new be,direction:new be,color:new pn,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new be,color:new pn,distance:0,decay:0};break;case"HemisphereLight":n={direction:new be,skyColor:new pn,groundColor:new pn};break;case"RectAreaLight":n={color:new pn,position:new be,halfWidth:new be,halfHeight:new be};break}return r[e.id]=n,n}}}function Ege(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let n;switch(e.type){case"DirectionalLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Dt};break;case"SpotLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Dt};break;case"PointLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Dt,shadowCameraNear:1,shadowCameraFar:1e3};break}return r[e.id]=n,n}}}let Sge=0;function Ige(r,e){return(e.castShadow?2:0)-(r.castShadow?2:0)+(e.map?1:0)-(r.map?1:0)}function Tge(r){const e=new Cge,n=Ege(),a={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let w=0;w<9;w++)a.probe.push(new be);const c=new be,h=new Zn,p=new Zn;function b(w){let I=0,E=0,R=0;for(let Y=0;Y<9;Y++)a.probe[Y].set(0,0,0);let k=0,G=0,N=0,O=0,D=0,W=0,H=0,K=0,j=0,J=0,ee=0;w.sort(Ige);for(let Y=0,ie=w.length;Y<ie;Y++){const ue=w[Y],Re=ue.color,_e=ue.intensity,Pe=ue.distance,rt=ue.shadow&&ue.shadow.map?ue.shadow.map.texture:null;if(ue.isAmbientLight)I+=Re.r*_e,E+=Re.g*_e,R+=Re.b*_e;else if(ue.isLightProbe){for(let de=0;de<9;de++)a.probe[de].addScaledVector(ue.sh.coefficients[de],_e);ee++}else if(ue.isDirectionalLight){const de=e.get(ue);if(de.color.copy(ue.color).multiplyScalar(ue.intensity),ue.castShadow){const we=ue.shadow,Le=n.get(ue);Le.shadowIntensity=we.intensity,Le.shadowBias=we.bias,Le.shadowNormalBias=we.normalBias,Le.shadowRadius=we.radius,Le.shadowMapSize=we.mapSize,a.directionalShadow[k]=Le,a.directionalShadowMap[k]=rt,a.directionalShadowMatrix[k]=ue.shadow.matrix,W++}a.directional[k]=de,k++}else if(ue.isSpotLight){const de=e.get(ue);de.position.setFromMatrixPosition(ue.matrixWorld),de.color.copy(Re).multiplyScalar(_e),de.distance=Pe,de.coneCos=Math.cos(ue.angle),de.penumbraCos=Math.cos(ue.angle*(1-ue.penumbra)),de.decay=ue.decay,a.spot[N]=de;const we=ue.shadow;if(ue.map&&(a.spotLightMap[j]=ue.map,j++,we.updateMatrices(ue),ue.castShadow&&J++),a.spotLightMatrix[N]=we.matrix,ue.castShadow){const Le=n.get(ue);Le.shadowIntensity=we.intensity,Le.shadowBias=we.bias,Le.shadowNormalBias=we.normalBias,Le.shadowRadius=we.radius,Le.shadowMapSize=we.mapSize,a.spotShadow[N]=Le,a.spotShadowMap[N]=rt,K++}N++}else if(ue.isRectAreaLight){const de=e.get(ue);de.color.copy(Re).multiplyScalar(_e),de.halfWidth.set(ue.width*.5,0,0),de.halfHeight.set(0,ue.height*.5,0),a.rectArea[O]=de,O++}else if(ue.isPointLight){const de=e.get(ue);if(de.color.copy(ue.color).multiplyScalar(ue.intensity),de.distance=ue.distance,de.decay=ue.decay,ue.castShadow){const we=ue.shadow,Le=n.get(ue);Le.shadowIntensity=we.intensity,Le.shadowBias=we.bias,Le.shadowNormalBias=we.normalBias,Le.shadowRadius=we.radius,Le.shadowMapSize=we.mapSize,Le.shadowCameraNear=we.camera.near,Le.shadowCameraFar=we.camera.far,a.pointShadow[G]=Le,a.pointShadowMap[G]=rt,a.pointShadowMatrix[G]=ue.shadow.matrix,H++}a.point[G]=de,G++}else if(ue.isHemisphereLight){const de=e.get(ue);de.skyColor.copy(ue.color).multiplyScalar(_e),de.groundColor.copy(ue.groundColor).multiplyScalar(_e),a.hemi[D]=de,D++}}O>0&&(r.has("OES_texture_float_linear")===!0?(a.rectAreaLTC1=an.LTC_FLOAT_1,a.rectAreaLTC2=an.LTC_FLOAT_2):(a.rectAreaLTC1=an.LTC_HALF_1,a.rectAreaLTC2=an.LTC_HALF_2)),a.ambient[0]=I,a.ambient[1]=E,a.ambient[2]=R;const re=a.hash;(re.directionalLength!==k||re.pointLength!==G||re.spotLength!==N||re.rectAreaLength!==O||re.hemiLength!==D||re.numDirectionalShadows!==W||re.numPointShadows!==H||re.numSpotShadows!==K||re.numSpotMaps!==j||re.numLightProbes!==ee)&&(a.directional.length=k,a.spot.length=N,a.rectArea.length=O,a.point.length=G,a.hemi.length=D,a.directionalShadow.length=W,a.directionalShadowMap.length=W,a.pointShadow.length=H,a.pointShadowMap.length=H,a.spotShadow.length=K,a.spotShadowMap.length=K,a.directionalShadowMatrix.length=W,a.pointShadowMatrix.length=H,a.spotLightMatrix.length=K+j-J,a.spotLightMap.length=j,a.numSpotLightShadowsWithMaps=J,a.numLightProbes=ee,re.directionalLength=k,re.pointLength=G,re.spotLength=N,re.rectAreaLength=O,re.hemiLength=D,re.numDirectionalShadows=W,re.numPointShadows=H,re.numSpotShadows=K,re.numSpotMaps=j,re.numLightProbes=ee,a.version=Sge++)}function y(w,I){let E=0,R=0,k=0,G=0,N=0;const O=I.matrixWorldInverse;for(let D=0,W=w.length;D<W;D++){const H=w[D];if(H.isDirectionalLight){const K=a.directional[E];K.direction.setFromMatrixPosition(H.matrixWorld),c.setFromMatrixPosition(H.target.matrixWorld),K.direction.sub(c),K.direction.transformDirection(O),E++}else if(H.isSpotLight){const K=a.spot[k];K.position.setFromMatrixPosition(H.matrixWorld),K.position.applyMatrix4(O),K.direction.setFromMatrixPosition(H.matrixWorld),c.setFromMatrixPosition(H.target.matrixWorld),K.direction.sub(c),K.direction.transformDirection(O),k++}else if(H.isRectAreaLight){const K=a.rectArea[G];K.position.setFromMatrixPosition(H.matrixWorld),K.position.applyMatrix4(O),p.identity(),h.copy(H.matrixWorld),h.premultiply(O),p.extractRotation(h),K.halfWidth.set(H.width*.5,0,0),K.halfHeight.set(0,H.height*.5,0),K.halfWidth.applyMatrix4(p),K.halfHeight.applyMatrix4(p),G++}else if(H.isPointLight){const K=a.point[R];K.position.setFromMatrixPosition(H.matrixWorld),K.position.applyMatrix4(O),R++}else if(H.isHemisphereLight){const K=a.hemi[N];K.direction.setFromMatrixPosition(H.matrixWorld),K.direction.transformDirection(O),N++}}}return{setup:b,setupView:y,state:a}}function fG(r){const e=new Tge(r),n=[],a=[];function c(I){w.camera=I,n.length=0,a.length=0}function h(I){n.push(I)}function p(I){a.push(I)}function b(){e.setup(n)}function y(I){e.setupView(n,I)}const w={lightsArray:n,shadowsArray:a,camera:null,lights:e,transmissionRenderTarget:{}};return{init:c,state:w,setupLights:b,setupLightsView:y,pushLight:h,pushShadow:p}}function Mge(r){let e=new WeakMap;function n(c,h=0){const p=e.get(c);let b;return p===void 0?(b=new fG(r),e.set(c,[b])):h>=p.length?(b=new fG(r),p.push(b)):b=p[h],b}function a(){e=new WeakMap}return{get:n,dispose:a}}const _ge=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Rge=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function kge(r,e,n){let a=new zv;const c=new Dt,h=new Dt,p=new Xi,b=new xk({depthPacking:JP}),y=new wk,w={},I=n.maxTextureSize,E={[Mh]:no,[no]:Mh,[mu]:mu},R=new bc({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Dt},radius:{value:4}},vertexShader:_ge,fragmentShader:Rge}),k=R.clone();k.defines.HORIZONTAL_PASS=1;const G=new gi;G.setAttribute("position",new bs(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const N=new Er(G,R),O=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=ZR;let D=this.type;this.render=function(J,ee,re){if(O.enabled===!1||O.autoUpdate===!1&&O.needsUpdate===!1||J.length===0)return;const Y=r.getRenderTarget(),ie=r.getActiveCubeFace(),ue=r.getActiveMipmapLevel(),Re=r.state;Re.setBlending(Ch),Re.buffers.color.setClear(1,1,1,1),Re.buffers.depth.setTest(!0),Re.setScissorTest(!1);const _e=D!==fu&&this.type===fu,Pe=D===fu&&this.type!==fu;for(let rt=0,de=J.length;rt<de;rt++){const we=J[rt],Le=we.shadow;if(Le===void 0){console.warn("THREE.WebGLShadowMap:",we,"has no shadow.");continue}if(Le.autoUpdate===!1&&Le.needsUpdate===!1)continue;c.copy(Le.mapSize);const Je=Le.getFrameExtents();if(c.multiply(Je),h.copy(Le.mapSize),(c.x>I||c.y>I)&&(c.x>I&&(h.x=Math.floor(I/Je.x),c.x=h.x*Je.x,Le.mapSize.x=h.x),c.y>I&&(h.y=Math.floor(I/Je.y),c.y=h.y*Je.y,Le.mapSize.y=h.y)),Le.map===null||_e===!0||Pe===!0){const Ve=this.type!==fu?{minFilter:ia,magFilter:ia}:{};Le.map!==null&&Le.map.dispose(),Le.map=new Ac(c.x,c.y,Ve),Le.map.texture.name=we.name+".shadowMap",Le.camera.updateProjectionMatrix()}r.setRenderTarget(Le.map),r.clear();const fe=Le.getViewportCount();for(let Ve=0;Ve<fe;Ve++){const Ne=Le.getViewport(Ve);p.set(h.x*Ne.x,h.y*Ne.y,h.x*Ne.z,h.y*Ne.w),Re.viewport(p),Le.updateMatrices(we,Ve),a=Le.getFrustum(),K(ee,re,Le.camera,we,this.type)}Le.isPointLightShadow!==!0&&this.type===fu&&W(Le,re),Le.needsUpdate=!1}D=this.type,O.needsUpdate=!1,r.setRenderTarget(Y,ie,ue)};function W(J,ee){const re=e.update(N);R.defines.VSM_SAMPLES!==J.blurSamples&&(R.defines.VSM_SAMPLES=J.blurSamples,k.defines.VSM_SAMPLES=J.blurSamples,R.needsUpdate=!0,k.needsUpdate=!0),J.mapPass===null&&(J.mapPass=new Ac(c.x,c.y)),R.uniforms.shadow_pass.value=J.map.texture,R.uniforms.resolution.value=J.mapSize,R.uniforms.radius.value=J.radius,r.setRenderTarget(J.mapPass),r.clear(),r.renderBufferDirect(ee,null,re,R,N,null),k.uniforms.shadow_pass.value=J.mapPass.texture,k.uniforms.resolution.value=J.mapSize,k.uniforms.radius.value=J.radius,r.setRenderTarget(J.map),r.clear(),r.renderBufferDirect(ee,null,re,k,N,null)}function H(J,ee,re,Y){let ie=null;const ue=re.isPointLight===!0?J.customDistanceMaterial:J.customDepthMaterial;if(ue!==void 0)ie=ue;else if(ie=re.isPointLight===!0?y:b,r.localClippingEnabled&&ee.clipShadows===!0&&Array.isArray(ee.clippingPlanes)&&ee.clippingPlanes.length!==0||ee.displacementMap&&ee.displacementScale!==0||ee.alphaMap&&ee.alphaTest>0||ee.map&&ee.alphaTest>0){const Re=ie.uuid,_e=ee.uuid;let Pe=w[Re];Pe===void 0&&(Pe={},w[Re]=Pe);let rt=Pe[_e];rt===void 0&&(rt=ie.clone(),Pe[_e]=rt,ee.addEventListener("dispose",j)),ie=rt}if(ie.visible=ee.visible,ie.wireframe=ee.wireframe,Y===fu?ie.side=ee.shadowSide!==null?ee.shadowSide:ee.side:ie.side=ee.shadowSide!==null?ee.shadowSide:E[ee.side],ie.alphaMap=ee.alphaMap,ie.alphaTest=ee.alphaTest,ie.map=ee.map,ie.clipShadows=ee.clipShadows,ie.clippingPlanes=ee.clippingPlanes,ie.clipIntersection=ee.clipIntersection,ie.displacementMap=ee.displacementMap,ie.displacementScale=ee.displacementScale,ie.displacementBias=ee.displacementBias,ie.wireframeLinewidth=ee.wireframeLinewidth,ie.linewidth=ee.linewidth,re.isPointLight===!0&&ie.isMeshDistanceMaterial===!0){const Re=r.properties.get(ie);Re.light=re}return ie}function K(J,ee,re,Y,ie){if(J.visible===!1)return;if(J.layers.test(ee.layers)&&(J.isMesh||J.isLine||J.isPoints)&&(J.castShadow||J.receiveShadow&&ie===fu)&&(!J.frustumCulled||a.intersectsObject(J))){J.modelViewMatrix.multiplyMatrices(re.matrixWorldInverse,J.matrixWorld);const _e=e.update(J),Pe=J.material;if(Array.isArray(Pe)){const rt=_e.groups;for(let de=0,we=rt.length;de<we;de++){const Le=rt[de],Je=Pe[Le.materialIndex];if(Je&&Je.visible){const fe=H(J,Je,Y,ie);J.onBeforeShadow(r,J,ee,re,_e,fe,Le),r.renderBufferDirect(re,null,_e,fe,J,Le),J.onAfterShadow(r,J,ee,re,_e,fe,Le)}}}else if(Pe.visible){const rt=H(J,Pe,Y,ie);J.onBeforeShadow(r,J,ee,re,_e,rt,null),r.renderBufferDirect(re,null,_e,rt,J,null),J.onAfterShadow(r,J,ee,re,_e,rt,null)}}const Re=J.children;for(let _e=0,Pe=Re.length;_e<Pe;_e++)K(Re[_e],ee,re,Y,ie)}function j(J){J.target.removeEventListener("dispose",j);for(const re in w){const Y=w[re],ie=J.target.uuid;ie in Y&&(Y[ie].dispose(),delete Y[ie])}}}const Bge={[AE]:bE,[yE]:wE,[vE]:CE,[Im]:xE,[bE]:AE,[wE]:yE,[CE]:vE,[xE]:Im};function Lge(r,e){function n(){let ke=!1;const wt=new Xi;let Wt=null;const jt=new Xi(0,0,0,0);return{setMask:function(tn){Wt!==tn&&!ke&&(r.colorMask(tn,tn,tn,tn),Wt=tn)},setLocked:function(tn){ke=tn},setClear:function(tn,cn,Vn,nn,qt){qt===!0&&(tn*=nn,cn*=nn,Vn*=nn),wt.set(tn,cn,Vn,nn),jt.equals(wt)===!1&&(r.clearColor(tn,cn,Vn,nn),jt.copy(wt))},reset:function(){ke=!1,Wt=null,jt.set(-1,0,0,0)}}}function a(){let ke=!1,wt=!1,Wt=null,jt=null,tn=null;return{setReversed:function(cn){if(wt!==cn){const Vn=e.get("EXT_clip_control");wt?Vn.clipControlEXT(Vn.LOWER_LEFT_EXT,Vn.ZERO_TO_ONE_EXT):Vn.clipControlEXT(Vn.LOWER_LEFT_EXT,Vn.NEGATIVE_ONE_TO_ONE_EXT);const nn=tn;tn=null,this.setClear(nn)}wt=cn},getReversed:function(){return wt},setTest:function(cn){cn?Vt(r.DEPTH_TEST):je(r.DEPTH_TEST)},setMask:function(cn){Wt!==cn&&!ke&&(r.depthMask(cn),Wt=cn)},setFunc:function(cn){if(wt&&(cn=Bge[cn]),jt!==cn){switch(cn){case AE:r.depthFunc(r.NEVER);break;case bE:r.depthFunc(r.ALWAYS);break;case yE:r.depthFunc(r.LESS);break;case Im:r.depthFunc(r.LEQUAL);break;case vE:r.depthFunc(r.EQUAL);break;case xE:r.depthFunc(r.GEQUAL);break;case wE:r.depthFunc(r.GREATER);break;case CE:r.depthFunc(r.NOTEQUAL);break;default:r.depthFunc(r.LEQUAL)}jt=cn}},setLocked:function(cn){ke=cn},setClear:function(cn){tn!==cn&&(wt&&(cn=1-cn),r.clearDepth(cn),tn=cn)},reset:function(){ke=!1,Wt=null,jt=null,tn=null,wt=!1}}}function c(){let ke=!1,wt=null,Wt=null,jt=null,tn=null,cn=null,Vn=null,nn=null,qt=null;return{setTest:function(mn){ke||(mn?Vt(r.STENCIL_TEST):je(r.STENCIL_TEST))},setMask:function(mn){wt!==mn&&!ke&&(r.stencilMask(mn),wt=mn)},setFunc:function(mn,fi,Ki){(Wt!==mn||jt!==fi||tn!==Ki)&&(r.stencilFunc(mn,fi,Ki),Wt=mn,jt=fi,tn=Ki)},setOp:function(mn,fi,Ki){(cn!==mn||Vn!==fi||nn!==Ki)&&(r.stencilOp(mn,fi,Ki),cn=mn,Vn=fi,nn=Ki)},setLocked:function(mn){ke=mn},setClear:function(mn){qt!==mn&&(r.clearStencil(mn),qt=mn)},reset:function(){ke=!1,wt=null,Wt=null,jt=null,tn=null,cn=null,Vn=null,nn=null,qt=null}}}const h=new n,p=new a,b=new c,y=new WeakMap,w=new WeakMap;let I={},E={},R=new WeakMap,k=[],G=null,N=!1,O=null,D=null,W=null,H=null,K=null,j=null,J=null,ee=new pn(0,0,0),re=0,Y=!1,ie=null,ue=null,Re=null,_e=null,Pe=null;const rt=r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let de=!1,we=0;const Le=r.getParameter(r.VERSION);Le.indexOf("WebGL")!==-1?(we=parseFloat(/^WebGL (\d)/.exec(Le)[1]),de=we>=1):Le.indexOf("OpenGL ES")!==-1&&(we=parseFloat(/^OpenGL ES (\d)/.exec(Le)[1]),de=we>=2);let Je=null,fe={};const Ve=r.getParameter(r.SCISSOR_BOX),Ne=r.getParameter(r.VIEWPORT),gt=new Xi().fromArray(Ve),bt=new Xi().fromArray(Ne);function zt(ke,wt,Wt,jt){const tn=new Uint8Array(4),cn=r.createTexture();r.bindTexture(ke,cn),r.texParameteri(ke,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(ke,r.TEXTURE_MAG_FILTER,r.NEAREST);for(let Vn=0;Vn<Wt;Vn++)ke===r.TEXTURE_3D||ke===r.TEXTURE_2D_ARRAY?r.texImage3D(wt,0,r.RGBA,1,1,jt,0,r.RGBA,r.UNSIGNED_BYTE,tn):r.texImage2D(wt+Vn,0,r.RGBA,1,1,0,r.RGBA,r.UNSIGNED_BYTE,tn);return cn}const Tt={};Tt[r.TEXTURE_2D]=zt(r.TEXTURE_2D,r.TEXTURE_2D,1),Tt[r.TEXTURE_CUBE_MAP]=zt(r.TEXTURE_CUBE_MAP,r.TEXTURE_CUBE_MAP_POSITIVE_X,6),Tt[r.TEXTURE_2D_ARRAY]=zt(r.TEXTURE_2D_ARRAY,r.TEXTURE_2D_ARRAY,1,1),Tt[r.TEXTURE_3D]=zt(r.TEXTURE_3D,r.TEXTURE_3D,1,1),h.setClear(0,0,0,1),p.setClear(1),b.setClear(0),Vt(r.DEPTH_TEST),p.setFunc(Im),Kt(!1),Ee(J_),Vt(r.CULL_FACE),Bt(Ch);function Vt(ke){I[ke]!==!0&&(r.enable(ke),I[ke]=!0)}function je(ke){I[ke]!==!1&&(r.disable(ke),I[ke]=!1)}function _t(ke,wt){return E[ke]!==wt?(r.bindFramebuffer(ke,wt),E[ke]=wt,ke===r.DRAW_FRAMEBUFFER&&(E[r.FRAMEBUFFER]=wt),ke===r.FRAMEBUFFER&&(E[r.DRAW_FRAMEBUFFER]=wt),!0):!1}function Ot(ke,wt){let Wt=k,jt=!1;if(ke){Wt=R.get(wt),Wt===void 0&&(Wt=[],R.set(wt,Wt));const tn=ke.textures;if(Wt.length!==tn.length||Wt[0]!==r.COLOR_ATTACHMENT0){for(let cn=0,Vn=tn.length;cn<Vn;cn++)Wt[cn]=r.COLOR_ATTACHMENT0+cn;Wt.length=tn.length,jt=!0}}else Wt[0]!==r.BACK&&(Wt[0]=r.BACK,jt=!0);jt&&r.drawBuffers(Wt)}function on(ke){return G!==ke?(r.useProgram(ke),G=ke,!0):!1}const vt={[Zd]:r.FUNC_ADD,[wP]:r.FUNC_SUBTRACT,[CP]:r.FUNC_REVERSE_SUBTRACT};vt[EP]=r.MIN,vt[SP]=r.MAX;const Mt={[IP]:r.ZERO,[TP]:r.ONE,[MP]:r.SRC_COLOR,[mE]:r.SRC_ALPHA,[NP]:r.SRC_ALPHA_SATURATE,[BP]:r.DST_COLOR,[RP]:r.DST_ALPHA,[_P]:r.ONE_MINUS_SRC_COLOR,[gE]:r.ONE_MINUS_SRC_ALPHA,[LP]:r.ONE_MINUS_DST_COLOR,[kP]:r.ONE_MINUS_DST_ALPHA,[DP]:r.CONSTANT_COLOR,[FP]:r.ONE_MINUS_CONSTANT_COLOR,[OP]:r.CONSTANT_ALPHA,[GP]:r.ONE_MINUS_CONSTANT_ALPHA};function Bt(ke,wt,Wt,jt,tn,cn,Vn,nn,qt,mn){if(ke===Ch){N===!0&&(je(r.BLEND),N=!1);return}if(N===!1&&(Vt(r.BLEND),N=!0),ke!==xP){if(ke!==O||mn!==Y){if((D!==Zd||K!==Zd)&&(r.blendEquation(r.FUNC_ADD),D=Zd,K=Zd),mn)switch(ke){case wm:r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA);break;case eR:r.blendFunc(r.ONE,r.ONE);break;case tR:r.blendFuncSeparate(r.ZERO,r.ONE_MINUS_SRC_COLOR,r.ZERO,r.ONE);break;case nR:r.blendFuncSeparate(r.ZERO,r.SRC_COLOR,r.ZERO,r.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",ke);break}else switch(ke){case wm:r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA);break;case eR:r.blendFunc(r.SRC_ALPHA,r.ONE);break;case tR:r.blendFuncSeparate(r.ZERO,r.ONE_MINUS_SRC_COLOR,r.ZERO,r.ONE);break;case nR:r.blendFunc(r.ZERO,r.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",ke);break}W=null,H=null,j=null,J=null,ee.set(0,0,0),re=0,O=ke,Y=mn}return}tn=tn||wt,cn=cn||Wt,Vn=Vn||jt,(wt!==D||tn!==K)&&(r.blendEquationSeparate(vt[wt],vt[tn]),D=wt,K=tn),(Wt!==W||jt!==H||cn!==j||Vn!==J)&&(r.blendFuncSeparate(Mt[Wt],Mt[jt],Mt[cn],Mt[Vn]),W=Wt,H=jt,j=cn,J=Vn),(nn.equals(ee)===!1||qt!==re)&&(r.blendColor(nn.r,nn.g,nn.b,qt),ee.copy(nn),re=qt),O=ke,Y=!1}function ve(ke,wt){ke.side===mu?je(r.CULL_FACE):Vt(r.CULL_FACE);let Wt=ke.side===no;wt&&(Wt=!Wt),Kt(Wt),ke.blending===wm&&ke.transparent===!1?Bt(Ch):Bt(ke.blending,ke.blendEquation,ke.blendSrc,ke.blendDst,ke.blendEquationAlpha,ke.blendSrcAlpha,ke.blendDstAlpha,ke.blendColor,ke.blendAlpha,ke.premultipliedAlpha),p.setFunc(ke.depthFunc),p.setTest(ke.depthTest),p.setMask(ke.depthWrite),h.setMask(ke.colorWrite);const jt=ke.stencilWrite;b.setTest(jt),jt&&(b.setMask(ke.stencilWriteMask),b.setFunc(ke.stencilFunc,ke.stencilRef,ke.stencilFuncMask),b.setOp(ke.stencilFail,ke.stencilZFail,ke.stencilZPass)),Z(ke.polygonOffset,ke.polygonOffsetFactor,ke.polygonOffsetUnits),ke.alphaToCoverage===!0?Vt(r.SAMPLE_ALPHA_TO_COVERAGE):je(r.SAMPLE_ALPHA_TO_COVERAGE)}function Kt(ke){ie!==ke&&(ke?r.frontFace(r.CW):r.frontFace(r.CCW),ie=ke)}function Ee(ke){ke!==bP?(Vt(r.CULL_FACE),ke!==ue&&(ke===J_?r.cullFace(r.BACK):ke===yP?r.cullFace(r.FRONT):r.cullFace(r.FRONT_AND_BACK))):je(r.CULL_FACE),ue=ke}function Q(ke){ke!==Re&&(de&&r.lineWidth(ke),Re=ke)}function Z(ke,wt,Wt){ke?(Vt(r.POLYGON_OFFSET_FILL),(_e!==wt||Pe!==Wt)&&(r.polygonOffset(wt,Wt),_e=wt,Pe=Wt)):je(r.POLYGON_OFFSET_FILL)}function ae(ke){ke?Vt(r.SCISSOR_TEST):je(r.SCISSOR_TEST)}function Ae(ke){ke===void 0&&(ke=r.TEXTURE0+rt-1),Je!==ke&&(r.activeTexture(ke),Je=ke)}function Ie(ke,wt,Wt){Wt===void 0&&(Je===null?Wt=r.TEXTURE0+rt-1:Wt=Je);let jt=fe[Wt];jt===void 0&&(jt={type:void 0,texture:void 0},fe[Wt]=jt),(jt.type!==ke||jt.texture!==wt)&&(Je!==Wt&&(r.activeTexture(Wt),Je=Wt),r.bindTexture(ke,wt||Tt[ke]),jt.type=ke,jt.texture=wt)}function Ze(){const ke=fe[Je];ke!==void 0&&ke.type!==void 0&&(r.bindTexture(ke.type,null),ke.type=void 0,ke.texture=void 0)}function At(){try{r.compressedTexImage2D.apply(r,arguments)}catch(ke){console.error("THREE.WebGLState:",ke)}}function dn(){try{r.compressedTexImage3D.apply(r,arguments)}catch(ke){console.error("THREE.WebGLState:",ke)}}function ge(){try{r.texSubImage2D.apply(r,arguments)}catch(ke){console.error("THREE.WebGLState:",ke)}}function se(){try{r.texSubImage3D.apply(r,arguments)}catch(ke){console.error("THREE.WebGLState:",ke)}}function Ge(){try{r.compressedTexSubImage2D.apply(r,arguments)}catch(ke){console.error("THREE.WebGLState:",ke)}}function ut(){try{r.compressedTexSubImage3D.apply(r,arguments)}catch(ke){console.error("THREE.WebGLState:",ke)}}function kt(){try{r.texStorage2D.apply(r,arguments)}catch(ke){console.error("THREE.WebGLState:",ke)}}function xt(){try{r.texStorage3D.apply(r,arguments)}catch(ke){console.error("THREE.WebGLState:",ke)}}function fn(){try{r.texImage2D.apply(r,arguments)}catch(ke){console.error("THREE.WebGLState:",ke)}}function Gt(){try{r.texImage3D.apply(r,arguments)}catch(ke){console.error("THREE.WebGLState:",ke)}}function Jt(ke){gt.equals(ke)===!1&&(r.scissor(ke.x,ke.y,ke.z,ke.w),gt.copy(ke))}function Ln(ke){bt.equals(ke)===!1&&(r.viewport(ke.x,ke.y,ke.z,ke.w),bt.copy(ke))}function Zt(ke,wt){let Wt=w.get(wt);Wt===void 0&&(Wt=new WeakMap,w.set(wt,Wt));let jt=Wt.get(ke);jt===void 0&&(jt=r.getUniformBlockIndex(wt,ke.name),Wt.set(ke,jt))}function bn(ke,wt){const jt=w.get(wt).get(ke);y.get(wt)!==jt&&(r.uniformBlockBinding(wt,jt,ke.__bindingPointIndex),y.set(wt,jt))}function Jn(){r.disable(r.BLEND),r.disable(r.CULL_FACE),r.disable(r.DEPTH_TEST),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SCISSOR_TEST),r.disable(r.STENCIL_TEST),r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),r.blendEquation(r.FUNC_ADD),r.blendFunc(r.ONE,r.ZERO),r.blendFuncSeparate(r.ONE,r.ZERO,r.ONE,r.ZERO),r.blendColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clearColor(0,0,0,0),r.depthMask(!0),r.depthFunc(r.LESS),p.setReversed(!1),r.clearDepth(1),r.stencilMask(4294967295),r.stencilFunc(r.ALWAYS,0,4294967295),r.stencilOp(r.KEEP,r.KEEP,r.KEEP),r.clearStencil(0),r.cullFace(r.BACK),r.frontFace(r.CCW),r.polygonOffset(0,0),r.activeTexture(r.TEXTURE0),r.bindFramebuffer(r.FRAMEBUFFER,null),r.bindFramebuffer(r.DRAW_FRAMEBUFFER,null),r.bindFramebuffer(r.READ_FRAMEBUFFER,null),r.useProgram(null),r.lineWidth(1),r.scissor(0,0,r.canvas.width,r.canvas.height),r.viewport(0,0,r.canvas.width,r.canvas.height),I={},Je=null,fe={},E={},R=new WeakMap,k=[],G=null,N=!1,O=null,D=null,W=null,H=null,K=null,j=null,J=null,ee=new pn(0,0,0),re=0,Y=!1,ie=null,ue=null,Re=null,_e=null,Pe=null,gt.set(0,0,r.canvas.width,r.canvas.height),bt.set(0,0,r.canvas.width,r.canvas.height),h.reset(),p.reset(),b.reset()}return{buffers:{color:h,depth:p,stencil:b},enable:Vt,disable:je,bindFramebuffer:_t,drawBuffers:Ot,useProgram:on,setBlending:Bt,setMaterial:ve,setFlipSided:Kt,setCullFace:Ee,setLineWidth:Q,setPolygonOffset:Z,setScissorTest:ae,activeTexture:Ae,bindTexture:Ie,unbindTexture:Ze,compressedTexImage2D:At,compressedTexImage3D:dn,texImage2D:fn,texImage3D:Gt,updateUBOMapping:Zt,uniformBlockBinding:bn,texStorage2D:kt,texStorage3D:xt,texSubImage2D:ge,texSubImage3D:se,compressedTexSubImage2D:Ge,compressedTexSubImage3D:ut,scissor:Jt,viewport:Ln,reset:Jn}}function Nge(r,e,n,a,c,h,p){const b=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,y=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),w=e.has("OCULUS_multiview")?e.get("OCULUS_multiview"):null,I=new Dt,E=new WeakMap;let R;const k=new WeakMap;let G=[],N=!1,O=!1;try{O=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function D(ge,se){return O?new OffscreenCanvas(ge,se):Cv("canvas")}function W(ge,se,Ge){let ut=1;const kt=dn(ge);if((kt.width>Ge||kt.height>Ge)&&(ut=Ge/Math.max(kt.width,kt.height)),ut<1)if(typeof HTMLImageElement<"u"&&ge instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&ge instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&ge instanceof ImageBitmap||typeof VideoFrame<"u"&&ge instanceof VideoFrame){const xt=Math.floor(ut*kt.width),fn=Math.floor(ut*kt.height);R===void 0&&(R=D(xt,fn));const Gt=se?D(xt,fn):R;return Gt.width=xt,Gt.height=fn,Gt.getContext("2d").drawImage(ge,0,0,xt,fn),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+kt.width+"x"+kt.height+") to ("+xt+"x"+fn+")."),Gt}else return"data"in ge&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+kt.width+"x"+kt.height+")."),ge;return ge}function H(ge){return ge.generateMipmaps}function K(ge){r.generateMipmap(ge)}function j(ge){return ge.isWebGLCubeRenderTarget?r.TEXTURE_CUBE_MAP:ge.isWebGL3DRenderTarget?r.TEXTURE_3D:ge.isWebGLArrayRenderTarget||ge.isCompressedArrayTexture?r.TEXTURE_2D_ARRAY:r.TEXTURE_2D}function J(ge,se,Ge,ut,kt=!1){if(ge!==null){if(r[ge]!==void 0)return r[ge];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+ge+"'")}let xt=se;if(se===r.RED&&(Ge===r.FLOAT&&(xt=r.R32F),Ge===r.HALF_FLOAT&&(xt=r.R16F),Ge===r.UNSIGNED_BYTE&&(xt=r.R8)),se===r.RED_INTEGER&&(Ge===r.UNSIGNED_BYTE&&(xt=r.R8UI),Ge===r.UNSIGNED_SHORT&&(xt=r.R16UI),Ge===r.UNSIGNED_INT&&(xt=r.R32UI),Ge===r.BYTE&&(xt=r.R8I),Ge===r.SHORT&&(xt=r.R16I),Ge===r.INT&&(xt=r.R32I)),se===r.RG&&(Ge===r.FLOAT&&(xt=r.RG32F),Ge===r.HALF_FLOAT&&(xt=r.RG16F),Ge===r.UNSIGNED_BYTE&&(xt=r.RG8)),se===r.RG_INTEGER&&(Ge===r.UNSIGNED_BYTE&&(xt=r.RG8UI),Ge===r.UNSIGNED_SHORT&&(xt=r.RG16UI),Ge===r.UNSIGNED_INT&&(xt=r.RG32UI),Ge===r.BYTE&&(xt=r.RG8I),Ge===r.SHORT&&(xt=r.RG16I),Ge===r.INT&&(xt=r.RG32I)),se===r.RGB_INTEGER&&(Ge===r.UNSIGNED_BYTE&&(xt=r.RGB8UI),Ge===r.UNSIGNED_SHORT&&(xt=r.RGB16UI),Ge===r.UNSIGNED_INT&&(xt=r.RGB32UI),Ge===r.BYTE&&(xt=r.RGB8I),Ge===r.SHORT&&(xt=r.RGB16I),Ge===r.INT&&(xt=r.RGB32I)),se===r.RGBA_INTEGER&&(Ge===r.UNSIGNED_BYTE&&(xt=r.RGBA8UI),Ge===r.UNSIGNED_SHORT&&(xt=r.RGBA16UI),Ge===r.UNSIGNED_INT&&(xt=r.RGBA32UI),Ge===r.BYTE&&(xt=r.RGBA8I),Ge===r.SHORT&&(xt=r.RGBA16I),Ge===r.INT&&(xt=r.RGBA32I)),se===r.RGB&&Ge===r.UNSIGNED_INT_5_9_9_9_REV&&(xt=r.RGB9_E5),se===r.RGBA){const fn=kt?vv:zi.getTransfer(ut);Ge===r.FLOAT&&(xt=r.RGBA32F),Ge===r.HALF_FLOAT&&(xt=r.RGBA16F),Ge===r.UNSIGNED_BYTE&&(xt=fn===hs?r.SRGB8_ALPHA8:r.RGBA8),Ge===r.UNSIGNED_SHORT_4_4_4_4&&(xt=r.RGBA4),Ge===r.UNSIGNED_SHORT_5_5_5_1&&(xt=r.RGB5_A1)}return(xt===r.R16F||xt===r.R32F||xt===r.RG16F||xt===r.RG32F||xt===r.RGBA16F||xt===r.RGBA32F)&&e.get("EXT_color_buffer_float"),xt}function ee(ge,se){let Ge;return ge?se===null||se===Rh||se===$d?Ge=r.DEPTH24_STENCIL8:se===qa?Ge=r.DEPTH32F_STENCIL8:se===q0&&(Ge=r.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):se===null||se===Rh||se===$d?Ge=r.DEPTH_COMPONENT24:se===qa?Ge=r.DEPTH_COMPONENT32F:se===q0&&(Ge=r.DEPTH_COMPONENT16),Ge}function re(ge,se){return H(ge)===!0||ge.isFramebufferTexture&&ge.minFilter!==ia&&ge.minFilter!==Dr?Math.log2(Math.max(se.width,se.height))+1:ge.mipmaps!==void 0&&ge.mipmaps.length>0?ge.mipmaps.length:ge.isCompressedTexture&&Array.isArray(ge.image)?se.mipmaps.length:1}function Y(ge){const se=ge.target;se.removeEventListener("dispose",Y),ue(se),se.isVideoTexture&&E.delete(se)}function ie(ge){const se=ge.target;se.removeEventListener("dispose",ie),_e(se)}function ue(ge){const se=a.get(ge);if(se.__webglInit===void 0)return;const Ge=ge.source,ut=k.get(Ge);if(ut){const kt=ut[se.__cacheKey];kt.usedTimes--,kt.usedTimes===0&&Re(ge),Object.keys(ut).length===0&&k.delete(Ge)}a.remove(ge)}function Re(ge){const se=a.get(ge);r.deleteTexture(se.__webglTexture);const Ge=ge.source,ut=k.get(Ge);delete ut[se.__cacheKey],p.memory.textures--}function _e(ge){const se=a.get(ge);if(ge.depthTexture&&(ge.depthTexture.dispose(),a.remove(ge.depthTexture)),ge.isWebGLCubeRenderTarget)for(let ut=0;ut<6;ut++){if(Array.isArray(se.__webglFramebuffer[ut]))for(let kt=0;kt<se.__webglFramebuffer[ut].length;kt++)r.deleteFramebuffer(se.__webglFramebuffer[ut][kt]);else r.deleteFramebuffer(se.__webglFramebuffer[ut]);se.__webglDepthbuffer&&r.deleteRenderbuffer(se.__webglDepthbuffer[ut])}else{if(Array.isArray(se.__webglFramebuffer))for(let ut=0;ut<se.__webglFramebuffer.length;ut++)r.deleteFramebuffer(se.__webglFramebuffer[ut]);else r.deleteFramebuffer(se.__webglFramebuffer);if(se.__webglDepthbuffer&&r.deleteRenderbuffer(se.__webglDepthbuffer),se.__webglMultisampledFramebuffer&&r.deleteFramebuffer(se.__webglMultisampledFramebuffer),se.__webglColorRenderbuffer)for(let ut=0;ut<se.__webglColorRenderbuffer.length;ut++)se.__webglColorRenderbuffer[ut]&&r.deleteRenderbuffer(se.__webglColorRenderbuffer[ut]);se.__webglDepthRenderbuffer&&r.deleteRenderbuffer(se.__webglDepthRenderbuffer)}const Ge=ge.textures;for(let ut=0,kt=Ge.length;ut<kt;ut++){const xt=a.get(Ge[ut]);xt.__webglTexture&&(r.deleteTexture(xt.__webglTexture),p.memory.textures--),a.remove(Ge[ut])}a.remove(ge)}let Pe=0;function rt(){Pe=0}function de(){const ge=Pe;return ge>=c.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+ge+" texture units while this GPU supports only "+c.maxTextures),Pe+=1,ge}function we(ge){const se=[];return se.push(ge.wrapS),se.push(ge.wrapT),se.push(ge.wrapR||0),se.push(ge.magFilter),se.push(ge.minFilter),se.push(ge.anisotropy),se.push(ge.internalFormat),se.push(ge.format),se.push(ge.type),se.push(ge.generateMipmaps),se.push(ge.premultiplyAlpha),se.push(ge.flipY),se.push(ge.unpackAlignment),se.push(ge.colorSpace),se.join()}function Le(ge,se){const Ge=a.get(ge);if(ge.isVideoTexture&&Ze(ge),ge.isRenderTargetTexture===!1&&ge.version>0&&Ge.__version!==ge.version){const ut=ge.image;if(ut===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(ut.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else if(_t(Ge,ge,se))return}n.bindTexture(r.TEXTURE_2D,Ge.__webglTexture,r.TEXTURE0+se)}function Je(ge,se){const Ge=a.get(ge);if(ge.version>0&&Ge.__version!==ge.version){_t(Ge,ge,se);return}n.bindTexture(r.TEXTURE_2D_ARRAY,Ge.__webglTexture,r.TEXTURE0+se)}function fe(ge,se){const Ge=a.get(ge);if(ge.version>0&&Ge.__version!==ge.version){_t(Ge,ge,se);return}n.bindTexture(r.TEXTURE_3D,Ge.__webglTexture,r.TEXTURE0+se)}function Ve(ge,se){const Ge=a.get(ge);if(ge.version>0&&Ge.__version!==ge.version){Ot(Ge,ge,se);return}n.bindTexture(r.TEXTURE_CUBE_MAP,Ge.__webglTexture,r.TEXTURE0+se)}const Ne={[gv]:r.REPEAT,[Rl]:r.CLAMP_TO_EDGE,[Av]:r.MIRRORED_REPEAT},gt={[ia]:r.NEAREST,[$R]:r.NEAREST_MIPMAP_NEAREST,[H0]:r.NEAREST_MIPMAP_LINEAR,[Dr]:r.LINEAR,[iv]:r.LINEAR_MIPMAP_NEAREST,[gu]:r.LINEAR_MIPMAP_LINEAR},bt={[tz]:r.NEVER,[oz]:r.ALWAYS,[nz]:r.LESS,[ak]:r.LEQUAL,[iz]:r.EQUAL,[az]:r.GEQUAL,[sz]:r.GREATER,[rz]:r.NOTEQUAL};function zt(ge,se){if(se.type===qa&&e.has("OES_texture_float_linear")===!1&&(se.magFilter===Dr||se.magFilter===iv||se.magFilter===H0||se.magFilter===gu||se.minFilter===Dr||se.minFilter===iv||se.minFilter===H0||se.minFilter===gu)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),r.texParameteri(ge,r.TEXTURE_WRAP_S,Ne[se.wrapS]),r.texParameteri(ge,r.TEXTURE_WRAP_T,Ne[se.wrapT]),(ge===r.TEXTURE_3D||ge===r.TEXTURE_2D_ARRAY)&&r.texParameteri(ge,r.TEXTURE_WRAP_R,Ne[se.wrapR]),r.texParameteri(ge,r.TEXTURE_MAG_FILTER,gt[se.magFilter]),r.texParameteri(ge,r.TEXTURE_MIN_FILTER,gt[se.minFilter]),se.compareFunction&&(r.texParameteri(ge,r.TEXTURE_COMPARE_MODE,r.COMPARE_REF_TO_TEXTURE),r.texParameteri(ge,r.TEXTURE_COMPARE_FUNC,bt[se.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(se.magFilter===ia||se.minFilter!==H0&&se.minFilter!==gu||se.type===qa&&e.has("OES_texture_float_linear")===!1)return;if(se.anisotropy>1||a.get(se).__currentAnisotropy){const Ge=e.get("EXT_texture_filter_anisotropic");r.texParameterf(ge,Ge.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(se.anisotropy,c.getMaxAnisotropy())),a.get(se).__currentAnisotropy=se.anisotropy}}}function Tt(ge,se){let Ge=!1;ge.__webglInit===void 0&&(ge.__webglInit=!0,se.addEventListener("dispose",Y));const ut=se.source;let kt=k.get(ut);kt===void 0&&(kt={},k.set(ut,kt));const xt=we(se);if(xt!==ge.__cacheKey){kt[xt]===void 0&&(kt[xt]={texture:r.createTexture(),usedTimes:0},p.memory.textures++,Ge=!0),kt[xt].usedTimes++;const fn=kt[ge.__cacheKey];fn!==void 0&&(kt[ge.__cacheKey].usedTimes--,fn.usedTimes===0&&Re(se)),ge.__cacheKey=xt,ge.__webglTexture=kt[xt].texture}return Ge}function Vt(ge){N=ge}function je(){const ge=N;N=!1;for(const se of G)_t(se.textureProperties,se.texture,se.slot),se.texture.isPendingDeferredUpload=!1;G=[],N=ge}function _t(ge,se,Ge){if(N)return se.isPendingDeferredUpload||(se.isPendingDeferredUpload=!0,G.push({textureProperties:ge,texture:se,slot:Ge})),!1;let ut=r.TEXTURE_2D;(se.isDataArrayTexture||se.isCompressedArrayTexture)&&(ut=r.TEXTURE_2D_ARRAY),se.isData3DTexture&&(ut=r.TEXTURE_3D);const kt=Tt(ge,se),xt=se.source;n.bindTexture(ut,ge.__webglTexture,r.TEXTURE0+Ge);const fn=a.get(xt);if(xt.version!==fn.__version||kt===!0){n.activeTexture(r.TEXTURE0+Ge);const Gt=zi.getPrimaries(zi.workingColorSpace),Jt=se.colorSpace===Ah?null:zi.getPrimaries(se.colorSpace),Ln=se.colorSpace===Ah||Gt===Jt?r.NONE:r.BROWSER_DEFAULT_WEBGL;r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,se.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,se.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,se.unpackAlignment),r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ln);let Zt=W(se.image,!1,c.maxTextureSize);Zt=At(se,Zt);const bn=h.convert(se.format,se.colorSpace),Jn=h.convert(se.type);let ke=J(se.internalFormat,bn,Jn,se.colorSpace,se.isVideoTexture);zt(ut,se);let wt;const Wt=se.mipmaps,jt=se.isVideoTexture!==!0,tn=fn.__version===void 0||kt===!0,cn=xt.dataReady,Vn=re(se,Zt);if(se.isDepthTexture)ke=ee(se.format===jd,se.type),tn&&(jt?n.texStorage2D(r.TEXTURE_2D,1,ke,Zt.width,Zt.height):n.texImage2D(r.TEXTURE_2D,0,ke,Zt.width,Zt.height,0,bn,Jn,null));else if(se.isDataTexture)if(Wt.length>0){jt&&tn&&n.texStorage2D(r.TEXTURE_2D,Vn,ke,Wt[0].width,Wt[0].height);for(let nn=0,qt=Wt.length;nn<qt;nn++)wt=Wt[nn],jt?cn&&n.texSubImage2D(r.TEXTURE_2D,nn,0,0,wt.width,wt.height,bn,Jn,wt.data):n.texImage2D(r.TEXTURE_2D,nn,ke,wt.width,wt.height,0,bn,Jn,wt.data);se.generateMipmaps=!1}else jt?(tn&&n.texStorage2D(r.TEXTURE_2D,Vn,ke,Zt.width,Zt.height),cn&&n.texSubImage2D(r.TEXTURE_2D,0,0,0,Zt.width,Zt.height,bn,Jn,Zt.data)):n.texImage2D(r.TEXTURE_2D,0,ke,Zt.width,Zt.height,0,bn,Jn,Zt.data);else if(se.isCompressedTexture)if(se.isCompressedArrayTexture){jt&&tn&&n.texStorage3D(r.TEXTURE_2D_ARRAY,Vn,ke,Wt[0].width,Wt[0].height,Zt.depth);for(let nn=0,qt=Wt.length;nn<qt;nn++)if(wt=Wt[nn],se.format!==to)if(bn!==null)if(jt){if(cn)if(se.layerUpdates.size>0){const mn=dR(wt.width,wt.height,se.format,se.type);for(const fi of se.layerUpdates){const Ki=wt.data.subarray(fi*mn/wt.data.BYTES_PER_ELEMENT,(fi+1)*mn/wt.data.BYTES_PER_ELEMENT);n.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY,nn,0,0,fi,wt.width,wt.height,1,bn,Ki)}se.clearLayerUpdates()}else n.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY,nn,0,0,0,wt.width,wt.height,Zt.depth,bn,wt.data)}else n.compressedTexImage3D(r.TEXTURE_2D_ARRAY,nn,ke,wt.width,wt.height,Zt.depth,0,wt.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else jt?cn&&n.texSubImage3D(r.TEXTURE_2D_ARRAY,nn,0,0,0,wt.width,wt.height,Zt.depth,bn,Jn,wt.data):n.texImage3D(r.TEXTURE_2D_ARRAY,nn,ke,wt.width,wt.height,Zt.depth,0,bn,Jn,wt.data)}else{jt&&tn&&n.texStorage2D(r.TEXTURE_2D,Vn,ke,Wt[0].width,Wt[0].height);for(let nn=0,qt=Wt.length;nn<qt;nn++)wt=Wt[nn],se.format!==to?bn!==null?jt?cn&&n.compressedTexSubImage2D(r.TEXTURE_2D,nn,0,0,wt.width,wt.height,bn,wt.data):n.compressedTexImage2D(r.TEXTURE_2D,nn,ke,wt.width,wt.height,0,wt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):jt?cn&&n.texSubImage2D(r.TEXTURE_2D,nn,0,0,wt.width,wt.height,bn,Jn,wt.data):n.texImage2D(r.TEXTURE_2D,nn,ke,wt.width,wt.height,0,bn,Jn,wt.data)}else if(se.isDataArrayTexture)if(jt){if(tn&&n.texStorage3D(r.TEXTURE_2D_ARRAY,Vn,ke,Zt.width,Zt.height,Zt.depth),cn)if(se.layerUpdates.size>0){const nn=dR(Zt.width,Zt.height,se.format,se.type);for(const qt of se.layerUpdates){const mn=Zt.data.subarray(qt*nn/Zt.data.BYTES_PER_ELEMENT,(qt+1)*nn/Zt.data.BYTES_PER_ELEMENT);n.texSubImage3D(r.TEXTURE_2D_ARRAY,0,0,0,qt,Zt.width,Zt.height,1,bn,Jn,mn)}se.clearLayerUpdates()}else n.texSubImage3D(r.TEXTURE_2D_ARRAY,0,0,0,0,Zt.width,Zt.height,Zt.depth,bn,Jn,Zt.data)}else n.texImage3D(r.TEXTURE_2D_ARRAY,0,ke,Zt.width,Zt.height,Zt.depth,0,bn,Jn,Zt.data);else if(se.isData3DTexture)jt?(tn&&n.texStorage3D(r.TEXTURE_3D,Vn,ke,Zt.width,Zt.height,Zt.depth),cn&&n.texSubImage3D(r.TEXTURE_3D,0,0,0,0,Zt.width,Zt.height,Zt.depth,bn,Jn,Zt.data)):n.texImage3D(r.TEXTURE_3D,0,ke,Zt.width,Zt.height,Zt.depth,0,bn,Jn,Zt.data);else if(se.isFramebufferTexture){if(tn)if(jt)n.texStorage2D(r.TEXTURE_2D,Vn,ke,Zt.width,Zt.height);else{let nn=Zt.width,qt=Zt.height;for(let mn=0;mn<Vn;mn++)n.texImage2D(r.TEXTURE_2D,mn,ke,nn,qt,0,bn,Jn,null),nn>>=1,qt>>=1}}else if(Wt.length>0){if(jt&&tn){const nn=dn(Wt[0]);n.texStorage2D(r.TEXTURE_2D,Vn,ke,nn.width,nn.height)}for(let nn=0,qt=Wt.length;nn<qt;nn++)wt=Wt[nn],jt?cn&&n.texSubImage2D(r.TEXTURE_2D,nn,0,0,bn,Jn,wt):n.texImage2D(r.TEXTURE_2D,nn,ke,bn,Jn,wt);se.generateMipmaps=!1}else if(jt){if(tn){const nn=dn(Zt);n.texStorage2D(r.TEXTURE_2D,Vn,ke,nn.width,nn.height)}cn&&n.texSubImage2D(r.TEXTURE_2D,0,0,0,bn,Jn,Zt)}else n.texImage2D(r.TEXTURE_2D,0,ke,bn,Jn,Zt);H(se)&&K(ut),fn.__version=xt.version,se.onUpdate&&se.onUpdate(se)}return ge.__version=se.version,!0}function Ot(ge,se,Ge){if(se.image.length!==6)return;const ut=Tt(ge,se),kt=se.source;n.bindTexture(r.TEXTURE_CUBE_MAP,ge.__webglTexture,r.TEXTURE0+Ge);const xt=a.get(kt);if(kt.version!==xt.__version||ut===!0){n.activeTexture(r.TEXTURE0+Ge);const fn=zi.getPrimaries(zi.workingColorSpace),Gt=se.colorSpace===Ah?null:zi.getPrimaries(se.colorSpace),Jt=se.colorSpace===Ah||fn===Gt?r.NONE:r.BROWSER_DEFAULT_WEBGL;r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,se.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,se.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,se.unpackAlignment),r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL,Jt);const Ln=se.isCompressedTexture||se.image[0].isCompressedTexture,Zt=se.image[0]&&se.image[0].isDataTexture,bn=[];for(let qt=0;qt<6;qt++)!Ln&&!Zt?bn[qt]=W(se.image[qt],!0,c.maxCubemapSize):bn[qt]=Zt?se.image[qt].image:se.image[qt],bn[qt]=At(se,bn[qt]);const Jn=bn[0],ke=h.convert(se.format,se.colorSpace),wt=h.convert(se.type),Wt=J(se.internalFormat,ke,wt,se.colorSpace),jt=se.isVideoTexture!==!0,tn=xt.__version===void 0||ut===!0,cn=kt.dataReady;let Vn=re(se,Jn);zt(r.TEXTURE_CUBE_MAP,se);let nn;if(Ln){jt&&tn&&n.texStorage2D(r.TEXTURE_CUBE_MAP,Vn,Wt,Jn.width,Jn.height);for(let qt=0;qt<6;qt++){nn=bn[qt].mipmaps;for(let mn=0;mn<nn.length;mn++){const fi=nn[mn];se.format!==to?ke!==null?jt?cn&&n.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,mn,0,0,fi.width,fi.height,ke,fi.data):n.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,mn,Wt,fi.width,fi.height,0,fi.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):jt?cn&&n.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,mn,0,0,fi.width,fi.height,ke,wt,fi.data):n.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,mn,Wt,fi.width,fi.height,0,ke,wt,fi.data)}}}else{if(nn=se.mipmaps,jt&&tn){nn.length>0&&Vn++;const qt=dn(bn[0]);n.texStorage2D(r.TEXTURE_CUBE_MAP,Vn,Wt,qt.width,qt.height)}for(let qt=0;qt<6;qt++)if(Zt){jt?cn&&n.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,0,0,0,bn[qt].width,bn[qt].height,ke,wt,bn[qt].data):n.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,0,Wt,bn[qt].width,bn[qt].height,0,ke,wt,bn[qt].data);for(let mn=0;mn<nn.length;mn++){const Ki=nn[mn].image[qt].image;jt?cn&&n.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,mn+1,0,0,Ki.width,Ki.height,ke,wt,Ki.data):n.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,mn+1,Wt,Ki.width,Ki.height,0,ke,wt,Ki.data)}}else{jt?cn&&n.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,0,0,0,ke,wt,bn[qt]):n.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,0,Wt,ke,wt,bn[qt]);for(let mn=0;mn<nn.length;mn++){const fi=nn[mn];jt?cn&&n.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,mn+1,0,0,ke,wt,fi.image[qt]):n.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+qt,mn+1,Wt,ke,wt,fi.image[qt])}}}H(se)&&K(r.TEXTURE_CUBE_MAP),xt.__version=kt.version,se.onUpdate&&se.onUpdate(se)}ge.__version=se.version}function on(ge,se,Ge,ut,kt,xt){const fn=h.convert(Ge.format,Ge.colorSpace),Gt=h.convert(Ge.type),Jt=J(Ge.internalFormat,fn,Gt,Ge.colorSpace),Ln=a.get(se),Zt=a.get(Ge);if(Zt.__renderTarget=se,!Ln.__hasExternalTextures){const Jn=Math.max(1,se.width>>xt),ke=Math.max(1,se.height>>xt);se.isWebGLMultiviewRenderTarget===!0?n.texStorage3D(r.TEXTURE_2D_ARRAY,0,Jt,se.width,se.height,se.numViews):kt===r.TEXTURE_3D||kt===r.TEXTURE_2D_ARRAY?n.texImage3D(kt,xt,Jt,Jn,ke,se.depth,0,fn,Gt,null):n.texImage2D(kt,xt,Jt,Jn,ke,0,fn,Gt,null)}n.bindFramebuffer(r.FRAMEBUFFER,ge);const bn=Ie(se);se.isWebGLMultiviewRenderTarget===!0?bn?w.framebufferTextureMultisampleMultiviewOVR(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,Zt.__webglTexture,0,Ae(se),0,se.numViews):w.framebufferTextureMultiviewOVR(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,Zt.__webglTexture,0,0,se.numViews):(kt===r.TEXTURE_2D||kt>=r.TEXTURE_CUBE_MAP_POSITIVE_X&&kt<=r.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&(bn?b.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,ut,kt,Zt.__webglTexture,0,Ae(se)):r.framebufferTexture2D(r.FRAMEBUFFER,ut,kt,Zt.__webglTexture,xt)),n.bindFramebuffer(r.FRAMEBUFFER,null)}function vt(ge,se,Ge){if(r.bindRenderbuffer(r.RENDERBUFFER,ge),se.isWebGLMultiviewRenderTarget===!0){const ut=Ie(se),kt=se.numViews,xt=se.depthTexture;let fn=r.DEPTH_COMPONENT24,Gt=r.DEPTH_ATTACHMENT;xt&&xt.isDepthTexture&&(xt.type===qa?fn=r.DEPTH_COMPONENT32F:xt.type===$d&&(fn=r.DEPTH24_STENCIL8,Gt=r.DEPTH_STENCIL_ATTACHMENT));let Jt=a.get(se.depthTexture).__webglTexture;Jt===void 0&&(Jt=r.createTexture(),r.bindTexture(r.TEXTURE_2D_ARRAY,Jt),r.texStorage3D(r.TEXTURE_2D_ARRAY,1,fn,se.width,se.height,kt)),ut?w.framebufferTextureMultisampleMultiviewOVR(r.FRAMEBUFFER,Gt,Jt,0,Ae(se),0,kt):w.framebufferTextureMultiviewOVR(r.FRAMEBUFFER,Gt,Jt,0,0,kt)}else if(se.depthBuffer){const ut=se.depthTexture,kt=ut&&ut.isDepthTexture?ut.type:null,xt=ee(se.stencilBuffer,kt),fn=se.stencilBuffer?r.DEPTH_STENCIL_ATTACHMENT:r.DEPTH_ATTACHMENT,Gt=Ae(se);Ie(se)?b.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,Gt,xt,se.width,se.height):Ge?r.renderbufferStorageMultisample(r.RENDERBUFFER,Gt,xt,se.width,se.height):r.renderbufferStorage(r.RENDERBUFFER,xt,se.width,se.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,fn,r.RENDERBUFFER,ge)}else{const ut=se.textures;for(let kt=0;kt<ut.length;kt++){const xt=ut[kt],fn=h.convert(xt.format,xt.colorSpace),Gt=h.convert(xt.type),Jt=J(xt.internalFormat,fn,Gt,xt.colorSpace),Ln=Ae(se);Ge&&Ie(se)===!1?r.renderbufferStorageMultisample(r.RENDERBUFFER,Ln,Jt,se.width,se.height):Ie(se)?b.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,Ln,Jt,se.width,se.height):r.renderbufferStorage(r.RENDERBUFFER,Jt,se.width,se.height)}}r.bindRenderbuffer(r.RENDERBUFFER,null)}function Mt(ge,se){if(se&&se.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(r.FRAMEBUFFER,ge),!(se.depthTexture&&se.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const ut=a.get(se.depthTexture);ut.__renderTarget=se,(!ut.__webglTexture||se.depthTexture.image.width!==se.width||se.depthTexture.image.height!==se.height)&&(se.depthTexture.image.width=se.width,se.depthTexture.image.height=se.height,se.depthTexture.needsUpdate=!0),se.depthTexture.image.depth!=1?Je(se.depthTexture,0):Le(se.depthTexture,0);const kt=ut.__webglTexture,xt=Ae(se);if(se.isWebGLMultiviewRenderTarget===!0){const fn=Ie(se),Gt=se.numViews;if(se.depthTexture.format===Yd)fn?w.framebufferTextureMultisampleMultiviewOVR(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,kt,0,xt,0,Gt):w.framebufferTextureMultiviewOVR(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,kt,0,0,Gt);else if(se.depthTexture.format===jd)fn?w.framebufferTextureMultisampleMultiviewOVR(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,kt,0,xt,0,Gt):w.framebufferTextureMultiviewOVR(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,kt,0,0,Gt);else throw new Error("Unknown depthTexture format")}else if(se.depthTexture.format===Yd)Ie(se)?b.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,kt,0,xt):r.framebufferTexture2D(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,kt,0);else if(se.depthTexture.format===jd)Ie(se)?b.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.TEXTURE_2D,kt,0,xt):r.framebufferTexture2D(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.TEXTURE_2D,kt,0);else throw new Error("Unknown depthTexture format")}function Bt(ge){const se=a.get(ge),Ge=ge.isWebGLCubeRenderTarget===!0;if(se.__boundDepthTexture!==ge.depthTexture){const ut=ge.depthTexture;if(se.__depthDisposeCallback&&se.__depthDisposeCallback(),ut){const kt=()=>{delete se.__boundDepthTexture,delete se.__depthDisposeCallback,ut.removeEventListener("dispose",kt)};ut.addEventListener("dispose",kt),se.__depthDisposeCallback=kt}se.__boundDepthTexture=ut}if(ge.depthTexture&&!se.__autoAllocateDepthBuffer){if(Ge)throw new Error("target.depthTexture not supported in Cube render targets");Mt(se.__webglFramebuffer,ge)}else if(Ge){se.__webglDepthbuffer=[];for(let ut=0;ut<6;ut++)if(n.bindFramebuffer(r.FRAMEBUFFER,se.__webglFramebuffer[ut]),se.__webglDepthbuffer[ut]===void 0)se.__webglDepthbuffer[ut]=r.createRenderbuffer(),vt(se.__webglDepthbuffer[ut],ge,!1);else{const kt=ge.stencilBuffer?r.DEPTH_STENCIL_ATTACHMENT:r.DEPTH_ATTACHMENT,xt=se.__webglDepthbuffer[ut];r.bindRenderbuffer(r.RENDERBUFFER,xt),r.framebufferRenderbuffer(r.FRAMEBUFFER,kt,r.RENDERBUFFER,xt)}}else if(n.bindFramebuffer(r.FRAMEBUFFER,se.__webglFramebuffer),se.__webglDepthbuffer===void 0)se.__webglDepthbuffer=r.createRenderbuffer(),vt(se.__webglDepthbuffer,ge,!1);else{const ut=ge.stencilBuffer?r.DEPTH_STENCIL_ATTACHMENT:r.DEPTH_ATTACHMENT,kt=se.__webglDepthbuffer;r.bindRenderbuffer(r.RENDERBUFFER,kt),r.framebufferRenderbuffer(r.FRAMEBUFFER,ut,r.RENDERBUFFER,kt)}n.bindFramebuffer(r.FRAMEBUFFER,null)}function ve(ge,se,Ge){const ut=a.get(ge);se!==void 0&&on(ut.__webglFramebuffer,ge,ge.texture,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,0),Ge!==void 0&&Bt(ge)}function Kt(ge){const se=ge.texture,Ge=a.get(ge),ut=a.get(se);ge.addEventListener("dispose",ie);const kt=ge.textures,xt=ge.isWebGLCubeRenderTarget===!0,fn=kt.length>1;if(fn||(ut.__webglTexture===void 0&&(ut.__webglTexture=r.createTexture()),ut.__version=se.version,p.memory.textures++),xt){Ge.__webglFramebuffer=[];for(let Gt=0;Gt<6;Gt++)if(se.mipmaps&&se.mipmaps.length>0){Ge.__webglFramebuffer[Gt]=[];for(let Jt=0;Jt<se.mipmaps.length;Jt++)Ge.__webglFramebuffer[Gt][Jt]=r.createFramebuffer()}else Ge.__webglFramebuffer[Gt]=r.createFramebuffer()}else{if(se.mipmaps&&se.mipmaps.length>0){Ge.__webglFramebuffer=[];for(let Gt=0;Gt<se.mipmaps.length;Gt++)Ge.__webglFramebuffer[Gt]=r.createFramebuffer()}else Ge.__webglFramebuffer=r.createFramebuffer();if(fn)for(let Gt=0,Jt=kt.length;Gt<Jt;Gt++){const Ln=a.get(kt[Gt]);Ln.__webglTexture===void 0&&(Ln.__webglTexture=r.createTexture(),p.memory.textures++)}if(ge.samples>0&&Ie(ge)===!1){Ge.__webglMultisampledFramebuffer=r.createFramebuffer(),Ge.__webglColorRenderbuffer=[],n.bindFramebuffer(r.FRAMEBUFFER,Ge.__webglMultisampledFramebuffer);for(let Gt=0;Gt<kt.length;Gt++){const Jt=kt[Gt];Ge.__webglColorRenderbuffer[Gt]=r.createRenderbuffer(),r.bindRenderbuffer(r.RENDERBUFFER,Ge.__webglColorRenderbuffer[Gt]);const Ln=h.convert(Jt.format,Jt.colorSpace),Zt=h.convert(Jt.type),bn=J(Jt.internalFormat,Ln,Zt,Jt.colorSpace,ge.isXRRenderTarget===!0),Jn=Ae(ge);r.renderbufferStorageMultisample(r.RENDERBUFFER,Jn,bn,ge.width,ge.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+Gt,r.RENDERBUFFER,Ge.__webglColorRenderbuffer[Gt])}r.bindRenderbuffer(r.RENDERBUFFER,null),ge.depthBuffer&&(Ge.__webglDepthRenderbuffer=r.createRenderbuffer(),vt(Ge.__webglDepthRenderbuffer,ge,!0)),n.bindFramebuffer(r.FRAMEBUFFER,null)}}if(xt){n.bindTexture(r.TEXTURE_CUBE_MAP,ut.__webglTexture),zt(r.TEXTURE_CUBE_MAP,se);for(let Gt=0;Gt<6;Gt++)if(se.mipmaps&&se.mipmaps.length>0)for(let Jt=0;Jt<se.mipmaps.length;Jt++)on(Ge.__webglFramebuffer[Gt][Jt],ge,se,r.COLOR_ATTACHMENT0,r.TEXTURE_CUBE_MAP_POSITIVE_X+Gt,Jt);else on(Ge.__webglFramebuffer[Gt],ge,se,r.COLOR_ATTACHMENT0,r.TEXTURE_CUBE_MAP_POSITIVE_X+Gt,0);H(se)&&K(r.TEXTURE_CUBE_MAP),n.unbindTexture()}else if(fn){for(let Gt=0,Jt=kt.length;Gt<Jt;Gt++){const Ln=kt[Gt],Zt=a.get(Ln);n.bindTexture(r.TEXTURE_2D,Zt.__webglTexture),zt(r.TEXTURE_2D,Ln),on(Ge.__webglFramebuffer,ge,Ln,r.COLOR_ATTACHMENT0+Gt,r.TEXTURE_2D,0),H(Ln)&&K(r.TEXTURE_2D)}n.unbindTexture()}else{let Gt=r.TEXTURE_2D;if((ge.isWebGL3DRenderTarget||ge.isWebGLArrayRenderTarget)&&(Gt=ge.isWebGL3DRenderTarget?r.TEXTURE_3D:r.TEXTURE_2D_ARRAY),ge.isWebGLMultiviewRenderTarget===!0&&(Gt=r.TEXTURE_2D_ARRAY),n.bindTexture(Gt,ut.__webglTexture),zt(Gt,se),se.mipmaps&&se.mipmaps.length>0)for(let Jt=0;Jt<se.mipmaps.length;Jt++)on(Ge.__webglFramebuffer[Jt],ge,se,r.COLOR_ATTACHMENT0,Gt,Jt);else on(Ge.__webglFramebuffer,ge,se,r.COLOR_ATTACHMENT0,Gt,0);H(se)&&K(Gt),n.unbindTexture()}(ge.depthBuffer||ge.isWebGLMultiviewRenderTarget===!0)&&this.setupDepthRenderbuffer(ge)}function Ee(ge){const se=ge.textures;for(let Ge=0,ut=se.length;Ge<ut;Ge++){const kt=se[Ge];if(H(kt)){const xt=j(ge),fn=a.get(kt).__webglTexture;n.bindTexture(xt,fn),K(xt),n.unbindTexture()}}}const Q=[],Z=[];function ae(ge){if(ge.samples>0){if(Ie(ge)===!1){const se=ge.textures,Ge=ge.width,ut=ge.height;let kt=r.COLOR_BUFFER_BIT;const xt=ge.stencilBuffer?r.DEPTH_STENCIL_ATTACHMENT:r.DEPTH_ATTACHMENT,fn=a.get(ge),Gt=se.length>1;if(Gt)for(let Jt=0;Jt<se.length;Jt++)n.bindFramebuffer(r.FRAMEBUFFER,fn.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+Jt,r.RENDERBUFFER,null),n.bindFramebuffer(r.FRAMEBUFFER,fn.__webglFramebuffer),r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0+Jt,r.TEXTURE_2D,null,0);n.bindFramebuffer(r.READ_FRAMEBUFFER,fn.__webglMultisampledFramebuffer),n.bindFramebuffer(r.DRAW_FRAMEBUFFER,fn.__webglFramebuffer);for(let Jt=0;Jt<se.length;Jt++){if(ge.resolveDepthBuffer&&(ge.depthBuffer&&(kt|=r.DEPTH_BUFFER_BIT),ge.stencilBuffer&&ge.resolveStencilBuffer&&(kt|=r.STENCIL_BUFFER_BIT)),Gt){r.framebufferRenderbuffer(r.READ_FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.RENDERBUFFER,fn.__webglColorRenderbuffer[Jt]);const Ln=a.get(se[Jt]).__webglTexture;r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,Ln,0)}r.blitFramebuffer(0,0,Ge,ut,0,0,Ge,ut,kt,r.NEAREST),y===!0&&(Q.length=0,Z.length=0,Q.push(r.COLOR_ATTACHMENT0+Jt),ge.depthBuffer&&ge.resolveDepthBuffer===!1&&(Q.push(xt),Z.push(xt),r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER,Z)),r.invalidateFramebuffer(r.READ_FRAMEBUFFER,Q))}if(n.bindFramebuffer(r.READ_FRAMEBUFFER,null),n.bindFramebuffer(r.DRAW_FRAMEBUFFER,null),Gt)for(let Jt=0;Jt<se.length;Jt++){n.bindFramebuffer(r.FRAMEBUFFER,fn.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+Jt,r.RENDERBUFFER,fn.__webglColorRenderbuffer[Jt]);const Ln=a.get(se[Jt]).__webglTexture;n.bindFramebuffer(r.FRAMEBUFFER,fn.__webglFramebuffer),r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0+Jt,r.TEXTURE_2D,Ln,0)}n.bindFramebuffer(r.DRAW_FRAMEBUFFER,fn.__webglMultisampledFramebuffer)}else if(ge.depthBuffer&&ge.resolveDepthBuffer===!1&&y){const se=ge.stencilBuffer?r.DEPTH_STENCIL_ATTACHMENT:r.DEPTH_ATTACHMENT;r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER,[se])}}}function Ae(ge){return Math.min(c.maxSamples,ge.samples)}function Ie(ge){const se=a.get(ge);return ge.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&se.__useRenderToTexture!==!1}function Ze(ge){const se=p.render.frame;E.get(ge)!==se&&(E.set(ge,se),ge.update())}function At(ge,se){const Ge=ge.colorSpace,ut=ge.format,kt=ge.type;return ge.isCompressedTexture===!0||ge.isVideoTexture===!0||Ge!==Tm&&Ge!==Ah&&(zi.getTransfer(Ge)===hs?(ut!==to||kt!==vu)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",Ge)),se}function dn(ge){return typeof HTMLImageElement<"u"&&ge instanceof HTMLImageElement?(I.width=ge.naturalWidth||ge.width,I.height=ge.naturalHeight||ge.height):typeof VideoFrame<"u"&&ge instanceof VideoFrame?(I.width=ge.displayWidth,I.height=ge.displayHeight):(I.width=ge.width,I.height=ge.height),I}this.allocateTextureUnit=de,this.resetTextureUnits=rt,this.setTexture2D=Le,this.setTexture2DArray=Je,this.setTexture3D=fe,this.setTextureCube=Ve,this.rebindTextures=ve,this.uploadTexture=_t,this.setupRenderTarget=Kt,this.updateRenderTargetMipmap=Ee,this.updateMultisampleRenderTarget=ae,this.setupDepthTexture=Mt,this.setupDepthRenderbuffer=Bt,this.setupFrameBufferTexture=on,this.useMultisampledRTT=Ie,this.runDeferredUploads=je,this.setDeferTextureUploads=Vt}function bV(r,e){function n(a,c=Ah){let h;const p=zi.getTransfer(c);if(a===vu)return r.UNSIGNED_BYTE;if(a===y2)return r.UNSIGNED_SHORT_4_4_4_4;if(a===v2)return r.UNSIGNED_SHORT_5_5_5_1;if(a===qR)return r.UNSIGNED_INT_5_9_9_9_REV;if(a===YR)return r.BYTE;if(a===jR)return r.SHORT;if(a===q0)return r.UNSIGNED_SHORT;if(a===b2)return r.INT;if(a===Rh)return r.UNSIGNED_INT;if(a===qa)return r.FLOAT;if(a===sA)return r.HALF_FLOAT;if(a===JR)return r.ALPHA;if(a===ek)return r.RGB;if(a===to)return r.RGBA;if(a===tk)return r.LUMINANCE;if(a===nk)return r.LUMINANCE_ALPHA;if(a===Yd)return r.DEPTH_COMPONENT;if(a===jd)return r.DEPTH_STENCIL;if(a===x2)return r.RED;if(a===Gv)return r.RED_INTEGER;if(a===ik)return r.RG;if(a===w2)return r.RG_INTEGER;if(a===C2)return r.RGBA_INTEGER;if(a===sv||a===rv||a===av||a===ov)if(p===hs)if(h=e.get("WEBGL_compressed_texture_s3tc_srgb"),h!==null){if(a===sv)return h.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(a===rv)return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(a===av)return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(a===ov)return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(h=e.get("WEBGL_compressed_texture_s3tc"),h!==null){if(a===sv)return h.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===rv)return h.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===av)return h.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===ov)return h.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(a===EE||a===SE||a===IE||a===TE)if(h=e.get("WEBGL_compressed_texture_pvrtc"),h!==null){if(a===EE)return h.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(a===SE)return h.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(a===IE)return h.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(a===TE)return h.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(a===ME||a===_E||a===RE)if(h=e.get("WEBGL_compressed_texture_etc"),h!==null){if(a===ME||a===_E)return p===hs?h.COMPRESSED_SRGB8_ETC2:h.COMPRESSED_RGB8_ETC2;if(a===RE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:h.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(a===kE||a===BE||a===LE||a===NE||a===DE||a===FE||a===OE||a===GE||a===UE||a===PE||a===zE||a===VE||a===WE||a===HE)if(h=e.get("WEBGL_compressed_texture_astc"),h!==null){if(a===kE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:h.COMPRESSED_RGBA_ASTC_4x4_KHR;if(a===BE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:h.COMPRESSED_RGBA_ASTC_5x4_KHR;if(a===LE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:h.COMPRESSED_RGBA_ASTC_5x5_KHR;if(a===NE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:h.COMPRESSED_RGBA_ASTC_6x5_KHR;if(a===DE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:h.COMPRESSED_RGBA_ASTC_6x6_KHR;if(a===FE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:h.COMPRESSED_RGBA_ASTC_8x5_KHR;if(a===OE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:h.COMPRESSED_RGBA_ASTC_8x6_KHR;if(a===GE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:h.COMPRESSED_RGBA_ASTC_8x8_KHR;if(a===UE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:h.COMPRESSED_RGBA_ASTC_10x5_KHR;if(a===PE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:h.COMPRESSED_RGBA_ASTC_10x6_KHR;if(a===zE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:h.COMPRESSED_RGBA_ASTC_10x8_KHR;if(a===VE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:h.COMPRESSED_RGBA_ASTC_10x10_KHR;if(a===WE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:h.COMPRESSED_RGBA_ASTC_12x10_KHR;if(a===HE)return p===hs?h.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:h.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(a===lv||a===XE||a===QE)if(h=e.get("EXT_texture_compression_bptc"),h!==null){if(a===lv)return p===hs?h.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:h.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(a===XE)return h.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(a===QE)return h.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(a===sk||a===KE||a===ZE||a===$E)if(h=e.get("EXT_texture_compression_rgtc"),h!==null){if(a===lv)return h.COMPRESSED_RED_RGTC1_EXT;if(a===KE)return h.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(a===ZE)return h.COMPRESSED_RED_GREEN_RGTC2_EXT;if(a===$E)return h.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return a===$d?r.UNSIGNED_INT_24_8:r[a]!==void 0?r[a]:null}return{convert:n}}class yV extends Ac{constructor(e,n,a,c={}){super(e,n,c),this.depthBuffer=!1,this.stencilBuffer=!1,this.numViews=a}copy(e){return super.copy(e),this.numViews=e.numViews,this}}yV.prototype.isWebGLMultiviewRenderTarget=!0;const Dge=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,Fge=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class Oge{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,n,a){if(this.texture===null){const c=new nr,h=e.properties.get(c);h.__webglTexture=n.texture,(n.depthNear!==a.depthNear||n.depthFar!==a.depthFar)&&(this.depthNear=n.depthNear,this.depthFar=n.depthFar),this.texture=c}}getMesh(e){if(this.texture!==null&&this.mesh===null){const n=e.cameras[0].viewport,a=new bc({vertexShader:Dge,fragmentShader:Fge,uniforms:{depthColor:{value:this.texture},depthWidth:{value:n.z},depthHeight:{value:n.w}}});this.mesh=new Er(new oA(20,20),a)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class Gge extends xu{constructor(e,n,a,c){super();const h=this;let p=null,b=1;var y=null;let w=null,I="local-floor",E=1,R=null,k=null;var G=[];let N=null,O=null,D=null,W=null;const H=new Oge,K=n.getContextAttributes();let j=null,J=null;const ee=[],re=[],Y=new Dt;let ie=null;const ue=new ea;ue.viewport=new Xi;const Re=new ea;Re.viewport=new Xi;const _e=[ue,Re],Pe=new oV;let rt=null,de=null;this.cameraAutoUpdate=!0,this.layersEnabled=!1,this.enabled=!1,this.isPresenting=!1,this.isMultiview=!1,this.getCameraPose=function(){return k},this.getController=function(je){let _t=ee[je];return _t===void 0&&(_t=new aE,ee[je]=_t),_t.getTargetRaySpace()},this.getControllerGrip=function(je){let _t=ee[je];return _t===void 0&&(_t=new aE,ee[je]=_t),_t.getGripSpace()},this.getHand=function(je){let _t=ee[je];return _t===void 0&&(_t=new aE,ee[je]=_t),_t.getHandSpace()};function we(je){const _t=re.indexOf(je.inputSource);if(_t===-1)return;const Ot=ee[_t];Ot!==void 0&&(Ot.update(je.inputSource,je.frame,R||w),Ot.dispatchEvent({type:je.type,data:je.inputSource}))}function Le(){p.removeEventListener("select",we),p.removeEventListener("selectstart",we),p.removeEventListener("selectend",we),p.removeEventListener("squeeze",we),p.removeEventListener("squeezestart",we),p.removeEventListener("squeezeend",we),p.removeEventListener("end",Le),p.removeEventListener("inputsourceschange",Je);for(let je=0;je<ee.length;je++){const _t=re[je];_t!==null&&(re[je]=null,ee[je].disconnect(_t))}rt=null,de=null,H.reset(),h.isPresenting=!1,e.setRenderTarget(j),D=null,O=null,N=null,p=null,J=null,Vt.stop(),e.setPixelRatio(ie),e.setSize(Y.width,Y.height,!1),h.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(je){b=je,h.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(je){I=je,h.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return R||w},this.setReferenceSpace=function(je){R=je},this.getBaseLayer=function(){return O!==null?O:D},this.getBinding=function(){return N},this.getRenderTarget=function(){return J},this.getFrame=function(){return W},this.getSession=function(){return p},this.setSession=async function(je){if(p=je,p!==null){if(j=e.getRenderTarget(),p.addEventListener("select",we),p.addEventListener("selectstart",we),p.addEventListener("selectend",we),p.addEventListener("squeeze",we),p.addEventListener("squeezestart",we),p.addEventListener("squeezeend",we),p.addEventListener("end",Le),p.addEventListener("inputsourceschange",Je),K.xrCompatible!==!0&&await n.makeXRCompatible(),ie=e.getPixelRatio(),e.getSize(Y),typeof XRWebGLBinding<"u"&&"createProjectionLayer"in XRWebGLBinding.prototype){let Ot=null,on=null,vt=null;K.depth&&(vt=K.stencil?n.DEPTH24_STENCIL8:n.DEPTH_COMPONENT24,Ot=K.stencil?jd:Yd,on=K.stencil?$d:Rh),h.isMultiview=c&&a.has("OCULUS_multiview");const Mt={colorFormat:n.RGBA8,depthFormat:vt,scaleFactor:b};h.isMultiview&&(Mt.textureType="texture-array"),N=new XRWebGLBinding(p,n),O=N.createProjectionLayer(Mt),p.updateRenderState({layers:[O]}),e.setPixelRatio(1),e.setSize(O.textureWidth,O.textureHeight,!1);const Bt={format:to,type:vu,depthTexture:new fk(O.textureWidth,O.textureHeight,on,void 0,void 0,void 0,void 0,void 0,void 0,Ot),stencilBuffer:K.stencil,colorSpace:e.outputColorSpace,samples:K.antialias?4:0,resolveDepthBuffer:O.ignoreDepthValues===!1};if(h.isMultiview){const ve=a.get("OCULUS_multiview");this.maxNumViews=n.getParameter(ve.MAX_VIEWS_OVR),J=new yV(O.textureWidth,O.textureHeight,2,Bt)}else J=new Ac(O.textureWidth,O.textureHeight,Bt)}else{const Ot={antialias:K.antialias,alpha:!0,depth:K.depth,stencil:K.stencil,framebufferScaleFactor:b};D=new XRWebGLLayer(p,n,Ot),p.updateRenderState({baseLayer:D}),e.setPixelRatio(1),e.setSize(D.framebufferWidth,D.framebufferHeight,!1),J=new Ac(D.framebufferWidth,D.framebufferHeight,{format:to,type:vu,colorSpace:e.outputColorSpace,stencilBuffer:K.stencil})}J.isXRRenderTarget=!0,this.setFoveation(E),R=null,w=await p.requestReferenceSpace(I),Vt.setContext(p),Vt.start(),h.isPresenting=!0,h.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(p!==null)return p.environmentBlendMode},this.addLayer=function(je){!window.XRWebGLBinding||!this.layersEnabled||!p||(G.push(je),this.updateLayers())},this.removeLayer=function(je){G.splice(G.indexOf(je),1),!(!window.XRWebGLBinding||!this.layersEnabled||!p)&&this.updateLayers()},this.updateLayers=function(){var je=G.map(function(_t){return _t});je.unshift(p.renderState.layers[0]),p.updateRenderState({layers:je})},this.getDepthTexture=function(){return H.getDepthTexture()};function Je(je){for(let _t=0;_t<je.removed.length;_t++){const Ot=je.removed[_t],on=re.indexOf(Ot);on>=0&&(re[on]=null,ee[on].disconnect(Ot))}for(let _t=0;_t<je.added.length;_t++){const Ot=je.added[_t];let on=re.indexOf(Ot);if(on===-1){for(let Mt=0;Mt<ee.length;Mt++)if(Mt>=re.length){re.push(Ot),on=Mt;break}else if(re[Mt]===null){re[Mt]=Ot,on=Mt;break}if(on===-1)break}const vt=ee[on];vt&&vt.connect(Ot)}}const fe=new be,Ve=new be;function Ne(je,_t,Ot){fe.setFromMatrixPosition(_t.matrixWorld),Ve.setFromMatrixPosition(Ot.matrixWorld);const on=fe.distanceTo(Ve),vt=_t.projectionMatrix.elements,Mt=Ot.projectionMatrix.elements,Bt=vt[14]/(vt[10]-1),ve=vt[14]/(vt[10]+1),Kt=(vt[9]+1)/vt[5],Ee=(vt[9]-1)/vt[5],Q=(vt[8]-1)/vt[0],Z=(Mt[8]+1)/Mt[0],ae=Bt*Q,Ae=Bt*Z,Ie=on/(-Q+Z),Ze=Ie*-Q;if(_t.matrixWorld.decompose(je.position,je.quaternion,je.scale),je.translateX(Ze),je.translateZ(Ie),je.matrixWorld.compose(je.position,je.quaternion,je.scale),je.matrixWorldInverse.copy(je.matrixWorld).invert(),vt[10]===-1)je.projectionMatrix.copy(_t.projectionMatrix),je.projectionMatrixInverse.copy(_t.projectionMatrixInverse);else{const At=Bt+Ie,dn=ve+Ie,ge=ae-Ze,se=Ae+(on-Ze),Ge=Kt*ve/dn*At,ut=Ee*ve/dn*At;je.projectionMatrix.makePerspective(ge,se,Ge,ut,At,dn),je.projectionMatrixInverse.copy(je.projectionMatrix).invert()}}function gt(je,_t){_t===null?je.matrixWorld.copy(je.matrix):je.matrixWorld.multiplyMatrices(_t.matrixWorld,je.matrix),je.matrixWorldInverse.copy(je.matrixWorld).invert()}this.setPoseTarget=function(je){je!==void 0&&(y=je)},this.updateCamera=function(je){if(p===null)return;let _t=je.near,Ot=je.far;H.texture!==null&&(H.depthNear>0&&(_t=H.depthNear),H.depthFar>0&&(Ot=H.depthFar)),Pe.near=Re.near=ue.near=_t,Pe.far=Re.far=ue.far=Ot,(rt!==Pe.near||de!==Pe.far)&&(p.updateRenderState({depthNear:Pe.near,depthFar:Pe.far}),rt=Pe.near,de=Pe.far),ue.layers.mask=je.layers.mask|2,Re.layers.mask=je.layers.mask|4,Pe.layers.mask=ue.layers.mask|Re.layers.mask;const on=Pe.cameras;var vt=y||je;const Mt=vt.parent;gt(Pe,Mt);for(let Bt=0;Bt<on.length;Bt++)gt(on[Bt],Mt);on.length===2?Ne(Pe,ue,Re):Pe.projectionMatrix.copy(ue.projectionMatrix),bt(je,Pe,vt)};function bt(je,_t,Ot){_t.matrixWorld.decompose(_t.position,_t.quaternion,_t.scale),Ot.parent===null?Ot.matrix.copy(_t.matrixWorld):(Ot.matrix.copy(Ot.parent.matrixWorld),Ot.matrix.invert(),Ot.matrix.multiply(_t.matrixWorld)),Ot.matrix.decompose(Ot.position,Ot.quaternion,Ot.scale),Ot.updateMatrixWorld(!0),je.projectionMatrix.copy(_t.projectionMatrix),je.projectionMatrixInverse.copy(_t.projectionMatrixInverse),je.isPerspectiveCamera&&(je.fov=J0*2*Math.atan(1/je.projectionMatrix.elements[5]),je.zoom=1)}this.getCamera=function(){return Pe},this.getFoveation=function(){if(!(O===null&&D===null))return E},this.setFoveation=function(je){E=je,O!==null&&(O.fixedFoveation=je),D!==null&&D.fixedFoveation!==void 0&&(D.fixedFoveation=je)},this.hasDepthSensing=function(){return H.texture!==null},this.getDepthSensingMesh=function(){return H.getMesh(Pe)};let zt=null;function Tt(je,_t){if(k=_t.getViewerPose(R||w),W=_t,k!==null){const Ot=k.views;D!==null&&(e.setRenderTargetFramebuffer(J,D.framebuffer),e.setRenderTarget(J));let on=!1;Ot.length!==Pe.cameras.length&&(Pe.cameras.length=0,on=!0);for(let Bt=0;Bt<Ot.length;Bt++){const ve=Ot[Bt];let Kt=null;if(D!==null)Kt=D.getViewport(ve);else{const Q=N.getViewSubImage(O,ve);Kt=Q.viewport,Bt===0&&(e.setRenderTargetTextures(J,Q.colorTexture,O.ignoreDepthValues?void 0:Q.depthStencilTexture),e.setRenderTarget(J))}let Ee=_e[Bt];Ee===void 0&&(Ee=new ea,Ee.layers.enable(Bt),Ee.viewport=new Xi,_e[Bt]=Ee),Ee.matrix.fromArray(ve.transform.matrix),Ee.matrix.decompose(Ee.position,Ee.quaternion,Ee.scale),Ee.projectionMatrix.fromArray(ve.projectionMatrix),Ee.projectionMatrixInverse.copy(Ee.projectionMatrix).invert(),Ee.viewport.set(Kt.x,Kt.y,Kt.width,Kt.height),Bt===0&&(Pe.matrix.copy(Ee.matrix),Pe.matrix.decompose(Pe.position,Pe.quaternion,Pe.scale)),on===!0&&Pe.cameras.push(Ee)}const vt=p.enabledFeatures;if(vt&&vt.includes("depth-sensing")&&p.depthUsage=="gpu-optimized"&&N){const Bt=N.getDepthInformation(Ot[0]);Bt&&Bt.isValid&&Bt.texture&&H.init(e,Bt,p.renderState)}}for(let Ot=0;Ot<ee.length;Ot++){const on=re[Ot],vt=ee[Ot];on!==null&&vt!==void 0&&vt.update(on,_t,R||w)}zt&&zt(je,_t),_t.detectedPlanes&&h.dispatchEvent({type:"planesdetected",data:_t}),W=null}const Vt=new fV;Vt.setAnimationLoop(Tt),this.setAnimationLoop=function(je){zt=je},this.dispose=function(){}}}const rm=new el,Uge=new Zn;function Pge(r,e){function n(O,D){O.matrixAutoUpdate===!0&&O.updateMatrix(),D.value.copy(O.matrix)}function a(O,D){D.color.getRGB(O.fogColor.value,dz(r)),D.isFog?(O.fogNear.value=D.near,O.fogFar.value=D.far):D.isFogExp2&&(O.fogDensity.value=D.density)}function c(O,D,W,H,K){D.isMeshBasicMaterial||D.isMeshLambertMaterial?h(O,D):D.isMeshToonMaterial?(h(O,D),E(O,D)):D.isMeshPhongMaterial?(h(O,D),I(O,D)):D.isMeshStandardMaterial?(h(O,D),R(O,D),D.isMeshPhysicalMaterial&&k(O,D,K)):D.isMeshMatcapMaterial?(h(O,D),G(O,D)):D.isMeshDepthMaterial?h(O,D):D.isMeshDistanceMaterial?(h(O,D),N(O,D)):D.isMeshNormalMaterial?h(O,D):D.isLineBasicMaterial?(p(O,D),D.isLineDashedMaterial&&b(O,D)):D.isPointsMaterial?y(O,D,W,H):D.isSpriteMaterial?w(O,D):D.isShadowMaterial?(O.color.value.copy(D.color),O.opacity.value=D.opacity):D.isShaderMaterial&&(D.uniformsNeedUpdate=!1)}function h(O,D){O.opacity.value=D.opacity,D.color&&O.diffuse.value.copy(D.color),D.emissive&&O.emissive.value.copy(D.emissive).multiplyScalar(D.emissiveIntensity),D.map&&(O.map.value=D.map,n(D.map,O.mapTransform)),D.alphaMap&&(O.alphaMap.value=D.alphaMap,n(D.alphaMap,O.alphaMapTransform)),D.bumpMap&&(O.bumpMap.value=D.bumpMap,n(D.bumpMap,O.bumpMapTransform),O.bumpScale.value=D.bumpScale,D.side===no&&(O.bumpScale.value*=-1)),D.normalMap&&(O.normalMap.value=D.normalMap,n(D.normalMap,O.normalMapTransform),O.normalScale.value.copy(D.normalScale),D.side===no&&O.normalScale.value.negate()),D.displacementMap&&(O.displacementMap.value=D.displacementMap,n(D.displacementMap,O.displacementMapTransform),O.displacementScale.value=D.displacementScale,O.displacementBias.value=D.displacementBias),D.emissiveMap&&(O.emissiveMap.value=D.emissiveMap,n(D.emissiveMap,O.emissiveMapTransform)),D.specularMap&&(O.specularMap.value=D.specularMap,n(D.specularMap,O.specularMapTransform)),D.alphaTest>0&&(O.alphaTest.value=D.alphaTest);const W=e.get(D),H=W.envMap,K=W.envMapRotation;H&&(O.envMap.value=H,rm.copy(K),rm.x*=-1,rm.y*=-1,rm.z*=-1,H.isCubeTexture&&H.isRenderTargetTexture===!1&&(rm.y*=-1,rm.z*=-1),O.envMapRotation.value.setFromMatrix4(Uge.makeRotationFromEuler(rm)),O.flipEnvMap.value=H.isCubeTexture&&H.isRenderTargetTexture===!1?-1:1,O.reflectivity.value=D.reflectivity,O.ior.value=D.ior,O.refractionRatio.value=D.refractionRatio),D.lightMap&&(O.lightMap.value=D.lightMap,O.lightMapIntensity.value=D.lightMapIntensity,n(D.lightMap,O.lightMapTransform)),D.aoMap&&(O.aoMap.value=D.aoMap,O.aoMapIntensity.value=D.aoMapIntensity,n(D.aoMap,O.aoMapTransform))}function p(O,D){O.diffuse.value.copy(D.color),O.opacity.value=D.opacity,D.map&&(O.map.value=D.map,n(D.map,O.mapTransform))}function b(O,D){O.dashSize.value=D.dashSize,O.totalSize.value=D.dashSize+D.gapSize,O.scale.value=D.scale}function y(O,D,W,H){O.diffuse.value.copy(D.color),O.opacity.value=D.opacity,O.size.value=D.size*W,O.scale.value=H*.5,D.map&&(O.map.value=D.map,n(D.map,O.uvTransform)),D.alphaMap&&(O.alphaMap.value=D.alphaMap,n(D.alphaMap,O.alphaMapTransform)),D.alphaTest>0&&(O.alphaTest.value=D.alphaTest)}function w(O,D){O.diffuse.value.copy(D.color),O.opacity.value=D.opacity,O.rotation.value=D.rotation,D.map&&(O.map.value=D.map,n(D.map,O.mapTransform)),D.alphaMap&&(O.alphaMap.value=D.alphaMap,n(D.alphaMap,O.alphaMapTransform)),D.alphaTest>0&&(O.alphaTest.value=D.alphaTest)}function I(O,D){O.specular.value.copy(D.specular),O.shininess.value=Math.max(D.shininess,1e-4)}function E(O,D){D.gradientMap&&(O.gradientMap.value=D.gradientMap)}function R(O,D){O.metalness.value=D.metalness,D.metalnessMap&&(O.metalnessMap.value=D.metalnessMap,n(D.metalnessMap,O.metalnessMapTransform)),O.roughness.value=D.roughness,D.roughnessMap&&(O.roughnessMap.value=D.roughnessMap,n(D.roughnessMap,O.roughnessMapTransform)),D.envMap&&(O.envMapIntensity.value=D.envMapIntensity)}function k(O,D,W){O.ior.value=D.ior,D.sheen>0&&(O.sheenColor.value.copy(D.sheenColor).multiplyScalar(D.sheen),O.sheenRoughness.value=D.sheenRoughness,D.sheenColorMap&&(O.sheenColorMap.value=D.sheenColorMap,n(D.sheenColorMap,O.sheenColorMapTransform)),D.sheenRoughnessMap&&(O.sheenRoughnessMap.value=D.sheenRoughnessMap,n(D.sheenRoughnessMap,O.sheenRoughnessMapTransform))),D.clearcoat>0&&(O.clearcoat.value=D.clearcoat,O.clearcoatRoughness.value=D.clearcoatRoughness,D.clearcoatMap&&(O.clearcoatMap.value=D.clearcoatMap,n(D.clearcoatMap,O.clearcoatMapTransform)),D.clearcoatRoughnessMap&&(O.clearcoatRoughnessMap.value=D.clearcoatRoughnessMap,n(D.clearcoatRoughnessMap,O.clearcoatRoughnessMapTransform)),D.clearcoatNormalMap&&(O.clearcoatNormalMap.value=D.clearcoatNormalMap,n(D.clearcoatNormalMap,O.clearcoatNormalMapTransform),O.clearcoatNormalScale.value.copy(D.clearcoatNormalScale),D.side===no&&O.clearcoatNormalScale.value.negate())),D.dispersion>0&&(O.dispersion.value=D.dispersion),D.iridescence>0&&(O.iridescence.value=D.iridescence,O.iridescenceIOR.value=D.iridescenceIOR,O.iridescenceThicknessMinimum.value=D.iridescenceThicknessRange[0],O.iridescenceThicknessMaximum.value=D.iridescenceThicknessRange[1],D.iridescenceMap&&(O.iridescenceMap.value=D.iridescenceMap,n(D.iridescenceMap,O.iridescenceMapTransform)),D.iridescenceThicknessMap&&(O.iridescenceThicknessMap.value=D.iridescenceThicknessMap,n(D.iridescenceThicknessMap,O.iridescenceThicknessMapTransform))),D.transmission>0&&(O.transmission.value=D.transmission,O.transmissionSamplerMap.value=W.texture,O.transmissionSamplerSize.value.set(W.width,W.height),D.transmissionMap&&(O.transmissionMap.value=D.transmissionMap,n(D.transmissionMap,O.transmissionMapTransform)),O.thickness.value=D.thickness,D.thicknessMap&&(O.thicknessMap.value=D.thicknessMap,n(D.thicknessMap,O.thicknessMapTransform)),O.attenuationDistance.value=D.attenuationDistance,O.attenuationColor.value.copy(D.attenuationColor)),D.anisotropy>0&&(O.anisotropyVector.value.set(D.anisotropy*Math.cos(D.anisotropyRotation),D.anisotropy*Math.sin(D.anisotropyRotation)),D.anisotropyMap&&(O.anisotropyMap.value=D.anisotropyMap,n(D.anisotropyMap,O.anisotropyMapTransform))),O.specularIntensity.value=D.specularIntensity,O.specularColor.value.copy(D.specularColor),D.specularColorMap&&(O.specularColorMap.value=D.specularColorMap,n(D.specularColorMap,O.specularColorMapTransform)),D.specularIntensityMap&&(O.specularIntensityMap.value=D.specularIntensityMap,n(D.specularIntensityMap,O.specularIntensityMapTransform))}function G(O,D){D.matcap&&(O.matcap.value=D.matcap)}function N(O,D){const W=e.get(D).light;O.referencePosition.value.setFromMatrixPosition(W.matrixWorld),O.nearDistance.value=W.shadow.camera.near,O.farDistance.value=W.shadow.camera.far}return{refreshFogUniforms:a,refreshMaterialUniforms:c}}function zge(r,e,n,a){let c={},h={},p=[];const b=r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);function y(W,H){const K=H.program;a.uniformBlockBinding(W,K)}function w(W,H){let K=c[W.id];K===void 0&&(G(W),K=I(W),c[W.id]=K,W.addEventListener("dispose",O));const j=H.program;a.updateUBOMapping(W,j);const J=e.render.frame;h[W.id]!==J&&(R(W),h[W.id]=J)}function I(W){const H=E();W.__bindingPointIndex=H;const K=r.createBuffer(),j=W.__size,J=W.usage;return r.bindBuffer(r.UNIFORM_BUFFER,K),r.bufferData(r.UNIFORM_BUFFER,j,J),r.bindBuffer(r.UNIFORM_BUFFER,null),r.bindBufferBase(r.UNIFORM_BUFFER,H,K),K}function E(){for(let W=0;W<b;W++)if(p.indexOf(W)===-1)return p.push(W),W;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function R(W){const H=c[W.id],K=W.uniforms,j=W.__cache;r.bindBuffer(r.UNIFORM_BUFFER,H);for(let J=0,ee=K.length;J<ee;J++){const re=Array.isArray(K[J])?K[J]:[K[J]];for(let Y=0,ie=re.length;Y<ie;Y++){const ue=re[Y];if(k(ue,J,Y,j)===!0){const Re=ue.__offset,_e=Array.isArray(ue.value)?ue.value:[ue.value];let Pe=0;for(let rt=0;rt<_e.length;rt++){const de=_e[rt],we=N(de);typeof de=="number"||typeof de=="boolean"?(ue.__data[0]=de,r.bufferSubData(r.UNIFORM_BUFFER,Re+Pe,ue.__data)):de.isMatrix3?(ue.__data[0]=de.elements[0],ue.__data[1]=de.elements[1],ue.__data[2]=de.elements[2],ue.__data[3]=0,ue.__data[4]=de.elements[3],ue.__data[5]=de.elements[4],ue.__data[6]=de.elements[5],ue.__data[7]=0,ue.__data[8]=de.elements[6],ue.__data[9]=de.elements[7],ue.__data[10]=de.elements[8],ue.__data[11]=0):(de.toArray(ue.__data,Pe),Pe+=we.storage/Float32Array.BYTES_PER_ELEMENT)}r.bufferSubData(r.UNIFORM_BUFFER,Re,ue.__data)}}}r.bindBuffer(r.UNIFORM_BUFFER,null)}function k(W,H,K,j){const J=W.value,ee=H+"_"+K;if(j[ee]===void 0)return typeof J=="number"||typeof J=="boolean"?j[ee]=J:j[ee]=J.clone(),!0;{const re=j[ee];if(typeof J=="number"||typeof J=="boolean"){if(re!==J)return j[ee]=J,!0}else if(re.equals(J)===!1)return re.copy(J),!0}return!1}function G(W){const H=W.uniforms;let K=0;const j=16;for(let ee=0,re=H.length;ee<re;ee++){const Y=Array.isArray(H[ee])?H[ee]:[H[ee]];for(let ie=0,ue=Y.length;ie<ue;ie++){const Re=Y[ie],_e=Array.isArray(Re.value)?Re.value:[Re.value];for(let Pe=0,rt=_e.length;Pe<rt;Pe++){const de=_e[Pe],we=N(de),Le=K%j,Je=Le%we.boundary,fe=Le+Je;K+=Je,fe!==0&&j-fe<we.storage&&(K+=j-fe),Re.__data=new Float32Array(we.storage/Float32Array.BYTES_PER_ELEMENT),Re.__offset=K,K+=we.storage}}}const J=K%j;return J>0&&(K+=j-J),W.__size=K,W.__cache={},this}function N(W){const H={boundary:0,storage:0};return typeof W=="number"||typeof W=="boolean"?(H.boundary=4,H.storage=4):W.isVector2?(H.boundary=8,H.storage=8):W.isVector3||W.isColor?(H.boundary=16,H.storage=12):W.isVector4?(H.boundary=16,H.storage=16):W.isMatrix3?(H.boundary=48,H.storage=48):W.isMatrix4?(H.boundary=64,H.storage=64):W.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",W),H}function O(W){const H=W.target;H.removeEventListener("dispose",O);const K=p.indexOf(H.__bindingPointIndex);p.splice(K,1),r.deleteBuffer(c[H.id]),delete c[H.id],delete h[H.id]}function D(){for(const W in c)r.deleteBuffer(c[W]);p=[],c={},h={}}return{bind:y,update:w,dispose:D}}class Vge{constructor(e={}){const{canvas:n=cz(),context:a=null,depth:c=!0,stencil:h=!1,alpha:p=!1,antialias:b=!1,premultipliedAlpha:y=!0,preserveDrawingBuffer:w=!1,powerPreference:I="default",failIfMajorPerformanceCaveat:E=!1,reverseDepthBuffer:R=!1,multiviewStereo:k=!1}=e;this.isWebGLRenderer=!0;let G;if(a!==null){if(typeof WebGLRenderingContext<"u"&&a instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");G=a.getContextAttributes().alpha}else G=p;const N=new Uint32Array(4),O=new Int32Array(4);let D=null,W=null;const H=[],K=[];this.domElement=n,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=Io,this.toneMapping=Eh,this.toneMappingExposure=1;const j=this;let J=!1,ee=0,re=0,Y=null,ie=-1,ue=null;const Re=new Xi,_e=new Xi;let Pe=null;const rt=new pn(0);let de=0,we=n.width,Le=n.height,Je=1,fe=null,Ve=null;const Ne=new Xi(0,0,we,Le),gt=new Xi(0,0,we,Le);let bt=!1;const zt=new zv;let Tt=!1,Vt=!1;this.transmissionResolutionScale=1;const je=new Zn,_t=new Zn,Ot=new be,on=new Xi,vt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Mt=!1;function Bt(){return Y===null?Je:1}let ve=a;function Kt(ce,We){return n.getContext(ce,We)}try{const ce={alpha:!0,depth:c,stencil:h,antialias:b,premultipliedAlpha:y,preserveDrawingBuffer:w,powerPreference:I,failIfMajorPerformanceCaveat:E};if("setAttribute"in n&&n.setAttribute("data-engine",`three.js r${g2}`),n.addEventListener("webglcontextlost",cn,!1),n.addEventListener("webglcontextrestored",Vn,!1),n.addEventListener("webglcontextcreationerror",nn,!1),ve===null){const We="webgl2";if(ve=Kt(We,ce),ve===null)throw Kt(We)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(ce){throw console.error("THREE.WebGLRenderer: "+ce.message),ce}let Ee,Q,Z,ae,Ae,Ie,Ze,At,dn,ge,se,Ge,ut,kt,xt,fn,Gt,Jt,Ln,Zt,bn,Jn,ke,wt,Wt;function jt(){Ee=new qpe(ve),Ee.init(),ke=new bV(ve,Ee),Q=new Qpe(ve,Ee,e,ke),Z=new Lge(ve,Ee),Q.reverseDepthBuffer&&R&&Z.buffers.depth.setReversed(!0),ae=new tme(ve),Ae=new vge,Ie=new Nge(ve,Ee,Z,Ae,Q,ke,ae),Ze=new Zpe(j),At=new jpe(j),dn=new lde(ve),wt=new Hpe(ve,dn),ge=new Jpe(ve,dn,ae,wt),se=new sme(ve,ge,dn,ae),Zt=new nme(ve,Q,Ie),fn=new Kpe(Ae),Ge=new yge(j,Ze,At,Ee,Q,wt,fn),ut=new Pge(j,Ae),kt=new wge,xt=new Mge(Ee),Ln=new Wpe(j,Ze,At,Z,se,G,y),Jt=new ime(j,Ee,ve),Gt=new kge(j,se,Q),Wt=new zge(ve,ae,Q,Z),bn=new Xpe(ve,Ee,ae),Jn=new eme(ve,Ee,ae),ae.programs=Ge.programs,j.capabilities=Q,j.extensions=Ee,j.properties=Ae,j.renderLists=kt,j.shadowMap=Gt,j.state=Z,j.info=ae}jt();const tn=new Gge(j,ve);this.xr=tn,this.getContext=function(){return ve},this.getContextAttributes=function(){return ve.getContextAttributes()},this.forceContextLoss=function(){const ce=Ee.get("WEBGL_lose_context");ce&&ce.loseContext()},this.forceContextRestore=function(){const ce=Ee.get("WEBGL_lose_context");ce&&ce.restoreContext()},this.getPixelRatio=function(){return Je},this.setPixelRatio=function(ce){ce!==void 0&&(Je=ce,this.setSize(we,Le,!1))},this.getSize=function(ce){return ce.set(we,Le)},this.setSize=function(ce,We,st=!0){if(tn.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}we=ce,Le=We,n.width=Math.floor(ce*Je),n.height=Math.floor(We*Je),st===!0&&(n.style.width=ce+"px",n.style.height=We+"px"),this.setViewport(0,0,ce,We)},this.getDrawingBufferSize=function(ce){return ce.set(we*Je,Le*Je).floor()},this.setDrawingBufferSize=function(ce,We,st){we=ce,Le=We,Je=st,n.width=Math.floor(ce*st),n.height=Math.floor(We*st),this.setViewport(0,0,ce,We)},this.getCurrentViewport=function(ce){return ce.copy(Re)},this.getViewport=function(ce){return ce.copy(Ne)},this.setViewport=function(ce,We,st,ot){ce.isVector4?Ne.set(ce.x,ce.y,ce.z,ce.w):Ne.set(ce,We,st,ot),Z.viewport(Re.copy(Ne).multiplyScalar(Je).round())},this.getScissor=function(ce){return ce.copy(gt)},this.setScissor=function(ce,We,st,ot){ce.isVector4?gt.set(ce.x,ce.y,ce.z,ce.w):gt.set(ce,We,st,ot),Z.scissor(_e.copy(gt).multiplyScalar(Je).round())},this.getScissorTest=function(){return bt},this.setScissorTest=function(ce){Z.setScissorTest(bt=ce)},this.setOpaqueSort=function(ce){fe=ce},this.setTransparentSort=function(ce){Ve=ce},this.getClearColor=function(ce){return ce.copy(Ln.getClearColor())},this.setClearColor=function(){Ln.setClearColor.apply(Ln,arguments)},this.getClearAlpha=function(){return Ln.getClearAlpha()},this.setClearAlpha=function(){Ln.setClearAlpha.apply(Ln,arguments)},this.clear=function(ce=!0,We=!0,st=!0){let ot=0;if(ce){let Xe=!1;if(Y!==null){const Nt=Y.texture.format;Xe=Nt===C2||Nt===w2||Nt===Gv}if(Xe){const Nt=Y.texture.type,sn=Nt===vu||Nt===Rh||Nt===q0||Nt===$d||Nt===y2||Nt===v2,un=Ln.getClearColor(),ln=Ln.getClearAlpha(),Dn=un.r,Un=un.g,Mn=un.b;sn?(N[0]=Dn,N[1]=Un,N[2]=Mn,N[3]=ln,ve.clearBufferuiv(ve.COLOR,0,N)):(O[0]=Dn,O[1]=Un,O[2]=Mn,O[3]=ln,ve.clearBufferiv(ve.COLOR,0,O))}else ot|=ve.COLOR_BUFFER_BIT}We&&(ot|=ve.DEPTH_BUFFER_BIT),st&&(ot|=ve.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),ve.clear(ot)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){n.removeEventListener("webglcontextlost",cn,!1),n.removeEventListener("webglcontextrestored",Vn,!1),n.removeEventListener("webglcontextcreationerror",nn,!1),Ln.dispose(),kt.dispose(),xt.dispose(),Ae.dispose(),Ze.dispose(),At.dispose(),se.dispose(),wt.dispose(),Wt.dispose(),Ge.dispose(),tn.dispose(),tn.removeEventListener("sessionstart",ro),tn.removeEventListener("sessionend",xc),ao.stop()};function cn(ce){ce.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),J=!0}function Vn(){console.log("THREE.WebGLRenderer: Context Restored."),J=!1;const ce=ae.autoReset,We=Gt.enabled,st=Gt.autoUpdate,ot=Gt.needsUpdate,Xe=Gt.type;jt(),ae.autoReset=ce,Gt.enabled=We,Gt.autoUpdate=st,Gt.needsUpdate=ot,Gt.type=Xe}function nn(ce){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",ce.statusMessage)}function qt(ce){const We=ce.target;We.removeEventListener("dispose",qt),mn(We)}function mn(ce){fi(ce),Ae.remove(ce)}function fi(ce){const We=Ae.get(ce).programs;We!==void 0&&(We.forEach(function(st){Ge.releaseProgram(st)}),ce.isShaderMaterial&&Ge.releaseShaderCache(ce))}this.renderBufferDirect=function(ce,We,st,ot,Xe,Nt){We===null&&(We=vt);const sn=Xe.isMesh&&Xe.matrixWorld.determinant()<0,un=Vs(ce,We,st,ot,Xe);Z.setMaterial(ot,sn);let ln=st.index,Dn=1;if(ot.wireframe===!0){if(ln=ge.getWireframeAttribute(st),ln===void 0)return;Dn=2}const Un=st.drawRange,Mn=st.attributes.position;let Ai=Un.start*Dn,Yn=(Un.start+Un.count)*Dn;Nt!==null&&(Ai=Math.max(Ai,Nt.start*Dn),Yn=Math.min(Yn,(Nt.start+Nt.count)*Dn)),ln!==null?(Ai=Math.max(Ai,0),Yn=Math.min(Yn,ln.count)):Mn!=null&&(Ai=Math.max(Ai,0),Yn=Math.min(Yn,Mn.count));const ys=Yn-Ai;if(ys<0||ys===1/0)return;wt.setup(Xe,ot,un,st,ln);let ss,ei=bn;if(ln!==null&&(ss=dn.get(ln),ei=Jn,ei.setIndex(ss)),Xe.isMesh)ot.wireframe===!0?(Z.setLineWidth(ot.wireframeLinewidth*Bt()),ei.setMode(ve.LINES)):ei.setMode(ve.TRIANGLES);else if(Xe.isLine){let Fs=ot.linewidth;Fs===void 0&&(Fs=1),Z.setLineWidth(Fs*Bt()),Xe.isLineSegments?ei.setMode(ve.LINES):Xe.isLineLoop?ei.setMode(ve.LINE_LOOP):ei.setMode(ve.LINE_STRIP)}else Xe.isPoints?ei.setMode(ve.POINTS):Xe.isSprite&&ei.setMode(ve.TRIANGLES);if(Xe.isBatchedMesh)if(Xe._multiDrawInstances!==null)ei.renderMultiDrawInstances(Xe._multiDrawStarts,Xe._multiDrawCounts,Xe._multiDrawCount,Xe._multiDrawInstances);else if(Ee.get("WEBGL_multi_draw"))ei.renderMultiDraw(Xe._multiDrawStarts,Xe._multiDrawCounts,Xe._multiDrawCount);else{const Fs=Xe._multiDrawStarts,xn=Xe._multiDrawCounts,Ec=Xe._multiDrawCount,Qn=ln?dn.get(ln).bytesPerElement:1,Ws=Ae.get(ot).currentProgram.getUniforms();for(let Sr=0;Sr<Ec;Sr++)Ws.setValue(ve,"_gl_DrawID",Sr),ei.render(Fs[Sr]/Qn,xn[Sr])}else if(Xe.isInstancedMesh)ei.renderInstances(Ai,ys,Xe.count);else if(st.isInstancedBufferGeometry){const Fs=st._maxInstanceCount!==void 0?st._maxInstanceCount:1/0,xn=Math.min(st.instanceCount,Fs);ei.renderInstances(Ai,ys,xn)}else ei.render(Ai,ys)};function Ki(ce,We,st){ce.transparent===!0&&ce.side===mu&&ce.forceSinglePass===!1?(ce.side=no,ce.needsUpdate=!0,Sa(ce,We,st),ce.side=Mh,ce.needsUpdate=!0,Sa(ce,We,st),ce.side=mu):Sa(ce,We,st)}this.compile=function(ce,We,st=null){st===null&&(st=ce),W=xt.get(st),W.init(We),K.push(W),st.traverseVisible(function(Xe){Xe.isLight&&Xe.layers.test(We.layers)&&(W.pushLight(Xe),Xe.castShadow&&W.pushShadow(Xe))}),ce!==st&&ce.traverseVisible(function(Xe){Xe.isLight&&Xe.layers.test(We.layers)&&(W.pushLight(Xe),Xe.castShadow&&W.pushShadow(Xe))}),W.setupLights();const ot=new Set;return ce.traverse(function(Xe){if(!(Xe.isMesh||Xe.isPoints||Xe.isLine||Xe.isSprite))return;const Nt=Xe.material;if(Nt)if(Array.isArray(Nt))for(let sn=0;sn<Nt.length;sn++){const un=Nt[sn];Ki(un,st,Xe),ot.add(un)}else Ki(Nt,st,Xe),ot.add(Nt)}),K.pop(),W=null,ot},this.compileAsync=function(ce,We,st=null){const ot=this.compile(ce,We,st);return new Promise(Xe=>{function Nt(){if(ot.forEach(function(sn){Ae.get(sn).currentProgram.isReady()&&ot.delete(sn)}),ot.size===0){Xe(ce);return}setTimeout(Nt,10)}Ee.get("KHR_parallel_shader_compile")!==null?Nt():setTimeout(Nt,10)})};let Ts=null;function ir(ce){Ts&&Ts(ce)}function ro(){ao.stop()}function xc(){ao.start()}const ao=new fV;ao.setAnimationLoop(ir),typeof self<"u"&&ao.setContext(self),this.setAnimationLoop=function(ce){Ts=ce,tn.setAnimationLoop(ce),ce===null?ao.stop():ao.start()},tn.addEventListener("sessionstart",ro),tn.addEventListener("sessionend",xc),this.render=function(ce,We){if(We!==void 0&&We.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(J===!0)return;if(ce.matrixWorldAutoUpdate===!0&&ce.updateMatrixWorld(),We.parent===null&&We.matrixWorldAutoUpdate===!0&&We.updateMatrixWorld(),tn.enabled===!0&&tn.isPresenting===!0&&(tn.cameraAutoUpdate===!0&&tn.updateCamera(We),We=tn.getCamera()),ce.isScene===!0&&ce.onBeforeRender(j,ce,We,Y),W=xt.get(ce,K.length),W.init(We),K.push(W),_t.multiplyMatrices(We.projectionMatrix,We.matrixWorldInverse),zt.setFromProjectionMatrix(_t),Vt=this.localClippingEnabled,Tt=fn.init(this.clippingPlanes,Vt),D=kt.get(ce,H.length),D.init(),H.push(D),tn.enabled===!0&&tn.isPresenting===!0){const Nt=j.xr.getDepthSensingMesh();Nt!==null&&wc(Nt,We,-1/0,j.sortObjects)}wc(ce,We,0,j.sortObjects),D.finish(),j.sortObjects===!0&&D.sort(fe,Ve),Mt=tn.enabled===!1||tn.isPresenting===!1||tn.hasDepthSensing()===!1,Mt&&Ln.addToRenderList(D,ce),this.info.render.frame++,Tt===!0&&fn.beginShadows();const st=W.state.shadowsArray;Gt.render(st,ce,We),Tt===!0&&fn.endShadows(),this.info.autoReset===!0&&this.info.reset();const ot=D.opaque,Xe=D.transmissive;if(W.setupLights(),We.isArrayCamera){const Nt=We.cameras;if(Xe.length>0)for(let sn=0,un=Nt.length;sn<un;sn++){const ln=Nt[sn];nl(ot,Xe,ce,ln)}if(Mt&&Ln.render(ce),tn.enabled&&tn.isMultiview)Ie.setDeferTextureUploads(!0),Cc(D,ce,We,We.cameras[0].viewport);else for(let sn=0,un=Nt.length;sn<un;sn++){const ln=Nt[sn];Cc(D,ce,ln,ln.viewport)}}else Xe.length>0&&nl(ot,Xe,ce,We),Mt&&Ln.render(ce),Cc(D,ce,We);Y!==null&&re===0&&(Ie.updateMultisampleRenderTarget(Y),Ie.updateRenderTargetMipmap(Y)),ce.isScene===!0&&ce.onAfterRender(j,ce,We),wt.resetDefaultState(),ie=-1,ue=null,K.pop(),K.length>0?(W=K[K.length-1],Tt===!0&&fn.setGlobalState(j.clippingPlanes,W.state.camera)):W=null,H.pop(),H.length>0?D=H[H.length-1]:D=null};function wc(ce,We,st,ot){if(ce.visible===!1)return;if(ce.layers.test(We.layers)){if(ce.isGroup)st=ce.renderOrder;else if(ce.isLOD)ce.autoUpdate===!0&&ce.update(We);else if(ce.isLight)W.pushLight(ce),ce.castShadow&&W.pushShadow(ce);else if(ce.isSprite){if(!ce.frustumCulled||zt.intersectsSprite(ce)){ot&&on.setFromMatrixPosition(ce.matrixWorld).applyMatrix4(_t);const sn=se.update(ce),un=ce.material;un.visible&&D.push(ce,sn,un,st,on.z,null)}}else if((ce.isMesh||ce.isLine||ce.isPoints)&&(!ce.frustumCulled||zt.intersectsObject(ce))){const sn=se.update(ce),un=ce.material;if(ot&&(ce.boundingSphere!==void 0?(ce.boundingSphere===null&&ce.computeBoundingSphere(),on.copy(ce.boundingSphere.center)):(sn.boundingSphere===null&&sn.computeBoundingSphere(),on.copy(sn.boundingSphere.center)),on.applyMatrix4(ce.matrixWorld).applyMatrix4(_t)),Array.isArray(un)){const ln=sn.groups;for(let Dn=0,Un=ln.length;Dn<Un;Dn++){const Mn=ln[Dn],Ai=un[Mn.materialIndex];Ai&&Ai.visible&&D.push(ce,sn,Ai,st,on.z,Mn)}}else un.visible&&D.push(ce,sn,un,st,on.z,null)}}const Nt=ce.children;for(let sn=0,un=Nt.length;sn<un;sn++)wc(Nt[sn],We,st,ot)}function Cc(ce,We,st,ot){const Xe=ce.opaque,Nt=ce.transmissive,sn=ce.transparent;W.setupLightsView(st),Tt===!0&&fn.setGlobalState(j.clippingPlanes,st),ot&&Z.viewport(Re.copy(ot)),Xe.length>0&&oo(Xe,We,st),Nt.length>0&&oo(Nt,We,st),sn.length>0&&oo(sn,We,st),Z.buffers.depth.setTest(!0),Z.buffers.depth.setMask(!0),Z.buffers.color.setMask(!0),Z.setPolygonOffset(!1)}function nl(ce,We,st,ot){if((st.isScene===!0?st.overrideMaterial:null)!==null)return;W.state.transmissionRenderTarget[ot.id]===void 0&&(W.state.transmissionRenderTarget[ot.id]=new Ac(1,1,{generateMipmaps:!0,type:Ee.has("EXT_color_buffer_half_float")||Ee.has("EXT_color_buffer_float")?sA:vu,minFilter:gu,samples:4,stencilBuffer:h,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:zi.workingColorSpace}));const Nt=W.state.transmissionRenderTarget[ot.id],sn=ot.viewport||Re;Nt.setSize(sn.z*j.transmissionResolutionScale,sn.w*j.transmissionResolutionScale);const un=j.getRenderTarget();j.setRenderTarget(Nt),j.getClearColor(rt),de=j.getClearAlpha(),de<1&&j.setClearColor(16777215,.5),j.clear(),Mt&&Ln.render(st);const ln=j.toneMapping;j.toneMapping=Eh;const Dn=ot.viewport;if(ot.viewport!==void 0&&(ot.viewport=void 0),W.setupLightsView(ot),Tt===!0&&fn.setGlobalState(j.clippingPlanes,ot),oo(ce,st,ot),Ie.updateMultisampleRenderTarget(Nt),Ie.updateRenderTargetMipmap(Nt),Ee.has("WEBGL_multisampled_render_to_texture")===!1){let Un=!1;for(let Mn=0,Ai=We.length;Mn<Ai;Mn++){const Yn=We[Mn],ys=Yn.object,ss=Yn.geometry,ei=Yn.material,Fs=Yn.group;if(ei.side===mu&&ys.layers.test(ot.layers)){const xn=ei.side;ei.side=no,ei.needsUpdate=!0,Ea(ys,st,ot,ss,ei,Fs),ei.side=xn,ei.needsUpdate=!0,Un=!0}}Un===!0&&(Ie.updateMultisampleRenderTarget(Nt),Ie.updateRenderTargetMipmap(Nt))}j.setRenderTarget(un),j.setClearColor(rt,de),Dn!==void 0&&(ot.viewport=Dn),j.toneMapping=ln}function oo(ce,We,st){const ot=We.isScene===!0?We.overrideMaterial:null;for(let Xe=0,Nt=ce.length;Xe<Nt;Xe++){const sn=ce[Xe],un=sn.object,ln=sn.geometry,Dn=ot===null?sn.material:ot,Un=sn.group;un.layers.test(st.layers)&&Ea(un,We,st,ln,Dn,Un)}}function Ea(ce,We,st,ot,Xe,Nt){ce.onBeforeRender(j,We,st,ot,Xe,Nt),ce.modelViewMatrix.multiplyMatrices(st.matrixWorldInverse,ce.matrixWorld),ce.normalMatrix.getNormalMatrix(ce.modelViewMatrix),Xe.onBeforeRender(j,We,st,ot,ce,Nt),Xe.transparent===!0&&Xe.side===mu&&Xe.forceSinglePass===!1?(Xe.side=no,Xe.needsUpdate=!0,j.renderBufferDirect(st,We,ot,Xe,ce,Nt),Xe.side=Mh,Xe.needsUpdate=!0,j.renderBufferDirect(st,We,ot,Xe,ce,Nt),Xe.side=mu):j.renderBufferDirect(st,We,ot,Xe,ce,Nt),ce.onAfterRender(j,We,st,ot,Xe,Nt)}function Sa(ce,We,st){We.isScene!==!0&&(We=vt);const ot=Ae.get(ce),Xe=W.state.lights,Nt=W.state.shadowsArray,sn=Xe.state.version,un=Ge.getParameters(ce,Xe.state,Nt,We,st),ln=Ge.getProgramCacheKey(un);let Dn=ot.programs;ot.environment=ce.isMeshStandardMaterial?We.environment:null,ot.fog=We.fog,ot.envMap=(ce.isMeshStandardMaterial?At:Ze).get(ce.envMap||ot.environment),ot.envMapRotation=ot.environment!==null&&ce.envMap===null?We.environmentRotation:ce.envMapRotation,Dn===void 0&&(ce.addEventListener("dispose",qt),Dn=new Map,ot.programs=Dn);let Un=Dn.get(ln);if(Un!==void 0){if(ot.currentProgram===Un&&ot.lightsStateVersion===sn)return Bo(ce,un),Un}else un.uniforms=Ge.getUniforms(ce),ce.onBeforeCompile(un,j),Un=Ge.acquireProgram(un,ln),Dn.set(ln,Un),ot.uniforms=un.uniforms;const Mn=ot.uniforms;return(!ce.isShaderMaterial&&!ce.isRawShaderMaterial||ce.clipping===!0)&&(Mn.clippingPlanes=fn.uniform),Bo(ce,un),ot.needsLights=Cu(ce),ot.lightsStateVersion=sn,ot.needsLights&&(Mn.ambientLightColor.value=Xe.state.ambient,Mn.lightProbe.value=Xe.state.probe,Mn.directionalLights.value=Xe.state.directional,Mn.directionalLightShadows.value=Xe.state.directionalShadow,Mn.spotLights.value=Xe.state.spot,Mn.spotLightShadows.value=Xe.state.spotShadow,Mn.rectAreaLights.value=Xe.state.rectArea,Mn.ltc_1.value=Xe.state.rectAreaLTC1,Mn.ltc_2.value=Xe.state.rectAreaLTC2,Mn.pointLights.value=Xe.state.point,Mn.pointLightShadows.value=Xe.state.pointShadow,Mn.hemisphereLights.value=Xe.state.hemi,Mn.directionalShadowMap.value=Xe.state.directionalShadowMap,Mn.directionalShadowMatrix.value=Xe.state.directionalShadowMatrix,Mn.spotShadowMap.value=Xe.state.spotShadowMap,Mn.spotLightMatrix.value=Xe.state.spotLightMatrix,Mn.spotLightMap.value=Xe.state.spotLightMap,Mn.pointShadowMap.value=Xe.state.pointShadowMap,Mn.pointShadowMatrix.value=Xe.state.pointShadowMatrix),ot.currentProgram=Un,ot.uniformsList=null,Un}function ko(ce){if(ce.uniformsList===null){const We=ce.currentProgram.getUniforms();ce.uniformsList=oE.seqWithValue(We.seq,ce.uniforms)}return ce.uniformsList}function Bo(ce,We){const st=Ae.get(ce);st.outputColorSpace=We.outputColorSpace,st.batching=We.batching,st.batchingColor=We.batchingColor,st.instancing=We.instancing,st.instancingColor=We.instancingColor,st.instancingMorph=We.instancingMorph,st.skinning=We.skinning,st.morphTargets=We.morphTargets,st.morphNormals=We.morphNormals,st.morphColors=We.morphColors,st.morphTargetsCount=We.morphTargetsCount,st.numClippingPlanes=We.numClippingPlanes,st.numIntersection=We.numClipIntersection,st.vertexAlphas=We.vertexAlphas,st.vertexTangents=We.vertexTangents,st.toneMapping=We.toneMapping,st.numMultiviewViews=We.numMultiviewViews}function Vs(ce,We,st,ot,Xe){We.isScene!==!0&&(We=vt),Ie.resetTextureUnits();const Nt=We.fog,sn=ot.isMeshStandardMaterial?We.environment:null,un=Y===null?j.outputColorSpace:Y.isXRRenderTarget===!0?Y.texture.colorSpace:Tm,ln=(ot.isMeshStandardMaterial?At:Ze).get(ot.envMap||sn),Dn=ot.vertexColors===!0&&!!st.attributes.color&&st.attributes.color.itemSize===4,Un=!!st.attributes.tangent&&(!!ot.normalMap||ot.anisotropy>0),Mn=!!st.morphAttributes.position,Ai=!!st.morphAttributes.normal,Yn=!!st.morphAttributes.color;let ys=Eh;ot.toneMapped&&(Y===null||Y.isXRRenderTarget===!0)&&(ys=j.toneMapping);const ss=Y&&Y.isWebGLMultiviewRenderTarget?Y.numViews:0,ei=st.morphAttributes.position||st.morphAttributes.normal||st.morphAttributes.color,Fs=ei!==void 0?ei.length:0,xn=Ae.get(ot),Ec=W.state.lights;if(Tt===!0&&(Vt===!0||ce!==ue)){const vs=ce===ue&&ot.id===ie;fn.setState(ot,ce,vs)}let Qn=!1;ot.version===xn.__version?(xn.needsLights&&xn.lightsStateVersion!==Ec.state.version||xn.outputColorSpace!==un||Xe.isBatchedMesh&&xn.batching===!1||!Xe.isBatchedMesh&&xn.batching===!0||Xe.isBatchedMesh&&xn.batchingColor===!0&&Xe.colorTexture===null||Xe.isBatchedMesh&&xn.batchingColor===!1&&Xe.colorTexture!==null||Xe.isInstancedMesh&&xn.instancing===!1||!Xe.isInstancedMesh&&xn.instancing===!0||Xe.isSkinnedMesh&&xn.skinning===!1||!Xe.isSkinnedMesh&&xn.skinning===!0||Xe.isInstancedMesh&&xn.instancingColor===!0&&Xe.instanceColor===null||Xe.isInstancedMesh&&xn.instancingColor===!1&&Xe.instanceColor!==null||Xe.isInstancedMesh&&xn.instancingMorph===!0&&Xe.morphTexture===null||Xe.isInstancedMesh&&xn.instancingMorph===!1&&Xe.morphTexture!==null||xn.envMap!==ln||ot.fog===!0&&xn.fog!==Nt||xn.numClippingPlanes!==void 0&&(xn.numClippingPlanes!==fn.numPlanes||xn.numIntersection!==fn.numIntersection)||xn.vertexAlphas!==Dn||xn.vertexTangents!==Un||xn.morphTargets!==Mn||xn.morphNormals!==Ai||xn.morphColors!==Yn||xn.toneMapping!==ys||xn.morphTargetsCount!==Fs||xn.numMultiviewViews!==ss)&&(Qn=!0):(Qn=!0,xn.__version=ot.version);let Ws=xn.currentProgram;Qn===!0&&(Ws=Sa(ot,We,Xe));let Sr=!1,Ia=!1,Xr=!1;const Si=Ws.getUniforms(),Cs=xn.uniforms;if(Z.useProgram(Ws.program)&&(Sr=!0,Ia=!0,Xr=!0),ot.id!==ie&&(ie=ot.id,Ia=!0),Sr||ue!==ce){Ws.numMultiviewViews>0?(Jt.updateCameraProjectionMatricesUniform(ce,Si),Jt.updateCameraViewMatricesUniform(ce,Si)):(Z.buffers.depth.getReversed()?(je.copy(ce.projectionMatrix),_ce(je),Rce(je),Si.setValue(ve,"projectionMatrix",je)):Si.setValue(ve,"projectionMatrix",ce.projectionMatrix),Si.setValue(ve,"viewMatrix",ce.matrixWorldInverse));const vs=Si.map.cameraPosition;vs!==void 0&&vs.setValue(ve,Ot.setFromMatrixPosition(ce.matrixWorld)),Q.logarithmicDepthBuffer&&Si.setValue(ve,"logDepthBufFC",2/(Math.log(ce.far+1)/Math.LN2)),(ot.isMeshPhongMaterial||ot.isMeshToonMaterial||ot.isMeshLambertMaterial||ot.isMeshBasicMaterial||ot.isMeshStandardMaterial||ot.isShaderMaterial)&&Si.setValue(ve,"isOrthographic",ce.isOrthographicCamera===!0),ue!==ce&&(ue=ce,Ia=!0,Xr=!0)}if(Xe.isSkinnedMesh){Si.setOptional(ve,Xe,"bindMatrix"),Si.setOptional(ve,Xe,"bindMatrixInverse");const vs=Xe.skeleton;vs&&(vs.boneTexture===null&&vs.computeBoneTexture(),Si.setValue(ve,"boneTexture",vs.boneTexture,Ie))}Xe.isBatchedMesh&&(Si.setOptional(ve,Xe,"batchingTexture"),Si.setValue(ve,"batchingTexture",Xe._matricesTexture,Ie),Si.setOptional(ve,Xe,"batchingIdTexture"),Si.setValue(ve,"batchingIdTexture",Xe._indirectTexture,Ie),Si.setOptional(ve,Xe,"batchingColorTexture"),Xe._colorsTexture!==null&&Si.setValue(ve,"batchingColorTexture",Xe._colorsTexture,Ie));const sr=st.morphAttributes;if((sr.position!==void 0||sr.normal!==void 0||sr.color!==void 0)&&Zt.update(Xe,st,Ws),(Ia||xn.receiveShadow!==Xe.receiveShadow)&&(xn.receiveShadow=Xe.receiveShadow,Si.setValue(ve,"receiveShadow",Xe.receiveShadow)),ot.isMeshGouraudMaterial&&ot.envMap!==null&&(Cs.envMap.value=ln,Cs.flipEnvMap.value=ln.isCubeTexture&&ln.isRenderTargetTexture===!1?-1:1),ot.isMeshStandardMaterial&&ot.envMap===null&&We.environment!==null&&(Cs.envMapIntensity.value=We.environmentIntensity),Ia&&(Si.setValue(ve,"toneMappingExposure",j.toneMappingExposure),xn.needsLights&&Bh(Cs,Xr),Nt&&ot.fog===!0&&ut.refreshFogUniforms(Cs,Nt),ut.refreshMaterialUniforms(Cs,ot,Je,Le,W.state.transmissionRenderTarget[ce.id]),oE.upload(ve,ko(xn),Cs,Ie)),ot.isShaderMaterial&&ot.uniformsNeedUpdate===!0&&(oE.upload(ve,ko(xn),Cs,Ie),ot.uniformsNeedUpdate=!1),ot.isSpriteMaterial&&Si.setValue(ve,"center",Xe.center),Ws.numMultiviewViews>0?Jt.updateObjectMatricesUniforms(Xe,ce,Si):(Si.setValue(ve,"modelViewMatrix",Xe.modelViewMatrix),Si.setValue(ve,"normalMatrix",Xe.normalMatrix)),Si.setValue(ve,"modelMatrix",Xe.matrixWorld),ot.isShaderMaterial||ot.isRawShaderMaterial){const vs=ot.uniformsGroups;for(let lo=0,co=vs.length;lo<co;lo++){const Eu=vs[lo];Wt.update(Eu,Ws),Wt.bind(Eu,Ws)}}return Ws}function Bh(ce,We){ce.ambientLightColor.needsUpdate=We,ce.lightProbe.needsUpdate=We,ce.directionalLights.needsUpdate=We,ce.directionalLightShadows.needsUpdate=We,ce.pointLights.needsUpdate=We,ce.pointLightShadows.needsUpdate=We,ce.spotLights.needsUpdate=We,ce.spotLightShadows.needsUpdate=We,ce.rectAreaLights.needsUpdate=We,ce.hemisphereLights.needsUpdate=We}function Cu(ce){return ce.isMeshLambertMaterial||ce.isMeshToonMaterial||ce.isMeshPhongMaterial||ce.isMeshStandardMaterial||ce.isShadowMaterial||ce.isShaderMaterial&&ce.lights===!0}this.setTexture2D=(function(){var ce=!1;return function(st,ot){st&&st.isWebGLRenderTarget&&(ce||(console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),ce=!0),st=st.texture),Ie.setTexture2D(st,ot)}})(),this.getActiveCubeFace=function(){return ee},this.getActiveMipmapLevel=function(){return re},this.getRenderTarget=function(){return Y},this.setRenderTargetTextures=function(ce,We,st){Ae.get(ce.texture).__webglTexture=We,Ae.get(ce.depthTexture).__webglTexture=st;const ot=Ae.get(ce);ot.__hasExternalTextures=!0,ot.__autoAllocateDepthBuffer=st===void 0,!ot.__autoAllocateDepthBuffer&&(!Y||!Y.isWebGLMultiviewRenderTarget)&&Ee.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),ot.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(ce,We){const st=Ae.get(ce);st.__webglFramebuffer=We,st.__useDefaultFramebuffer=We===void 0};const Lo=ve.createFramebuffer();this.setRenderTarget=function(ce,We=0,st=0){ce===null&&this.xr.isPresenting&&(ce=this.xr.getRenderTarget()),Y=ce,ee=We,re=st;let ot=!0,Xe=null,Nt=!1,sn=!1;if(ce){const ln=Ae.get(ce);if(ln.__useDefaultFramebuffer!==void 0)Z.bindFramebuffer(ve.FRAMEBUFFER,null),ot=!1;else if(ln.__webglFramebuffer===void 0)Ie.setupRenderTarget(ce);else if(ln.__hasExternalTextures)Ie.rebindTextures(ce,Ae.get(ce.texture).__webglTexture,Ae.get(ce.depthTexture).__webglTexture);else if(ce.depthBuffer){const Mn=ce.depthTexture;if(ln.__boundDepthTexture!==Mn){if(Mn!==null&&Ae.has(Mn)&&(ce.width!==Mn.image.width||ce.height!==Mn.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");Ie.setupDepthRenderbuffer(ce)}}const Dn=ce.texture;(Dn.isData3DTexture||Dn.isDataArrayTexture||Dn.isCompressedArrayTexture)&&(sn=!0);const Un=Ae.get(ce).__webglFramebuffer;ce.isWebGLCubeRenderTarget?(Array.isArray(Un[We])?Xe=Un[We][st]:Xe=Un[We],Nt=!0):ce.samples>0&&Ie.useMultisampledRTT(ce)===!1?Xe=Ae.get(ce).__webglMultisampledFramebuffer:Array.isArray(Un)?Xe=Un[st]:Xe=Un,Re.copy(ce.viewport),_e.copy(ce.scissor),Pe=ce.scissorTest}else Re.copy(Ne).multiplyScalar(Je).floor(),_e.copy(gt).multiplyScalar(Je).floor(),Pe=bt;if(st!==0&&(Xe=Lo),Z.bindFramebuffer(ve.FRAMEBUFFER,Xe)&&ot&&Z.drawBuffers(ce,Xe),Z.viewport(Re),Z.scissor(_e),Z.setScissorTest(Pe),Nt){const ln=Ae.get(ce.texture);ve.framebufferTexture2D(ve.FRAMEBUFFER,ve.COLOR_ATTACHMENT0,ve.TEXTURE_CUBE_MAP_POSITIVE_X+We,ln.__webglTexture,st)}else if(sn){const ln=Ae.get(ce.texture),Dn=We;ve.framebufferTextureLayer(ve.FRAMEBUFFER,ve.COLOR_ATTACHMENT0,ln.__webglTexture,st,Dn)}else if(ce!==null&&st!==0){const ln=Ae.get(ce.texture);ve.framebufferTexture2D(ve.FRAMEBUFFER,ve.COLOR_ATTACHMENT0,ve.TEXTURE_2D,ln.__webglTexture,st)}ie=-1},this.readRenderTargetPixels=function(ce,We,st,ot,Xe,Nt,sn){if(!(ce&&ce.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let un=Ae.get(ce).__webglFramebuffer;if(ce.isWebGLCubeRenderTarget&&sn!==void 0&&(un=un[sn]),un){Z.bindFramebuffer(ve.FRAMEBUFFER,un);try{const ln=ce.texture,Dn=ln.format,Un=ln.type;if(!Q.textureFormatReadable(Dn)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!Q.textureTypeReadable(Un)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}We>=0&&We<=ce.width-ot&&st>=0&&st<=ce.height-Xe&&ve.readPixels(We,st,ot,Xe,ke.convert(Dn),ke.convert(Un),Nt)}finally{const ln=Y!==null?Ae.get(Y).__webglFramebuffer:null;Z.bindFramebuffer(ve.FRAMEBUFFER,ln)}}},this.readRenderTargetPixelsAsync=async function(ce,We,st,ot,Xe,Nt,sn){if(!(ce&&ce.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let un=Ae.get(ce).__webglFramebuffer;if(ce.isWebGLCubeRenderTarget&&sn!==void 0&&(un=un[sn]),un){const ln=ce.texture,Dn=ln.format,Un=ln.type;if(!Q.textureFormatReadable(Dn))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!Q.textureTypeReadable(Un))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(We>=0&&We<=ce.width-ot&&st>=0&&st<=ce.height-Xe){Z.bindFramebuffer(ve.FRAMEBUFFER,un);const Mn=ve.createBuffer();ve.bindBuffer(ve.PIXEL_PACK_BUFFER,Mn),ve.bufferData(ve.PIXEL_PACK_BUFFER,Nt.byteLength,ve.STREAM_READ),ve.readPixels(We,st,ot,Xe,ke.convert(Dn),ke.convert(Un),0);const Ai=Y!==null?Ae.get(Y).__webglFramebuffer:null;Z.bindFramebuffer(ve.FRAMEBUFFER,Ai);const Yn=ve.fenceSync(ve.SYNC_GPU_COMMANDS_COMPLETE,0);return ve.flush(),await Mce(ve,Yn,4),ve.bindBuffer(ve.PIXEL_PACK_BUFFER,Mn),ve.getBufferSubData(ve.PIXEL_PACK_BUFFER,0,Nt),ve.deleteBuffer(Mn),ve.deleteSync(Yn),Nt}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(ce,We=null,st=0){ce.isTexture!==!0&&(V0("WebGLRenderer: copyFramebufferToTexture function signature has changed."),We=arguments[0]||null,ce=arguments[1]);const ot=Math.pow(2,-st),Xe=Math.floor(ce.image.width*ot),Nt=Math.floor(ce.image.height*ot),sn=We!==null?We.x:0,un=We!==null?We.y:0;Ie.setTexture2D(ce,0),ve.copyTexSubImage2D(ve.TEXTURE_2D,st,0,0,sn,un,Xe,Nt),Z.unbindTexture()};const il=ve.createFramebuffer(),Lm=ve.createFramebuffer();this.copyTextureToTexture=function(ce,We,st=null,ot=null,Xe=0,Nt=null){ce.isTexture!==!0&&(V0("WebGLRenderer: copyTextureToTexture function signature has changed."),ot=arguments[0]||null,ce=arguments[1],We=arguments[2],Nt=arguments[3]||0,st=null),Nt===null&&(Xe!==0?(V0("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),Nt=Xe,Xe=0):Nt=0);let sn,un,ln,Dn,Un,Mn,Ai,Yn,ys;const ss=ce.isCompressedTexture?ce.mipmaps[Nt]:ce.image;if(st!==null)sn=st.max.x-st.min.x,un=st.max.y-st.min.y,ln=st.isBox3?st.max.z-st.min.z:1,Dn=st.min.x,Un=st.min.y,Mn=st.isBox3?st.min.z:0;else{const Cs=Math.pow(2,-Xe);sn=Math.floor(ss.width*Cs),un=Math.floor(ss.height*Cs),ce.isDataArrayTexture?ln=ss.depth:ce.isData3DTexture?ln=Math.floor(ss.depth*Cs):ln=1,Dn=0,Un=0,Mn=0}ot!==null?(Ai=ot.x,Yn=ot.y,ys=ot.z):(Ai=0,Yn=0,ys=0);const ei=ke.convert(We.format),Fs=ke.convert(We.type);let xn;We.isData3DTexture?(Ie.setTexture3D(We,0),xn=ve.TEXTURE_3D):We.isDataArrayTexture||We.isCompressedArrayTexture?(Ie.setTexture2DArray(We,0),xn=ve.TEXTURE_2D_ARRAY):(Ie.setTexture2D(We,0),xn=ve.TEXTURE_2D),ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL,We.flipY),ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL,We.premultiplyAlpha),ve.pixelStorei(ve.UNPACK_ALIGNMENT,We.unpackAlignment);const Ec=ve.getParameter(ve.UNPACK_ROW_LENGTH),Qn=ve.getParameter(ve.UNPACK_IMAGE_HEIGHT),Ws=ve.getParameter(ve.UNPACK_SKIP_PIXELS),Sr=ve.getParameter(ve.UNPACK_SKIP_ROWS),Ia=ve.getParameter(ve.UNPACK_SKIP_IMAGES);ve.pixelStorei(ve.UNPACK_ROW_LENGTH,ss.width),ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT,ss.height),ve.pixelStorei(ve.UNPACK_SKIP_PIXELS,Dn),ve.pixelStorei(ve.UNPACK_SKIP_ROWS,Un),ve.pixelStorei(ve.UNPACK_SKIP_IMAGES,Mn);const Xr=ce.isDataArrayTexture||ce.isData3DTexture,Si=We.isDataArrayTexture||We.isData3DTexture;if(ce.isDepthTexture){const Cs=Ae.get(ce),sr=Ae.get(We),vs=Ae.get(Cs.__renderTarget),lo=Ae.get(sr.__renderTarget);Z.bindFramebuffer(ve.READ_FRAMEBUFFER,vs.__webglFramebuffer),Z.bindFramebuffer(ve.DRAW_FRAMEBUFFER,lo.__webglFramebuffer);for(let co=0;co<ln;co++)Xr&&(ve.framebufferTextureLayer(ve.READ_FRAMEBUFFER,ve.COLOR_ATTACHMENT0,Ae.get(ce).__webglTexture,Xe,Mn+co),ve.framebufferTextureLayer(ve.DRAW_FRAMEBUFFER,ve.COLOR_ATTACHMENT0,Ae.get(We).__webglTexture,Nt,ys+co)),ve.blitFramebuffer(Dn,Un,sn,un,Ai,Yn,sn,un,ve.DEPTH_BUFFER_BIT,ve.NEAREST);Z.bindFramebuffer(ve.READ_FRAMEBUFFER,null),Z.bindFramebuffer(ve.DRAW_FRAMEBUFFER,null)}else if(Xe!==0||ce.isRenderTargetTexture||Ae.has(ce)){const Cs=Ae.get(ce),sr=Ae.get(We);Z.bindFramebuffer(ve.READ_FRAMEBUFFER,il),Z.bindFramebuffer(ve.DRAW_FRAMEBUFFER,Lm);for(let vs=0;vs<ln;vs++)Xr?ve.framebufferTextureLayer(ve.READ_FRAMEBUFFER,ve.COLOR_ATTACHMENT0,Cs.__webglTexture,Xe,Mn+vs):ve.framebufferTexture2D(ve.READ_FRAMEBUFFER,ve.COLOR_ATTACHMENT0,ve.TEXTURE_2D,Cs.__webglTexture,Xe),Si?ve.framebufferTextureLayer(ve.DRAW_FRAMEBUFFER,ve.COLOR_ATTACHMENT0,sr.__webglTexture,Nt,ys+vs):ve.framebufferTexture2D(ve.DRAW_FRAMEBUFFER,ve.COLOR_ATTACHMENT0,ve.TEXTURE_2D,sr.__webglTexture,Nt),Xe!==0?ve.blitFramebuffer(Dn,Un,sn,un,Ai,Yn,sn,un,ve.COLOR_BUFFER_BIT,ve.NEAREST):Si?ve.copyTexSubImage3D(xn,Nt,Ai,Yn,ys+vs,Dn,Un,sn,un):ve.copyTexSubImage2D(xn,Nt,Ai,Yn,Dn,Un,sn,un);Z.bindFramebuffer(ve.READ_FRAMEBUFFER,null),Z.bindFramebuffer(ve.DRAW_FRAMEBUFFER,null)}else Si?ce.isDataTexture||ce.isData3DTexture?ve.texSubImage3D(xn,Nt,Ai,Yn,ys,sn,un,ln,ei,Fs,ss.data):We.isCompressedArrayTexture?ve.compressedTexSubImage3D(xn,Nt,Ai,Yn,ys,sn,un,ln,ei,ss.data):ve.texSubImage3D(xn,Nt,Ai,Yn,ys,sn,un,ln,ei,Fs,ss):ce.isDataTexture?ve.texSubImage2D(ve.TEXTURE_2D,Nt,Ai,Yn,sn,un,ei,Fs,ss.data):ce.isCompressedTexture?ve.compressedTexSubImage2D(ve.TEXTURE_2D,Nt,Ai,Yn,ss.width,ss.height,ei,ss.data):ve.texSubImage2D(ve.TEXTURE_2D,Nt,Ai,Yn,sn,un,ei,Fs,ss);ve.pixelStorei(ve.UNPACK_ROW_LENGTH,Ec),ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT,Qn),ve.pixelStorei(ve.UNPACK_SKIP_PIXELS,Ws),ve.pixelStorei(ve.UNPACK_SKIP_ROWS,Sr),ve.pixelStorei(ve.UNPACK_SKIP_IMAGES,Ia),Nt===0&&We.generateMipmaps&&ve.generateMipmap(xn),Z.unbindTexture()},this.copyTextureToTexture3D=function(ce,We,st=null,ot=null,Xe=0){return ce.isTexture!==!0&&(V0("WebGLRenderer: copyTextureToTexture3D function signature has changed."),st=arguments[0]||null,ot=arguments[1]||null,ce=arguments[2],We=arguments[3],Xe=arguments[4]||0),V0('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(ce,We,st,ot,Xe)},this.initRenderTarget=function(ce){Ae.get(ce).__webglFramebuffer===void 0&&Ie.setupRenderTarget(ce)},this.initTexture=function(ce){ce.isCubeTexture?Ie.setTextureCube(ce,0):ce.isData3DTexture?Ie.setTexture3D(ce,0):ce.isDataArrayTexture||ce.isCompressedArrayTexture?Ie.setTexture2DArray(ce,0):Ie.setTexture2D(ce,0),Z.unbindTexture()},this.resetState=function(){ee=0,re=0,Y=null,Z.reset(),wt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return gc}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const n=this.getContext();n.drawingBufferColorspace=zi._getDrawingBufferColorSpace(e),n.unpackColorSpace=zi._getUnpackColorSpace()}}const Wge=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:HP,AddEquation:Zd,AddOperation:PP,AdditiveAnimationBlendMode:rk,AdditiveBlending:eR,AgXToneMapping:QP,AlphaFormat:JR,AlwaysCompare:oz,AlwaysDepth:bE,AlwaysStencilFunc:sR,AmbientLight:tV,AnimationAction:hV,AnimationClip:Rv,AnimationLoader:ehe,AnimationMixer:_he,AnimationObjectGroup:The,AnimationUtils:Yue,ArcCurve:Iz,ArrayCamera:oV,ArrowHelper:Jhe,AttachedBindMode:iR,Audio:cV,AudioAnalyser:Ahe,AudioContext:Mk,AudioListener:phe,AudioLoader:hhe,AxesHelper:ede,BackSide:no,BasicDepthPacking:qP,BasicShadowMap:_le,BatchedMesh:wz,Bone:hk,BooleanKeyframeTrack:km,Box2:Uhe,Box3:io,Box3Helper:jhe,BoxGeometry:Rm,BoxHelper:Yhe,BufferAttribute:bs,BufferGeometry:gi,BufferGeometryLoader:aV,ByteType:YR,Cache:yh,Camera:M2,CameraHelper:$he,CanvasTexture:vue,CapsuleGeometry:D2,CatmullRomCurve3:Tz,CineonToneMapping:WP,CircleGeometry:F2,ClampToEdgeWrapping:Rl,Clock:lV,Color:pn,ColorKeyframeTrack:Sk,ColorManagement:zi,CompressedArrayTexture:bue,CompressedCubeTexture:yue,CompressedTexture:L2,CompressedTextureLoader:the,ConeGeometry:O2,ConstantAlphaFactor:OP,ConstantColorFactor:DP,Controls:nde,CubeCamera:pz,CubeReflectionMapping:_h,CubeRefractionMapping:qd,CubeTexture:Pv,CubeTextureLoader:nhe,CubeUVReflectionMapping:iA,CubicBezierCurve:mk,CubicBezierCurve3:Mz,CubicInterpolant:Kz,CullFaceBack:J_,CullFaceFront:yP,CullFaceFrontBack:Mle,CullFaceNone:bP,Curve:yc,CurvePath:Rz,CustomBlending:xP,CustomToneMapping:XP,CylinderGeometry:aA,Cylindrical:Ghe,Data3DTexture:I2,DataArrayTexture:Uv,DataTexture:bu,DataTextureLoader:ihe,DataUtils:Xce,DecrementStencilOp:Wle,DecrementWrapStencilOp:Xle,DefaultLoadingManager:Yz,DepthFormat:Yd,DepthStencilFormat:jd,DepthTexture:fk,DetachedBindMode:ZP,DirectionalLight:eV,DirectionalLightHelper:Zhe,DiscreteInterpolant:Zz,DodecahedronGeometry:G2,DoubleSide:mu,DstAlphaFactor:RP,DstColorFactor:BP,DynamicCopyUsage:ace,DynamicDrawUsage:ece,DynamicReadUsage:ice,EdgesGeometry:kz,EllipseCurve:N2,EqualCompare:iz,EqualDepth:vE,EqualStencilFunc:$le,EquirectangularReflectionMapping:pv,EquirectangularRefractionMapping:mv,Euler:el,EventDispatcher:xu,ExtrudeGeometry:P2,FileLoader:kh,Float16BufferAttribute:qce,Float32BufferAttribute:Tn,FloatType:qa,Fog:R2,FogExp2:_2,FramebufferTexture:Aue,FrontSide:Mh,Frustum:zv,GLBufferAttribute:Dhe,GLSL1:lce,GLSL3:rR,GreaterCompare:sz,GreaterDepth:wE,GreaterEqualCompare:az,GreaterEqualDepth:xE,GreaterEqualStencilFunc:Jle,GreaterStencilFunc:jle,GridHelper:Qhe,Group:Q0,HalfFloatType:sA,HemisphereLight:jz,HemisphereLightHelper:Xhe,IcosahedronGeometry:z2,ImageBitmapLoader:uhe,ImageLoader:kv,ImageUtils:uz,IncrementStencilOp:Vle,IncrementWrapStencilOp:Hle,InstancedBufferAttribute:tA,InstancedBufferGeometry:rV,InstancedInterleavedBuffer:Nhe,InstancedMesh:xz,Int16BufferAttribute:Yce,Int32BufferAttribute:jce,Int8BufferAttribute:Kce,IntType:b2,InterleavedBuffer:k2,InterleavedBufferAttribute:Mm,Interpolant:Xv,InterpolateDiscrete:bv,InterpolateLinear:YE,InterpolateSmooth:rE,InvertStencilOp:Qle,KeepStencilOp:mm,KeyframeTrack:vc,LOD:yz,LatheGeometry:Vv,Layers:T2,LessCompare:nz,LessDepth:yE,LessEqualCompare:ak,LessEqualDepth:Im,LessEqualStencilFunc:Yle,LessStencilFunc:Zle,Light:af,LightProbe:sV,Line:Jd,Line3:Phe,LineBasicMaterial:so,LineCurve:gk,LineCurve3:_z,LineDashedMaterial:Hz,LineLoop:Cz,LineSegments:wu,LinearFilter:Dr,LinearInterpolant:Ek,LinearMipMapLinearFilter:Lle,LinearMipMapNearestFilter:Ble,LinearMipmapLinearFilter:gu,LinearMipmapNearestFilter:iv,LinearSRGBColorSpace:Tm,LinearToneMapping:zP,LinearTransfer:vv,Loader:Ro,LoaderUtils:uR,LoadingManager:Ik,LoopOnce:$P,LoopPingPong:jP,LoopRepeat:YP,LuminanceAlphaFormat:nk,LuminanceFormat:tk,MOUSE:Ile,Material:Ca,MaterialLoader:$2,MathUtils:Ice,Matrix2:Bk,Matrix3:ii,Matrix4:Zn,MaxEquation:SP,Mesh:Er,MeshBasicMaterial:sf,MeshDepthMaterial:xk,MeshDistanceMaterial:wk,MeshLambertMaterial:Vz,MeshMatcapMaterial:Wz,MeshNormalMaterial:zz,MeshPhongMaterial:Uz,MeshPhysicalMaterial:Gz,MeshStandardMaterial:vk,MeshToonMaterial:Pz,MinEquation:EP,MirroredRepeatWrapping:Av,MixOperation:UP,MultiplyBlending:nR,MultiplyOperation:Ov,NearestFilter:ia,NearestMipMapLinearFilter:kle,NearestMipMapNearestFilter:Rle,NearestMipmapLinearFilter:H0,NearestMipmapNearestFilter:$R,NeutralToneMapping:KP,NeverCompare:tz,NeverDepth:AE,NeverStencilFunc:Kle,NoBlending:Ch,NoColorSpace:Ah,NoToneMapping:Eh,NormalAnimationBlendMode:E2,NormalBlending:wm,NotEqualCompare:rz,NotEqualDepth:CE,NotEqualStencilFunc:qle,NumberKeyframeTrack:Mv,Object3D:Qi,ObjectLoader:lhe,ObjectSpaceNormalMap:ez,OctahedronGeometry:Wv,OneFactor:TP,OneMinusConstantAlphaFactor:GP,OneMinusConstantColorFactor:FP,OneMinusDstAlphaFactor:kP,OneMinusDstColorFactor:LP,OneMinusSrcAlphaFactor:gE,OneMinusSrcColorFactor:_P,OrthographicCamera:Z2,PCFShadowMap:ZR,PCFSoftShadowMap:vP,PMREMGenerator:fR,Path:Ev,PerspectiveCamera:ea,Plane:Qd,PlaneGeometry:oA,PlaneHelper:qhe,PointLight:Jz,PointLightHelper:Whe,Points:Ez,PointsMaterial:dk,PolarGridHelper:Khe,PolyhedronGeometry:rf,PositionalAudio:ghe,PropertyBinding:Hi,PropertyMixer:uV,QuadraticBezierCurve:Ak,QuadraticBezierCurve3:bk,Quaternion:_o,QuaternionKeyframeTrack:Qv,QuaternionLinearInterpolant:$z,RED_GREEN_RGTC2_Format:ZE,RED_RGTC1_Format:sk,REVISION:g2,RGBADepthPacking:JP,RGBAFormat:to,RGBAIntegerFormat:C2,RGBA_ASTC_10x10_Format:VE,RGBA_ASTC_10x5_Format:UE,RGBA_ASTC_10x6_Format:PE,RGBA_ASTC_10x8_Format:zE,RGBA_ASTC_12x10_Format:WE,RGBA_ASTC_12x12_Format:HE,RGBA_ASTC_4x4_Format:kE,RGBA_ASTC_5x4_Format:BE,RGBA_ASTC_5x5_Format:LE,RGBA_ASTC_6x5_Format:NE,RGBA_ASTC_6x6_Format:DE,RGBA_ASTC_8x5_Format:FE,RGBA_ASTC_8x6_Format:OE,RGBA_ASTC_8x8_Format:GE,RGBA_BPTC_Format:lv,RGBA_ETC2_EAC_Format:RE,RGBA_PVRTC_2BPPV1_Format:TE,RGBA_PVRTC_4BPPV1_Format:IE,RGBA_S3TC_DXT1_Format:rv,RGBA_S3TC_DXT3_Format:av,RGBA_S3TC_DXT5_Format:ov,RGBDepthPacking:Gle,RGBFormat:ek,RGBIntegerFormat:Nle,RGB_BPTC_SIGNED_Format:XE,RGB_BPTC_UNSIGNED_Format:QE,RGB_ETC1_Format:ME,RGB_ETC2_Format:_E,RGB_PVRTC_2BPPV1_Format:SE,RGB_PVRTC_4BPPV1_Format:EE,RGB_S3TC_DXT1_Format:sv,RGDepthPacking:Ule,RGFormat:ik,RGIntegerFormat:w2,RawShaderMaterial:Oz,Ray:rA,Raycaster:Fhe,RectAreaLight:nV,RedFormat:x2,RedIntegerFormat:Gv,ReinhardToneMapping:VP,RenderTarget:S2,RenderTarget3D:Rhe,RenderTargetArray:khe,RepeatWrapping:gv,ReplaceStencilOp:zle,ReverseSubtractEquation:CP,RingGeometry:V2,SIGNED_RED_GREEN_RGTC2_Format:$E,SIGNED_RED_RGTC1_Format:KE,SRGBColorSpace:Io,SRGBTransfer:hs,Scene:gz,ShaderChunk:mi,ShaderLib:pc,ShaderMaterial:bc,ShadowMaterial:Fz,Shape:Em,ShapeGeometry:W2,ShapePath:tde,ShapeUtils:yu,ShortType:jR,Skeleton:B2,SkeletonHelper:Vhe,SkinnedMesh:vz,Source:vm,Sphere:wa,SphereGeometry:Hv,Spherical:Ohe,SphericalHarmonics3:iV,SplineCurve:yk,SpotLight:qz,SpotLightHelper:zhe,Sprite:bz,SpriteMaterial:uk,SrcAlphaFactor:mE,SrcAlphaSaturateFactor:NP,SrcColorFactor:MP,StaticCopyUsage:rce,StaticDrawUsage:xv,StaticReadUsage:nce,StereoCamera:dhe,StreamCopyUsage:oce,StreamDrawUsage:tce,StreamReadUsage:sce,StringKeyframeTrack:Bm,SubtractEquation:wP,SubtractiveBlending:tR,TOUCH:Tle,TangentSpaceNormalMap:nf,TetrahedronGeometry:H2,Texture:nr,TextureLoader:she,TextureUtils:ode,TimestampQuery:cce,TorusGeometry:X2,TorusKnotGeometry:Q2,Triangle:To,TriangleFanDrawMode:Ole,TriangleStripDrawMode:Fle,TrianglesDrawMode:Dle,TubeGeometry:K2,UVMapping:A2,Uint16BufferAttribute:lk,Uint32BufferAttribute:ck,Uint8BufferAttribute:Zce,Uint8ClampedBufferAttribute:$ce,Uniform:kk,UniformsGroup:Lhe,UniformsLib:an,UniformsUtils:fz,UnsignedByteType:vu,UnsignedInt248Type:$d,UnsignedInt5999Type:qR,UnsignedIntType:Rh,UnsignedShort4444Type:y2,UnsignedShort5551Type:v2,UnsignedShortType:q0,VSMShadowMap:fu,Vector2:Dt,Vector3:be,Vector4:Xi,VectorKeyframeTrack:_v,VideoFrameTexture:gue,VideoTexture:Sz,WebGL3DRenderTarget:Dce,WebGLArrayRenderTarget:Nce,WebGLCoordinateSystem:gc,WebGLCubeRenderTarget:mz,WebGLRenderTarget:Ac,WebGLRenderer:Vge,WebGLUtils:bV,WebGPUCoordinateSystem:wv,WebXRController:aE,WireframeGeometry:Dz,WrapAroundEnding:yv,ZeroCurvatureEnding:bm,ZeroFactor:IP,ZeroSlopeEnding:ym,ZeroStencilOp:Ple,createCanvasElement:cz},Symbol.toStringTag,{value:"Module"}));var Hge={},vV={8167:r=>{var e=Object.prototype.toString;r.exports=function(n){return n.BYTES_PER_ELEMENT&&e.call(n.buffer)==="[object ArrayBuffer]"||Array.isArray(n)}},5734:r=>{r.exports=function(e,n){return typeof e=="number"?e:typeof n=="number"?n:0}},7961:(r,e)=>{e.byteLength=function(w){var I=b(w),E=I[0],R=I[1];return 3*(E+R)/4-R},e.toByteArray=function(w){var I,E,R=b(w),k=R[0],G=R[1],N=new c((function(W,H,K){return 3*(H+K)/4-K})(0,k,G)),O=0,D=G>0?k-4:k;for(E=0;E<D;E+=4)I=a[w.charCodeAt(E)]<<18|a[w.charCodeAt(E+1)]<<12|a[w.charCodeAt(E+2)]<<6|a[w.charCodeAt(E+3)],N[O++]=I>>16&255,N[O++]=I>>8&255,N[O++]=255&I;return G===2&&(I=a[w.charCodeAt(E)]<<2|a[w.charCodeAt(E+1)]>>4,N[O++]=255&I),G===1&&(I=a[w.charCodeAt(E)]<<10|a[w.charCodeAt(E+1)]<<4|a[w.charCodeAt(E+2)]>>2,N[O++]=I>>8&255,N[O++]=255&I),N},e.fromByteArray=function(w){for(var I,E=w.length,R=E%3,k=[],G=16383,N=0,O=E-R;N<O;N+=G)k.push(y(w,N,N+G>O?O:N+G));return R===1?(I=w[E-1],k.push(n[I>>2]+n[I<<4&63]+"==")):R===2&&(I=(w[E-2]<<8)+w[E-1],k.push(n[I>>10]+n[I>>4&63]+n[I<<2&63]+"=")),k.join("")};for(var n=[],a=[],c=typeof Uint8Array<"u"?Uint8Array:Array,h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",p=0;p<64;++p)n[p]=h[p],a[h.charCodeAt(p)]=p;function b(w){var I=w.length;if(I%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var E=w.indexOf("=");return E===-1&&(E=I),[E,E===I?0:4-E%4]}function y(w,I,E){for(var R,k,G=[],N=I;N<E;N+=3)R=(w[N]<<16&16711680)+(w[N+1]<<8&65280)+(255&w[N+2]),G.push(n[(k=R)>>18&63]+n[k>>12&63]+n[k>>6&63]+n[63&k]);return G.join("")}a[45]=62,a[95]=63},911:(r,e,n)=>{var a=n(9922).hp;r.exports=function(c,h){if(a.isBuffer(c)&&a.isBuffer(h)){if(typeof c.equals=="function")return c.equals(h);if(c.length!==h.length)return!1;for(var p=0;p<c.length;p++)if(c[p]!==h[p])return!1;return!0}}},9922:(r,e,n)=>{const a=n(7961),c=n(1024),h=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;e.hp=y,e.IS=50;const p=2147483647;function b(Q){if(Q>p)throw new RangeError('The value "'+Q+'" is invalid for option "size"');const Z=new Uint8Array(Q);return Object.setPrototypeOf(Z,y.prototype),Z}function y(Q,Z,ae){if(typeof Q=="number"){if(typeof Z=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return E(Q)}return w(Q,Z,ae)}function w(Q,Z,ae){if(typeof Q=="string")return(function(Ze,At){if(typeof At=="string"&&At!==""||(At="utf8"),!y.isEncoding(At))throw new TypeError("Unknown encoding: "+At);const dn=0|N(Ze,At);let ge=b(dn);const se=ge.write(Ze,At);return se!==dn&&(ge=ge.slice(0,se)),ge})(Q,Z);if(ArrayBuffer.isView(Q))return(function(Ze){if(Mt(Ze,Uint8Array)){const At=new Uint8Array(Ze);return k(At.buffer,At.byteOffset,At.byteLength)}return R(Ze)})(Q);if(Q==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof Q);if(Mt(Q,ArrayBuffer)||Q&&Mt(Q.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Mt(Q,SharedArrayBuffer)||Q&&Mt(Q.buffer,SharedArrayBuffer)))return k(Q,Z,ae);if(typeof Q=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const Ae=Q.valueOf&&Q.valueOf();if(Ae!=null&&Ae!==Q)return y.from(Ae,Z,ae);const Ie=(function(Ze){if(y.isBuffer(Ze)){const At=0|G(Ze.length),dn=b(At);return dn.length===0||Ze.copy(dn,0,0,At),dn}return Ze.length!==void 0?typeof Ze.length!="number"||Bt(Ze.length)?b(0):R(Ze):Ze.type==="Buffer"&&Array.isArray(Ze.data)?R(Ze.data):void 0})(Q);if(Ie)return Ie;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof Q[Symbol.toPrimitive]=="function")return y.from(Q[Symbol.toPrimitive]("string"),Z,ae);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof Q)}function I(Q){if(typeof Q!="number")throw new TypeError('"size" argument must be of type number');if(Q<0)throw new RangeError('The value "'+Q+'" is invalid for option "size"')}function E(Q){return I(Q),b(Q<0?0:0|G(Q))}function R(Q){const Z=Q.length<0?0:0|G(Q.length),ae=b(Z);for(let Ae=0;Ae<Z;Ae+=1)ae[Ae]=255&Q[Ae];return ae}function k(Q,Z,ae){if(Z<0||Q.byteLength<Z)throw new RangeError('"offset" is outside of buffer bounds');if(Q.byteLength<Z+(ae||0))throw new RangeError('"length" is outside of buffer bounds');let Ae;return Ae=Z===void 0&&ae===void 0?new Uint8Array(Q):ae===void 0?new Uint8Array(Q,Z):new Uint8Array(Q,Z,ae),Object.setPrototypeOf(Ae,y.prototype),Ae}function G(Q){if(Q>=p)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+p.toString(16)+" bytes");return 0|Q}function N(Q,Z){if(y.isBuffer(Q))return Q.length;if(ArrayBuffer.isView(Q)||Mt(Q,ArrayBuffer))return Q.byteLength;if(typeof Q!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof Q);const ae=Q.length,Ae=arguments.length>2&&arguments[2]===!0;if(!Ae&&ae===0)return 0;let Ie=!1;for(;;)switch(Z){case"ascii":case"latin1":case"binary":return ae;case"utf8":case"utf-8":return Ot(Q).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*ae;case"hex":return ae>>>1;case"base64":return on(Q).length;default:if(Ie)return Ae?-1:Ot(Q).length;Z=(""+Z).toLowerCase(),Ie=!0}}function O(Q,Z,ae){let Ae=!1;if((Z===void 0||Z<0)&&(Z=0),Z>this.length||((ae===void 0||ae>this.length)&&(ae=this.length),ae<=0)||(ae>>>=0)<=(Z>>>=0))return"";for(Q||(Q="utf8");;)switch(Q){case"hex":return Pe(this,Z,ae);case"utf8":case"utf-8":return ie(this,Z,ae);case"ascii":return Re(this,Z,ae);case"latin1":case"binary":return _e(this,Z,ae);case"base64":return Y(this,Z,ae);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return rt(this,Z,ae);default:if(Ae)throw new TypeError("Unknown encoding: "+Q);Q=(Q+"").toLowerCase(),Ae=!0}}function D(Q,Z,ae){const Ae=Q[Z];Q[Z]=Q[ae],Q[ae]=Ae}function W(Q,Z,ae,Ae,Ie){if(Q.length===0)return-1;if(typeof ae=="string"?(Ae=ae,ae=0):ae>2147483647?ae=2147483647:ae<-2147483648&&(ae=-2147483648),Bt(ae=+ae)&&(ae=Ie?0:Q.length-1),ae<0&&(ae=Q.length+ae),ae>=Q.length){if(Ie)return-1;ae=Q.length-1}else if(ae<0){if(!Ie)return-1;ae=0}if(typeof Z=="string"&&(Z=y.from(Z,Ae)),y.isBuffer(Z))return Z.length===0?-1:H(Q,Z,ae,Ae,Ie);if(typeof Z=="number")return Z&=255,typeof Uint8Array.prototype.indexOf=="function"?Ie?Uint8Array.prototype.indexOf.call(Q,Z,ae):Uint8Array.prototype.lastIndexOf.call(Q,Z,ae):H(Q,[Z],ae,Ae,Ie);throw new TypeError("val must be string, number or Buffer")}function H(Q,Z,ae,Ae,Ie){let Ze,At=1,dn=Q.length,ge=Z.length;if(Ae!==void 0&&((Ae=String(Ae).toLowerCase())==="ucs2"||Ae==="ucs-2"||Ae==="utf16le"||Ae==="utf-16le")){if(Q.length<2||Z.length<2)return-1;At=2,dn/=2,ge/=2,ae/=2}function se(Ge,ut){return At===1?Ge[ut]:Ge.readUInt16BE(ut*At)}if(Ie){let Ge=-1;for(Ze=ae;Ze<dn;Ze++)if(se(Q,Ze)===se(Z,Ge===-1?0:Ze-Ge)){if(Ge===-1&&(Ge=Ze),Ze-Ge+1===ge)return Ge*At}else Ge!==-1&&(Ze-=Ze-Ge),Ge=-1}else for(ae+ge>dn&&(ae=dn-ge),Ze=ae;Ze>=0;Ze--){let Ge=!0;for(let ut=0;ut<ge;ut++)if(se(Q,Ze+ut)!==se(Z,ut)){Ge=!1;break}if(Ge)return Ze}return-1}function K(Q,Z,ae,Ae){ae=Number(ae)||0;const Ie=Q.length-ae;Ae?(Ae=Number(Ae))>Ie&&(Ae=Ie):Ae=Ie;const Ze=Z.length;let At;for(Ae>Ze/2&&(Ae=Ze/2),At=0;At<Ae;++At){const dn=parseInt(Z.substr(2*At,2),16);if(Bt(dn))return At;Q[ae+At]=dn}return At}function j(Q,Z,ae,Ae){return vt(Ot(Z,Q.length-ae),Q,ae,Ae)}function J(Q,Z,ae,Ae){return vt((function(Ie){const Ze=[];for(let At=0;At<Ie.length;++At)Ze.push(255&Ie.charCodeAt(At));return Ze})(Z),Q,ae,Ae)}function ee(Q,Z,ae,Ae){return vt(on(Z),Q,ae,Ae)}function re(Q,Z,ae,Ae){return vt((function(Ie,Ze){let At,dn,ge;const se=[];for(let Ge=0;Ge<Ie.length&&!((Ze-=2)<0);++Ge)At=Ie.charCodeAt(Ge),dn=At>>8,ge=At%256,se.push(ge),se.push(dn);return se})(Z,Q.length-ae),Q,ae,Ae)}function Y(Q,Z,ae){return Z===0&&ae===Q.length?a.fromByteArray(Q):a.fromByteArray(Q.slice(Z,ae))}function ie(Q,Z,ae){ae=Math.min(Q.length,ae);const Ae=[];let Ie=Z;for(;Ie<ae;){const Ze=Q[Ie];let At=null,dn=Ze>239?4:Ze>223?3:Ze>191?2:1;if(Ie+dn<=ae){let ge,se,Ge,ut;switch(dn){case 1:Ze<128&&(At=Ze);break;case 2:ge=Q[Ie+1],(192&ge)==128&&(ut=(31&Ze)<<6|63&ge,ut>127&&(At=ut));break;case 3:ge=Q[Ie+1],se=Q[Ie+2],(192&ge)==128&&(192&se)==128&&(ut=(15&Ze)<<12|(63&ge)<<6|63&se,ut>2047&&(ut<55296||ut>57343)&&(At=ut));break;case 4:ge=Q[Ie+1],se=Q[Ie+2],Ge=Q[Ie+3],(192&ge)==128&&(192&se)==128&&(192&Ge)==128&&(ut=(15&Ze)<<18|(63&ge)<<12|(63&se)<<6|63&Ge,ut>65535&&ut<1114112&&(At=ut))}}At===null?(At=65533,dn=1):At>65535&&(At-=65536,Ae.push(At>>>10&1023|55296),At=56320|1023&At),Ae.push(At),Ie+=dn}return(function(Ze){const At=Ze.length;if(At<=ue)return String.fromCharCode.apply(String,Ze);let dn="",ge=0;for(;ge<At;)dn+=String.fromCharCode.apply(String,Ze.slice(ge,ge+=ue));return dn})(Ae)}y.TYPED_ARRAY_SUPPORT=(function(){try{const Q=new Uint8Array(1),Z={foo:function(){return 42}};return Object.setPrototypeOf(Z,Uint8Array.prototype),Object.setPrototypeOf(Q,Z),Q.foo()===42}catch{return!1}})(),y.TYPED_ARRAY_SUPPORT||typeof console>"u"||typeof console.error!="function"||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(y.prototype,"parent",{enumerable:!0,get:function(){if(y.isBuffer(this))return this.buffer}}),Object.defineProperty(y.prototype,"offset",{enumerable:!0,get:function(){if(y.isBuffer(this))return this.byteOffset}}),y.poolSize=8192,y.from=function(Q,Z,ae){return w(Q,Z,ae)},Object.setPrototypeOf(y.prototype,Uint8Array.prototype),Object.setPrototypeOf(y,Uint8Array),y.alloc=function(Q,Z,ae){return(function(Ae,Ie,Ze){return I(Ae),Ae<=0?b(Ae):Ie!==void 0?typeof Ze=="string"?b(Ae).fill(Ie,Ze):b(Ae).fill(Ie):b(Ae)})(Q,Z,ae)},y.allocUnsafe=function(Q){return E(Q)},y.allocUnsafeSlow=function(Q){return E(Q)},y.isBuffer=function(Q){return Q!=null&&Q._isBuffer===!0&&Q!==y.prototype},y.compare=function(Q,Z){if(Mt(Q,Uint8Array)&&(Q=y.from(Q,Q.offset,Q.byteLength)),Mt(Z,Uint8Array)&&(Z=y.from(Z,Z.offset,Z.byteLength)),!y.isBuffer(Q)||!y.isBuffer(Z))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(Q===Z)return 0;let ae=Q.length,Ae=Z.length;for(let Ie=0,Ze=Math.min(ae,Ae);Ie<Ze;++Ie)if(Q[Ie]!==Z[Ie]){ae=Q[Ie],Ae=Z[Ie];break}return ae<Ae?-1:Ae<ae?1:0},y.isEncoding=function(Q){switch(String(Q).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},y.concat=function(Q,Z){if(!Array.isArray(Q))throw new TypeError('"list" argument must be an Array of Buffers');if(Q.length===0)return y.alloc(0);let ae;if(Z===void 0)for(Z=0,ae=0;ae<Q.length;++ae)Z+=Q[ae].length;const Ae=y.allocUnsafe(Z);let Ie=0;for(ae=0;ae<Q.length;++ae){let Ze=Q[ae];if(Mt(Ze,Uint8Array))Ie+Ze.length>Ae.length?(y.isBuffer(Ze)||(Ze=y.from(Ze)),Ze.copy(Ae,Ie)):Uint8Array.prototype.set.call(Ae,Ze,Ie);else{if(!y.isBuffer(Ze))throw new TypeError('"list" argument must be an Array of Buffers');Ze.copy(Ae,Ie)}Ie+=Ze.length}return Ae},y.byteLength=N,y.prototype._isBuffer=!0,y.prototype.swap16=function(){const Q=this.length;if(Q%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let Z=0;Z<Q;Z+=2)D(this,Z,Z+1);return this},y.prototype.swap32=function(){const Q=this.length;if(Q%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let Z=0;Z<Q;Z+=4)D(this,Z,Z+3),D(this,Z+1,Z+2);return this},y.prototype.swap64=function(){const Q=this.length;if(Q%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let Z=0;Z<Q;Z+=8)D(this,Z,Z+7),D(this,Z+1,Z+6),D(this,Z+2,Z+5),D(this,Z+3,Z+4);return this},y.prototype.toString=function(){const Q=this.length;return Q===0?"":arguments.length===0?ie(this,0,Q):O.apply(this,arguments)},y.prototype.toLocaleString=y.prototype.toString,y.prototype.equals=function(Q){if(!y.isBuffer(Q))throw new TypeError("Argument must be a Buffer");return this===Q||y.compare(this,Q)===0},y.prototype.inspect=function(){let Q="";const Z=e.IS;return Q=this.toString("hex",0,Z).replace(/(.{2})/g,"$1 ").trim(),this.length>Z&&(Q+=" ... "),"<Buffer "+Q+">"},h&&(y.prototype[h]=y.prototype.inspect),y.prototype.compare=function(Q,Z,ae,Ae,Ie){if(Mt(Q,Uint8Array)&&(Q=y.from(Q,Q.offset,Q.byteLength)),!y.isBuffer(Q))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof Q);if(Z===void 0&&(Z=0),ae===void 0&&(ae=Q?Q.length:0),Ae===void 0&&(Ae=0),Ie===void 0&&(Ie=this.length),Z<0||ae>Q.length||Ae<0||Ie>this.length)throw new RangeError("out of range index");if(Ae>=Ie&&Z>=ae)return 0;if(Ae>=Ie)return-1;if(Z>=ae)return 1;if(this===Q)return 0;let Ze=(Ie>>>=0)-(Ae>>>=0),At=(ae>>>=0)-(Z>>>=0);const dn=Math.min(Ze,At),ge=this.slice(Ae,Ie),se=Q.slice(Z,ae);for(let Ge=0;Ge<dn;++Ge)if(ge[Ge]!==se[Ge]){Ze=ge[Ge],At=se[Ge];break}return Ze<At?-1:At<Ze?1:0},y.prototype.includes=function(Q,Z,ae){return this.indexOf(Q,Z,ae)!==-1},y.prototype.indexOf=function(Q,Z,ae){return W(this,Q,Z,ae,!0)},y.prototype.lastIndexOf=function(Q,Z,ae){return W(this,Q,Z,ae,!1)},y.prototype.write=function(Q,Z,ae,Ae){if(Z===void 0)Ae="utf8",ae=this.length,Z=0;else if(ae===void 0&&typeof Z=="string")Ae=Z,ae=this.length,Z=0;else{if(!isFinite(Z))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");Z>>>=0,isFinite(ae)?(ae>>>=0,Ae===void 0&&(Ae="utf8")):(Ae=ae,ae=void 0)}const Ie=this.length-Z;if((ae===void 0||ae>Ie)&&(ae=Ie),Q.length>0&&(ae<0||Z<0)||Z>this.length)throw new RangeError("Attempt to write outside buffer bounds");Ae||(Ae="utf8");let Ze=!1;for(;;)switch(Ae){case"hex":return K(this,Q,Z,ae);case"utf8":case"utf-8":return j(this,Q,Z,ae);case"ascii":case"latin1":case"binary":return J(this,Q,Z,ae);case"base64":return ee(this,Q,Z,ae);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return re(this,Q,Z,ae);default:if(Ze)throw new TypeError("Unknown encoding: "+Ae);Ae=(""+Ae).toLowerCase(),Ze=!0}},y.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const ue=4096;function Re(Q,Z,ae){let Ae="";ae=Math.min(Q.length,ae);for(let Ie=Z;Ie<ae;++Ie)Ae+=String.fromCharCode(127&Q[Ie]);return Ae}function _e(Q,Z,ae){let Ae="";ae=Math.min(Q.length,ae);for(let Ie=Z;Ie<ae;++Ie)Ae+=String.fromCharCode(Q[Ie]);return Ae}function Pe(Q,Z,ae){const Ae=Q.length;(!Z||Z<0)&&(Z=0),(!ae||ae<0||ae>Ae)&&(ae=Ae);let Ie="";for(let Ze=Z;Ze<ae;++Ze)Ie+=ve[Q[Ze]];return Ie}function rt(Q,Z,ae){const Ae=Q.slice(Z,ae);let Ie="";for(let Ze=0;Ze<Ae.length-1;Ze+=2)Ie+=String.fromCharCode(Ae[Ze]+256*Ae[Ze+1]);return Ie}function de(Q,Z,ae){if(Q%1!=0||Q<0)throw new RangeError("offset is not uint");if(Q+Z>ae)throw new RangeError("Trying to access beyond buffer length")}function we(Q,Z,ae,Ae,Ie,Ze){if(!y.isBuffer(Q))throw new TypeError('"buffer" argument must be a Buffer instance');if(Z>Ie||Z<Ze)throw new RangeError('"value" argument is out of bounds');if(ae+Ae>Q.length)throw new RangeError("Index out of range")}function Le(Q,Z,ae,Ae,Ie){Tt(Z,Ae,Ie,Q,ae,7);let Ze=Number(Z&BigInt(4294967295));Q[ae++]=Ze,Ze>>=8,Q[ae++]=Ze,Ze>>=8,Q[ae++]=Ze,Ze>>=8,Q[ae++]=Ze;let At=Number(Z>>BigInt(32)&BigInt(4294967295));return Q[ae++]=At,At>>=8,Q[ae++]=At,At>>=8,Q[ae++]=At,At>>=8,Q[ae++]=At,ae}function Je(Q,Z,ae,Ae,Ie){Tt(Z,Ae,Ie,Q,ae,7);let Ze=Number(Z&BigInt(4294967295));Q[ae+7]=Ze,Ze>>=8,Q[ae+6]=Ze,Ze>>=8,Q[ae+5]=Ze,Ze>>=8,Q[ae+4]=Ze;let At=Number(Z>>BigInt(32)&BigInt(4294967295));return Q[ae+3]=At,At>>=8,Q[ae+2]=At,At>>=8,Q[ae+1]=At,At>>=8,Q[ae]=At,ae+8}function fe(Q,Z,ae,Ae,Ie,Ze){if(ae+Ae>Q.length)throw new RangeError("Index out of range");if(ae<0)throw new RangeError("Index out of range")}function Ve(Q,Z,ae,Ae,Ie){return Z=+Z,ae>>>=0,Ie||fe(Q,0,ae,4),c.write(Q,Z,ae,Ae,23,4),ae+4}function Ne(Q,Z,ae,Ae,Ie){return Z=+Z,ae>>>=0,Ie||fe(Q,0,ae,8),c.write(Q,Z,ae,Ae,52,8),ae+8}y.prototype.slice=function(Q,Z){const ae=this.length;(Q=~~Q)<0?(Q+=ae)<0&&(Q=0):Q>ae&&(Q=ae),(Z=Z===void 0?ae:~~Z)<0?(Z+=ae)<0&&(Z=0):Z>ae&&(Z=ae),Z<Q&&(Z=Q);const Ae=this.subarray(Q,Z);return Object.setPrototypeOf(Ae,y.prototype),Ae},y.prototype.readUintLE=y.prototype.readUIntLE=function(Q,Z,ae){Q>>>=0,Z>>>=0,ae||de(Q,Z,this.length);let Ae=this[Q],Ie=1,Ze=0;for(;++Ze<Z&&(Ie*=256);)Ae+=this[Q+Ze]*Ie;return Ae},y.prototype.readUintBE=y.prototype.readUIntBE=function(Q,Z,ae){Q>>>=0,Z>>>=0,ae||de(Q,Z,this.length);let Ae=this[Q+--Z],Ie=1;for(;Z>0&&(Ie*=256);)Ae+=this[Q+--Z]*Ie;return Ae},y.prototype.readUint8=y.prototype.readUInt8=function(Q,Z){return Q>>>=0,Z||de(Q,1,this.length),this[Q]},y.prototype.readUint16LE=y.prototype.readUInt16LE=function(Q,Z){return Q>>>=0,Z||de(Q,2,this.length),this[Q]|this[Q+1]<<8},y.prototype.readUint16BE=y.prototype.readUInt16BE=function(Q,Z){return Q>>>=0,Z||de(Q,2,this.length),this[Q]<<8|this[Q+1]},y.prototype.readUint32LE=y.prototype.readUInt32LE=function(Q,Z){return Q>>>=0,Z||de(Q,4,this.length),(this[Q]|this[Q+1]<<8|this[Q+2]<<16)+16777216*this[Q+3]},y.prototype.readUint32BE=y.prototype.readUInt32BE=function(Q,Z){return Q>>>=0,Z||de(Q,4,this.length),16777216*this[Q]+(this[Q+1]<<16|this[Q+2]<<8|this[Q+3])},y.prototype.readBigUInt64LE=Kt((function(Q){Vt(Q>>>=0,"offset");const Z=this[Q],ae=this[Q+7];Z!==void 0&&ae!==void 0||je(Q,this.length-8);const Ae=Z+256*this[++Q]+65536*this[++Q]+this[++Q]*2**24,Ie=this[++Q]+256*this[++Q]+65536*this[++Q]+ae*2**24;return BigInt(Ae)+(BigInt(Ie)<<BigInt(32))})),y.prototype.readBigUInt64BE=Kt((function(Q){Vt(Q>>>=0,"offset");const Z=this[Q],ae=this[Q+7];Z!==void 0&&ae!==void 0||je(Q,this.length-8);const Ae=Z*2**24+65536*this[++Q]+256*this[++Q]+this[++Q],Ie=this[++Q]*2**24+65536*this[++Q]+256*this[++Q]+ae;return(BigInt(Ae)<<BigInt(32))+BigInt(Ie)})),y.prototype.readIntLE=function(Q,Z,ae){Q>>>=0,Z>>>=0,ae||de(Q,Z,this.length);let Ae=this[Q],Ie=1,Ze=0;for(;++Ze<Z&&(Ie*=256);)Ae+=this[Q+Ze]*Ie;return Ie*=128,Ae>=Ie&&(Ae-=Math.pow(2,8*Z)),Ae},y.prototype.readIntBE=function(Q,Z,ae){Q>>>=0,Z>>>=0,ae||de(Q,Z,this.length);let Ae=Z,Ie=1,Ze=this[Q+--Ae];for(;Ae>0&&(Ie*=256);)Ze+=this[Q+--Ae]*Ie;return Ie*=128,Ze>=Ie&&(Ze-=Math.pow(2,8*Z)),Ze},y.prototype.readInt8=function(Q,Z){return Q>>>=0,Z||de(Q,1,this.length),128&this[Q]?-1*(255-this[Q]+1):this[Q]},y.prototype.readInt16LE=function(Q,Z){Q>>>=0,Z||de(Q,2,this.length);const ae=this[Q]|this[Q+1]<<8;return 32768&ae?4294901760|ae:ae},y.prototype.readInt16BE=function(Q,Z){Q>>>=0,Z||de(Q,2,this.length);const ae=this[Q+1]|this[Q]<<8;return 32768&ae?4294901760|ae:ae},y.prototype.readInt32LE=function(Q,Z){return Q>>>=0,Z||de(Q,4,this.length),this[Q]|this[Q+1]<<8|this[Q+2]<<16|this[Q+3]<<24},y.prototype.readInt32BE=function(Q,Z){return Q>>>=0,Z||de(Q,4,this.length),this[Q]<<24|this[Q+1]<<16|this[Q+2]<<8|this[Q+3]},y.prototype.readBigInt64LE=Kt((function(Q){Vt(Q>>>=0,"offset");const Z=this[Q],ae=this[Q+7];Z!==void 0&&ae!==void 0||je(Q,this.length-8);const Ae=this[Q+4]+256*this[Q+5]+65536*this[Q+6]+(ae<<24);return(BigInt(Ae)<<BigInt(32))+BigInt(Z+256*this[++Q]+65536*this[++Q]+this[++Q]*2**24)})),y.prototype.readBigInt64BE=Kt((function(Q){Vt(Q>>>=0,"offset");const Z=this[Q],ae=this[Q+7];Z!==void 0&&ae!==void 0||je(Q,this.length-8);const Ae=(Z<<24)+65536*this[++Q]+256*this[++Q]+this[++Q];return(BigInt(Ae)<<BigInt(32))+BigInt(this[++Q]*2**24+65536*this[++Q]+256*this[++Q]+ae)})),y.prototype.readFloatLE=function(Q,Z){return Q>>>=0,Z||de(Q,4,this.length),c.read(this,Q,!0,23,4)},y.prototype.readFloatBE=function(Q,Z){return Q>>>=0,Z||de(Q,4,this.length),c.read(this,Q,!1,23,4)},y.prototype.readDoubleLE=function(Q,Z){return Q>>>=0,Z||de(Q,8,this.length),c.read(this,Q,!0,52,8)},y.prototype.readDoubleBE=function(Q,Z){return Q>>>=0,Z||de(Q,8,this.length),c.read(this,Q,!1,52,8)},y.prototype.writeUintLE=y.prototype.writeUIntLE=function(Q,Z,ae,Ae){Q=+Q,Z>>>=0,ae>>>=0,Ae||we(this,Q,Z,ae,Math.pow(2,8*ae)-1,0);let Ie=1,Ze=0;for(this[Z]=255&Q;++Ze<ae&&(Ie*=256);)this[Z+Ze]=Q/Ie&255;return Z+ae},y.prototype.writeUintBE=y.prototype.writeUIntBE=function(Q,Z,ae,Ae){Q=+Q,Z>>>=0,ae>>>=0,Ae||we(this,Q,Z,ae,Math.pow(2,8*ae)-1,0);let Ie=ae-1,Ze=1;for(this[Z+Ie]=255&Q;--Ie>=0&&(Ze*=256);)this[Z+Ie]=Q/Ze&255;return Z+ae},y.prototype.writeUint8=y.prototype.writeUInt8=function(Q,Z,ae){return Q=+Q,Z>>>=0,ae||we(this,Q,Z,1,255,0),this[Z]=255&Q,Z+1},y.prototype.writeUint16LE=y.prototype.writeUInt16LE=function(Q,Z,ae){return Q=+Q,Z>>>=0,ae||we(this,Q,Z,2,65535,0),this[Z]=255&Q,this[Z+1]=Q>>>8,Z+2},y.prototype.writeUint16BE=y.prototype.writeUInt16BE=function(Q,Z,ae){return Q=+Q,Z>>>=0,ae||we(this,Q,Z,2,65535,0),this[Z]=Q>>>8,this[Z+1]=255&Q,Z+2},y.prototype.writeUint32LE=y.prototype.writeUInt32LE=function(Q,Z,ae){return Q=+Q,Z>>>=0,ae||we(this,Q,Z,4,4294967295,0),this[Z+3]=Q>>>24,this[Z+2]=Q>>>16,this[Z+1]=Q>>>8,this[Z]=255&Q,Z+4},y.prototype.writeUint32BE=y.prototype.writeUInt32BE=function(Q,Z,ae){return Q=+Q,Z>>>=0,ae||we(this,Q,Z,4,4294967295,0),this[Z]=Q>>>24,this[Z+1]=Q>>>16,this[Z+2]=Q>>>8,this[Z+3]=255&Q,Z+4},y.prototype.writeBigUInt64LE=Kt((function(Q,Z=0){return Le(this,Q,Z,BigInt(0),BigInt("0xffffffffffffffff"))})),y.prototype.writeBigUInt64BE=Kt((function(Q,Z=0){return Je(this,Q,Z,BigInt(0),BigInt("0xffffffffffffffff"))})),y.prototype.writeIntLE=function(Q,Z,ae,Ae){if(Q=+Q,Z>>>=0,!Ae){const dn=Math.pow(2,8*ae-1);we(this,Q,Z,ae,dn-1,-dn)}let Ie=0,Ze=1,At=0;for(this[Z]=255&Q;++Ie<ae&&(Ze*=256);)Q<0&&At===0&&this[Z+Ie-1]!==0&&(At=1),this[Z+Ie]=(Q/Ze|0)-At&255;return Z+ae},y.prototype.writeIntBE=function(Q,Z,ae,Ae){if(Q=+Q,Z>>>=0,!Ae){const dn=Math.pow(2,8*ae-1);we(this,Q,Z,ae,dn-1,-dn)}let Ie=ae-1,Ze=1,At=0;for(this[Z+Ie]=255&Q;--Ie>=0&&(Ze*=256);)Q<0&&At===0&&this[Z+Ie+1]!==0&&(At=1),this[Z+Ie]=(Q/Ze|0)-At&255;return Z+ae},y.prototype.writeInt8=function(Q,Z,ae){return Q=+Q,Z>>>=0,ae||we(this,Q,Z,1,127,-128),Q<0&&(Q=255+Q+1),this[Z]=255&Q,Z+1},y.prototype.writeInt16LE=function(Q,Z,ae){return Q=+Q,Z>>>=0,ae||we(this,Q,Z,2,32767,-32768),this[Z]=255&Q,this[Z+1]=Q>>>8,Z+2},y.prototype.writeInt16BE=function(Q,Z,ae){return Q=+Q,Z>>>=0,ae||we(this,Q,Z,2,32767,-32768),this[Z]=Q>>>8,this[Z+1]=255&Q,Z+2},y.prototype.writeInt32LE=function(Q,Z,ae){return Q=+Q,Z>>>=0,ae||we(this,Q,Z,4,2147483647,-2147483648),this[Z]=255&Q,this[Z+1]=Q>>>8,this[Z+2]=Q>>>16,this[Z+3]=Q>>>24,Z+4},y.prototype.writeInt32BE=function(Q,Z,ae){return Q=+Q,Z>>>=0,ae||we(this,Q,Z,4,2147483647,-2147483648),Q<0&&(Q=4294967295+Q+1),this[Z]=Q>>>24,this[Z+1]=Q>>>16,this[Z+2]=Q>>>8,this[Z+3]=255&Q,Z+4},y.prototype.writeBigInt64LE=Kt((function(Q,Z=0){return Le(this,Q,Z,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),y.prototype.writeBigInt64BE=Kt((function(Q,Z=0){return Je(this,Q,Z,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),y.prototype.writeFloatLE=function(Q,Z,ae){return Ve(this,Q,Z,!0,ae)},y.prototype.writeFloatBE=function(Q,Z,ae){return Ve(this,Q,Z,!1,ae)},y.prototype.writeDoubleLE=function(Q,Z,ae){return Ne(this,Q,Z,!0,ae)},y.prototype.writeDoubleBE=function(Q,Z,ae){return Ne(this,Q,Z,!1,ae)},y.prototype.copy=function(Q,Z,ae,Ae){if(!y.isBuffer(Q))throw new TypeError("argument should be a Buffer");if(ae||(ae=0),Ae||Ae===0||(Ae=this.length),Z>=Q.length&&(Z=Q.length),Z||(Z=0),Ae>0&&Ae<ae&&(Ae=ae),Ae===ae||Q.length===0||this.length===0)return 0;if(Z<0)throw new RangeError("targetStart out of bounds");if(ae<0||ae>=this.length)throw new RangeError("Index out of range");if(Ae<0)throw new RangeError("sourceEnd out of bounds");Ae>this.length&&(Ae=this.length),Q.length-Z<Ae-ae&&(Ae=Q.length-Z+ae);const Ie=Ae-ae;return this===Q&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(Z,ae,Ae):Uint8Array.prototype.set.call(Q,this.subarray(ae,Ae),Z),Ie},y.prototype.fill=function(Q,Z,ae,Ae){if(typeof Q=="string"){if(typeof Z=="string"?(Ae=Z,Z=0,ae=this.length):typeof ae=="string"&&(Ae=ae,ae=this.length),Ae!==void 0&&typeof Ae!="string")throw new TypeError("encoding must be a string");if(typeof Ae=="string"&&!y.isEncoding(Ae))throw new TypeError("Unknown encoding: "+Ae);if(Q.length===1){const Ze=Q.charCodeAt(0);(Ae==="utf8"&&Ze<128||Ae==="latin1")&&(Q=Ze)}}else typeof Q=="number"?Q&=255:typeof Q=="boolean"&&(Q=Number(Q));if(Z<0||this.length<Z||this.length<ae)throw new RangeError("Out of range index");if(ae<=Z)return this;let Ie;if(Z>>>=0,ae=ae===void 0?this.length:ae>>>0,Q||(Q=0),typeof Q=="number")for(Ie=Z;Ie<ae;++Ie)this[Ie]=Q;else{const Ze=y.isBuffer(Q)?Q:y.from(Q,Ae),At=Ze.length;if(At===0)throw new TypeError('The value "'+Q+'" is invalid for argument "value"');for(Ie=0;Ie<ae-Z;++Ie)this[Ie+Z]=Ze[Ie%At]}return this};const gt={};function bt(Q,Z,ae){gt[Q]=class extends ae{constructor(){super(),Object.defineProperty(this,"message",{value:Z.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${Q}]`,this.stack,delete this.name}get code(){return Q}set code(Ae){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:Ae,writable:!0})}toString(){return`${this.name} [${Q}]: ${this.message}`}}}function zt(Q){let Z="",ae=Q.length;const Ae=Q[0]==="-"?1:0;for(;ae>=Ae+4;ae-=3)Z=`_${Q.slice(ae-3,ae)}${Z}`;return`${Q.slice(0,ae)}${Z}`}function Tt(Q,Z,ae,Ae,Ie,Ze){if(Q>ae||Q<Z){const At=typeof Z=="bigint"?"n":"";let dn;throw dn=Z===0||Z===BigInt(0)?`>= 0${At} and < 2${At} ** ${8*(Ze+1)}${At}`:`>= -(2${At} ** ${8*(Ze+1)-1}${At}) and < 2 ** ${8*(Ze+1)-1}${At}`,new gt.ERR_OUT_OF_RANGE("value",dn,Q)}(function(At,dn,ge){Vt(dn,"offset"),At[dn]!==void 0&&At[dn+ge]!==void 0||je(dn,At.length-(ge+1))})(Ae,Ie,Ze)}function Vt(Q,Z){if(typeof Q!="number")throw new gt.ERR_INVALID_ARG_TYPE(Z,"number",Q)}function je(Q,Z,ae){throw Math.floor(Q)!==Q?(Vt(Q,ae),new gt.ERR_OUT_OF_RANGE("offset","an integer",Q)):Z<0?new gt.ERR_BUFFER_OUT_OF_BOUNDS:new gt.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${Z}`,Q)}bt("ERR_BUFFER_OUT_OF_BOUNDS",(function(Q){return Q?`${Q} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),bt("ERR_INVALID_ARG_TYPE",(function(Q,Z){return`The "${Q}" argument must be of type number. Received type ${typeof Z}`}),TypeError),bt("ERR_OUT_OF_RANGE",(function(Q,Z,ae){let Ae=`The value of "${Q}" is out of range.`,Ie=ae;return Number.isInteger(ae)&&Math.abs(ae)>2**32?Ie=zt(String(ae)):typeof ae=="bigint"&&(Ie=String(ae),(ae>BigInt(2)**BigInt(32)||ae<-(BigInt(2)**BigInt(32)))&&(Ie=zt(Ie)),Ie+="n"),Ae+=` It must be ${Z}. Received ${Ie}`,Ae}),RangeError);const _t=/[^+/0-9A-Za-z-_]/g;function Ot(Q,Z){let ae;Z=Z||1/0;const Ae=Q.length;let Ie=null;const Ze=[];for(let At=0;At<Ae;++At){if(ae=Q.charCodeAt(At),ae>55295&&ae<57344){if(!Ie){if(ae>56319){(Z-=3)>-1&&Ze.push(239,191,189);continue}if(At+1===Ae){(Z-=3)>-1&&Ze.push(239,191,189);continue}Ie=ae;continue}if(ae<56320){(Z-=3)>-1&&Ze.push(239,191,189),Ie=ae;continue}ae=65536+(Ie-55296<<10|ae-56320)}else Ie&&(Z-=3)>-1&&Ze.push(239,191,189);if(Ie=null,ae<128){if((Z-=1)<0)break;Ze.push(ae)}else if(ae<2048){if((Z-=2)<0)break;Ze.push(ae>>6|192,63&ae|128)}else if(ae<65536){if((Z-=3)<0)break;Ze.push(ae>>12|224,ae>>6&63|128,63&ae|128)}else{if(!(ae<1114112))throw new Error("Invalid code point");if((Z-=4)<0)break;Ze.push(ae>>18|240,ae>>12&63|128,ae>>6&63|128,63&ae|128)}}return Ze}function on(Q){return a.toByteArray((function(Z){if((Z=(Z=Z.split("=")[0]).trim().replace(_t,"")).length<2)return"";for(;Z.length%4!=0;)Z+="=";return Z})(Q))}function vt(Q,Z,ae,Ae){let Ie;for(Ie=0;Ie<Ae&&!(Ie+ae>=Z.length||Ie>=Q.length);++Ie)Z[Ie+ae]=Q[Ie];return Ie}function Mt(Q,Z){return Q instanceof Z||Q!=null&&Q.constructor!=null&&Q.constructor.name!=null&&Q.constructor.name===Z.name}function Bt(Q){return Q!=Q}const ve=(function(){const Q="0123456789abcdef",Z=new Array(256);for(let ae=0;ae<16;++ae){const Ae=16*ae;for(let Ie=0;Ie<16;++Ie)Z[Ae+Ie]=Q[ae]+Q[Ie]}return Z})();function Kt(Q){return typeof BigInt>"u"?Ee:Q}function Ee(){throw new Error("BigInt not supported")}},9089:r=>{r.exports=function(e){var n=[];return n.toString=function(){return this.map((function(a){var c="",h=a[5]!==void 0;return a[4]&&(c+="@supports (".concat(a[4],") {")),a[2]&&(c+="@media ".concat(a[2]," {")),h&&(c+="@layer".concat(a[5].length>0?" ".concat(a[5]):""," {")),c+=e(a),h&&(c+="}"),a[2]&&(c+="}"),a[4]&&(c+="}"),c})).join("")},n.i=function(a,c,h,p,b){typeof a=="string"&&(a=[[null,a,void 0]]);var y={};if(h)for(var w=0;w<this.length;w++){var I=this[w][0];I!=null&&(y[I]=!0)}for(var E=0;E<a.length;E++){var R=[].concat(a[E]);h&&y[R[0]]||(b!==void 0&&(R[5]===void 0||(R[1]="@layer".concat(R[5].length>0?" ".concat(R[5]):""," {").concat(R[1],"}")),R[5]=b),c&&(R[2]&&(R[1]="@media ".concat(R[2]," {").concat(R[1],"}")),R[2]=c),p&&(R[4]?(R[1]="@supports (".concat(R[4],") {").concat(R[1],"}"),R[4]=p):R[4]="".concat(p)),n.push(R))}},n}},6492:r=>{r.exports=function(e,n){return n||(n={}),e&&(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),n.hash&&(e+=n.hash),/["'() \t\n]|(%20)/.test(e)||n.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e)}},963:r=>{r.exports=function(e){var n=e[1],a=e[3];if(!a)return n;if(typeof btoa=="function"){var c=btoa(unescape(encodeURIComponent(JSON.stringify(a)))),h="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(c),p="/*# ".concat(h," */");return[n].concat([p]).join(`
`)}return[n].join(`
`)}},8878:(r,e,n)=>{e.formatArgs=function(c){if(c[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+c[0]+(this.useColors?"%c ":" ")+"+"+r.exports.humanize(this.diff),!this.useColors)return;const h="color: "+this.color;c.splice(1,0,h,"color: inherit");let p=0,b=0;c[0].replace(/%[a-zA-Z%]/g,(y=>{y!=="%%"&&(p++,y==="%c"&&(b=p))})),c.splice(b,0,h)},e.save=function(c){try{c?e.storage.setItem("debug",c):e.storage.removeItem("debug")}catch{}},e.load=function(){let c;try{c=e.storage.getItem("debug")}catch{}return!c&&typeof process<"u"&&"env"in process&&(c=Hge.DEBUG),c},e.useColors=function(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let c;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(c=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(c[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},e.storage=(function(){try{return localStorage}catch{}})(),e.destroy=(()=>{let c=!1;return()=>{c||(c=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],e.log=console.debug||console.log||(()=>{}),r.exports=n(8945)(e);const{formatters:a}=r.exports;a.j=function(c){try{return JSON.stringify(c)}catch(h){return"[UnexpectedJSONParseError]: "+h.message}}},8945:(r,e,n)=>{r.exports=function(a){function c(b){let y,w,I,E=null;function R(...k){if(!R.enabled)return;const G=R,N=Number(new Date),O=N-(y||N);G.diff=O,G.prev=y,G.curr=N,y=N,k[0]=c.coerce(k[0]),typeof k[0]!="string"&&k.unshift("%O");let D=0;k[0]=k[0].replace(/%([a-zA-Z%])/g,((W,H)=>{if(W==="%%")return"%";D++;const K=c.formatters[H];if(typeof K=="function"){const j=k[D];W=K.call(G,j),k.splice(D,1),D--}return W})),c.formatArgs.call(G,k),(G.log||c.log).apply(G,k)}return R.namespace=b,R.useColors=c.useColors(),R.color=c.selectColor(b),R.extend=h,R.destroy=c.destroy,Object.defineProperty(R,"enabled",{enumerable:!0,configurable:!1,get:()=>E!==null?E:(w!==c.namespaces&&(w=c.namespaces,I=c.enabled(b)),I),set:k=>{E=k}}),typeof c.init=="function"&&c.init(R),R}function h(b,y){const w=c(this.namespace+(y===void 0?":":y)+b);return w.log=this.log,w}function p(b,y){let w=0,I=0,E=-1,R=0;for(;w<b.length;)if(I<y.length&&(y[I]===b[w]||y[I]==="*"))y[I]==="*"?(E=I,R=w,I++):(w++,I++);else{if(E===-1)return!1;I=E+1,R++,w=R}for(;I<y.length&&y[I]==="*";)I++;return I===y.length}return c.debug=c,c.default=c,c.coerce=function(b){return b instanceof Error?b.stack||b.message:b},c.disable=function(){const b=[...c.names,...c.skips.map((y=>"-"+y))].join(",");return c.enable(""),b},c.enable=function(b){c.save(b),c.namespaces=b,c.names=[],c.skips=[];const y=(typeof b=="string"?b:"").trim().replace(" ",",").split(",").filter(Boolean);for(const w of y)w[0]==="-"?c.skips.push(w.slice(1)):c.names.push(w)},c.enabled=function(b){for(const y of c.skips)if(p(b,y))return!1;for(const y of c.names)if(p(b,y))return!0;return!1},c.humanize=n(9192),c.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(a).forEach((b=>{c[b]=a[b]})),c.names=[],c.skips=[],c.formatters={},c.selectColor=function(b){let y=0;for(let w=0;w<b.length;w++)y=(y<<5)-y+b.charCodeAt(w),y|=0;return c.colors[Math.abs(y)%c.colors.length]},c.enable(c.load()),c}},1124:(r,e,n)=>{var a=n(6240),c=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;function p(y,w,I){var E=w[I];if(E!=null){if(c.call(y,I)&&(y[I]===void 0||y[I]===null))throw new TypeError("Cannot convert undefined or null to object ("+I+")");c.call(y,I)&&a(E)?y[I]=b(Object(y[I]),w[I]):y[I]=E}}function b(y,w){if(y===w)return y;for(var I in w=Object(w))c.call(w,I)&&p(y,w,I);if(Object.getOwnPropertySymbols)for(var E=Object.getOwnPropertySymbols(w),R=0;R<E.length;R++)h.call(w,E[R])&&p(y,w,E[R]);return y}r.exports=function(y){y=(function(I){if(I==null)throw new TypeError("Sources cannot be null or undefined");return Object(I)})(y);for(var w=1;w<arguments.length;w++)b(y,arguments[w]);return y}},8480:r=>{r.exports=function(e){switch(e){case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"uint8":return Uint8Array;case"uint16":return Uint16Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;case"array":return Array;case"uint8_clamped":return Uint8ClampedArray}}},919:(r,e,n)=>{var a;a=typeof window<"u"?window:n.g!==void 0?n.g:typeof self<"u"?self:{},r.exports=a},1024:(r,e)=>{e.read=function(n,a,c,h,p){var b,y,w=8*p-h-1,I=(1<<w)-1,E=I>>1,R=-7,k=c?p-1:0,G=c?-1:1,N=n[a+k];for(k+=G,b=N&(1<<-R)-1,N>>=-R,R+=w;R>0;b=256*b+n[a+k],k+=G,R-=8);for(y=b&(1<<-R)-1,b>>=-R,R+=h;R>0;y=256*y+n[a+k],k+=G,R-=8);if(b===0)b=1-E;else{if(b===I)return y?NaN:1/0*(N?-1:1);y+=Math.pow(2,h),b-=E}return(N?-1:1)*y*Math.pow(2,b-h)},e.write=function(n,a,c,h,p,b){var y,w,I,E=8*b-p-1,R=(1<<E)-1,k=R>>1,G=p===23?Math.pow(2,-24)-Math.pow(2,-77):0,N=h?0:b-1,O=h?1:-1,D=a<0||a===0&&1/a<0?1:0;for(a=Math.abs(a),isNaN(a)||a===1/0?(w=isNaN(a)?1:0,y=R):(y=Math.floor(Math.log(a)/Math.LN2),a*(I=Math.pow(2,-y))<1&&(y--,I*=2),(a+=y+k>=1?G/I:G*Math.pow(2,1-k))*I>=2&&(y++,I/=2),y+k>=R?(w=0,y=R):y+k>=1?(w=(a*I-1)*Math.pow(2,p),y+=k):(w=a*Math.pow(2,k-1)*Math.pow(2,p),y=0));p>=8;n[c+N]=255&w,N+=O,w/=256,p-=8);for(y=y<<p|w,E+=p;E>0;n[c+N]=255&y,N+=O,y/=256,E-=8);n[c+N-O]|=128*D}},2225:r=>{function e(n){return!!n.constructor&&typeof n.constructor.isBuffer=="function"&&n.constructor.isBuffer(n)}r.exports=function(n){return n!=null&&(e(n)||(function(a){return typeof a.readFloatLE=="function"&&typeof a.slice=="function"&&e(a.slice(0,0))})(n)||!!n._isBuffer)}},8847:r=>{r.exports=function(n){if(!n)return!1;var a=e.call(n);return a==="[object Function]"||typeof n=="function"&&a!=="[object RegExp]"||typeof window<"u"&&(n===window.setTimeout||n===window.alert||n===window.confirm||n===window.prompt)};var e=Object.prototype.toString},6240:r=>{r.exports=function(e){var n=typeof e;return e!==null&&(n==="object"||n==="function")}},5651:(r,e,n)=>{var a=n(5406),c=n(4597),h=n(5734),p=["x","e","a","o","n","s","r","c","u","m","v","w","z"],b=["m","w"],y=["H","I","N","E","F","K","L","T","U","V","W","X","Y","Z"],w=9,I=32;function E(O){this.glyphs=[],this._measure=this.computeMetrics.bind(this),this.update(O)}function R(O){return new Function(["return function "+O+"() {","  return this._"+O,"}"].join(`
`))()}function k(O,D){if(!O.chars||O.chars.length===0)return null;var W=N(O.chars,D);return W>=0?O.chars[W]:null}function G(O,D,W){if(!O.kernings||O.kernings.length===0)return 0;for(var H=O.kernings,K=0;K<H.length;K++){var j=H[K];if(j.first===D&&j.second===W)return j.amount}return 0}function N(O,D,W){for(var H=W=W||0;H<O.length;H++)if(O[H].id===D)return H;return-1}r.exports=function(O){return new E(O)},E.prototype.update=function(O){if(O=c({measure:this._measure},O),this._opt=O,this._opt.tabSize=h(this._opt.tabSize,4),!O.font)throw new Error("must provide a valid bitmap font");var D=this.glyphs,W=O.text||"",H=O.font;this._setupSpaceGlyphs(H);var K=a.lines(W,O),j=O.width||0;D.length=0;var J=K.reduce((function(de,we){return Math.max(de,we.width,j)}),0),ee=0,re=0,Y=h(O.lineHeight,H.common.lineHeight),ie=H.common.base,ue=Y-ie,Re=O.letterSpacing||0,_e=Y*K.length-ue,Pe=(function(de){return de==="center"?1:de==="right"?2:0})(this._opt.align);re-=_e,this._width=J,this._height=_e,this._descender=Y-ie,this._baseline=ie,this._xHeight=(function(de){for(var we=0;we<p.length;we++){var Le=p[we].charCodeAt(0),Je=N(de.chars,Le);if(Je>=0)return de.chars[Je].height}return 0})(H),this._capHeight=(function(de){for(var we=0;we<y.length;we++){var Le=y[we].charCodeAt(0),Je=N(de.chars,Le);if(Je>=0)return de.chars[Je].height}return 0})(H),this._lineHeight=Y,this._ascender=Y-ue-this._xHeight;var rt=this;K.forEach((function(de,we){for(var Le,Je=de.start,fe=de.end,Ve=de.width,Ne=Je;Ne<fe;Ne++){var gt=W.charCodeAt(Ne),bt=rt.getGlyph(H,gt);if(bt){Le&&(ee+=G(H,Le.id,bt.id));var zt=ee;Pe===1?zt+=(J-Ve)/2:Pe===2&&(zt+=J-Ve),D.push({position:[zt,re],data:bt,index:Ne,line:we}),ee+=bt.xadvance+Re,Le=bt}}re+=Y,ee=0})),this._linesTotal=K.length},E.prototype._setupSpaceGlyphs=function(O){if(this._fallbackSpaceGlyph=null,this._fallbackTabGlyph=null,O.chars&&O.chars.length!==0){var D=k(O,I)||(function(H){for(var K=0;K<b.length;K++){var j=b[K].charCodeAt(0),J=N(H.chars,j);if(J>=0)return H.chars[J]}return 0})(O)||O.chars[0],W=this._opt.tabSize*D.xadvance;this._fallbackSpaceGlyph=D,this._fallbackTabGlyph=c(D,{x:0,y:0,xadvance:W,id:w,xoffset:0,yoffset:0,width:0,height:0})}},E.prototype.getGlyph=function(O,D){return k(O,D)||(D===w?this._fallbackTabGlyph:D===I?this._fallbackSpaceGlyph:null)},E.prototype.computeMetrics=function(O,D,W,H){var K,j=this._opt.letterSpacing||0,J=this._opt.font,ee=0,re=0,Y=0;if(!J.chars||J.chars.length===0)return{start:D,end:D,width:0};W=Math.min(O.length,W);for(var ie=D;ie<W;ie++){var ue,Re=O.charCodeAt(ie);if(ue=this.getGlyph(J,Re)){ue.xoffset;var _e=(ee+=K?G(J,K.id,ue.id):0)+ue.xadvance+j,Pe=ee+ue.width;if(Pe>=H||_e>=H)break;ee=_e,re=Pe,K=ue}Y++}return K&&(re+=K.xoffset),{start:D,end:D+Y,width:re}},["width","height","descender","ascender","xHeight","baseline","capHeight","lineHeight"].forEach((function(O){Object.defineProperty(E.prototype,O,{get:R(O),configurable:!0})}))},5751:(r,e,n)=>{var a=n(9922).hp,c=n(3558),h=function(){},p=n(1476),b=n(7034),y=n(7480),w=n(573),I=n(4597),E=self.XMLHttpRequest&&"withCredentials"in new XMLHttpRequest;r.exports=function(R,k){k=typeof k=="function"?k:h,typeof R=="string"?R={uri:R}:R||(R={}),R.binary&&(R=(function(G){if(E)return I(G,{responseType:"arraybuffer"});if(self.XMLHttpRequest===void 0)throw new Error("your browser does not support XHR loading");var N=new self.XMLHttpRequest;return N.overrideMimeType("text/plain; charset=x-user-defined"),I({xhr:N},G)})(R)),c(R,(function(G,N,O){if(G)return k(G);if(!/^2/.test(N.statusCode))return k(new Error("http status code: "+N.statusCode));if(!O)return k(new Error("no body result"));var D,W,H=!1;if(D=O,Object.prototype.toString.call(D)==="[object ArrayBuffer]"){var K=new Uint8Array(O);O=a.from(K,"binary")}w(O)&&(H=!0,typeof O=="string"&&(O=a.from(O,"binary"))),H||(a.isBuffer(O)&&(O=O.toString(R.encoding)),O=O.trim());try{var j=N.headers["content-type"];W=H?y(O):/json/.test(j)||O.charAt(0)==="{"?JSON.parse(O):/xml/.test(j)||O.charAt(0)==="<"?b(O):p(O)}catch(J){k(new Error("error parsing font "+J.message)),k=h}k(null,W)}))}},573:(r,e,n)=>{var a=n(9922).hp,c=n(911),h=a.from([66,77,70,3]);r.exports=function(p){return typeof p=="string"?p.substring(0,3)==="BMF":p.length>4&&c(p.slice(0,4),h)}},9192:r=>{var e=1e3,n=60*e,a=60*n,c=24*a,h=7*c;function p(b,y,w,I){var E=y>=1.5*w;return Math.round(b/w)+" "+I+(E?"s":"")}r.exports=function(b,y){y=y||{};var w,I,E=typeof b;if(E==="string"&&b.length>0)return(function(R){if(!((R=String(R)).length>100)){var k=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(R);if(k){var G=parseFloat(k[1]);switch((k[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*G;case"weeks":case"week":case"w":return G*h;case"days":case"day":case"d":return G*c;case"hours":case"hour":case"hrs":case"hr":case"h":return G*a;case"minutes":case"minute":case"mins":case"min":case"m":return G*n;case"seconds":case"second":case"secs":case"sec":case"s":return G*e;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return G;default:return}}}})(b);if(E==="number"&&isFinite(b))return y.long?(w=b,(I=Math.abs(w))>=c?p(w,I,c,"day"):I>=a?p(w,I,a,"hour"):I>=n?p(w,I,n,"minute"):I>=e?p(w,I,e,"second"):w+" ms"):(function(R){var k=Math.abs(R);return k>=c?Math.round(R/c)+"d":k>=a?Math.round(R/a)+"h":k>=n?Math.round(R/n)+"m":k>=e?Math.round(R/e)+"s":R+"ms"})(b);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(b))}},1476:r=>{function e(a,c){if(!(a=a.replace(/\t+/g," ").trim()))return null;var h=a.indexOf(" ");if(h===-1)throw new Error("no named row at line "+c);var p=a.substring(0,h);a=(a=(a=(a=a.substring(h+1)).replace(/letter=[\'\"]\S+[\'\"]/gi,"")).split("=")).map((function(E){return E.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g)}));for(var b=[],y=0;y<a.length;y++){var w=a[y];y===0?b.push({key:w[0],data:""}):y===a.length-1?b[b.length-1].data=n(w[0]):(b[b.length-1].data=n(w[0]),b.push({key:w[1],data:""}))}var I={key:p,data:{}};return b.forEach((function(E){I.data[E.key]=E.data})),I}function n(a){return a&&a.length!==0?a.indexOf('"')===0||a.indexOf("'")===0?a.substring(1,a.length-1):a.indexOf(",")!==-1?(function(c){return c.split(",").map((function(h){return parseInt(h,10)}))})(a):parseInt(a,10):""}r.exports=function(a){if(!a)throw new Error("no data provided");var c={pages:[],chars:[],kernings:[]},h=(a=a.toString().trim()).split(/\r\n?|\n/g);if(h.length===0)throw new Error("no data in BMFont file");for(var p=0;p<h.length;p++){var b=e(h[p],p);if(b)if(b.key==="page"){if(typeof b.data.id!="number")throw new Error("malformed file at line "+p+" -- needs page id=N");if(typeof b.data.file!="string")throw new Error("malformed file at line "+p+' -- needs page file="path"');c.pages[b.data.id]=b.data.file}else b.key==="chars"||b.key==="kernings"||(b.key==="char"?c.chars.push(b.data):b.key==="kerning"?c.kernings.push(b.data):c[b.key]=b.data)}return c}},7480:r=>{var e=[66,77,70];function n(c,h,p){if(p>h.length-1)return 0;var b=h.readUInt8(p++),y=h.readInt32LE(p);switch(p+=4,b){case 1:c.info=(function(w,I){var E={};E.size=w.readInt16LE(I);var R=w.readUInt8(I+2);return E.smooth=R>>7&1,E.unicode=R>>6&1,E.italic=R>>5&1,E.bold=R>>4&1,R>>3&1&&(E.fixedHeight=1),E.charset=w.readUInt8(I+3)||"",E.stretchH=w.readUInt16LE(I+4),E.aa=w.readUInt8(I+6),E.padding=[w.readInt8(I+7),w.readInt8(I+8),w.readInt8(I+9),w.readInt8(I+10)],E.spacing=[w.readInt8(I+11),w.readInt8(I+12)],E.outline=w.readUInt8(I+13),E.face=(function(k,G){return a(k,G).toString("utf8")})(w,I+14),E})(h,p);break;case 2:c.common=(function(w,I){var E={};return E.lineHeight=w.readUInt16LE(I),E.base=w.readUInt16LE(I+2),E.scaleW=w.readUInt16LE(I+4),E.scaleH=w.readUInt16LE(I+6),E.pages=w.readUInt16LE(I+8),w.readUInt8(I+10),E.packed=0,E.alphaChnl=w.readUInt8(I+11),E.redChnl=w.readUInt8(I+12),E.greenChnl=w.readUInt8(I+13),E.blueChnl=w.readUInt8(I+14),E})(h,p);break;case 3:c.pages=(function(w,I,E){for(var R=[],k=a(w,I),G=k.length+1,N=E/G,O=0;O<N;O++)R[O]=w.slice(I,I+k.length).toString("utf8"),I+=G;return R})(h,p,y);break;case 4:c.chars=(function(w,I,E){for(var R=[],k=E/20,G=0;G<k;G++){var N={},O=20*G;N.id=w.readUInt32LE(I+0+O),N.x=w.readUInt16LE(I+4+O),N.y=w.readUInt16LE(I+6+O),N.width=w.readUInt16LE(I+8+O),N.height=w.readUInt16LE(I+10+O),N.xoffset=w.readInt16LE(I+12+O),N.yoffset=w.readInt16LE(I+14+O),N.xadvance=w.readInt16LE(I+16+O),N.page=w.readUInt8(I+18+O),N.chnl=w.readUInt8(I+19+O),R[G]=N}return R})(h,p,y);break;case 5:c.kernings=(function(w,I,E){for(var R=[],k=E/10,G=0;G<k;G++){var N={},O=10*G;N.first=w.readUInt32LE(I+0+O),N.second=w.readUInt32LE(I+4+O),N.amount=w.readInt16LE(I+8+O),R[G]=N}return R})(h,p,y)}return 5+y}function a(c,h){for(var p=h;p<c.length&&c[p]!==0;p++);return c.slice(h,p)}r.exports=function(c){if(c.length<6)throw new Error("invalid buffer length for BMFont");var h=e.every((function(w,I){return c.readUInt8(I)===w}));if(!h)throw new Error("BMFont missing BMF byte header");var p=3;if(c.readUInt8(p++)>3)throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");for(var b={kernings:[],chars:[]},y=0;y<5;y++)p+=n(b,c,p);return b}},7034:(r,e,n)=>{var a=n(7829),c=n(1896),h={scaleh:"scaleH",scalew:"scaleW",stretchh:"stretchH",lineheight:"lineHeight",alphachnl:"alphaChnl",redchnl:"redChnl",greenchnl:"greenChnl",bluechnl:"blueChnl"};function p(b){var y=(function(w){for(var I=[],E=0;E<w.attributes.length;E++)I.push(w.attributes[E]);return I})(b);return y.reduce((function(w,I){var E;return w[E=I.nodeName,h[E.toLowerCase()]||E]=I.nodeValue,w}),{})}r.exports=function(b){b=b.toString();var y=c(b),w={pages:[],chars:[],kernings:[]};["info","common"].forEach((function(O){var D=y.getElementsByTagName(O)[0];D&&(w[O]=a(p(D)))}));var I=y.getElementsByTagName("pages")[0];if(!I)throw new Error("malformed file -- no <pages> element");for(var E=I.getElementsByTagName("page"),R=0;R<E.length;R++){var k=E[R],G=parseInt(k.getAttribute("id"),10),N=k.getAttribute("file");if(isNaN(G))throw new Error('malformed file -- page "id" attribute is NaN');if(!N)throw new Error('malformed file -- needs page "file" attribute');w.pages[parseInt(G,10)]=N}return["chars","kernings"].forEach((function(O){var D=y.getElementsByTagName(O)[0];if(D)for(var W=O.substring(0,O.length-1),H=D.getElementsByTagName(W),K=0;K<H.length;K++){var j=H[K];w[O].push(a(p(j)))}})),w}},7829:r=>{var e="chasrset";r.exports=function(n){for(var a in n=Object.assign({},n),e in n&&(n.charset=n[e],delete n[e]),n)a!=="face"&&a!=="charset"&&(n[a]=a==="padding"||a==="spacing"?n[a].split(",").map((function(c){return parseInt(c,10)})):parseInt(n[a],10));return n}},3216:r=>{var e=function(n){return n.replace(/^\s+|\s+$/g,"")};r.exports=function(n){if(!n)return{};for(var a,c={},h=e(n).split(`
`),p=0;p<h.length;p++){var b=h[p],y=b.indexOf(":"),w=e(b.slice(0,y)).toLowerCase(),I=e(b.slice(y+1));c[w]===void 0?c[w]=I:(a=c[w],Object.prototype.toString.call(a)==="[object Array]"?c[w].push(I):c[w]=[c[w],I])}return c}},9035:(r,e,n)=>{var a=n(8480),c=n(8167),h=n(2225),p=[0,2,3],b=[2,1,3];r.exports=function(y,w){y&&(c(y)||h(y))||(w=y||{},y=null);for(var I=typeof(w=typeof w=="number"?{count:w}:w||{}).type=="string"?w.type:"uint16",E=typeof w.count=="number"?w.count:1,R=w.start||0,k=w.clockwise!==!1?p:b,G=k[0],N=k[1],O=k[2],D=6*E,W=y||new(a(I))(D),H=0,K=0;H<D;H+=6,K+=4){var j=H+R;W[j+0]=K+0,W[j+1]=K+1,W[j+2]=K+2,W[j+3]=K+G,W[j+4]=K+N,W[j+5]=K+O}return W}},4433:(r,e,n)=>{var a=n(5651),c=n(9035),h=n(7106),p=n(1684);r.exports=function(y){return new b(y)};class b extends THREE.BufferGeometry{constructor(w){super(),typeof w=="string"&&(w={text:w}),this._opt=Object.assign({},w),w&&this.update(w)}update(w){if(typeof w=="string"&&(w={text:w}),!(w=Object.assign({},this._opt,w)).font)throw new TypeError("must specify a { font } in options");this.layout=a(w);var I=w.flipY!==!1,E=w.font,R=E.common.scaleW,k=E.common.scaleH,G=this.layout.glyphs.filter((function(H){var K=H.data;return K.width*K.height>0}));this.visibleGlyphs=G;var N=h.positions(G),O=h.uvs(G,R,k,I),D=c([],{clockwise:!0,type:"uint16",count:G.length});if(this.setIndex(D),this.setAttribute("position",new THREE.BufferAttribute(N,2)),this.setAttribute("uv",new THREE.BufferAttribute(O,2)),!w.multipage&&"page"in this.attributes)this.removeAttribute("page");else if(w.multipage){var W=h.pages(G);this.setAttribute("page",new THREE.BufferAttribute(W,1))}this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere()}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new THREE.Sphere);var w=this.attributes.position.array,I=this.attributes.position.itemSize;if(!w||!I||w.length<2)return this.boundingSphere.radius=0,void this.boundingSphere.center.set(0,0,0);p.computeSphere(w,this.boundingSphere),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new THREE.Box3);var w=this.boundingBox,I=this.attributes.position.array,E=this.attributes.position.itemSize;!I||!E||I.length<2?w.makeEmpty():p.computeBox(I,w)}}},1684:r=>{var e={min:[0,0],max:[0,0]};function n(a){var c=a.length/2;e.min[0]=a[0],e.min[1]=a[1],e.max[0]=a[0],e.max[1]=a[1];for(var h=0;h<c;h++){var p=a[2*h+0],b=a[2*h+1];e.min[0]=Math.min(p,e.min[0]),e.min[1]=Math.min(b,e.min[1]),e.max[0]=Math.max(p,e.max[0]),e.max[1]=Math.max(b,e.max[1])}}r.exports.computeBox=function(a,c){n(a),c.min.set(e.min[0],e.min[1],0),c.max.set(e.max[0],e.max[1],0)},r.exports.computeSphere=function(a,c){n(a);var h=e.min[0],p=e.min[1],b=e.max[0]-h,y=e.max[1]-p,w=Math.sqrt(b*b+y*y);c.center.set(h+b/2,p+y/2,0),c.radius=w/2}},7106:r=>{r.exports.pages=function(e){var n=new Float32Array(4*e.length*1),a=0;return e.forEach((function(c){var h=c.data.page||0;n[a++]=h,n[a++]=h,n[a++]=h,n[a++]=h})),n},r.exports.uvs=function(e,n,a,c){var h=new Float32Array(4*e.length*2),p=0;return e.forEach((function(b){var y=b.data,w=y.x+y.width,I=y.y+y.height,E=y.x/n,R=y.y/a,k=w/n,G=I/a;c&&(R=(a-y.y)/a,G=(a-I)/a),h[p++]=E,h[p++]=R,h[p++]=E,h[p++]=G,h[p++]=k,h[p++]=G,h[p++]=k,h[p++]=R})),h},r.exports.positions=function(e){var n=new Float32Array(4*e.length*2),a=0;return e.forEach((function(c){var h=c.data,p=c.position[0]+h.xoffset,b=c.position[1]+h.yoffset,y=h.width,w=h.height;n[a++]=p,n[a++]=b,n[a++]=p,n[a++]=b+w,n[a++]=p+y,n[a++]=b+w,n[a++]=p+y,n[a++]=b})),n}},5406:r=>{var e=/\n/,n=/\s/;function a(p,b,y,w){var I=p.indexOf(b,y);return I===-1||I>w?w:I}function c(p){return n.test(p)}function h(p,b,y,w){return{start:b,end:b+Math.min(w,y-b)}}r.exports=function(p,b){return r.exports.lines(p,b).map((function(y){return p.substring(y.start,y.end)})).join(`
`)},r.exports.lines=function(p,b){if((b=b||{}).width===0&&b.mode!=="nowrap")return[];p=p||"";var y=typeof b.width=="number"?b.width:Number.MAX_VALUE,w=Math.max(0,b.start||0),I=typeof b.end=="number"?b.end:p.length,E=b.mode,R=b.measure||h;return E==="pre"?(function(k,G,N,O,D){for(var W=[],H=N,K=N;K<O&&K<G.length;K++){var j=G.charAt(K),J=e.test(j);if(J||K===O-1){var ee=k(G,H,J?K:K+1,D);W.push(ee),H=K+1}}return W})(R,p,w,I,y):(function(k,G,N,O,D,W){var H=[],K=D;for(W==="nowrap"&&(K=Number.MAX_VALUE);N<O&&N<G.length;){for(var j=a(G,`
`,N,O);N<j&&c(G.charAt(N));)N++;var J=k(G,N,j,K),ee=N+(J.end-J.start),re=ee+1;if(ee<j){for(;ee>N&&!c(G.charAt(ee));)ee--;if(ee===N)re>N+1&&re--,ee=re;else for(re=ee;ee>N&&c(G.charAt(ee-1));)ee--}if(ee>=N){var Y=k(G,N,ee,K);H.push(Y)}N=re}return H})(R,p,w,I,y,E)}},3558:(r,e,n)=>{var a=n(919),c=n(8847),h=n(3216),p=n(4597);function b(I,E,R){var k=I;return c(E)?(R=E,typeof I=="string"&&(k={uri:I})):k=p(E,{uri:I}),k.callback=R,k}function y(I,E,R){return w(E=b(I,E,R))}function w(I){if(I.callback===void 0)throw new Error("callback argument missing");var E=!1,R=function(ue,Re,_e){E||(E=!0,I.callback(ue,Re,_e))};function k(){var ue=void 0;if(ue=W.response?W.response:W.responseText||(function(Re){try{if(Re.responseType==="document")return Re.responseXML;var _e=Re.responseXML&&Re.responseXML.documentElement.nodeName==="parsererror";if(Re.responseType===""&&!_e)return Re.responseXML}catch{}return null})(W),Y)try{ue=JSON.parse(ue)}catch{}return ue}function G(ue){return clearTimeout(H),ue instanceof Error||(ue=new Error(""+(ue||"Unknown XMLHttpRequest Error"))),ue.statusCode=0,R(ue,ie)}function N(){if(!D){var ue;clearTimeout(H),ue=I.useXDR&&W.status===void 0?200:W.status===1223?204:W.status;var Re=ie,_e=null;return ue!==0?(Re={body:k(),statusCode:ue,method:j,headers:{},url:K,rawRequest:W},W.getAllResponseHeaders&&(Re.headers=h(W.getAllResponseHeaders()))):_e=new Error("Internal XMLHttpRequest Error"),R(_e,Re,Re.body)}}var O,D,W=I.xhr||null;W||(W=I.cors||I.useXDR?new y.XDomainRequest:new y.XMLHttpRequest);var H,K=W.url=I.uri||I.url,j=W.method=I.method||"GET",J=I.body||I.data,ee=W.headers=I.headers||{},re=!!I.sync,Y=!1,ie={body:void 0,headers:{},statusCode:0,method:j,url:K,rawRequest:W};if("json"in I&&I.json!==!1&&(Y=!0,ee.accept||ee.Accept||(ee.Accept="application/json"),j!=="GET"&&j!=="HEAD"&&(ee["content-type"]||ee["Content-Type"]||(ee["Content-Type"]="application/json"),J=JSON.stringify(I.json===!0?J:I.json))),W.onreadystatechange=function(){W.readyState===4&&setTimeout(N,0)},W.onload=N,W.onerror=G,W.onprogress=function(){},W.onabort=function(){D=!0},W.ontimeout=G,W.open(j,K,!re,I.username,I.password),re||(W.withCredentials=!!I.withCredentials),!re&&I.timeout>0&&(H=setTimeout((function(){if(!D){D=!0,W.abort("timeout");var ue=new Error("XMLHttpRequest timeout");ue.code="ETIMEDOUT",G(ue)}}),I.timeout)),W.setRequestHeader)for(O in ee)ee.hasOwnProperty(O)&&W.setRequestHeader(O,ee[O]);else if(I.headers&&!(function(ue){for(var Re in ue)if(ue.hasOwnProperty(Re))return!1;return!0})(I.headers))throw new Error("Headers cannot be set on an XDomainRequest object");return"responseType"in I&&(W.responseType=I.responseType),"beforeSend"in I&&typeof I.beforeSend=="function"&&I.beforeSend(W),W.send(J||null),W}r.exports=y,r.exports.default=y,y.XMLHttpRequest=a.XMLHttpRequest||function(){},y.XDomainRequest="withCredentials"in new y.XMLHttpRequest?y.XMLHttpRequest:a.XDomainRequest,(function(I,E){for(var R=0;R<I.length;R++)E(I[R])})(["get","put","post","patch","head","delete"],(function(I){y[I==="delete"?"del":I]=function(E,R,k){return(R=b(E,R,k)).method=I.toUpperCase(),w(R)}}))},1896:r=>{r.exports=self.DOMParser!==void 0?function(e){return new self.DOMParser().parseFromString(e,"application/xml")}:self.ActiveXObject!==void 0&&new self.ActiveXObject("Microsoft.XMLDOM")?function(e){var n=new self.ActiveXObject("Microsoft.XMLDOM");return n.async="false",n.loadXML(e),n}:function(e){var n=document.createElement("div");return n.innerHTML=e,n}},4597:r=>{r.exports=function(){for(var n={},a=0;a<arguments.length;a++){var c=arguments[a];for(var h in c)e.call(c,h)&&(n[h]=c[h])}return n};var e=Object.prototype.hasOwnProperty},8132:()=>{window.aframeStats=function(r){var e=null,n=r;return{update:function(){var a;e("te").set((a=n.querySelectorAll("*"),Array.prototype.slice.call(a).filter((function(c){return c.isEntity})),a.length)),window.performance.getEntriesByName&&e("lt").set(window.performance.getEntriesByName("render-started")[0].startTime.toFixed(0))},start:function(){},end:function(){},attach:function(a){e=a},values:{te:{caption:"Entities"},lt:{caption:"Load Time"}},groups:[{caption:"A-Frame",values:["te","lt"]}],fractions:[]}}},3729:r=>{window.glStats=function(){var e=null,n=0,a=0,c=0,h=0,p=0,b=0,y=0;function w(I,E){return function(){E.apply(this,arguments),I.apply(this,arguments)}}return WebGLRenderingContext.prototype.drawArrays=w(WebGLRenderingContext.prototype.drawArrays,(function(){n++,arguments[0]==this.POINTS?b+=arguments[2]:p+=arguments[2]})),WebGLRenderingContext.prototype.drawElements=w(WebGLRenderingContext.prototype.drawElements,(function(){a++,h+=arguments[1]/3,p+=arguments[1]})),WebGLRenderingContext.prototype.useProgram=w(WebGLRenderingContext.prototype.useProgram,(function(){c++})),WebGLRenderingContext.prototype.bindTexture=w(WebGLRenderingContext.prototype.bindTexture,(function(){y++})),{update:function(){e("allcalls").set(n+a),e("drawElements").set(a),e("drawArrays").set(n),e("bindTexture").set(y),e("useProgram").set(c),e("glfaces").set(h),e("glvertices").set(p),e("glpoints").set(b)},start:function(){n=0,a=0,c=0,h=0,p=0,b=0,y=0},end:function(){},attach:function(I){e=I},values:{allcalls:{over:3e3,caption:"Calls (hook)"},drawelements:{caption:"drawElements (hook)"},drawarrays:{caption:"drawArrays (hook)"}},groups:[{caption:"WebGL",values:["allcalls","drawelements","drawarrays","useprogram","bindtexture","glfaces","glvertices","glpoints"]}],fractions:[{base:"allcalls",steps:["drawelements","drawarrays"]}]}},window.threeStats=function(e){var n=null;return{update:function(){n("renderer.info.memory.geometries").set(e.info.memory.geometries),n("renderer.info.programs").set(e.info.programs?.length??NaN),n("renderer.info.memory.textures").set(e.info.memory.textures),n("renderer.info.render.calls").set(e.info.render.calls),n("renderer.info.render.triangles").set(e.info.render.triangles),n("renderer.info.render.points").set(e.info.render.points)},start:function(){},end:function(){},attach:function(a){n=a},values:{"renderer.info.memory.geometries":{caption:"Geometries"},"renderer.info.memory.textures":{caption:"Textures"},"renderer.info.programs":{caption:"Programs"},"renderer.info.render.calls":{caption:"Calls"},"renderer.info.render.triangles":{caption:"Triangles",over:1e3},"renderer.info.render.points":{caption:"Points"}},groups:[{caption:"Three.js - Memory",values:["renderer.info.memory.geometries","renderer.info.programs","renderer.info.memory.textures"]},{caption:"Three.js - Render",values:["renderer.info.render.calls","renderer.info.render.triangles","renderer.info.render.points"]}],fractions:[]}},window.BrowserStats=function(){var e=null,n=0,a=0;window.performance&&!performance.memory&&(performance.memory={usedJSHeapSize:0,totalJSHeapSize:0}),performance.memory.totalJSHeapSize===0&&console.warn("totalJSHeapSize === 0... performance.memory is only available in Chrome .");var c=Math.log(1024);function h(p){var b=Math.floor(Math.log(p)/c);return Math.round(100*p/Math.pow(1024,b))/100}return{update:function(){n=h(performance.memory.usedJSHeapSize),a=h(performance.memory.totalJSHeapSize),e("memory").set(n),e("total").set(a)},start:function(){n=0},end:function(){},attach:function(p){e=p},values:{memory:{caption:"Used Memory",average:!0,avgMs:1e3,over:22},total:{caption:"Total Memory"}},groups:[{caption:"Browser",values:["memory","total"]}],fractions:[{base:"total",steps:["memory"]}]}},r.exports={glStats:window.glStats,threeStats:window.threeStats,BrowserStats:window.BrowserStats}},282:r=>{(function(){"performance"in window==0&&(window.performance={});var e=window.performance;if("now"in e==0){var n=Date.now();e.timing&&e.timing.navigationStart&&(n=e.timing.navigationStart),e.now=function(){return Date.now()-n}}e.mark||(e.mark=function(){}),e.measure||(e.measure=function(){})})(),window.rStats=function(e){function n(N,O){for(var D=Object.keys(N),W=0,H=D.length;W<H;W++)O(D[W])}var a=e||{},c=a.colours||["#850700","#c74900","#fcb300","#284280","#4c7c0c"],h=(a.CSSPath?a.CSSPath:"")+"rStats.css";(a.css||["https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300",h]).forEach((function(N){var O,D;O=N,(D=document.createElement("link")).href=O,D.rel="stylesheet",D.type="text/css",document.getElementsByTagName("head")[0].appendChild(D)})),a.values||(a.values={});var p,b,y=10,w={};function I(N,O,D){var W=D||{},H=document.createElement("canvas"),K=H.getContext("2d"),j=0,J=0,ee=W.color?W.color:"#666666",re=document.createElement("canvas"),Y=re.getContext("2d");re.width=1,re.height=20,Y.fillStyle="#444444",Y.fillRect(0,0,1,20),Y.fillStyle=ee,Y.fillRect(0,y,1,y),Y.fillStyle="#ffffff",Y.globalAlpha=.5,Y.fillRect(0,y,1,1),Y.globalAlpha=1;var ie=document.createElement("canvas"),ue=ie.getContext("2d");return ie.width=1,ie.height=20,ue.fillStyle="#444444",ue.fillRect(0,0,1,20),ue.fillStyle="#b70000",ue.fillRect(0,y,1,y),ue.globalAlpha=.5,ue.fillStyle="#ffffff",ue.fillRect(0,y,1,1),ue.globalAlpha=1,H.width=200,H.height=y,H.style.width=H.width+"px",H.style.height=H.height+"px",H.className="rs-canvas",N.appendChild(H),K.fillStyle="#444444",K.fillRect(0,0,H.width,H.height),{draw:function(Re,_e){(J+=.1*(Re-J))>(j*=.99)&&(j=J),K.drawImage(H,1,0,H.width-1,H.height,0,0,H.width-1,H.height),_e?K.drawImage(ie,H.width-1,H.height-J*H.height/j-y):K.drawImage(re,H.width-1,H.height-J*H.height/j-y)}}}function E(N,O){var D=document.createElement("canvas"),W=D.getContext("2d");return D.width=200,D.height=y*O,D.style.width=D.width+"px",D.style.height=D.height+"px",D.className="rs-canvas",N.appendChild(D),W.fillStyle="#444444",W.fillRect(0,0,D.width,D.height),{draw:function(H){W.drawImage(D,1,0,D.width-1,D.height,0,0,D.width-1,D.height);var K=0;n(H,(function(j){var J=H[j]*D.height;W.fillStyle=c[j],W.fillRect(D.width-1,K,1,J),K+=J}))}}}function R(N,O){var D,W=N,H=0,K=0,j=0,J=0,ee=performance.now(),re=0,Y=document.createElement("div"),ie=document.createElement("span"),ue=document.createElement("div"),Re=document.createTextNode(""),_e=a?a.values[W.toLowerCase()]:null,Pe=new I(Y,W,_e),rt=!1;function de(Je){if(_e&&_e.average){J+=Je,re++;var fe=performance.now();fe-ee>=(_e.avgMs||1e3)&&(j=J/re,J=0,ee=fe,re=0)}}function we(){D=performance.now(),a.userTimingAPI&&performance.mark(W+"-start"),rt=!0}function Le(){H=performance.now()-D,a.userTimingAPI&&(performance.mark(W+"-end"),rt&&performance.measure(W,W+"-start",W+"-end")),de(H)}return ie.className="rs-counter-id",ie.textContent=_e&&_e.caption?_e.caption:W,ue.className="rs-counter-value",ue.appendChild(Re),Y.appendChild(ie),Y.appendChild(ue),O?O.div.appendChild(Y):b.appendChild(Y),D=performance.now(),{set:function(Je){de(H=Je)},start:we,tick:function(){Le(),we()},end:Le,frame:function(){var Je=performance.now(),fe=Je-D;K++,fe>1e3&&(H=_e&&_e.interpolate===!1?K:1e3*K/fe,K=0,D=Je,de(H))},value:function(){return H},draw:function(){var Je=_e&&_e.average?j:H;Re.nodeValue=Math.round(100*Je)/100;var fe=_e&&(_e.below&&H<_e.below||_e.over&&H>_e.over);Pe.draw(H,fe),Y.className=fe?"rs-counter-base alarm":"rs-counter-base"}}}function k(N){var O=N.toLowerCase();if(O===void 0&&(O="default"),w[O])return w[O];var D=null;a&&a.groups&&n(a.groups,(function(H){var K=a.groups[parseInt(H,10)];D||K.values.indexOf(O.toLowerCase())===-1||(D=K)}));var W=new R(O,D);return w[O]=W,W}function G(){n(a.plugins,(function(N){a.plugins[N].update()})),n(w,(function(N){w[N].draw()})),a&&a.fractions&&n(a.fractions,(function(N){var O=a.fractions[parseInt(N,10)],D=[],W=w[O.base.toLowerCase()];W&&(W=W.value(),n(a.fractions[N].steps,(function(H){var K=a.fractions[N].steps[parseInt(H,10)].toLowerCase(),j=w[K];j&&D.push(j.value()/W)}))),O.graph.draw(D)}))}return(function(){if(a.plugins){a.values||(a.values={}),a.groups||(a.groups=[]),a.fractions||(a.fractions=[]);for(var N=0;N<a.plugins.length;N++)a.plugins[N].attach(k),n(a.plugins[N].values,(function(O){a.values[O]=a.plugins[N].values[O]})),a.groups=a.groups.concat(a.plugins[N].groups),a.fractions=a.fractions.concat(a.plugins[N].fractions)}else a.plugins={};(p=document.createElement("div")).className="rs-base",(b=document.createElement("div")).className="rs-container",b.style.height="auto",p.appendChild(b),document.body.appendChild(p),a&&(a.groups&&n(a.groups,(function(O){var D=a.groups[parseInt(O,10)],W=document.createElement("div");W.className="rs-group",D.div=W;var H=document.createElement("h1");H.textContent=D.caption,H.addEventListener("click",(function(K){this.classList.toggle("hidden"),K.preventDefault()}).bind(W)),b.appendChild(H),b.appendChild(W)})),a.fractions&&n(a.fractions,(function(O){var D=a.fractions[parseInt(O,10)],W=document.createElement("div");W.className="rs-fraction";var H=document.createElement("div");H.className="rs-legend";var K=0;n(a.fractions[O].steps,(function(J){var ee=document.createElement("p");ee.textContent=a.fractions[O].steps[J],ee.style.color=c[K],H.appendChild(ee),K++})),W.appendChild(H),W.style.height=K*y+"px",D.div=W;var j=new E(W,K);D.graph=j,b.appendChild(W)})))})(),function(N){return N?k(N):{element:p,update:G}}},r.exports=window.rStats},2535:r=>{var e={base64:function(n,a){return"data:"+n+";base64,"+a},isMobile:function(){var n,a=!1;return n=navigator.userAgent||navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4)))&&(a=!0),a},isIOS:function(){return/(iPad|iPhone|iPod)/g.test(navigator.userAgent)},isIFrame:function(){try{return window.self!==window.top}catch{return!0}},appendQueryParameter:function(n,a,c){var h=n.indexOf("?")<0?"?":"&";return n+(h+a+"=")+c},getQueryParameter:function(n){n=n.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");var a=new RegExp("[\\?&]"+n+"=([^&#]*)").exec(location.search);return a===null?"":decodeURIComponent(a[1].replace(/\+/g," "))},isLandscapeMode:function(){return window.orientation==90||window.orientation==-90}};r.exports=e},5928:(r,e,n)=>{var a,c=n(2535);r.exports=(a=navigator.userAgent||navigator.vendor||window.opera).match(/iPhone/i)||a.match(/iPod/i)?function(){var h=null;this.request=function(){h||(h=setInterval((function(){window.location.href="/",setTimeout(window.stop,0)}),15e3))},this.release=function(){h&&(clearInterval(h),h=null)}}:function(){var h=document.createElement("video");h.addEventListener("ended",(function(){h.play()})),this.request=function(){h.paused&&(h.src=c.base64("video/webm","GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw=="),h.play())},this.release=function(){h.pause(),h.src=""}}},8217:(r,e,n)=>{n.d(e,{A:()=>K});var a=n(963),c=n.n(a),h=n(9089),p=n.n(h),b=n(6492),y=n.n(b),w=new URL(n(9169),n.b),I=new URL(n(6085),n.b),E=new URL(n(3931),n.b),R=new URL(n(7889),n.b),k=new URL(n(6517),n.b),G=p()(c()),N=y()(w),O=y()(I),D=y()(E),W=y()(R),H=y()(k);G.push([r.id,`/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url(${N}) 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url(${O}) 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url(${D});
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(${W}) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(${H}) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`,"",{version:3,sources:["webpack://./src/style/aframe.css"],names:[],mappings:"AAAA,sCAAsC;AACtC;EACE,SAAS;EACT,OAAO;EACP,eAAe;EACf,QAAQ;EACR,MAAM;AACR;;AAEA;EACE,YAAY;EACZ,SAAS;EACT,gBAAgB;EAChB,UAAU;EACV,WAAW;AACb;;AAEA,oDAAoD;AACpD;EACE,sBAAsB;EACtB,uBAAuB;EACvB,iBAAiB;EACjB,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;EACpB,0BAA0B;AAC5B;;AAEA;;EAEE,UAAU;EACV,WAAW;AACb;;AAEA;EACE,WAAW;AACb;;AAEA,gEAAgE;AAChE;EACE,6BAA6B;AAC/B;;AAEA;EACE,wBAAwB;AAC1B;;AAEA;EACE,YAAY;EACZ,OAAO;EACP,kBAAkB;EAClB,MAAM;EACN,WAAW;AACb;;AAEA;EACE,YAAY;EACZ,iBAAiB;EACjB,oBAAoB;AACtB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,yBAAyB;EACzB,eAAe;EACf,SAAS;EACT,QAAQ;EACR,iBAAiB;EACjB,WAAW;EACX,qBAAqB;EACrB,eAAe;EACf,8BAA8B;EAC9B,kBAAkB;EAClB,cAAc;EACd,YAAY;AACd;;AAEA,+BAA+B;AAC/B,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;;AAErE;EACE,sCAAsC;EACtC,8CAA8C;AAChD;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,YAAY;EACZ,WAAW;AACb;;AAEA;;;;EAIE,aAAa;AACf;;AAEA;;EAEE,0DAA0D;AAC5D;;AAEA;EACE,6BAA6B;EAC7B,cAAc;EACd,qBAAqB;EACrB,6BAA6B;AAC/B;;AAEA;EACE,sBAAsB;EACtB,WAAW;EACX,gBAAgB;EAChB,kBAAkB;EAClB,UAAU;AACZ;;AAEA;;EAEE,kCAAkC;EAClC,eAAe;EACf,WAAW;EACX,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,WAAW;AACb;;AAEA;;;EAGE,WAAW;EACX,iBAAiB;EACjB,aAAa;AACf;;AAEA;EACE,yFAA4qB;AAC9qB;;AAEA;EACE,yFAAkzB;AACpzB;;AAEA;EACE,yDAA2qK;AAC7qK;;AAEA;;EAEE,wBAAwB;EACxB,SAAS;EACT,SAAS;EACT,eAAe;EACf,eAAe;EACf,gBAAgB;EAChB,kBAAkB;EAClB;;;;GAIC;EACD,gBAAgB;EAChB,cAAc;EACd,kBAAkB;EAClB,QAAQ;EACR,sCAAsC;EACtC,8CAA8C;EAC9C,aAAa;EACb,kBAAkB;EAClB,0BAA0B,EAAE,8CAA8C;AAC5E;;AAEA;EACE,yBAAyB;EACzB,kBAAkB;AACpB;;AAEA;;;;EAIE,yBAAyB;AAC3B;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,sBAAsB;EACtB,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,SAAS;EACT,kBAAkB;AACpB;;AAEA;EACE,qCAAqC;EACrC,4BAA4B;EAC5B,kCAAkC;EAClC,qBAAqB;EACrB,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,QAAQ;EACR,QAAQ;EACR,SAAS;AACX;;AAEA;;EAEE,eAAe;AACjB;;AAEA;EACE,SAAS;AACX;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,2FAAivF;EACjvF,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,8CAA8C;EAC9C,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,QAAQ;EACR,2BAA2B;EAC3B,WAAW;AACb;;AAEA;EACE,6DAA25B;EAC35B,YAAY;EACZ,YAAY;EACZ,oBAAoB;EACpB,WAAW;AACb;;AAEA;EACE,oCAAoC;EACpC,kCAAkC;EAClC,kBAAkB;EAClB,eAAe;EACf,YAAY;EACZ,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,UAAU;EACV,SAAS;EACT,QAAQ;EACR,YAAY;AACd;;AAEA;EACE,kBAAkB;EAClB,+BAA+B;EAC/B,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,gCAAgC;EAChC,eAAe;EACf,YAAY;EACZ,aAAa;EACb,wBAAwB;EACxB,uBAAuB;EACvB,kCAAkC;EAClC,eAAe;EACf,kBAAkB;EAClB,YAAY;AACd;;AAEA;EACE,WAAW;EACX,WAAW;EACX,sBAAsB;EACtB,aAAa;EACb,uBAAuB;EACvB,qBAAqB;EACrB,sBAAsB;AACxB;;AAEA;EACE,qBAAqB;EACrB,mBAAmB;EACnB,eAAe;EACf,WAAW;AACb;;AAEA;EACE,oBAAoB;EACpB,oBAAoB;EACpB,WAAW;EACX,WAAW;AACb;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,UAAU;EACV,eAAe;EACf,WAAW;EACX,kBAAkB;EAClB,iBAAiB;EACjB,YAAY;EACZ,qBAAqB;EACrB,yCAAyC;EACzC,iCAAiC;EACjC,wEAAwE;EACxE,iBAAiB;AACnB;;AAEA;EACE,mEAAmE;AACrE;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;EACzB,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,kBAAkB;EAClB,oBAAoB;EACpB,sBAAsB;EACtB,SAAS;EACT,OAAO;EACP,QAAQ;EACR,MAAM;EACN,YAAY;AACd;;AAEA;EACE,oBAAoB;AACtB",sourcesContent:[`/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z' fill='%23fff'/%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z' fill='%23fff'/%3E%3Cpath d='M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z' fill='%23fff'/%3E%3Cpath d='M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg width='108' height='62' viewBox='0 0 108 62' version='1.1' id='svg320' sodipodi:docname='fullscreen-aframe.svg' xml:space='preserve' inkscape:version='1.2.1 (9c6d41e  2022-07-14)' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:cc='http://creativecommons.org/ns%23' xmlns:dc='http://purl.org/dc/elements/1.1/'%3E%3Cdefs id='defs324' /%3E%3Csodipodi:namedview id='namedview322' pagecolor='%23ffffff' bordercolor='%23000000' borderopacity='0.25' inkscape:showpageshadow='2' inkscape:pageopacity='0.0' inkscape:pagecheckerboard='0' inkscape:deskcolor='%23d1d1d1' showgrid='false' inkscape:zoom='3.8064516' inkscape:cx='91.423729' inkscape:cy='-1.4449153' inkscape:window-width='1440' inkscape:window-height='847' inkscape:window-x='32' inkscape:window-y='25' inkscape:window-maximized='0' inkscape:current-layer='svg320' /%3E%3Ctitle id='title312'%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z' fill='%23fff' id='path314' style='fill:%23ffffff' /%3E%3Cg id='g356' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g358' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g360' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g362' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g364' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g366' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g368' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g370' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g372' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g374' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g376' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g378' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g380' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g382' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g384' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cmetadata id='metadata561'%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=''%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d='m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4' id='path596' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4' id='path598' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4' id='path600' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616' id='path602' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3C/svg%3E");
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`],sourceRoot:""}]);const K=G},2470:(r,e,n)=>{n.d(e,{A:()=>b});var a=n(963),c=n.n(a),h=n(9089),p=n.n(h)()(c());p.push([r.id,`.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`,"",{version:3,sources:["webpack://./src/style/rStats.css"],names:[],mappings:"AAAA;EACE,sBAAsB;EACtB,cAAc;EACd,gBAAgB;EAChB,oBAAoB;EACpB,SAAS;EACT,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,aAAa;EACb,eAAe;EACf,QAAQ;EACR,YAAY;EACZ,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;EACX,eAAe;EACf,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;EACf,UAAU;AACZ;;AAEA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,sCAAsC;EACtC,8BAA8B;EAC9B,kBAAkB;AACpB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,YAAY;EACZ,sCAAsC;EACtC,8BAA8B;EAC9B,aAAa;AACf;;AAEA;EACE,cAAc;EACd;;;;;;;;2BAQyB;AAC3B;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,iBAAiB;EACjB,WAAW;AACb;;AAEA;EACE,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;AACV;;AAEA;EACE;IACE,UAAU;IACV,SAAS;EACX;AACF",sourcesContent:[`.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`],sourceRoot:""}]);const b=p},7180:(r,e,n)=>{n.r(e),n.d(e,{default:()=>D});var a=n(5072),c=n.n(a),h=n(7825),p=n.n(h),b=n(7659),y=n.n(b),w=n(5056),I=n.n(w),E=n(540),R=n.n(E),k=n(1113),G=n.n(k),N=n(8217),O={};O.styleTagTransform=G(),O.setAttributes=I(),O.insert=y().bind(null,"head"),O.domAPI=p(),O.insertStyleElement=R(),c()(N.A,O);const D=N.A&&N.A.locals?N.A.locals:void 0},9379:(r,e,n)=>{n.r(e),n.d(e,{default:()=>D});var a=n(5072),c=n.n(a),h=n(7825),p=n.n(h),b=n(7659),y=n.n(b),w=n(5056),I=n.n(w),E=n(540),R=n.n(E),k=n(1113),G=n.n(k),N=n(2470),O={};O.styleTagTransform=G(),O.setAttributes=I(),O.insert=y().bind(null,"head"),O.domAPI=p(),O.insertStyleElement=R(),c()(N.A,O);const D=N.A&&N.A.locals?N.A.locals:void 0},5072:r=>{var e=[];function n(h){for(var p=-1,b=0;b<e.length;b++)if(e[b].identifier===h){p=b;break}return p}function a(h,p){for(var b={},y=[],w=0;w<h.length;w++){var I=h[w],E=p.base?I[0]+p.base:I[0],R=b[E]||0,k="".concat(E," ").concat(R);b[E]=R+1;var G=n(k),N={css:I[1],media:I[2],sourceMap:I[3],supports:I[4],layer:I[5]};if(G!==-1)e[G].references++,e[G].updater(N);else{var O=c(N,p);p.byIndex=w,e.splice(w,0,{identifier:k,updater:O,references:1})}y.push(k)}return y}function c(h,p){var b=p.domAPI(p);return b.update(h),function(y){if(y){if(y.css===h.css&&y.media===h.media&&y.sourceMap===h.sourceMap&&y.supports===h.supports&&y.layer===h.layer)return;b.update(h=y)}else b.remove()}}r.exports=function(h,p){var b=a(h=h||[],p=p||{});return function(y){y=y||[];for(var w=0;w<b.length;w++){var I=n(b[w]);e[I].references--}for(var E=a(y,p),R=0;R<b.length;R++){var k=n(b[R]);e[k].references===0&&(e[k].updater(),e.splice(k,1))}b=E}}},7659:r=>{var e={};r.exports=function(n,a){var c=(function(h){if(e[h]===void 0){var p=document.querySelector(h);if(window.HTMLIFrameElement&&p instanceof window.HTMLIFrameElement)try{p=p.contentDocument.head}catch{p=null}e[h]=p}return e[h]})(n);if(!c)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");c.appendChild(a)}},540:r=>{r.exports=function(e){var n=document.createElement("style");return e.setAttributes(n,e.attributes),e.insert(n,e.options),n}},5056:(r,e,n)=>{r.exports=function(a){var c=n.nc;c&&a.setAttribute("nonce",c)}},7825:r=>{r.exports=function(e){if(typeof document>"u")return{update:function(){},remove:function(){}};var n=e.insertStyleElement(e);return{update:function(a){(function(c,h,p){var b="";p.supports&&(b+="@supports (".concat(p.supports,") {")),p.media&&(b+="@media ".concat(p.media," {"));var y=p.layer!==void 0;y&&(b+="@layer".concat(p.layer.length>0?" ".concat(p.layer):""," {")),b+=p.css,y&&(b+="}"),p.media&&(b+="}"),p.supports&&(b+="}");var w=p.sourceMap;w&&typeof btoa<"u"&&(b+=`
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(w))))," */")),h.styleTagTransform(b,c,h.options)})(n,e,a)},remove:function(){(function(a){if(a.parentNode===null)return!1;a.parentNode.removeChild(a)})(n)}}}},1113:r=>{r.exports=function(e,n){if(n.styleSheet)n.styleSheet.cssText=e;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(e))}}},3931:r=>{r.exports="data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E"},6085:r=>{r.exports="data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"},9169:r=>{r.exports="data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"},6517:r=>{r.exports="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E"},7889:r=>{r.exports="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E"}},pG={};function Nn(r){var e=pG[r];if(e!==void 0)return e.exports;var n=pG[r]={id:r,exports:{}};return vV[r](n,n.exports,Nn),n.exports}Nn.m=vV,Nn.n=r=>{var e=r&&r.__esModule?()=>r.default:()=>r;return Nn.d(e,{a:e}),e},Nn.d=(r,e)=>{for(var n in e)Nn.o(e,n)&&!Nn.o(r,n)&&Object.defineProperty(r,n,{enumerable:!0,get:e[n]})},Nn.g=(function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}})(),Nn.o=(r,e)=>Object.prototype.hasOwnProperty.call(r,e),Nn.r=r=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})},Nn.b=document.baseURI||self.location.href,Nn.nc=void 0;var xV={};Nn.d(xV,{A:()=>mye});var mR={};Nn.r(mR),Nn.d(mR,{computeMikkTSpaceTangents:()=>d0e,computeMorphedAttributes:()=>y0e,deepCloneAttribute:()=>p0e,deinterleaveAttribute:()=>i2,deinterleaveGeometry:()=>g0e,estimateBytesUsed:()=>A0e,interleaveAttributes:()=>m0e,mergeAttributes:()=>kR,mergeGeometries:()=>f0e,mergeGroups:()=>v0e,mergeVertices:()=>b0e,toCreasedNormals:()=>x0e,toTrianglesDrawMode:()=>BR});var gR={};Nn.r(gR),Nn.d(gR,{checkARSupport:()=>Hk,checkHeadsetConnected:()=>Wk,checkVRSupport:()=>FR,isAppleVisionPro:()=>aW,isBrowserEnvironment:()=>$k,isFirefoxReality:()=>oW,isIOS:()=>Kv,isIpad:()=>rW,isLandscape:()=>lW,isMobile:()=>ef,isMobileDeviceRequestingDesktopSite:()=>Xk,isMobileVR:()=>Kk,isNodeEnvironment:()=>pAe,isOculusBrowser:()=>Qk,isR7:()=>Zk,isTablet:()=>sW,isWebXRAvailable:()=>q2});var AR={};Nn.r(AR),Nn.d(AR,{clearObject:()=>jk,createPool:()=>Yk,removeUnusedKeys:()=>Lv});var bR={};Nn.r(bR),Nn.d(bR,{equals:()=>hE,isCoordinate:()=>yAe,isCoordinates:()=>uW,parse:()=>o2,regex:()=>cW,stringify:()=>uE,toVector3:()=>vAe});var yR={};Nn.r(yR),Nn.d(yR,{getComponentProperty:()=>hW,getComponentPropertyPath:()=>J2,setComponentProperty:()=>qk});var vR={};Nn.r(vR),Nn.d(vR,{parseUrl:()=>OR,validateCubemapSrc:()=>fW,validateEnvMapSrc:()=>Jk,validateSrc:()=>l2});var xR={};Nn.r(xR),Nn.d(xR,{createCompatibleTexture:()=>tB,handleTextureEvents:()=>eB,isCompatibleTexture:()=>pW,setTextureProperties:()=>c2,updateDistortionMap:()=>du,updateEnvMap:()=>GR,updateMap:()=>fE,updateMapMaterialFromData:()=>eS});var nA={};Nn.r(nA),Nn.d(nA,{parse:()=>Nv,stringify:()=>EAe,toCamelCase:()=>mW});var wR={};Nn.r(wR),Nn.d(wR,{checkControllerPresentAndSetup:()=>tl,emitIfAxesChanged:()=>Bl,findMatchingControllerWebXR:()=>nB,isControllerPresentWebXR:()=>gW,onButtonEvent:()=>qn});var CR={};Nn.r(CR),Nn.d(CR,{bind:()=>MAe,checkHeadsetConnected:()=>_Ae,clone:()=>sB,coordinates:()=>bR,debounce:()=>bW,debug:()=>$i,deepEqual:()=>rB,device:()=>gR,diff:()=>yW,entity:()=>yR,extend:()=>Mo,extendDeep:()=>jo,findAllScenes:()=>xW,forceCanvasResizeSafariMobile:()=>dW,getElData:()=>DAe,getUrlParameter:()=>Dv,isIOS:()=>RAe,isIframed:()=>vW,isMobile:()=>kAe,material:()=>xR,objectPool:()=>AR,shouldCaptureKeyEvent:()=>aB,split:()=>Th,splitString:()=>NAe,srcLoader:()=>vR,styleParser:()=>nA,throttle:()=>BAe,throttleLeadingAndTrailing:()=>AW,throttleTick:()=>LAe,trackedControls:()=>wR});var ER={};Nn.r(ER),Nn.d(ER,{isSingleProperty:()=>tS,parseProperties:()=>SW,parseProperty:()=>nS,process:()=>Zv,processPropertyDefinition:()=>PR,stringifyProperties:()=>IW,stringifyProperty:()=>oB});var SR={};Nn.r(SR),Nn.d(SR,{Component:()=>Fv,components:()=>hr,registerComponent:()=>kn,registrationOrderWarnings:()=>_W});var IR={};Nn.r(IR),Nn.d(IR,{System:()=>f2,registerSystem:()=>kl,systems:()=>xh});var wV={update:null,begin:null,loopBegin:null,changeBegin:null,change:null,changeComplete:null,loopComplete:null,complete:null,loop:1,direction:"normal",autoplay:!0,timelineOffset:0},Nk={duration:1e3,delay:0,endDelay:0,easing:"easeOutElastic(1, .5)",round:0},Xge=["translateX","translateY","translateZ","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","perspective"],e2={CSS:{},springs:{}};function vh(r,e,n){return Math.min(Math.max(r,e),n)}function tv(r,e){return r.indexOf(e)>-1}function BC(r,e){return r.apply(null,e)}var Qge=/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i,Kge=/^rgb/,Zge=/^hsl/,zn={arr:function(r){return Array.isArray(r)},obj:function(r){return tv(Object.prototype.toString.call(r),"Object")},pth:function(r){return zn.obj(r)&&r.hasOwnProperty("totalLength")},svg:function(r){return r instanceof SVGElement},inp:function(r){return r instanceof HTMLInputElement},dom:function(r){return r.nodeType||zn.svg(r)},str:function(r){return typeof r=="string"},fnc:function(r){return typeof r=="function"},und:function(r){return r===void 0},hex:function(r){return Qge.test(r)},rgb:function(r){return Kge.test(r)},hsl:function(r){return Zge.test(r)},col:function(r){return zn.hex(r)||zn.rgb(r)||zn.hsl(r)},key:function(r){return!wV.hasOwnProperty(r)&&!Nk.hasOwnProperty(r)&&r!=="targets"&&r!=="keyframes"}},$ge=/\(([^)]+)\)/;function CV(r){var e=$ge.exec(r);return e?e[1].split(",").map((function(n){return parseFloat(n)})):[]}function EV(r,e){var n=CV(r),a=vh(zn.und(n[0])?1:n[0],.1,100),c=vh(zn.und(n[1])?100:n[1],.1,100),h=vh(zn.und(n[2])?10:n[2],.1,100),p=vh(zn.und(n[3])?0:n[3],.1,100),b=Math.sqrt(c/a),y=h/(2*Math.sqrt(c*a)),w=y<1?b*Math.sqrt(1-y*y):0,I=y<1?(y*b-p)/w:-p+b;function E(R){var k=e?e*R/1e3:R;return k=y<1?Math.exp(-k*y*b)*(1*Math.cos(w*k)+I*Math.sin(w*k)):(1+I*k)*Math.exp(-k*b),R===0||R===1?R:1-k}return e?E:function(){var R=e2.springs[r];if(R)return R;for(var k=1/6,G=0,N=0;;)if(E(G+=k)===1){if(++N>=16)break}else N=0;var O=G*k*1e3;return e2.springs[r]=O,O}}function LC(r,e){r===void 0&&(r=1),e===void 0&&(e=.5);var n=vh(r,1,10),a=vh(e,.1,2);return function(c){return c===0||c===1?c:-n*Math.pow(2,10*(c-1))*Math.sin((c-1-a/(2*Math.PI)*Math.asin(1/n))*(2*Math.PI)/a)}}function Yge(r){return r===void 0&&(r=10),function(e){return Math.round(e*r)*(1/r)}}var mG=(function(){var r=.1;function e(p,b){return 1-3*b+3*p}function n(p,b){return 3*b-6*p}function a(p){return 3*p}function c(p,b,y){return((e(b,y)*p+n(b,y))*p+a(b))*p}function h(p,b,y){return 3*e(b,y)*p*p+2*n(b,y)*p+a(b)}return function(p,b,y,w){if(0<=p&&p<=1&&0<=y&&y<=1){var I=new Float32Array(11);if(p!==b||y!==w)for(var E=0;E<11;++E)I[E]=c(E*r,p,y);return function(R){return p===b&&y===w||R===0||R===1?R:c((function(k){for(var G=0,N=1;N!==10&&I[N]<=k;++N)G+=r;--N;var O=G+(k-I[N])/(I[N+1]-I[N])*r,D=h(O,p,y);return D>=.001?(function(W,H,K,j){for(var J=0;J<4;++J){var ee=h(H,K,j);if(ee===0)return H;H-=(c(H,K,j)-W)/ee}return H})(k,O,p,y):D===0?O:(function(W,H,K,j,J){var ee,re,Y=0;do(ee=c(re=H+(K-H)/2,j,J)-W)>0?K=re:H=re;while(Math.abs(ee)>1e-7&&++Y<10);return re})(k,G,G+r,p,y)})(R),b,w)}}}})(),SV=(function(){var r=["Quad","Cubic","Quart","Quint","Sine","Expo","Circ","Back","Elastic"],e={In:[[.55,.085,.68,.53],[.55,.055,.675,.19],[.895,.03,.685,.22],[.755,.05,.855,.06],[.47,0,.745,.715],[.95,.05,.795,.035],[.6,.04,.98,.335],[.6,-.28,.735,.045],LC],Out:[[.25,.46,.45,.94],[.215,.61,.355,1],[.165,.84,.44,1],[.23,1,.32,1],[.39,.575,.565,1],[.19,1,.22,1],[.075,.82,.165,1],[.175,.885,.32,1.275],function(p,b){return function(y){return 1-LC(p,b)(1-y)}}],InOut:[[.455,.03,.515,.955],[.645,.045,.355,1],[.77,0,.175,1],[.86,0,.07,1],[.445,.05,.55,.95],[1,0,0,1],[.785,.135,.15,.86],[.68,-.55,.265,1.55],function(p,b){return function(y){return y<.5?LC(p,b)(2*y)/2:1-LC(p,b)(-2*y+2)/2}}]},n={linear:[.25,.25,.75,.75]};for(var a in e)for(var c=0,h=e[a].length;c<h;c++)n["ease"+a+r[c]]=e[a][c];return n})();function TR(r,e){if(zn.fnc(r))return r;var n=r.split("(")[0],a=SV[n],c=CV(r);switch(n){case"spring":return EV(r,e);case"cubicBezier":return BC(mG,c);case"steps":return BC(Yge,c);default:return zn.fnc(a)?BC(a,c):BC(mG,a)}}function IV(r){try{return document.querySelectorAll(r)}catch{return}}var gG=[];function t2(r,e){for(var n=gG,a=r.length,c=arguments.length>=2?arguments[1]:void 0,h=0;h<a;h++)if(h in r){var p=r[h];e.call(c,p,h,r)&&n.push(p)}return(gG=r).length=0,n}function j2(r,e){e||(e=[]);for(var n=0,a=r.length;n<a;n++){var c=r[n];Array.isArray(c)?j2(c,e):e.push(c)}return e}function AG(r){return zn.arr(r)?r:(zn.str(r)&&(r=IV(r)||r),r instanceof NodeList||r instanceof HTMLCollection?[].slice.call(r):[r])}function Dk(r,e){return r.some((function(n){return n===e}))}function Fk(r){var e={};for(var n in r)e[n]=r[n];return e}function MR(r,e){var n=Fk(r);for(var a in r)n[a]=e.hasOwnProperty(a)?e[a]:r[a];return n}function n2(r,e){var n=Fk(r);for(var a in e)n[a]=zn.und(r[a])?e[a]:r[a];return n}var jge=/rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g,qge=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,Jge=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,e0e=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g,t0e=/hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g,n0e=/([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/;function Ih(r){var e=n0e.exec(r);if(e)return e[2]}function _R(r,e){return zn.fnc(r)?r(e.target,e.id,e.total):r}function pu(r,e){return r.getAttribute(e)}function Ok(r,e,n){if(Dk([n,"deg","rad","turn"],Ih(e)))return e;var a=e2.CSS[e+n];if(!zn.und(a))return a;var c=document.createElement(r.tagName),h=r.parentNode&&r.parentNode!==document?r.parentNode:document.body;h.appendChild(c),c.style.position="absolute",c.style.width=100+n;var p=100/c.offsetWidth;h.removeChild(c);var b=p*parseFloat(e);return e2.CSS[e+n]=b,b}function TV(r,e,n){if(e in r.style){var a=e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),c=r.style[e]||getComputedStyle(r).getPropertyValue(a)||"0";return n?Ok(r,c,n):c}}function Gk(r,e){return zn.dom(r)&&!zn.inp(r)&&(pu(r,e)||zn.svg(r)&&r[e])?"attribute":zn.dom(r)&&Dk(Xge,e)?"transform":zn.dom(r)&&e!=="transform"&&TV(r,e)?"css":r[e]!=null?"object":void 0}var i0e=/(\w+)\(([^)]*)\)/g;function MV(r){if(zn.dom(r)){for(var e,n=r.style.transform||"",a=new Map;e=i0e.exec(n);)a.set(e[1],e[2]);return a}}function Uk(r,e,n,a){switch(Gk(r,e)){case"transform":return(function(c,h,p,b){var y=tv(h,"scale")?1:0+(function(I){return tv(I,"translate")||I==="perspective"?"px":tv(I,"rotate")||tv(I,"skew")?"deg":void 0})(h),w=MV(c).get(h)||y;return p&&(p.transforms.list.set(h,w),p.transforms.last=h),b?Ok(c,w,b):w})(r,e,a,n);case"css":return TV(r,e,n);case"attribute":return pu(r,e);default:return r[e]||0}}var s0e=/^(\*=|\+=|-=)/;function Pk(r,e){var n=s0e.exec(r);if(!n)return r;var a=Ih(r)||0,c=parseFloat(e),h=parseFloat(r.replace(n[0],""));switch(n[0][0]){case"+":return c+h+a;case"-":return c-h+a;case"*":return c*h+a}}var r0e=/\s/g;function _V(r,e){if(zn.col(r))return(function(c){return zn.rgb(c)?(h=c,(p=jge.exec(h))?"rgba("+p[1]+",1)":h):zn.hex(c)?(function(b){var y=b.replace(qge,(function(I,E,R,k){return E+E+R+R+k+k})),w=Jge.exec(y);return"rgba("+parseInt(w[1],16)+","+parseInt(w[2],16)+","+parseInt(w[3],16)+",1)"})(c):zn.hsl(c)?(function(b){var y,w,I,E=e0e.exec(b)||t0e.exec(b),R=parseInt(E[1],10)/360,k=parseInt(E[2],10)/100,G=parseInt(E[3],10)/100,N=E[4]||1;function O(H,K,j){return j<0&&(j+=1),j>1&&(j-=1),j<1/6?H+6*(K-H)*j:j<.5?K:j<2/3?H+(K-H)*(2/3-j)*6:H}if(k==0)y=w=I=G;else{var D=G<.5?G*(1+k):G+k-G*k,W=2*G-D;y=O(W,D,R+1/3),w=O(W,D,R),I=O(W,D,R-1/3)}return"rgba("+255*y+","+255*w+","+255*I+","+N+")"})(c):void 0;var h,p})(r);var n=Ih(r),a=n?r.substr(0,r.length-n.length):r;return e&&!r0e.test(r)?a+e:a}function RR(r,e){return Math.sqrt(Math.pow(e.x-r.x,2)+Math.pow(e.y-r.y,2))}function bG(r){for(var e,n=r.points,a=0,c=0;c<n.numberOfItems;c++){var h=n.getItem(c);c>0&&(a+=RR(e,h)),e=h}return a}function yG(r){if(r.getTotalLength)return r.getTotalLength();switch(r.tagName.toLowerCase()){case"circle":return(function(e){return 2*Math.PI*pu(e,"r")})(r);case"rect":return(function(e){return 2*pu(e,"width")+2*pu(e,"height")})(r);case"line":return(function(e){return RR({x:pu(e,"x1"),y:pu(e,"y1")},{x:pu(e,"x2"),y:pu(e,"y2")})})(r);case"polyline":return bG(r);case"polygon":return(function(e){var n=e.points;return bG(e)+RR(n.getItem(n.numberOfItems-1),n.getItem(0))})(r)}}function RV(r,e){var n=e||{},a=n.el||(function(w){for(var I=w.parentNode;zn.svg(I)&&(I=I.parentNode,zn.svg(I.parentNode)););return I})(r),c=a.getBoundingClientRect(),h=pu(a,"viewBox"),p=c.width,b=c.height,y=n.viewBox||(h?h.split(" "):[0,0,p,b]);return{el:a,viewBox:y,x:y[0]/1,y:y[1]/1,w:p/y[2],h:b/y[3]}}function a0e(r,e){function n(b){b===void 0&&(b=0);var y=e+b>=1?e+b:0;return r.el.getPointAtLength(y)}var a=RV(r.el,r.svg),c=n(),h=n(-1),p=n(1);switch(r.property){case"x":return(c.x-a.x)*a.w;case"y":return(c.y-a.y)*a.h;case"angle":return 180*Math.atan2(p.y-h.y,p.x-h.x)/Math.PI}}var i_=/-?\d*\.?\d+/g;function vG(r,e){var n=_V(zn.pth(r)?r.totalLength:r,e)+"";return{original:n,numbers:n.match(i_)?n.match(i_).map(Number):[0],strings:zn.str(r)||e?n.split(i_):[]}}function kV(r){return t2(r?j2(zn.arr(r)?r.map(AG):AG(r)):[],(function(e,n,a){return a.indexOf(e)===n}))}function BV(r){var e=kV(r);return e.map((function(n,a){return{target:n,id:a,total:e.length,transforms:{list:MV(n)}}}))}var o0e=/^spring/;function l0e(r,e){var n=Fk(e);if(o0e.test(n.easing)&&(n.duration=EV(n.easing)),zn.arr(r)){var a=r.length;a!==2||zn.obj(r[0])?zn.fnc(e.duration)||(n.duration=e.duration/a):r={value:r}}var c=zn.arr(r)?r:[r];return c.map((function(h,p){var b=zn.obj(h)&&!zn.pth(h)?h:{value:h};return zn.und(b.delay)&&(b.delay=p?0:e.delay),zn.und(b.endDelay)&&(b.endDelay=p===c.length-1?e.endDelay:0),b})).map((function(h){return n2(h,n)}))}var LV={css:function(r,e,n){return r.style[e]=n},attribute:function(r,e,n){return r.setAttribute(e,n)},object:function(r,e,n){return r[e]=n},transform:function(r,e,n,a,c){if(a.list.set(e,n),e===a.last||c){var h="";a.list.forEach((function(p,b){h+=b+"("+p+") "})),r.style.transform=h}}};function NV(r,e){for(var n=BV(r),a=0,c=n.length;a<c;a++){var h=n[a];for(var p in e){var b=_R(e[p],h),y=h.target,w=Ih(b),I=Uk(y,p,w,h),E=Pk(_V(b,w||Ih(I)),I),R=Gk(y,p);LV[R](y,p,E,h.transforms,!0)}}}function c0e(r,e){return t2(j2(r.map((function(n){return e.map((function(a){return(function(c,h){var p=Gk(c.target,h.name);if(p){var b=(function(w,I){var E;return w.tweens.map((function(R){var k=(function(J,ee){var re={};for(var Y in J){var ie=_R(J[Y],ee);zn.arr(ie)&&(ie=ie.map((function(ue){return _R(ue,ee)}))).length===1&&(ie=ie[0]),re[Y]=ie}return re.duration=parseFloat(re.duration),re.delay=parseFloat(re.delay),re})(R,I),G=k.value,N=zn.arr(G)?G[1]:G,O=Ih(N),D=Uk(I.target,w.name,O,I),W=E?E.to.original:D,H=zn.arr(G)?G[0]:W,K=Ih(H)||Ih(D),j=O||K;return zn.und(N)&&(N=W),k.from=vG(H,j),k.to=vG(Pk(N,H),j),k.start=E?E.end:0,k.end=k.start+k.delay+k.duration+k.endDelay,k.easing=TR(k.easing,k.duration),k.isPath=zn.pth(G),k.isColor=zn.col(k.from.original),k.isColor&&(k.round=1),E=k,k}))})(h,c),y=b[b.length-1];return{type:p,property:h.name,animatable:c,tweens:b,duration:y.end,delay:b[0].delay,endDelay:y.endDelay}}})(n,a)}))}))),(function(n){return!zn.und(n)}))}function DV(r,e){var n=r.length,a=function(h){return h.timelineOffset?h.timelineOffset:0},c={};return c.duration=n?Math.max.apply(Math,r.map((function(h){return a(h)+h.duration}))):e.duration,c.delay=n?Math.min.apply(Math,r.map((function(h){return a(h)+h.delay}))):e.delay,c.endDelay=n?c.duration-Math.max.apply(Math,r.map((function(h){return a(h)+h.duration-h.endDelay}))):e.endDelay,c}var lE,xG=0,So=[],s_=[],u0e=(function(){function r(){lE=requestAnimationFrame(e)}function e(n){var a=So.length;if(a){for(var c=0;c<a;){var h=So[c];if(h.paused){var p=So.indexOf(h);p>-1&&(So.splice(p,1),a=So.length)}else h.tick(n);c++}r()}else lE=cancelAnimationFrame(lE)}return r})();function Lr(r){r===void 0&&(r={});var e,n=0,a=0,c=0,h=0,p=null;function b(){return window.Promise&&new Promise((function(D){return p=D}))}var y=b(),w=(function(D){var W=MR(wV,D),H=MR(Nk,D),K=(function(Y,ie){var ue=[],Re=ie.keyframes;for(var _e in Re&&(ie=n2((function(Pe){for(var rt=t2(j2(Pe.map((function(Je){return Object.keys(Je)}))),(function(Je){return zn.key(Je)})).reduce((function(Je,fe){return Je.indexOf(fe)<0&&Je.push(fe),Je}),[]),de={},we=function(Je){var fe=rt[Je];de[fe]=Pe.map((function(Ve){var Ne={};for(var gt in Ve)zn.key(gt)?gt==fe&&(Ne.value=Ve[gt]):Ne[gt]=Ve[gt];return Ne}))},Le=0;Le<rt.length;Le++)we(Le);return de})(Re),ie)),ie)zn.key(_e)&&ue.push({name:_e,tweens:l0e(ie[_e],Y)});return ue})(H,D),j=BV(D.targets),J=c0e(j,K),ee=DV(J,H),re=xG;return xG++,n2(W,{id:re,children:[],animatables:j,animations:J,duration:ee.duration,delay:ee.delay,endDelay:ee.endDelay})})(r);function I(){w.reversed=!w.reversed;for(var D=0,W=e.length;D<W;D++)e[D].reversed=w.reversed}function E(D){return w.reversed?w.duration-D:D}function R(){n=0,a=E(w.currentTime)*(1/Lr.speed)}function k(D,W){W&&W.seek(D-W.timelineOffset)}function G(D){for(var W=0,H=w.animations,K=H.length;W<K;){var j=H[W],J=j.animatable,ee=j.tweens,re=ee.length-1,Y=ee[re];re&&(Y=t2(ee,(function(zt){return D<zt.end}))[0]||Y);for(var ie=vh(D-Y.start-Y.delay,0,Y.duration)/Y.duration,ue=isNaN(ie)?1:Y.easing(ie),Re=Y.to.strings,_e=Y.round,Pe=[],rt=Y.to.numbers.length,de=void 0,we=0;we<rt;we++){var Le=void 0,Je=Y.to.numbers[we],fe=Y.from.numbers[we]||0;Le=Y.isPath?a0e(Y.value,ue*Je):fe+ue*(Je-fe),_e&&(Y.isColor&&we>2||(Le=Math.round(Le*_e)/_e)),Pe.push(Le)}var Ve=Re.length;if(Ve){de=Re[0];for(var Ne=0;Ne<Ve;Ne++){Re[Ne];var gt=Re[Ne+1],bt=Pe[Ne];isNaN(bt)||(de+=gt?bt+gt:bt+" ")}}else de=Pe[0];LV[j.type](J.target,j.property,de,J.transforms),j.currentValue=de,W++}}function N(D){w[D]&&!w.passThrough&&w[D](w)}function O(D){var W=w.duration,H=w.delay,K=W-w.endDelay,j=E(D);w.progress=vh(j/W*100,0,100),w.reversePlayback=j<w.currentTime,e&&(function(J){if(w.reversePlayback)for(var ee=h;ee--;)k(J,e[ee]);else for(var re=0;re<h;re++)k(J,e[re])})(j),!w.began&&w.currentTime>0&&(w.began=!0,N("begin"),N("loopBegin")),j<=H&&w.currentTime!==0&&G(0),(j>=K&&w.currentTime!==W||!W)&&G(W),j>H&&j<K?(w.changeBegan||(w.changeBegan=!0,w.changeCompleted=!1,N("changeBegin")),N("change"),G(j)):w.changeBegan&&(w.changeCompleted=!0,w.changeBegan=!1,N("changeComplete")),w.currentTime=vh(j,0,W),w.began&&N("update"),D>=W&&(a=0,w.remaining&&w.remaining!==!0&&w.remaining--,w.remaining?(n=c,N("loopComplete"),N("loopBegin"),w.direction==="alternate"&&I()):(w.paused=!0,w.completed||(w.completed=!0,N("loopComplete"),N("complete"),"Promise"in window&&(p(),y=b()))))}return w.reset=function(){var D=w.direction;w.passThrough=!1,w.currentTime=0,w.progress=0,w.paused=!0,w.began=!1,w.changeBegan=!1,w.completed=!1,w.changeCompleted=!1,w.reversePlayback=!1,w.reversed=D==="reverse",w.remaining=w.loop,e=w.children;for(var W=h=e.length;W--;)w.children[W].reset();(w.reversed&&w.loop!==!0||D==="alternate"&&w.loop===1)&&w.remaining++,G(0)},w.set=function(D,W){return NV(D,W),w},w.tick=function(D){c=D,n||(n=c),O((c+(a-n))*Lr.speed)},w.seek=function(D){O(E(D))},w.pause=function(){w.paused=!0,R()},w.play=function(){w.paused&&(w.paused=!1,So.push(w),R(),lE||u0e())},w.reverse=function(){I(),R()},w.restart=function(){w.reset(),w.play()},w.finished=y,w.reset(),w.autoplay&&w.play(),w}function wG(r,e){for(var n=e.length;n--;)Dk(r,e[n].animatable.target)&&e.splice(n,1)}document.addEventListener("visibilitychange",(function(){if(document.hidden){for(var r=0,e=So.length;r<e;r++)activeInstance[r].pause();s_=So.slice(0),So=[]}else for(var n=0,a=s_.length;n<a;n++)s_[n].play()})),Lr.version="3.0.0",Lr.speed=1,Lr.running=So,Lr.remove=function(r){for(var e=kV(r),n=So.length;n--;){var a=So[n],c=a.animations,h=a.children;wG(e,c);for(var p=h.length;p--;){var b=h[p],y=b.animations;wG(e,y),y.length||b.children.length||h.splice(p,1)}c.length||h.length||a.pause()}},Lr.get=Uk,Lr.set=NV,Lr.convertPx=Ok,Lr.path=function(r,e){var n=zn.str(r)?IV(r)[0]:r,a=e||100;return function(c){return{property:c,el:n,svg:RV(n),totalLength:yG(n)*(a/100)}}},Lr.setDashoffset=function(r){var e=yG(r);return r.setAttribute("stroke-dasharray",e),e},Lr.stagger=function(r,e){e===void 0&&(e={});var n=e.direction||"normal",a=e.easing?TR(e.easing):null,c=e.grid,h=e.axis,p=e.from||0,b=p==="first",y=p==="center",w=p==="last",I=zn.arr(r),E=parseFloat(I?r[0]:r),R=I?parseFloat(r[1]):0,k=Ih(I?r[1]:r)||0,G=e.start||0+(I?E:0),N=[],O=0;return function(D,W,H){if(b&&(p=0),y&&(p=(H-1)/2),w&&(p=H-1),!N.length){for(var K=0;K<H;K++){if(c){var j=y?(c[0]-1)/2:p%c[0],J=y?(c[1]-1)/2:Math.floor(p/c[0]),ee=j-K%c[0],re=J-Math.floor(K/c[0]),Y=Math.sqrt(ee*ee+re*re);h==="x"&&(Y=-ee),h==="y"&&(Y=-re),N.push(Y)}else N.push(Math.abs(p-K));O=Math.max.apply(Math,N)}a&&(N=N.map((function(ie){return a(ie/O)*O}))),n==="reverse"&&(N=N.map((function(ie){return h?ie<0?-1*ie:-ie:Math.abs(O-ie)})))}return G+(I?(R-E)/O:E)*(Math.round(100*N[W])/100)+k}},Lr.timeline=function(r){r===void 0&&(r={});var e=Lr(r);return e.duration=0,e.add=function(n,a){var c=So.indexOf(e),h=e.children;function p(R){R.passThrough=!0}c>-1&&So.splice(c,1);for(var b=0;b<h.length;b++)p(h[b]);var y=n2(n,MR(Nk,r));y.targets=y.targets||r.targets;var w=e.duration;y.autoplay=!1,y.direction=e.direction,y.timelineOffset=zn.und(a)?w:Pk(a,w),p(e),e.seek(y.timelineOffset);var I=Lr(y);p(I),h.push(I);var E=DV(h,r);return e.delay=E.delay,e.endDelay=E.endDelay,e.duration=E.duration,e.seek(0),e.reset(),e.autoplay&&e.play(),e},e},Lr.easing=TR,Lr.penner=SV,Lr.random=function(r,e){return Math.floor(Math.random()*(e-r+1))+r};const cE=Lr,X=Wge,r_=new WeakMap;class FV extends X.Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,n,a,c){const h=new X.FileLoader(this.manager);h.setPath(this.path),h.setResponseType("arraybuffer"),h.setRequestHeader(this.requestHeader),h.setWithCredentials(this.withCredentials),h.load(e,(p=>{this.parse(p,n,c)}),a,c)}parse(e,n,a=()=>{}){this.decodeDracoFile(e,n,null,null,X.SRGBColorSpace,a).catch(a)}decodeDracoFile(e,n,a,c,h=X.LinearSRGBColorSpace,p=()=>{}){const b={attributeIDs:a||this.defaultAttributeIDs,attributeTypes:c||this.defaultAttributeTypes,useUniqueIDs:!!a,vertexColorSpace:h};return this.decodeGeometry(e,b).then(n).catch(p)}decodeGeometry(e,n){const a=JSON.stringify(n);if(r_.has(e)){const y=r_.get(e);if(y.key===a)return y.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let c;const h=this.workerNextTaskID++,p=e.byteLength,b=this._getWorker(h,p).then((y=>(c=y,new Promise(((w,I)=>{c._callbacks[h]={resolve:w,reject:I},c.postMessage({type:"decode",id:h,taskConfig:n,buffer:e},[e])}))))).then((y=>this._createGeometry(y.geometry)));return b.catch((()=>!0)).then((()=>{c&&h&&this._releaseTask(c,h)})),r_.set(e,{key:a,promise:b}),b}_createGeometry(e){const n=new X.BufferGeometry;e.index&&n.setIndex(new X.BufferAttribute(e.index.array,1));for(let a=0;a<e.attributes.length;a++){const c=e.attributes[a],h=c.name,p=c.array,b=c.itemSize,y=new X.BufferAttribute(p,b);h==="color"&&(this._assignVertexColorSpace(y,c.vertexColorSpace),y.normalized=p instanceof Float32Array==0),n.setAttribute(h,y)}return n}_assignVertexColorSpace(e,n){if(n!==X.SRGBColorSpace)return;const a=new X.Color;for(let c=0,h=e.count;c<h;c++)a.fromBufferAttribute(e,c),X.ColorManagement.toWorkingColorSpace(a,X.SRGBColorSpace),e.setXYZ(c,a.r,a.g,a.b)}_loadLibrary(e,n){const a=new X.FileLoader(this.manager);return a.setPath(this.decoderPath),a.setResponseType(n),a.setWithCredentials(this.withCredentials),new Promise(((c,h)=>{a.load(e,c,void 0,h)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",n=[];return e?n.push(this._loadLibrary("draco_decoder.js","text")):(n.push(this._loadLibrary("draco_wasm_wrapper.js","text")),n.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(n).then((a=>{const c=a[0];e||(this.decoderConfig.wasmBinary=a[1]);const h=h0e.toString(),p=["/* draco decoder */",c,"","/* worker */",h.substring(h.indexOf("{")+1,h.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([p]))})),this.decoderPending}_getWorker(e,n){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const c=new Worker(this.workerSourceURL);c._callbacks={},c._taskCosts={},c._taskLoad=0,c.postMessage({type:"init",decoderConfig:this.decoderConfig}),c.onmessage=function(h){const p=h.data;switch(p.type){case"decode":c._callbacks[p.id].resolve(p);break;case"error":c._callbacks[p.id].reject(p);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+p.type+'"')}},this.workerPool.push(c)}else this.workerPool.sort((function(c,h){return c._taskLoad>h._taskLoad?-1:1}));const a=this.workerPool[this.workerPool.length-1];return a._taskCosts[e]=n,a._taskLoad+=n,a}))}_releaseTask(e,n){e._taskLoad-=e._taskCosts[n],delete e._callbacks[n],delete e._taskCosts[n]}debug(){console.log("Task load: ",this.workerPool.map((e=>e._taskLoad)))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function h0e(){let r,e;function n(a,c,h,p,b,y){const w=y.num_components(),I=h.num_points()*w,E=I*b.BYTES_PER_ELEMENT,R=(function(N,O){switch(O){case Float32Array:return N.DT_FLOAT32;case Int8Array:return N.DT_INT8;case Int16Array:return N.DT_INT16;case Int32Array:return N.DT_INT32;case Uint8Array:return N.DT_UINT8;case Uint16Array:return N.DT_UINT16;case Uint32Array:return N.DT_UINT32}})(a,b),k=a._malloc(E);c.GetAttributeDataArrayForAllPoints(h,y,R,E,k);const G=new b(a.HEAPF32.buffer,k,I).slice();return a._free(k),{name:p,array:G,itemSize:w}}onmessage=function(a){const c=a.data;switch(c.type){case"init":r=c.decoderConfig,e=new Promise((function(b){r.onModuleLoaded=function(y){b({draco:y})},DracoDecoderModule(r)}));break;case"decode":const h=c.buffer,p=c.taskConfig;e.then((b=>{const y=b.draco,w=new y.Decoder;try{const I=(function(R,k,G,N){const O=N.attributeIDs,D=N.attributeTypes;let W,H;const K=k.GetEncodedGeometryType(G);if(K===R.TRIANGULAR_MESH)W=new R.Mesh,H=k.DecodeArrayToMesh(G,G.byteLength,W);else{if(K!==R.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");W=new R.PointCloud,H=k.DecodeArrayToPointCloud(G,G.byteLength,W)}if(!H.ok()||W.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+H.error_msg());const j={index:null,attributes:[]};for(const J in O){const ee=self[D[J]];let re,Y;if(N.useUniqueIDs)Y=O[J],re=k.GetAttributeByUniqueId(W,Y);else{if(Y=k.GetAttributeId(W,R[O[J]]),Y===-1)continue;re=k.GetAttribute(W,Y)}const ie=n(R,k,W,J,ee,re);J==="color"&&(ie.vertexColorSpace=N.vertexColorSpace),j.attributes.push(ie)}return K===R.TRIANGULAR_MESH&&(j.index=(function(J,ee,re){const Y=3*re.num_faces(),ie=4*Y,ue=J._malloc(ie);ee.GetTrianglesUInt32Array(re,ie,ue);const Re=new Uint32Array(J.HEAPF32.buffer,ue,Y).slice();return J._free(ue),{array:Re,itemSize:1}})(R,k,W)),R.destroy(W),j})(y,w,new Int8Array(h),p),E=I.attributes.map((R=>R.array.buffer));I.index&&E.push(I.index.array.buffer),self.postMessage({type:"decode",id:c.id,geometry:I},E)}catch(I){console.error(I),self.postMessage({type:"error",id:c.id,error:I.message})}finally{y.destroy(w)}}))}}}function d0e(r,e,n=!0){if(!e||!e.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!r.hasAttribute("position")||!r.hasAttribute("normal")||!r.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function a(p){if(p.normalized||p.isInterleavedBufferAttribute){const b=new Float32Array(p.count*p.itemSize);for(let y=0,w=0;y<p.count;y++)b[w++]=p.getX(y),b[w++]=p.getY(y),p.itemSize>2&&(b[w++]=p.getZ(y));return b}return p.array instanceof Float32Array?p.array:new Float32Array(p.array)}const c=r.index?r.toNonIndexed():r,h=e.generateTangents(a(c.attributes.position),a(c.attributes.normal),a(c.attributes.uv));if(n)for(let p=3;p<h.length;p+=4)h[p]*=-1;return c.setAttribute("tangent",new X.BufferAttribute(h,4)),r!==c&&r.copy(c),r}function f0e(r,e=!1){const n=r[0].index!==null,a=new Set(Object.keys(r[0].attributes)),c=new Set(Object.keys(r[0].morphAttributes)),h={},p={},b=r[0].morphTargetsRelative,y=new X.BufferGeometry;let w=0;for(let I=0;I<r.length;++I){const E=r[I];let R=0;if(n!==(E.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+I+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const k in E.attributes){if(!a.has(k))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+I+'. All geometries must have compatible attributes; make sure "'+k+'" attribute exists among all geometries, or in none of them.'),null;h[k]===void 0&&(h[k]=[]),h[k].push(E.attributes[k]),R++}if(R!==a.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+I+". Make sure all geometries have the same number of attributes."),null;if(b!==E.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+I+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const k in E.morphAttributes){if(!c.has(k))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+I+".  .morphAttributes must be consistent throughout all geometries."),null;p[k]===void 0&&(p[k]=[]),p[k].push(E.morphAttributes[k])}if(e){let k;if(n)k=E.index.count;else{if(E.attributes.position===void 0)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+I+". The geometry must have either an index or a position attribute"),null;k=E.attributes.position.count}y.addGroup(w,k,I),w+=k}}if(n){let I=0;const E=[];for(let R=0;R<r.length;++R){const k=r[R].index;for(let G=0;G<k.count;++G)E.push(k.getX(G)+I);I+=r[R].attributes.position.count}y.setIndex(E)}for(const I in h){const E=kR(h[I]);if(!E)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+I+" attribute."),null;y.setAttribute(I,E)}for(const I in p){const E=p[I][0].length;if(E===0)break;y.morphAttributes=y.morphAttributes||{},y.morphAttributes[I]=[];for(let R=0;R<E;++R){const k=[];for(let N=0;N<p[I].length;++N)k.push(p[I][N][R]);const G=kR(k);if(!G)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+I+" morphAttribute."),null;y.morphAttributes[I].push(G)}}return y}function kR(r){let e,n,a,c=-1,h=0;for(let w=0;w<r.length;++w){const I=r[w];if(e===void 0&&(e=I.array.constructor),e!==I.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(n===void 0&&(n=I.itemSize),n!==I.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(a===void 0&&(a=I.normalized),a!==I.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(c===-1&&(c=I.gpuType),c!==I.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;h+=I.count*n}const p=new e(h),b=new X.BufferAttribute(p,n,a);let y=0;for(let w=0;w<r.length;++w){const I=r[w];if(I.isInterleavedBufferAttribute){const E=y/n;for(let R=0,k=I.count;R<k;R++)for(let G=0;G<n;G++){const N=I.getComponent(R,G);b.setComponent(R+E,G,N)}}else p.set(I.array,y);y+=I.count*n}return c!==void 0&&(b.gpuType=c),b}function p0e(r){return r.isInstancedInterleavedBufferAttribute||r.isInterleavedBufferAttribute?i2(r):r.isInstancedBufferAttribute?new X.InstancedBufferAttribute().copy(r):new X.BufferAttribute().copy(r)}function m0e(r){let e,n=0,a=0;for(let w=0,I=r.length;w<I;++w){const E=r[w];if(e===void 0&&(e=E.array.constructor),e!==E.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;n+=E.array.length,a+=E.itemSize}const c=new X.InterleavedBuffer(new e(n),a);let h=0;const p=[],b=["getX","getY","getZ","getW"],y=["setX","setY","setZ","setW"];for(let w=0,I=r.length;w<I;w++){const E=r[w],R=E.itemSize,k=E.count,G=new X.InterleavedBufferAttribute(c,R,h,E.normalized);p.push(G),h+=R;for(let N=0;N<k;N++)for(let O=0;O<R;O++)G[y[O]](N,E[b[O]](N))}return p}function i2(r){const e=r.data.array.constructor,n=r.count,a=r.itemSize,c=r.normalized,h=new e(n*a);let p;p=r.isInstancedInterleavedBufferAttribute?new X.InstancedBufferAttribute(h,a,c,r.meshPerAttribute):new X.BufferAttribute(h,a,c);for(let b=0;b<n;b++)p.setX(b,r.getX(b)),a>=2&&p.setY(b,r.getY(b)),a>=3&&p.setZ(b,r.getZ(b)),a>=4&&p.setW(b,r.getW(b));return p}function g0e(r){const e=r.attributes,n=r.morphTargets,a=new Map;for(const c in e){const h=e[c];h.isInterleavedBufferAttribute&&(a.has(h)||a.set(h,i2(h)),e[c]=a.get(h))}for(const c in n){const h=n[c];h.isInterleavedBufferAttribute&&(a.has(h)||a.set(h,i2(h)),n[c]=a.get(h))}}function A0e(r){let e=0;for(const a in r.attributes){const c=r.getAttribute(a);e+=c.count*c.itemSize*c.array.BYTES_PER_ELEMENT}const n=r.getIndex();return e+=n?n.count*n.itemSize*n.array.BYTES_PER_ELEMENT:0,e}function b0e(r,e=1e-4){e=Math.max(e,Number.EPSILON);const n={},a=r.getIndex(),c=r.getAttribute("position"),h=a?a.count:c.count;let p=0;const b=Object.keys(r.attributes),y={},w={},I=[],E=["getX","getY","getZ","getW"],R=["setX","setY","setZ","setW"];for(let W=0,H=b.length;W<H;W++){const K=b[W],j=r.attributes[K];y[K]=new j.constructor(new j.array.constructor(j.count*j.itemSize),j.itemSize,j.normalized);const J=r.morphAttributes[K];J&&(w[K]||(w[K]=[]),J.forEach(((ee,re)=>{const Y=new ee.array.constructor(ee.count*ee.itemSize);w[K][re]=new ee.constructor(Y,ee.itemSize,ee.normalized)})))}const k=.5*e,G=Math.log10(1/e),N=Math.pow(10,G),O=k*N;for(let W=0;W<h;W++){const H=a?a.getX(W):W;let K="";for(let j=0,J=b.length;j<J;j++){const ee=b[j],re=r.getAttribute(ee),Y=re.itemSize;for(let ie=0;ie<Y;ie++)K+=~~(re[E[ie]](H)*N+O)+","}if(K in n)I.push(n[K]);else{for(let j=0,J=b.length;j<J;j++){const ee=b[j],re=r.getAttribute(ee),Y=r.morphAttributes[ee],ie=re.itemSize,ue=y[ee],Re=w[ee];for(let _e=0;_e<ie;_e++){const Pe=E[_e],rt=R[_e];if(ue[rt](p,re[Pe](H)),Y)for(let de=0,we=Y.length;de<we;de++)Re[de][rt](p,Y[de][Pe](H))}}n[K]=p,I.push(p),p++}}const D=r.clone();for(const W in r.attributes){const H=y[W];if(D.setAttribute(W,new H.constructor(H.array.slice(0,p*H.itemSize),H.itemSize,H.normalized)),W in w)for(let K=0;K<w[W].length;K++){const j=w[W][K];D.morphAttributes[W][K]=new j.constructor(j.array.slice(0,p*j.itemSize),j.itemSize,j.normalized)}}return D.setIndex(I),D}function BR(r,e){if(e===X.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),r;if(e===X.TriangleFanDrawMode||e===X.TriangleStripDrawMode){let n=r.getIndex();if(n===null){const p=[],b=r.getAttribute("position");if(b===void 0)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),r;for(let y=0;y<b.count;y++)p.push(y);r.setIndex(p),n=r.getIndex()}const a=n.count-2,c=[];if(e===X.TriangleFanDrawMode)for(let p=1;p<=a;p++)c.push(n.getX(0)),c.push(n.getX(p)),c.push(n.getX(p+1));else for(let p=0;p<a;p++)p%2==0?(c.push(n.getX(p)),c.push(n.getX(p+1)),c.push(n.getX(p+2))):(c.push(n.getX(p+2)),c.push(n.getX(p+1)),c.push(n.getX(p)));c.length/3!==a&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const h=r.clone();return h.setIndex(c),h.clearGroups(),h}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),r}function y0e(r){const e=new X.Vector3,n=new X.Vector3,a=new X.Vector3,c=new X.Vector3,h=new X.Vector3,p=new X.Vector3,b=new X.Vector3,y=new X.Vector3,w=new X.Vector3;function I(we,Le,Je,fe,Ve,Ne,gt,bt){e.fromBufferAttribute(Le,Ve),n.fromBufferAttribute(Le,Ne),a.fromBufferAttribute(Le,gt);const zt=we.morphTargetInfluences;if(Je&&zt){b.set(0,0,0),y.set(0,0,0),w.set(0,0,0);for(let Tt=0,Vt=Je.length;Tt<Vt;Tt++){const je=zt[Tt],_t=Je[Tt];je!==0&&(c.fromBufferAttribute(_t,Ve),h.fromBufferAttribute(_t,Ne),p.fromBufferAttribute(_t,gt),fe?(b.addScaledVector(c,je),y.addScaledVector(h,je),w.addScaledVector(p,je)):(b.addScaledVector(c.sub(e),je),y.addScaledVector(h.sub(n),je),w.addScaledVector(p.sub(a),je)))}e.add(b),n.add(y),a.add(w)}we.isSkinnedMesh&&(we.applyBoneTransform(Ve,e),we.applyBoneTransform(Ne,n),we.applyBoneTransform(gt,a)),bt[3*Ve+0]=e.x,bt[3*Ve+1]=e.y,bt[3*Ve+2]=e.z,bt[3*Ne+0]=n.x,bt[3*Ne+1]=n.y,bt[3*Ne+2]=n.z,bt[3*gt+0]=a.x,bt[3*gt+1]=a.y,bt[3*gt+2]=a.z}const E=r.geometry,R=r.material;let k,G,N;const O=E.index,D=E.attributes.position,W=E.morphAttributes.position,H=E.morphTargetsRelative,K=E.attributes.normal,j=E.morphAttributes.position,J=E.groups,ee=E.drawRange;let re,Y,ie,ue,Re,_e,Pe;const rt=new Float32Array(D.count*D.itemSize),de=new Float32Array(K.count*K.itemSize);if(O!==null)if(Array.isArray(R))for(re=0,ie=J.length;re<ie;re++)for(Re=J[re],_e=Math.max(Re.start,ee.start),Pe=Math.min(Re.start+Re.count,ee.start+ee.count),Y=_e,ue=Pe;Y<ue;Y+=3)k=O.getX(Y),G=O.getX(Y+1),N=O.getX(Y+2),I(r,D,W,H,k,G,N,rt),I(r,K,j,H,k,G,N,de);else for(_e=Math.max(0,ee.start),Pe=Math.min(O.count,ee.start+ee.count),re=_e,ie=Pe;re<ie;re+=3)k=O.getX(re),G=O.getX(re+1),N=O.getX(re+2),I(r,D,W,H,k,G,N,rt),I(r,K,j,H,k,G,N,de);else if(Array.isArray(R))for(re=0,ie=J.length;re<ie;re++)for(Re=J[re],_e=Math.max(Re.start,ee.start),Pe=Math.min(Re.start+Re.count,ee.start+ee.count),Y=_e,ue=Pe;Y<ue;Y+=3)k=Y,G=Y+1,N=Y+2,I(r,D,W,H,k,G,N,rt),I(r,K,j,H,k,G,N,de);else for(_e=Math.max(0,ee.start),Pe=Math.min(D.count,ee.start+ee.count),re=_e,ie=Pe;re<ie;re+=3)k=re,G=re+1,N=re+2,I(r,D,W,H,k,G,N,rt),I(r,K,j,H,k,G,N,de);return{positionAttribute:D,normalAttribute:K,morphedPositionAttribute:new X.Float32BufferAttribute(rt,3),morphedNormalAttribute:new X.Float32BufferAttribute(de,3)}}function v0e(r){if(r.groups.length===0)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),r;let e=r.groups;if(e=e.sort(((p,b)=>p.materialIndex!==b.materialIndex?p.materialIndex-b.materialIndex:p.start-b.start)),r.getIndex()===null){const p=r.getAttribute("position"),b=[];for(let y=0;y<p.count;y+=3)b.push(y,y+1,y+2);r.setIndex(b)}const n=r.getIndex(),a=[];for(let p=0;p<e.length;p++){const b=e[p],y=b.start,w=y+b.count;for(let I=y;I<w;I++)a.push(n.getX(I))}r.dispose(),r.setIndex(a);let c=0;for(let p=0;p<e.length;p++){const b=e[p];b.start=c,c+=b.count}let h=e[0];r.groups=[h];for(let p=1;p<e.length;p++){const b=e[p];h.materialIndex===b.materialIndex?h.count+=b.count:(h=b,r.groups.push(h))}return r}function x0e(r,e=Math.PI/3){const n=Math.cos(e),a=100*(1+1e-10),c=[new X.Vector3,new X.Vector3,new X.Vector3],h=new X.Vector3,p=new X.Vector3,b=new X.Vector3,y=new X.Vector3;function w(N){return`${~~(N.x*a)},${~~(N.y*a)},${~~(N.z*a)}`}const I=r.index?r.toNonIndexed():r,E=I.attributes.position,R={};for(let N=0,O=E.count/3;N<O;N++){const D=3*N,W=c[0].fromBufferAttribute(E,D+0),H=c[1].fromBufferAttribute(E,D+1),K=c[2].fromBufferAttribute(E,D+2);h.subVectors(K,H),p.subVectors(W,H);const j=new X.Vector3().crossVectors(h,p).normalize();for(let J=0;J<3;J++){const ee=w(c[J]);ee in R||(R[ee]=[]),R[ee].push(j)}}const k=new Float32Array(3*E.count),G=new X.BufferAttribute(k,3,!1);for(let N=0,O=E.count/3;N<O;N++){const D=3*N,W=c[0].fromBufferAttribute(E,D+0),H=c[1].fromBufferAttribute(E,D+1),K=c[2].fromBufferAttribute(E,D+2);h.subVectors(K,H),p.subVectors(W,H),b.crossVectors(h,p).normalize();for(let j=0;j<3;j++){const J=R[w(c[j])];y.set(0,0,0);for(let ee=0,re=J.length;ee<re;ee++){const Y=J[ee];b.dot(Y)>n&&y.add(Y)}y.normalize(),G.setXYZ(D+j,y.x,y.y,y.z)}}return I.setAttribute("normal",G),I}class zk extends X.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(n){return new I0e(n)})),this.register((function(n){return new T0e(n)})),this.register((function(n){return new F0e(n)})),this.register((function(n){return new O0e(n)})),this.register((function(n){return new G0e(n)})),this.register((function(n){return new _0e(n)})),this.register((function(n){return new R0e(n)})),this.register((function(n){return new k0e(n)})),this.register((function(n){return new B0e(n)})),this.register((function(n){return new S0e(n)})),this.register((function(n){return new L0e(n)})),this.register((function(n){return new M0e(n)})),this.register((function(n){return new D0e(n)})),this.register((function(n){return new N0e(n)})),this.register((function(n){return new C0e(n)})),this.register((function(n){return new U0e(n)})),this.register((function(n){return new P0e(n)}))}load(e,n,a,c){const h=this;let p;if(this.resourcePath!=="")p=this.resourcePath;else if(this.path!==""){const w=X.LoaderUtils.extractUrlBase(e);p=X.LoaderUtils.resolveURL(w,this.path)}else p=X.LoaderUtils.extractUrlBase(e);this.manager.itemStart(e);const b=function(w){c?c(w):console.error(w),h.manager.itemError(e),h.manager.itemEnd(e)},y=new X.FileLoader(this.manager);y.setPath(this.path),y.setResponseType("arraybuffer"),y.setRequestHeader(this.requestHeader),y.setWithCredentials(this.withCredentials),y.load(e,(function(w){try{h.parse(w,p,(function(I){n(I),h.manager.itemEnd(e)}),b)}catch(I){b(I)}}),a,b)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,n,a,c){let h;const p={},b={},y=new TextDecoder;if(typeof e=="string")h=JSON.parse(e);else if(e instanceof ArrayBuffer)if(y.decode(new Uint8Array(e,0,4))===OV){try{p[Mi.KHR_BINARY_GLTF]=new z0e(e)}catch(I){return void(c&&c(I))}h=JSON.parse(p[Mi.KHR_BINARY_GLTF].content)}else h=JSON.parse(y.decode(e));else h=e;if(h.asset===void 0||h.asset.version[0]<2)return void(c&&c(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const w=new q0e(h,{path:n||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});w.fileLoader.setRequestHeader(this.requestHeader);for(let I=0;I<this.pluginCallbacks.length;I++){const E=this.pluginCallbacks[I](w);E.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),b[E.name]=E,p[E.name]=!0}if(h.extensionsUsed)for(let I=0;I<h.extensionsUsed.length;++I){const E=h.extensionsUsed[I],R=h.extensionsRequired||[];switch(E){case Mi.KHR_MATERIALS_UNLIT:p[E]=new E0e;break;case Mi.KHR_DRACO_MESH_COMPRESSION:p[E]=new V0e(h,this.dracoLoader);break;case Mi.KHR_TEXTURE_TRANSFORM:p[E]=new W0e;break;case Mi.KHR_MESH_QUANTIZATION:p[E]=new H0e;break;default:R.indexOf(E)>=0&&b[E]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+E+'".')}}w.setExtensions(p),w.setPlugins(b),w.parse(a,c)}parseAsync(e,n){const a=this;return new Promise((function(c,h){a.parse(e,n,c,h)}))}}function w0e(){let r={};return{get:function(e){return r[e]},add:function(e,n){r[e]=n},remove:function(e){delete r[e]},removeAll:function(){r={}}}}const Mi={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class C0e{constructor(e){this.parser=e,this.name=Mi.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,n=this.parser.json.nodes||[];for(let a=0,c=n.length;a<c;a++){const h=n[a];h.extensions&&h.extensions[this.name]&&h.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,h.extensions[this.name].light)}}_loadLight(e){const n=this.parser,a="light:"+e;let c=n.cache.get(a);if(c)return c;const h=n.json,p=((h.extensions&&h.extensions[this.name]||{}).lights||[])[e];let b;const y=new X.Color(16777215);p.color!==void 0&&y.setRGB(p.color[0],p.color[1],p.color[2],X.LinearSRGBColorSpace);const w=p.range!==void 0?p.range:0;switch(p.type){case"directional":b=new X.DirectionalLight(y),b.target.position.set(0,0,-1),b.add(b.target);break;case"point":b=new X.PointLight(y),b.distance=w;break;case"spot":b=new X.SpotLight(y),b.distance=w,p.spot=p.spot||{},p.spot.innerConeAngle=p.spot.innerConeAngle!==void 0?p.spot.innerConeAngle:0,p.spot.outerConeAngle=p.spot.outerConeAngle!==void 0?p.spot.outerConeAngle:Math.PI/4,b.angle=p.spot.outerConeAngle,b.penumbra=1-p.spot.innerConeAngle/p.spot.outerConeAngle,b.target.position.set(0,0,-1),b.add(b.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+p.type)}return b.position.set(0,0,0),gh(b,p),p.intensity!==void 0&&(b.intensity=p.intensity),b.name=n.createUniqueName(p.name||"light_"+e),c=Promise.resolve(b),n.cache.add(a,c),c}getDependency(e,n){if(e==="light")return this._loadLight(n)}createNodeAttachment(e){const n=this,a=this.parser,c=a.json.nodes[e],h=(c.extensions&&c.extensions[this.name]||{}).light;return h===void 0?null:this._loadLight(h).then((function(p){return a._getNodeRef(n.cache,h,p)}))}}class E0e{constructor(){this.name=Mi.KHR_MATERIALS_UNLIT}getMaterialType(){return X.MeshBasicMaterial}extendParams(e,n,a){const c=[];e.color=new X.Color(1,1,1),e.opacity=1;const h=n.pbrMetallicRoughness;if(h){if(Array.isArray(h.baseColorFactor)){const p=h.baseColorFactor;e.color.setRGB(p[0],p[1],p[2],X.LinearSRGBColorSpace),e.opacity=p[3]}h.baseColorTexture!==void 0&&c.push(a.assignTexture(e,"map",h.baseColorTexture,X.SRGBColorSpace))}return Promise.all(c)}}class S0e{constructor(e){this.parser=e,this.name=Mi.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,n){const a=this.parser.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const c=a.extensions[this.name].emissiveStrength;return c!==void 0&&(n.emissiveIntensity=c),Promise.resolve()}}class I0e{constructor(e){this.parser=e,this.name=Mi.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return n.extensions&&n.extensions[this.name]?X.MeshPhysicalMaterial:null}extendMaterialParams(e,n){const a=this.parser,c=a.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const h=[],p=c.extensions[this.name];if(p.clearcoatFactor!==void 0&&(n.clearcoat=p.clearcoatFactor),p.clearcoatTexture!==void 0&&h.push(a.assignTexture(n,"clearcoatMap",p.clearcoatTexture)),p.clearcoatRoughnessFactor!==void 0&&(n.clearcoatRoughness=p.clearcoatRoughnessFactor),p.clearcoatRoughnessTexture!==void 0&&h.push(a.assignTexture(n,"clearcoatRoughnessMap",p.clearcoatRoughnessTexture)),p.clearcoatNormalTexture!==void 0&&(h.push(a.assignTexture(n,"clearcoatNormalMap",p.clearcoatNormalTexture)),p.clearcoatNormalTexture.scale!==void 0)){const b=p.clearcoatNormalTexture.scale;n.clearcoatNormalScale=new X.Vector2(b,b)}return Promise.all(h)}}class T0e{constructor(e){this.parser=e,this.name=Mi.KHR_MATERIALS_DISPERSION}getMaterialType(e){const n=this.parser.json.materials[e];return n.extensions&&n.extensions[this.name]?X.MeshPhysicalMaterial:null}extendMaterialParams(e,n){const a=this.parser.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const c=a.extensions[this.name];return n.dispersion=c.dispersion!==void 0?c.dispersion:0,Promise.resolve()}}class M0e{constructor(e){this.parser=e,this.name=Mi.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return n.extensions&&n.extensions[this.name]?X.MeshPhysicalMaterial:null}extendMaterialParams(e,n){const a=this.parser,c=a.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const h=[],p=c.extensions[this.name];return p.iridescenceFactor!==void 0&&(n.iridescence=p.iridescenceFactor),p.iridescenceTexture!==void 0&&h.push(a.assignTexture(n,"iridescenceMap",p.iridescenceTexture)),p.iridescenceIor!==void 0&&(n.iridescenceIOR=p.iridescenceIor),n.iridescenceThicknessRange===void 0&&(n.iridescenceThicknessRange=[100,400]),p.iridescenceThicknessMinimum!==void 0&&(n.iridescenceThicknessRange[0]=p.iridescenceThicknessMinimum),p.iridescenceThicknessMaximum!==void 0&&(n.iridescenceThicknessRange[1]=p.iridescenceThicknessMaximum),p.iridescenceThicknessTexture!==void 0&&h.push(a.assignTexture(n,"iridescenceThicknessMap",p.iridescenceThicknessTexture)),Promise.all(h)}}class _0e{constructor(e){this.parser=e,this.name=Mi.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return n.extensions&&n.extensions[this.name]?X.MeshPhysicalMaterial:null}extendMaterialParams(e,n){const a=this.parser,c=a.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const h=[];n.sheenColor=new X.Color(0,0,0),n.sheenRoughness=0,n.sheen=1;const p=c.extensions[this.name];if(p.sheenColorFactor!==void 0){const b=p.sheenColorFactor;n.sheenColor.setRGB(b[0],b[1],b[2],X.LinearSRGBColorSpace)}return p.sheenRoughnessFactor!==void 0&&(n.sheenRoughness=p.sheenRoughnessFactor),p.sheenColorTexture!==void 0&&h.push(a.assignTexture(n,"sheenColorMap",p.sheenColorTexture,X.SRGBColorSpace)),p.sheenRoughnessTexture!==void 0&&h.push(a.assignTexture(n,"sheenRoughnessMap",p.sheenRoughnessTexture)),Promise.all(h)}}class R0e{constructor(e){this.parser=e,this.name=Mi.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return n.extensions&&n.extensions[this.name]?X.MeshPhysicalMaterial:null}extendMaterialParams(e,n){const a=this.parser,c=a.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const h=[],p=c.extensions[this.name];return p.transmissionFactor!==void 0&&(n.transmission=p.transmissionFactor),p.transmissionTexture!==void 0&&h.push(a.assignTexture(n,"transmissionMap",p.transmissionTexture)),Promise.all(h)}}class k0e{constructor(e){this.parser=e,this.name=Mi.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return n.extensions&&n.extensions[this.name]?X.MeshPhysicalMaterial:null}extendMaterialParams(e,n){const a=this.parser,c=a.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const h=[],p=c.extensions[this.name];n.thickness=p.thicknessFactor!==void 0?p.thicknessFactor:0,p.thicknessTexture!==void 0&&h.push(a.assignTexture(n,"thicknessMap",p.thicknessTexture)),n.attenuationDistance=p.attenuationDistance||1/0;const b=p.attenuationColor||[1,1,1];return n.attenuationColor=new X.Color().setRGB(b[0],b[1],b[2],X.LinearSRGBColorSpace),Promise.all(h)}}class B0e{constructor(e){this.parser=e,this.name=Mi.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return n.extensions&&n.extensions[this.name]?X.MeshPhysicalMaterial:null}extendMaterialParams(e,n){const a=this.parser.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const c=a.extensions[this.name];return n.ior=c.ior!==void 0?c.ior:1.5,Promise.resolve()}}class L0e{constructor(e){this.parser=e,this.name=Mi.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return n.extensions&&n.extensions[this.name]?X.MeshPhysicalMaterial:null}extendMaterialParams(e,n){const a=this.parser,c=a.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const h=[],p=c.extensions[this.name];n.specularIntensity=p.specularFactor!==void 0?p.specularFactor:1,p.specularTexture!==void 0&&h.push(a.assignTexture(n,"specularIntensityMap",p.specularTexture));const b=p.specularColorFactor||[1,1,1];return n.specularColor=new X.Color().setRGB(b[0],b[1],b[2],X.LinearSRGBColorSpace),p.specularColorTexture!==void 0&&h.push(a.assignTexture(n,"specularColorMap",p.specularColorTexture,X.SRGBColorSpace)),Promise.all(h)}}class N0e{constructor(e){this.parser=e,this.name=Mi.EXT_MATERIALS_BUMP}getMaterialType(e){const n=this.parser.json.materials[e];return n.extensions&&n.extensions[this.name]?X.MeshPhysicalMaterial:null}extendMaterialParams(e,n){const a=this.parser,c=a.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const h=[],p=c.extensions[this.name];return n.bumpScale=p.bumpFactor!==void 0?p.bumpFactor:1,p.bumpTexture!==void 0&&h.push(a.assignTexture(n,"bumpMap",p.bumpTexture)),Promise.all(h)}}class D0e{constructor(e){this.parser=e,this.name=Mi.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const n=this.parser.json.materials[e];return n.extensions&&n.extensions[this.name]?X.MeshPhysicalMaterial:null}extendMaterialParams(e,n){const a=this.parser,c=a.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const h=[],p=c.extensions[this.name];return p.anisotropyStrength!==void 0&&(n.anisotropy=p.anisotropyStrength),p.anisotropyRotation!==void 0&&(n.anisotropyRotation=p.anisotropyRotation),p.anisotropyTexture!==void 0&&h.push(a.assignTexture(n,"anisotropyMap",p.anisotropyTexture)),Promise.all(h)}}class F0e{constructor(e){this.parser=e,this.name=Mi.KHR_TEXTURE_BASISU}loadTexture(e){const n=this.parser,a=n.json,c=a.textures[e];if(!c.extensions||!c.extensions[this.name])return null;const h=c.extensions[this.name],p=n.options.ktx2Loader;if(!p){if(a.extensionsRequired&&a.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return n.loadTextureImage(e,h.source,p)}}class O0e{constructor(e){this.parser=e,this.name=Mi.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const n=this.name,a=this.parser,c=a.json,h=c.textures[e];if(!h.extensions||!h.extensions[n])return null;const p=h.extensions[n],b=c.images[p.source];let y=a.textureLoader;if(b.uri){const w=a.options.manager.getHandler(b.uri);w!==null&&(y=w)}return this.detectSupport().then((function(w){if(w)return a.loadTextureImage(e,p.source,y);if(c.extensionsRequired&&c.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return a.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const n=new Image;n.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",n.onload=n.onerror=function(){e(n.height===1)}}))),this.isSupported}}class G0e{constructor(e){this.parser=e,this.name=Mi.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const n=this.name,a=this.parser,c=a.json,h=c.textures[e];if(!h.extensions||!h.extensions[n])return null;const p=h.extensions[n],b=c.images[p.source];let y=a.textureLoader;if(b.uri){const w=a.options.manager.getHandler(b.uri);w!==null&&(y=w)}return this.detectSupport().then((function(w){if(w)return a.loadTextureImage(e,p.source,y);if(c.extensionsRequired&&c.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return a.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const n=new Image;n.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",n.onload=n.onerror=function(){e(n.height===1)}}))),this.isSupported}}class U0e{constructor(e){this.name=Mi.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const n=this.parser.json,a=n.bufferViews[e];if(a.extensions&&a.extensions[this.name]){const c=a.extensions[this.name],h=this.parser.getDependency("buffer",c.buffer),p=this.parser.options.meshoptDecoder;if(!p||!p.supported){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return h.then((function(b){const y=c.byteOffset||0,w=c.byteLength||0,I=c.count,E=c.byteStride,R=new Uint8Array(b,y,w);return p.decodeGltfBufferAsync?p.decodeGltfBufferAsync(I,E,R,c.mode,c.filter).then((function(k){return k.buffer})):p.ready.then((function(){const k=new ArrayBuffer(I*E);return p.decodeGltfBuffer(new Uint8Array(k),I,E,R,c.mode,c.filter),k}))}))}return null}}class P0e{constructor(e){this.name=Mi.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const n=this.parser.json,a=n.nodes[e];if(!a.extensions||!a.extensions[this.name]||a.mesh===void 0)return null;const c=n.meshes[a.mesh];for(const y of c.primitives)if(y.mode!==_l.TRIANGLES&&y.mode!==_l.TRIANGLE_STRIP&&y.mode!==_l.TRIANGLE_FAN&&y.mode!==void 0)return null;const h=a.extensions[this.name].attributes,p=[],b={};for(const y in h)p.push(this.parser.getDependency("accessor",h[y]).then((w=>(b[y]=w,b[y]))));return p.length<1?null:(p.push(this.parser.createNodeMesh(e)),Promise.all(p).then((y=>{const w=y.pop(),I=w.isGroup?w.children:[w],E=y[0].count,R=[];for(const k of I){const G=new X.Matrix4,N=new X.Vector3,O=new X.Quaternion,D=new X.Vector3(1,1,1),W=new X.InstancedMesh(k.geometry,k.material,E);for(let H=0;H<E;H++)b.TRANSLATION&&N.fromBufferAttribute(b.TRANSLATION,H),b.ROTATION&&O.fromBufferAttribute(b.ROTATION,H),b.SCALE&&D.fromBufferAttribute(b.SCALE,H),W.setMatrixAt(H,G.compose(N,O,D));for(const H in b)if(H==="_COLOR_0"){const K=b[H];W.instanceColor=new X.InstancedBufferAttribute(K.array,K.itemSize,K.normalized)}else H!=="TRANSLATION"&&H!=="ROTATION"&&H!=="SCALE"&&k.geometry.setAttribute(H,b[H]);X.Object3D.prototype.copy.call(W,k),this.parser.assignFinalMaterial(W),R.push(W)}return w.isGroup?(w.clear(),w.add(...R),w):R[0]})))}}const OV="glTF";class z0e{constructor(e){this.name=Mi.KHR_BINARY_GLTF,this.content=null,this.body=null;const n=new DataView(e,0,12),a=new TextDecoder;if(this.header={magic:a.decode(new Uint8Array(e.slice(0,4))),version:n.getUint32(4,!0),length:n.getUint32(8,!0)},this.header.magic!==OV)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const c=this.header.length-12,h=new DataView(e,12);let p=0;for(;p<c;){const b=h.getUint32(p,!0);p+=4;const y=h.getUint32(p,!0);if(p+=4,y===1313821514){const w=new Uint8Array(e,12+p,b);this.content=a.decode(w)}else if(y===5130562){const w=12+p;this.body=e.slice(w,w+b)}p+=b}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class V0e{constructor(e,n){if(!n)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Mi.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=n,this.dracoLoader.preload()}decodePrimitive(e,n){const a=this.json,c=this.dracoLoader,h=e.extensions[this.name].bufferView,p=e.extensions[this.name].attributes,b={},y={},w={};for(const I in p){const E=LR[I]||I.toLowerCase();b[E]=p[I]}for(const I in e.attributes){const E=LR[I]||I.toLowerCase();if(p[I]!==void 0){const R=a.accessors[e.attributes[I]],k=j0[R.componentType];w[E]=k.name,y[E]=R.normalized===!0}}return n.getDependency("bufferView",h).then((function(I){return new Promise((function(E,R){c.decodeDracoFile(I,(function(k){for(const G in k.attributes){const N=k.attributes[G],O=y[G];O!==void 0&&(N.normalized=O)}E(k)}),b,w,X.LinearSRGBColorSpace,R)}))}))}}class W0e{constructor(){this.name=Mi.KHR_TEXTURE_TRANSFORM}extendTexture(e,n){return(n.texCoord!==void 0&&n.texCoord!==e.channel||n.offset!==void 0||n.rotation!==void 0||n.scale!==void 0)&&(e=e.clone(),n.texCoord!==void 0&&(e.channel=n.texCoord),n.offset!==void 0&&e.offset.fromArray(n.offset),n.rotation!==void 0&&(e.rotation=n.rotation),n.scale!==void 0&&e.repeat.fromArray(n.scale),e.needsUpdate=!0),e}}class H0e{constructor(){this.name=Mi.KHR_MESH_QUANTIZATION}}class GV extends X.Interpolant{constructor(e,n,a,c){super(e,n,a,c)}copySampleValue_(e){const n=this.resultBuffer,a=this.sampleValues,c=this.valueSize,h=e*c*3+c;for(let p=0;p!==c;p++)n[p]=a[h+p];return n}interpolate_(e,n,a,c){const h=this.resultBuffer,p=this.sampleValues,b=this.valueSize,y=2*b,w=3*b,I=c-n,E=(a-n)/I,R=E*E,k=R*E,G=e*w,N=G-w,O=-2*k+3*R,D=k-R,W=1-O,H=D-R+E;for(let K=0;K!==b;K++){const j=p[N+K+b],J=p[N+K+y]*I,ee=p[G+K+b],re=p[G+K]*I;h[K]=W*j+H*J+O*ee+D*re}return h}}const X0e=new X.Quaternion;class Q0e extends GV{interpolate_(e,n,a,c){const h=super.interpolate_(e,n,a,c);return X0e.fromArray(h).normalize().toArray(h),h}}const _l={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},j0={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},CG={9728:X.NearestFilter,9729:X.LinearFilter,9984:X.NearestMipmapNearestFilter,9985:X.LinearMipmapNearestFilter,9986:X.NearestMipmapLinearFilter,9987:X.LinearMipmapLinearFilter},EG={33071:X.ClampToEdgeWrapping,33648:X.MirroredRepeatWrapping,10497:X.RepeatWrapping},a_={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},LR={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Vd={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},K0e={CUBICSPLINE:void 0,LINEAR:X.InterpolateLinear,STEP:X.InterpolateDiscrete};function Z0e(r){return r.DefaultMaterial===void 0&&(r.DefaultMaterial=new X.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:X.FrontSide})),r.DefaultMaterial}function am(r,e,n){for(const a in n.extensions)r[a]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[a]=n.extensions[a])}function gh(r,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(r.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function $0e(r,e){if(r.updateMorphTargets(),e.weights!==void 0)for(let n=0,a=e.weights.length;n<a;n++)r.morphTargetInfluences[n]=e.weights[n];if(e.extras&&Array.isArray(e.extras.targetNames)){const n=e.extras.targetNames;if(r.morphTargetInfluences.length===n.length){r.morphTargetDictionary={};for(let a=0,c=n.length;a<c;a++)r.morphTargetDictionary[n[a]]=a}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Y0e(r){let e;const n=r.extensions&&r.extensions[Mi.KHR_DRACO_MESH_COMPRESSION];if(e=n?"draco:"+n.bufferView+":"+n.indices+":"+o_(n.attributes):r.indices+":"+o_(r.attributes)+":"+r.mode,r.targets!==void 0)for(let a=0,c=r.targets.length;a<c;a++)e+=":"+o_(r.targets[a]);return e}function o_(r){let e="";const n=Object.keys(r).sort();for(let a=0,c=n.length;a<c;a++)e+=n[a]+":"+r[n[a]]+";";return e}function NR(r){switch(r){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const j0e=new X.Matrix4;class q0e{constructor(e={},n={}){this.json=e,this.extensions={},this.plugins={},this.options=n,this.cache=new w0e,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let a=!1,c=-1,h=!1,p=-1;if(typeof navigator<"u"){const b=navigator.userAgent;a=/^((?!chrome|android).)*safari/i.test(b)===!0;const y=b.match(/Version\/(\d+)/);c=a&&y?parseInt(y[1],10):-1,h=b.indexOf("Firefox")>-1,p=h?b.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||a&&c<17||h&&p<98?this.textureLoader=new X.TextureLoader(this.options.manager):this.textureLoader=new X.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new X.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,n){const a=this,c=this.json,h=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll((function(p){return p._markDefs&&p._markDefs()})),Promise.all(this._invokeAll((function(p){return p.beforeRoot&&p.beforeRoot()}))).then((function(){return Promise.all([a.getDependencies("scene"),a.getDependencies("animation"),a.getDependencies("camera")])})).then((function(p){const b={scene:p[0][c.scene||0],scenes:p[0],animations:p[1],cameras:p[2],asset:c.asset,parser:a,userData:{}};return am(h,b,c),gh(b,c),Promise.all(a._invokeAll((function(y){return y.afterRoot&&y.afterRoot(b)}))).then((function(){for(const y of b.scenes)y.updateMatrixWorld();e(b)}))})).catch(n)}_markDefs(){const e=this.json.nodes||[],n=this.json.skins||[],a=this.json.meshes||[];for(let c=0,h=n.length;c<h;c++){const p=n[c].joints;for(let b=0,y=p.length;b<y;b++)e[p[b]].isBone=!0}for(let c=0,h=e.length;c<h;c++){const p=e[c];p.mesh!==void 0&&(this._addNodeRef(this.meshCache,p.mesh),p.skin!==void 0&&(a[p.mesh].isSkinnedMesh=!0)),p.camera!==void 0&&this._addNodeRef(this.cameraCache,p.camera)}}_addNodeRef(e,n){n!==void 0&&(e.refs[n]===void 0&&(e.refs[n]=e.uses[n]=0),e.refs[n]++)}_getNodeRef(e,n,a){if(e.refs[n]<=1)return a;const c=a.clone(),h=(p,b)=>{const y=this.associations.get(p);y!=null&&this.associations.set(b,y);for(const[w,I]of p.children.entries())h(I,b.children[w])};return h(a,c),c.name+="_instance_"+e.uses[n]++,c}_invokeOne(e){const n=Object.values(this.plugins);n.push(this);for(let a=0;a<n.length;a++){const c=e(n[a]);if(c)return c}return null}_invokeAll(e){const n=Object.values(this.plugins);n.unshift(this);const a=[];for(let c=0;c<n.length;c++){const h=e(n[c]);h&&a.push(h)}return a}getDependency(e,n){const a=e+":"+n;let c=this.cache.get(a);if(!c){switch(e){case"scene":c=this.loadScene(n);break;case"node":c=this._invokeOne((function(h){return h.loadNode&&h.loadNode(n)}));break;case"mesh":c=this._invokeOne((function(h){return h.loadMesh&&h.loadMesh(n)}));break;case"accessor":c=this.loadAccessor(n);break;case"bufferView":c=this._invokeOne((function(h){return h.loadBufferView&&h.loadBufferView(n)}));break;case"buffer":c=this.loadBuffer(n);break;case"material":c=this._invokeOne((function(h){return h.loadMaterial&&h.loadMaterial(n)}));break;case"texture":c=this._invokeOne((function(h){return h.loadTexture&&h.loadTexture(n)}));break;case"skin":c=this.loadSkin(n);break;case"animation":c=this._invokeOne((function(h){return h.loadAnimation&&h.loadAnimation(n)}));break;case"camera":c=this.loadCamera(n);break;default:if(c=this._invokeOne((function(h){return h!=this&&h.getDependency&&h.getDependency(e,n)})),!c)throw new Error("Unknown type: "+e)}this.cache.add(a,c)}return c}getDependencies(e){let n=this.cache.get(e);if(!n){const a=this,c=this.json[e+(e==="mesh"?"es":"s")]||[];n=Promise.all(c.map((function(h,p){return a.getDependency(e,p)}))),this.cache.add(e,n)}return n}loadBuffer(e){const n=this.json.buffers[e],a=this.fileLoader;if(n.type&&n.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+n.type+" buffer type is not supported.");if(n.uri===void 0&&e===0)return Promise.resolve(this.extensions[Mi.KHR_BINARY_GLTF].body);const c=this.options;return new Promise((function(h,p){a.load(X.LoaderUtils.resolveURL(n.uri,c.path),h,void 0,(function(){p(new Error('THREE.GLTFLoader: Failed to load buffer "'+n.uri+'".'))}))}))}loadBufferView(e){const n=this.json.bufferViews[e];return this.getDependency("buffer",n.buffer).then((function(a){const c=n.byteLength||0,h=n.byteOffset||0;return a.slice(h,h+c)}))}loadAccessor(e){const n=this,a=this.json,c=this.json.accessors[e];if(c.bufferView===void 0&&c.sparse===void 0){const p=a_[c.type],b=j0[c.componentType],y=c.normalized===!0,w=new b(c.count*p);return Promise.resolve(new X.BufferAttribute(w,p,y))}const h=[];return c.bufferView!==void 0?h.push(this.getDependency("bufferView",c.bufferView)):h.push(null),c.sparse!==void 0&&(h.push(this.getDependency("bufferView",c.sparse.indices.bufferView)),h.push(this.getDependency("bufferView",c.sparse.values.bufferView))),Promise.all(h).then((function(p){const b=p[0],y=a_[c.type],w=j0[c.componentType],I=w.BYTES_PER_ELEMENT,E=I*y,R=c.byteOffset||0,k=c.bufferView!==void 0?a.bufferViews[c.bufferView].byteStride:void 0,G=c.normalized===!0;let N,O;if(k&&k!==E){const D=Math.floor(R/k),W="InterleavedBuffer:"+c.bufferView+":"+c.componentType+":"+D+":"+c.count;let H=n.cache.get(W);H||(N=new w(b,D*k,c.count*k/I),H=new X.InterleavedBuffer(N,k/I),n.cache.add(W,H)),O=new X.InterleavedBufferAttribute(H,y,R%k/I,G)}else N=b===null?new w(c.count*y):new w(b,R,c.count*y),O=new X.BufferAttribute(N,y,G);if(c.sparse!==void 0){const D=a_.SCALAR,W=j0[c.sparse.indices.componentType],H=c.sparse.indices.byteOffset||0,K=c.sparse.values.byteOffset||0,j=new W(p[1],H,c.sparse.count*D),J=new w(p[2],K,c.sparse.count*y);b!==null&&(O=new X.BufferAttribute(O.array.slice(),O.itemSize,O.normalized)),O.normalized=!1;for(let ee=0,re=j.length;ee<re;ee++){const Y=j[ee];if(O.setX(Y,J[ee*y]),y>=2&&O.setY(Y,J[ee*y+1]),y>=3&&O.setZ(Y,J[ee*y+2]),y>=4&&O.setW(Y,J[ee*y+3]),y>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}O.normalized=G}return O}))}loadTexture(e){const n=this.json,a=this.options,c=n.textures[e].source,h=n.images[c];let p=this.textureLoader;if(h.uri){const b=a.manager.getHandler(h.uri);b!==null&&(p=b)}return this.loadTextureImage(e,c,p)}loadTextureImage(e,n,a){const c=this,h=this.json,p=h.textures[e],b=h.images[n],y=(b.uri||b.bufferView)+":"+p.sampler;if(this.textureCache[y])return this.textureCache[y];const w=this.loadImageSource(n,a).then((function(I){I.flipY=!1,I.name=p.name||b.name||"",I.name===""&&typeof b.uri=="string"&&b.uri.startsWith("data:image/")===!1&&(I.name=b.uri);const E=(h.samplers||{})[p.sampler]||{};return I.magFilter=CG[E.magFilter]||X.LinearFilter,I.minFilter=CG[E.minFilter]||X.LinearMipmapLinearFilter,I.wrapS=EG[E.wrapS]||X.RepeatWrapping,I.wrapT=EG[E.wrapT]||X.RepeatWrapping,I.generateMipmaps=!I.isCompressedTexture&&I.minFilter!==X.NearestFilter&&I.minFilter!==X.LinearFilter,c.associations.set(I,{textures:e}),I})).catch((function(){return null}));return this.textureCache[y]=w,w}loadImageSource(e,n){const a=this.json,c=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then((I=>I.clone()));const h=a.images[e],p=self.URL||self.webkitURL;let b=h.uri||"",y=!1;if(h.bufferView!==void 0)b=this.getDependency("bufferView",h.bufferView).then((function(I){y=!0;const E=new Blob([I],{type:h.mimeType});return b=p.createObjectURL(E),b}));else if(h.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const w=Promise.resolve(b).then((function(I){return new Promise((function(E,R){let k=E;n.isImageBitmapLoader===!0&&(k=function(G){const N=new X.Texture(G);N.needsUpdate=!0,E(N)}),n.load(X.LoaderUtils.resolveURL(I,c.path),k,void 0,R)}))})).then((function(I){var E;return y===!0&&p.revokeObjectURL(b),gh(I,h),I.userData.mimeType=h.mimeType||((E=h.uri).search(/\.jpe?g($|\?)/i)>0||E.search(/^data\:image\/jpeg/)===0?"image/jpeg":E.search(/\.webp($|\?)/i)>0||E.search(/^data\:image\/webp/)===0?"image/webp":E.search(/\.ktx2($|\?)/i)>0||E.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"),I})).catch((function(I){throw console.error("THREE.GLTFLoader: Couldn't load texture",b),I}));return this.sourceCache[e]=w,w}assignTexture(e,n,a,c){const h=this;return this.getDependency("texture",a.index).then((function(p){if(!p)return null;if(a.texCoord!==void 0&&a.texCoord>0&&((p=p.clone()).channel=a.texCoord),h.extensions[Mi.KHR_TEXTURE_TRANSFORM]){const b=a.extensions!==void 0?a.extensions[Mi.KHR_TEXTURE_TRANSFORM]:void 0;if(b){const y=h.associations.get(p);p=h.extensions[Mi.KHR_TEXTURE_TRANSFORM].extendTexture(p,b),h.associations.set(p,y)}}return c!==void 0&&(p.colorSpace=c),e[n]=p,p}))}assignFinalMaterial(e){const n=e.geometry;let a=e.material;const c=n.attributes.tangent===void 0,h=n.attributes.color!==void 0,p=n.attributes.normal===void 0;if(e.isPoints){const b="PointsMaterial:"+a.uuid;let y=this.cache.get(b);y||(y=new X.PointsMaterial,X.Material.prototype.copy.call(y,a),y.color.copy(a.color),y.map=a.map,y.sizeAttenuation=!1,this.cache.add(b,y)),a=y}else if(e.isLine){const b="LineBasicMaterial:"+a.uuid;let y=this.cache.get(b);y||(y=new X.LineBasicMaterial,X.Material.prototype.copy.call(y,a),y.color.copy(a.color),y.map=a.map,this.cache.add(b,y)),a=y}if(c||h||p){let b="ClonedMaterial:"+a.uuid+":";c&&(b+="derivative-tangents:"),h&&(b+="vertex-colors:"),p&&(b+="flat-shading:");let y=this.cache.get(b);y||(y=a.clone(),h&&(y.vertexColors=!0),p&&(y.flatShading=!0),c&&(y.normalScale&&(y.normalScale.y*=-1),y.clearcoatNormalScale&&(y.clearcoatNormalScale.y*=-1)),this.cache.add(b,y),this.associations.set(y,this.associations.get(a))),a=y}e.material=a}getMaterialType(){return X.MeshStandardMaterial}loadMaterial(e){const n=this,a=this.json,c=this.extensions,h=a.materials[e];let p;const b={},y=[];if((h.extensions||{})[Mi.KHR_MATERIALS_UNLIT]){const I=c[Mi.KHR_MATERIALS_UNLIT];p=I.getMaterialType(),y.push(I.extendParams(b,h,n))}else{const I=h.pbrMetallicRoughness||{};if(b.color=new X.Color(1,1,1),b.opacity=1,Array.isArray(I.baseColorFactor)){const E=I.baseColorFactor;b.color.setRGB(E[0],E[1],E[2],X.LinearSRGBColorSpace),b.opacity=E[3]}I.baseColorTexture!==void 0&&y.push(n.assignTexture(b,"map",I.baseColorTexture,X.SRGBColorSpace)),b.metalness=I.metallicFactor!==void 0?I.metallicFactor:1,b.roughness=I.roughnessFactor!==void 0?I.roughnessFactor:1,I.metallicRoughnessTexture!==void 0&&(y.push(n.assignTexture(b,"metalnessMap",I.metallicRoughnessTexture)),y.push(n.assignTexture(b,"roughnessMap",I.metallicRoughnessTexture))),p=this._invokeOne((function(E){return E.getMaterialType&&E.getMaterialType(e)})),y.push(Promise.all(this._invokeAll((function(E){return E.extendMaterialParams&&E.extendMaterialParams(e,b)}))))}h.doubleSided===!0&&(b.side=X.DoubleSide);const w=h.alphaMode||"OPAQUE";if(w==="BLEND"?(b.transparent=!0,b.depthWrite=!1):(b.transparent=!1,w==="MASK"&&(b.alphaTest=h.alphaCutoff!==void 0?h.alphaCutoff:.5)),h.normalTexture!==void 0&&p!==X.MeshBasicMaterial&&(y.push(n.assignTexture(b,"normalMap",h.normalTexture)),b.normalScale=new X.Vector2(1,1),h.normalTexture.scale!==void 0)){const I=h.normalTexture.scale;b.normalScale.set(I,I)}if(h.occlusionTexture!==void 0&&p!==X.MeshBasicMaterial&&(y.push(n.assignTexture(b,"aoMap",h.occlusionTexture)),h.occlusionTexture.strength!==void 0&&(b.aoMapIntensity=h.occlusionTexture.strength)),h.emissiveFactor!==void 0&&p!==X.MeshBasicMaterial){const I=h.emissiveFactor;b.emissive=new X.Color().setRGB(I[0],I[1],I[2],X.LinearSRGBColorSpace)}return h.emissiveTexture!==void 0&&p!==X.MeshBasicMaterial&&y.push(n.assignTexture(b,"emissiveMap",h.emissiveTexture,X.SRGBColorSpace)),Promise.all(y).then((function(){const I=new p(b);return h.name&&(I.name=h.name),gh(I,h),n.associations.set(I,{materials:e}),h.extensions&&am(c,I,h),I}))}createUniqueName(e){const n=X.PropertyBinding.sanitizeNodeName(e||"");return n in this.nodeNamesUsed?n+"_"+ ++this.nodeNamesUsed[n]:(this.nodeNamesUsed[n]=0,n)}loadGeometries(e){const n=this,a=this.extensions,c=this.primitiveCache;function h(b){return a[Mi.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(b,n).then((function(y){return SG(y,b,n)}))}const p=[];for(let b=0,y=e.length;b<y;b++){const w=e[b],I=Y0e(w),E=c[I];if(E)p.push(E.promise);else{let R;R=w.extensions&&w.extensions[Mi.KHR_DRACO_MESH_COMPRESSION]?h(w):SG(new X.BufferGeometry,w,n),c[I]={primitive:w,promise:R},p.push(R)}}return Promise.all(p)}loadMesh(e){const n=this,a=this.json,c=this.extensions,h=a.meshes[e],p=h.primitives,b=[];for(let y=0,w=p.length;y<w;y++){const I=p[y].material===void 0?Z0e(this.cache):this.getDependency("material",p[y].material);b.push(I)}return b.push(n.loadGeometries(p)),Promise.all(b).then((function(y){const w=y.slice(0,y.length-1),I=y[y.length-1],E=[];for(let k=0,G=I.length;k<G;k++){const N=I[k],O=p[k];let D;const W=w[k];if(O.mode===_l.TRIANGLES||O.mode===_l.TRIANGLE_STRIP||O.mode===_l.TRIANGLE_FAN||O.mode===void 0)D=h.isSkinnedMesh===!0?new X.SkinnedMesh(N,W):new X.Mesh(N,W),D.isSkinnedMesh===!0&&D.normalizeSkinWeights(),O.mode===_l.TRIANGLE_STRIP?D.geometry=BR(D.geometry,X.TriangleStripDrawMode):O.mode===_l.TRIANGLE_FAN&&(D.geometry=BR(D.geometry,X.TriangleFanDrawMode));else if(O.mode===_l.LINES)D=new X.LineSegments(N,W);else if(O.mode===_l.LINE_STRIP)D=new X.Line(N,W);else if(O.mode===_l.LINE_LOOP)D=new X.LineLoop(N,W);else{if(O.mode!==_l.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+O.mode);D=new X.Points(N,W)}Object.keys(D.geometry.morphAttributes).length>0&&$0e(D,h),D.name=n.createUniqueName(h.name||"mesh_"+e),gh(D,h),O.extensions&&am(c,D,O),n.assignFinalMaterial(D),E.push(D)}for(let k=0,G=E.length;k<G;k++)n.associations.set(E[k],{meshes:e,primitives:k});if(E.length===1)return h.extensions&&am(c,E[0],h),E[0];const R=new X.Group;h.extensions&&am(c,R,h),n.associations.set(R,{meshes:e});for(let k=0,G=E.length;k<G;k++)R.add(E[k]);return R}))}loadCamera(e){let n;const a=this.json.cameras[e],c=a[a.type];if(c)return a.type==="perspective"?n=new X.PerspectiveCamera(X.MathUtils.radToDeg(c.yfov),c.aspectRatio||1,c.znear||1,c.zfar||2e6):a.type==="orthographic"&&(n=new X.OrthographicCamera(-c.xmag,c.xmag,c.ymag,-c.ymag,c.znear,c.zfar)),a.name&&(n.name=this.createUniqueName(a.name)),gh(n,a),Promise.resolve(n);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const n=this.json.skins[e],a=[];for(let c=0,h=n.joints.length;c<h;c++)a.push(this._loadNodeShallow(n.joints[c]));return n.inverseBindMatrices!==void 0?a.push(this.getDependency("accessor",n.inverseBindMatrices)):a.push(null),Promise.all(a).then((function(c){const h=c.pop(),p=c,b=[],y=[];for(let w=0,I=p.length;w<I;w++){const E=p[w];if(E){b.push(E);const R=new X.Matrix4;h!==null&&R.fromArray(h.array,16*w),y.push(R)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',n.joints[w])}return new X.Skeleton(b,y)}))}loadAnimation(e){const n=this.json,a=this,c=n.animations[e],h=c.name?c.name:"animation_"+e,p=[],b=[],y=[],w=[],I=[];for(let E=0,R=c.channels.length;E<R;E++){const k=c.channels[E],G=c.samplers[k.sampler],N=k.target,O=N.node,D=c.parameters!==void 0?c.parameters[G.input]:G.input,W=c.parameters!==void 0?c.parameters[G.output]:G.output;N.node!==void 0&&(p.push(this.getDependency("node",O)),b.push(this.getDependency("accessor",D)),y.push(this.getDependency("accessor",W)),w.push(G),I.push(N))}return Promise.all([Promise.all(p),Promise.all(b),Promise.all(y),Promise.all(w),Promise.all(I)]).then((function(E){const R=E[0],k=E[1],G=E[2],N=E[3],O=E[4],D=[];for(let W=0,H=R.length;W<H;W++){const K=R[W],j=k[W],J=G[W],ee=N[W],re=O[W];if(K===void 0)continue;K.updateMatrix&&K.updateMatrix();const Y=a._createAnimationTracks(K,j,J,ee,re);if(Y)for(let ie=0;ie<Y.length;ie++)D.push(Y[ie])}return new X.AnimationClip(h,void 0,D)}))}createNodeMesh(e){const n=this.json,a=this,c=n.nodes[e];return c.mesh===void 0?null:a.getDependency("mesh",c.mesh).then((function(h){const p=a._getNodeRef(a.meshCache,c.mesh,h);return c.weights!==void 0&&p.traverse((function(b){if(b.isMesh)for(let y=0,w=c.weights.length;y<w;y++)b.morphTargetInfluences[y]=c.weights[y]})),p}))}loadNode(e){const n=this,a=this.json.nodes[e],c=n._loadNodeShallow(e),h=[],p=a.children||[];for(let y=0,w=p.length;y<w;y++)h.push(n.getDependency("node",p[y]));const b=a.skin===void 0?Promise.resolve(null):n.getDependency("skin",a.skin);return Promise.all([c,Promise.all(h),b]).then((function(y){const w=y[0],I=y[1],E=y[2];E!==null&&w.traverse((function(R){R.isSkinnedMesh&&R.bind(E,j0e)}));for(let R=0,k=I.length;R<k;R++)w.add(I[R]);return w}))}_loadNodeShallow(e){const n=this.json,a=this.extensions,c=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const h=n.nodes[e],p=h.name?c.createUniqueName(h.name):"",b=[],y=c._invokeOne((function(w){return w.createNodeMesh&&w.createNodeMesh(e)}));return y&&b.push(y),h.camera!==void 0&&b.push(c.getDependency("camera",h.camera).then((function(w){return c._getNodeRef(c.cameraCache,h.camera,w)}))),c._invokeAll((function(w){return w.createNodeAttachment&&w.createNodeAttachment(e)})).forEach((function(w){b.push(w)})),this.nodeCache[e]=Promise.all(b).then((function(w){let I;if(I=h.isBone===!0?new X.Bone:w.length>1?new X.Group:w.length===1?w[0]:new X.Object3D,I!==w[0])for(let E=0,R=w.length;E<R;E++)I.add(w[E]);if(h.name&&(I.userData.name=h.name,I.name=p),gh(I,h),h.extensions&&am(a,I,h),h.matrix!==void 0){const E=new X.Matrix4;E.fromArray(h.matrix),I.applyMatrix4(E)}else h.translation!==void 0&&I.position.fromArray(h.translation),h.rotation!==void 0&&I.quaternion.fromArray(h.rotation),h.scale!==void 0&&I.scale.fromArray(h.scale);return c.associations.has(I)||c.associations.set(I,{}),c.associations.get(I).nodes=e,I})),this.nodeCache[e]}loadScene(e){const n=this.extensions,a=this.json.scenes[e],c=this,h=new X.Group;a.name&&(h.name=c.createUniqueName(a.name)),gh(h,a),a.extensions&&am(n,h,a);const p=a.nodes||[],b=[];for(let y=0,w=p.length;y<w;y++)b.push(c.getDependency("node",p[y]));return Promise.all(b).then((function(y){for(let w=0,I=y.length;w<I;w++)h.add(y[w]);return c.associations=(w=>{const I=new Map;for(const[E,R]of c.associations)(E instanceof X.Material||E instanceof X.Texture)&&I.set(E,R);return w.traverse((E=>{const R=c.associations.get(E);R!=null&&I.set(E,R)})),I})(h),h}))}_createAnimationTracks(e,n,a,c,h){const p=[],b=e.name?e.name:e.uuid,y=[];let w;switch(Vd[h.path]===Vd.weights?e.traverse((function(R){R.morphTargetInfluences&&y.push(R.name?R.name:R.uuid)})):y.push(b),Vd[h.path]){case Vd.weights:w=X.NumberKeyframeTrack;break;case Vd.rotation:w=X.QuaternionKeyframeTrack;break;case Vd.position:case Vd.scale:w=X.VectorKeyframeTrack;break;default:w=a.itemSize===1?X.NumberKeyframeTrack:X.VectorKeyframeTrack}const I=c.interpolation!==void 0?K0e[c.interpolation]:X.InterpolateLinear,E=this._getArrayFromAccessor(a);for(let R=0,k=y.length;R<k;R++){const G=new w(y[R]+"."+Vd[h.path],n.array,E,I);c.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(G),p.push(G)}return p}_getArrayFromAccessor(e){let n=e.array;if(e.normalized){const a=NR(n.constructor),c=new Float32Array(n.length);for(let h=0,p=n.length;h<p;h++)c[h]=n[h]*a;n=c}return n}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(n){return new(this instanceof X.QuaternionKeyframeTrack?Q0e:GV)(this.times,this.values,this.getValueSize()/3,n)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function SG(r,e,n){const a=e.attributes,c=[];function h(p,b){return n.getDependency("accessor",p).then((function(y){r.setAttribute(b,y)}))}for(const p in a){const b=LR[p]||p.toLowerCase();b in r.attributes||c.push(h(a[p],b))}if(e.indices!==void 0&&!r.index){const p=n.getDependency("accessor",e.indices).then((function(b){r.setIndex(b)}));c.push(p)}return X.ColorManagement.workingColorSpace!==X.LinearSRGBColorSpace&&"COLOR_0"in a&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${X.ColorManagement.workingColorSpace}" not supported.`),gh(r,e),(function(p,b,y){const w=b.attributes,I=new X.Box3;if(w.POSITION===void 0)return;{const k=y.json.accessors[w.POSITION],G=k.min,N=k.max;if(G===void 0||N===void 0)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(I.set(new X.Vector3(G[0],G[1],G[2]),new X.Vector3(N[0],N[1],N[2])),k.normalized){const O=NR(j0[k.componentType]);I.min.multiplyScalar(O),I.max.multiplyScalar(O)}}const E=b.targets;if(E!==void 0){const k=new X.Vector3,G=new X.Vector3;for(let N=0,O=E.length;N<O;N++){const D=E[N];if(D.POSITION!==void 0){const W=y.json.accessors[D.POSITION],H=W.min,K=W.max;if(H!==void 0&&K!==void 0){if(G.setX(Math.max(Math.abs(H[0]),Math.abs(K[0]))),G.setY(Math.max(Math.abs(H[1]),Math.abs(K[1]))),G.setZ(Math.max(Math.abs(H[2]),Math.abs(K[2]))),W.normalized){const j=NR(j0[W.componentType]);G.multiplyScalar(j)}k.max(G)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}I.expandByVector(k)}p.boundingBox=I;const R=new X.Sphere;I.getCenter(R.center),R.radius=I.min.distanceTo(I.max)/2,p.boundingSphere=R})(r,e,n),Promise.all(c).then((function(){return e.targets!==void 0?(function(p,b,y){let w=!1,I=!1,E=!1;for(let N=0,O=b.length;N<O;N++){const D=b[N];if(D.POSITION!==void 0&&(w=!0),D.NORMAL!==void 0&&(I=!0),D.COLOR_0!==void 0&&(E=!0),w&&I&&E)break}if(!w&&!I&&!E)return Promise.resolve(p);const R=[],k=[],G=[];for(let N=0,O=b.length;N<O;N++){const D=b[N];if(w){const W=D.POSITION!==void 0?y.getDependency("accessor",D.POSITION):p.attributes.position;R.push(W)}if(I){const W=D.NORMAL!==void 0?y.getDependency("accessor",D.NORMAL):p.attributes.normal;k.push(W)}if(E){const W=D.COLOR_0!==void 0?y.getDependency("accessor",D.COLOR_0):p.attributes.color;G.push(W)}}return Promise.all([Promise.all(R),Promise.all(k),Promise.all(G)]).then((function(N){const O=N[0],D=N[1],W=N[2];return w&&(p.morphAttributes.position=O),I&&(p.morphAttributes.normal=D),E&&(p.morphAttributes.color=W),p.morphTargetsRelative=!0,p}))})(r,e.targets,n):r}))}class J0e{constructor(e=4){this.pool=e,this.queue=[],this.workers=[],this.workersResolve=[],this.workerStatus=0}_initWorker(e){if(!this.workers[e]){const n=this.workerCreator();n.addEventListener("message",this._onMessage.bind(this,e)),this.workers[e]=n}}_getIdleWorker(){for(let e=0;e<this.pool;e++)if(!(this.workerStatus&1<<e))return e;return-1}_onMessage(e,n){const a=this.workersResolve[e];if(a&&a(n),this.queue.length){const{resolve:c,msg:h,transfer:p}=this.queue.shift();this.workersResolve[e]=c,this.workers[e].postMessage(h,p)}else this.workerStatus^=1<<e}setWorkerCreator(e){this.workerCreator=e}setWorkerLimit(e){this.pool=e}postMessage(e,n){return new Promise((a=>{const c=this._getIdleWorker();c!==-1?(this._initWorker(c),this.workerStatus|=1<<c,this.workersResolve[c]=a,this.workers[c].postMessage(e,n)):this.queue.push({resolve:a,msg:e,transfer:n})}))}dispose(){this.workers.forEach((e=>e.terminate())),this.workersResolve.length=0,this.workers.length=0,this.queue.length=0,this.workerStatus=0}}const UV=9,PV=15,zV=16,VV=22,WV=37,HV=43,XV=76,QV=83,KV=97,ZV=100,$V=103,YV=109,jV=165,qV=166,Vk=1000066e3;class eAe{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=0,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:0,descriptorBlockSize:0,versionNumber:2,colorModel:0,colorPrimaries:1,transferFunction:2,flags:0,texelBlockDimension:[0,0,0,0],bytesPlane:[0,0,0,0,0,0,0,0],samples:[]}],this.keyValue={},this.globalData=null}}class zy{constructor(e,n,a,c){this._dataView=void 0,this._littleEndian=void 0,this._offset=void 0,this._dataView=new DataView(e.buffer,e.byteOffset+n,a),this._littleEndian=c,this._offset=0}_nextUint8(){const e=this._dataView.getUint8(this._offset);return this._offset+=1,e}_nextUint16(){const e=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,e}_nextUint32(){const e=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint64(){const e=this._dataView.getUint32(this._offset,this._littleEndian)+4294967296*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,e}_nextInt32(){const e=this._dataView.getInt32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint8Array(e){const n=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._offset,e);return this._offset+=e,n}_skip(e){return this._offset+=e,this}_scan(e,n){n===void 0&&(n=0);const a=this._offset;let c=0;for(;this._dataView.getUint8(this._offset)!==n&&c<e;)c++,this._offset++;return c<e&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+a,c)}}const $a=[171,75,84,88,32,50,48,187,13,10,26,10];function IG(r){return new TextDecoder().decode(r)}var tAe=Nn(9922).hp;let l_,mh,DR;const c_={env:{emscripten_notify_memory_growth:function(r){DR=new Uint8Array(mh.exports.memory.buffer)}}};class nAe{init(){return l_||(l_=typeof fetch<"u"?fetch("data:application/wasm;base64,"+TG).then((e=>e.arrayBuffer())).then((e=>WebAssembly.instantiate(e,c_))).then(this._init):WebAssembly.instantiate(tAe.from(TG,"base64"),c_).then(this._init),l_)}_init(e){mh=e.instance,c_.env.emscripten_notify_memory_growth(0)}decode(e,n=0){if(!mh)throw new Error("ZSTDDecoder: Await .init() before decoding.");const a=e.byteLength,c=mh.exports.malloc(a);DR.set(e,c),n=n||Number(mh.exports.ZSTD_findDecompressedSize(c,a));const h=mh.exports.malloc(n),p=mh.exports.ZSTD_decompress(h,n,c,a),b=DR.slice(h,h+p);return mh.exports.free(c),mh.exports.free(h),b}}const TG="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",u_=new WeakMap;let h_,d_=0;class qo extends X.Loader{constructor(e){super(e),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerPool=new J0e,this.workerSourceURL="",this.workerConfig=null,typeof MSC_TRANSCODER<"u"&&console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(e){return this.transcoderPath=e,this}setWorkerLimit(e){return this.workerPool.setWorkerLimit(e),this}async detectSupportAsync(e){return this.workerConfig={astcSupported:await e.hasFeatureAsync("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:await e.hasFeatureAsync("texture-compression-etc1"),etc2Supported:await e.hasFeatureAsync("texture-compression-etc2"),dxtSupported:await e.hasFeatureAsync("texture-compression-bc"),bptcSupported:await e.hasFeatureAsync("texture-compression-bptc"),pvrtcSupported:await e.hasFeatureAsync("texture-compression-pvrtc")},this}detectSupport(e){return e.isWebGPURenderer===!0?this.workerConfig={astcSupported:e.hasFeature("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:e.hasFeature("texture-compression-etc1"),etc2Supported:e.hasFeature("texture-compression-etc2"),dxtSupported:e.hasFeature("texture-compression-bc"),bptcSupported:e.hasFeature("texture-compression-bptc"),pvrtcSupported:e.hasFeature("texture-compression-pvrtc")}:this.workerConfig={astcSupported:e.extensions.has("WEBGL_compressed_texture_astc"),astcHDRSupported:e.extensions.has("WEBGL_compressed_texture_astc")&&e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),etc1Supported:e.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:e.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:e.extensions.has("WEBGL_compressed_texture_s3tc"),bptcSupported:e.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:e.extensions.has("WEBGL_compressed_texture_pvrtc")||e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},this}init(){if(!this.transcoderPending){const e=new X.FileLoader(this.manager);e.setPath(this.transcoderPath),e.setWithCredentials(this.withCredentials);const n=e.loadAsync("basis_transcoder.js"),a=new X.FileLoader(this.manager);a.setPath(this.transcoderPath),a.setResponseType("arraybuffer"),a.setWithCredentials(this.withCredentials);const c=a.loadAsync("basis_transcoder.wasm");this.transcoderPending=Promise.all([n,c]).then((([h,p])=>{const b=qo.BasisWorker.toString(),y=["/* constants */","let _EngineFormat = "+JSON.stringify(qo.EngineFormat),"let _EngineType = "+JSON.stringify(qo.EngineType),"let _TranscoderFormat = "+JSON.stringify(qo.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(qo.BasisFormat),"/* basis_transcoder.js */",h,"/* worker */",b.substring(b.indexOf("{")+1,b.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([y])),this.transcoderBinary=p,this.workerPool.setWorkerCreator((()=>{const w=new Worker(this.workerSourceURL),I=this.transcoderBinary.slice(0);return w.postMessage({type:"init",config:this.workerConfig,transcoderBinary:I},[I]),w}))})),d_>0&&console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),d_++}return this.transcoderPending}load(e,n,a,c){if(this.workerConfig===null)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");const h=new X.FileLoader(this.manager);h.setResponseType("arraybuffer"),h.setWithCredentials(this.withCredentials),h.load(e,(p=>{this.parse(p,n,c)}),a,c)}parse(e,n,a){if(this.workerConfig===null)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");if(u_.has(e))return u_.get(e).promise.then(n).catch(a);this._createTexture(e).then((c=>n?n(c):null)).catch(a)}_createTextureFrom(e,n){const{type:a,error:c,data:{faces:h,width:p,height:b,format:y,type:w,dfdFlags:I}}=e;if(a==="error")return Promise.reject(c);let E;if(n.faceCount===6)E=new X.CompressedCubeTexture(h,y,w);else{const R=h[0].mipmaps;E=n.layerCount>1?new X.CompressedArrayTexture(R,p,b,n.layerCount,y,w):new X.CompressedTexture(R,p,b,y,w)}return E.minFilter=h[0].mipmaps.length===1?X.LinearFilter:X.LinearMipmapLinearFilter,E.magFilter=X.LinearFilter,E.generateMipmaps=!1,E.needsUpdate=!0,E.colorSpace=MG(n),E.premultiplyAlpha=!!(1&I),E}async _createTexture(e,n={}){const a=(function(b){const y=new Uint8Array(b.buffer,b.byteOffset,$a.length);if(y[0]!==$a[0]||y[1]!==$a[1]||y[2]!==$a[2]||y[3]!==$a[3]||y[4]!==$a[4]||y[5]!==$a[5]||y[6]!==$a[6]||y[7]!==$a[7]||y[8]!==$a[8]||y[9]!==$a[9]||y[10]!==$a[10]||y[11]!==$a[11])throw new Error("Missing KTX 2.0 identifier.");const w=new eAe,I=17*Uint32Array.BYTES_PER_ELEMENT,E=new zy(b,$a.length,I,!0);w.vkFormat=E._nextUint32(),w.typeSize=E._nextUint32(),w.pixelWidth=E._nextUint32(),w.pixelHeight=E._nextUint32(),w.pixelDepth=E._nextUint32(),w.layerCount=E._nextUint32(),w.faceCount=E._nextUint32();const R=E._nextUint32();w.supercompressionScheme=E._nextUint32();const k=E._nextUint32(),G=E._nextUint32(),N=E._nextUint32(),O=E._nextUint32(),D=E._nextUint64(),W=E._nextUint64(),H=new zy(b,$a.length+I,3*R*8,!0);for(let bt=0;bt<R;bt++)w.levels.push({levelData:new Uint8Array(b.buffer,b.byteOffset+H._nextUint64(),H._nextUint64()),uncompressedByteLength:H._nextUint64()});const K=new zy(b,k,G,!0),j={vendorId:K._skip(4)._nextUint16(),descriptorType:K._nextUint16(),versionNumber:K._nextUint16(),descriptorBlockSize:K._nextUint16(),colorModel:K._nextUint8(),colorPrimaries:K._nextUint8(),transferFunction:K._nextUint8(),flags:K._nextUint8(),texelBlockDimension:[K._nextUint8(),K._nextUint8(),K._nextUint8(),K._nextUint8()],bytesPlane:[K._nextUint8(),K._nextUint8(),K._nextUint8(),K._nextUint8(),K._nextUint8(),K._nextUint8(),K._nextUint8(),K._nextUint8()],samples:[]},J=(j.descriptorBlockSize/4-6)/4;for(let bt=0;bt<J;bt++){const zt={bitOffset:K._nextUint16(),bitLength:K._nextUint8(),channelType:K._nextUint8(),samplePosition:[K._nextUint8(),K._nextUint8(),K._nextUint8(),K._nextUint8()],sampleLower:-1/0,sampleUpper:1/0};64&zt.channelType?(zt.sampleLower=K._nextInt32(),zt.sampleUpper=K._nextInt32()):(zt.sampleLower=K._nextUint32(),zt.sampleUpper=K._nextUint32()),j.samples[bt]=zt}w.dataFormatDescriptor.length=0,w.dataFormatDescriptor.push(j);const ee=new zy(b,N,O,!0);for(;ee._offset<O;){const bt=ee._nextUint32(),zt=ee._scan(bt),Tt=IG(zt);if(w.keyValue[Tt]=ee._nextUint8Array(bt-zt.byteLength-1),Tt.match(/^ktx/i)){const Vt=IG(w.keyValue[Tt]);w.keyValue[Tt]=Vt.substring(0,Vt.lastIndexOf("\0"))}ee._skip(bt%4?4-bt%4:0)}if(W<=0)return w;const re=new zy(b,D,W,!0),Y=re._nextUint16(),ie=re._nextUint16(),ue=re._nextUint32(),Re=re._nextUint32(),_e=re._nextUint32(),Pe=re._nextUint32(),rt=[];for(let bt=0;bt<R;bt++)rt.push({imageFlags:re._nextUint32(),rgbSliceByteOffset:re._nextUint32(),rgbSliceByteLength:re._nextUint32(),alphaSliceByteOffset:re._nextUint32(),alphaSliceByteLength:re._nextUint32()});const de=D+re._offset,we=de+ue,Le=we+Re,Je=Le+_e,fe=new Uint8Array(b.buffer,b.byteOffset+de,ue),Ve=new Uint8Array(b.buffer,b.byteOffset+we,Re),Ne=new Uint8Array(b.buffer,b.byteOffset+Le,_e),gt=new Uint8Array(b.buffer,b.byteOffset+Je,Pe);return w.globalData={endpointCount:Y,selectorCount:ie,imageDescs:rt,endpointsData:fe,selectorsData:Ve,tablesData:Ne,extendedData:gt},w})(new Uint8Array(e)),c=a.vkFormat===Vk&&a.dataFormatDescriptor[0].colorModel===167;if(a.vkFormat!==0&&(!c||this.workerConfig.astcHDRSupported))return(async function(b){const{vkFormat:y}=b;if(f_[y]===void 0)throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");let w;b.supercompressionScheme===2&&(h_||(h_=new Promise((async R=>{const k=new nAe;await k.init(),R(k)}))),w=await h_);const I=[];for(let R=0;R<b.levels.length;R++){const k=Math.max(1,b.pixelWidth>>R),G=Math.max(1,b.pixelHeight>>R),N=b.pixelDepth?Math.max(1,b.pixelDepth>>R):0,O=b.levels[R];let D,W;if(b.supercompressionScheme===0)D=O.levelData;else{if(b.supercompressionScheme!==2)throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");D=w.decode(O.levelData,O.uncompressedByteLength)}W=p_[y]===X.FloatType?new Float32Array(D.buffer,D.byteOffset,D.byteLength/Float32Array.BYTES_PER_ELEMENT):p_[y]===X.HalfFloatType?new Uint16Array(D.buffer,D.byteOffset,D.byteLength/Uint16Array.BYTES_PER_ELEMENT):D,I.push({data:W,width:k,height:G,depth:N})}let E;if(iAe.has(f_[y]))E=b.pixelDepth===0?new X.DataTexture(I[0].data,b.pixelWidth,b.pixelHeight):new X.Data3DTexture(I[0].data,b.pixelWidth,b.pixelHeight,b.pixelDepth);else{if(b.pixelDepth>0)throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");E=new X.CompressedTexture(I,b.pixelWidth,b.pixelHeight),E.minFilter=I.length===1?X.LinearFilter:X.LinearMipmapLinearFilter,E.magFilter=X.LinearFilter}return E.mipmaps=I,E.type=p_[y],E.format=f_[y],E.colorSpace=MG(b),E.needsUpdate=!0,Promise.resolve(E)})(a);const h=n,p=this.init().then((()=>this.workerPool.postMessage({type:"transcode",buffer:e,taskConfig:h},[e]))).then((b=>this._createTextureFrom(b.data,a)));return u_.set(e,{promise:p}),p}dispose(){return this.workerPool.dispose(),this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),d_--,this}}qo.BasisFormat={ETC1S:0,UASTC:1,UASTC_HDR:2},qo.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16,BC6H:22,RGB_HALF:24,RGBA_HALF:25},qo.EngineFormat={RGBAFormat:X.RGBAFormat,RGBA_ASTC_4x4_Format:X.RGBA_ASTC_4x4_Format,RGB_BPTC_UNSIGNED_Format:X.RGB_BPTC_UNSIGNED_Format,RGBA_BPTC_Format:X.RGBA_BPTC_Format,RGBA_ETC2_EAC_Format:X.RGBA_ETC2_EAC_Format,RGBA_PVRTC_4BPPV1_Format:X.RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT5_Format:X.RGBA_S3TC_DXT5_Format,RGB_ETC1_Format:X.RGB_ETC1_Format,RGB_ETC2_Format:X.RGB_ETC2_Format,RGB_PVRTC_4BPPV1_Format:X.RGB_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format:X.RGBA_S3TC_DXT1_Format},qo.EngineType={UnsignedByteType:X.UnsignedByteType,HalfFloatType:X.HalfFloatType,FloatType:X.FloatType},qo.BasisWorker=function(){let r,e,n;const a=_EngineFormat,c=_EngineType,h=_TranscoderFormat,p=_BasisFormat;self.addEventListener("message",(function(E){const R=E.data;switch(R.type){case"init":r=R.config,k=R.transcoderBinary,e=new Promise((G=>{n={wasmBinary:k,onRuntimeInitialized:G},BASIS(n)})).then((()=>{n.initializeBasis(),n.KTX2File===void 0&&console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")}));break;case"transcode":e.then((()=>{try{const{faces:G,buffers:N,width:O,height:D,hasAlpha:W,format:H,type:K,dfdFlags:j}=(function(J){const ee=new n.KTX2File(new Uint8Array(J));function re(){ee.close(),ee.delete()}if(!ee.isValid())throw re(),new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");let Y;if(ee.isUASTC())Y=p.UASTC;else if(ee.isETC1S())Y=p.ETC1S;else{if(!ee.isHDR())throw new Error("THREE.KTX2Loader: Unknown Basis encoding");Y=p.UASTC_HDR}const ie=ee.getWidth(),ue=ee.getHeight(),Re=ee.getLayers()||1,_e=ee.getLevels(),Pe=ee.getFaces(),rt=ee.getHasAlpha(),de=ee.getDFDFlags(),{transcoderFormat:we,engineFormat:Le,engineType:Je}=(function(Ne,gt,bt,zt){const Tt=y[Ne];for(let Vt=0;Vt<Tt.length;Vt++){const je=Tt[Vt];if((!je.if||r[je.if])&&je.basisFormat.includes(Ne)&&!(zt&&je.transcoderFormat.length<2)&&(!je.needsPowerOfTwo||w(gt)&&w(bt)))return{transcoderFormat:je.transcoderFormat[zt?1:0],engineFormat:je.engineFormat[zt?1:0],engineType:je.engineType[0]}}throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.")})(Y,ie,ue,rt);if(!ie||!ue||!_e)throw re(),new Error("THREE.KTX2Loader:	Invalid texture");if(!ee.startTranscoding())throw re(),new Error("THREE.KTX2Loader: .startTranscoding failed");const fe=[],Ve=[];for(let Ne=0;Ne<Pe;Ne++){const gt=[];for(let bt=0;bt<_e;bt++){const zt=[];let Tt,Vt;for(let _t=0;_t<Re;_t++){const Ot=ee.getImageLevelInfo(bt,_t,Ne);Ne!==0||bt!==0||_t!==0||Ot.origWidth%4==0&&Ot.origHeight%4==0||console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."),_e>1?(Tt=Ot.origWidth,Vt=Ot.origHeight):(Tt=Ot.width,Vt=Ot.height);let on=new Uint8Array(ee.getImageTranscodedSizeInBytes(bt,_t,0,we));const vt=ee.transcodeImage(on,bt,_t,Ne,we,0,-1,-1);if(Je===c.HalfFloatType&&(on=new Uint16Array(on.buffer,on.byteOffset,on.byteLength/Uint16Array.BYTES_PER_ELEMENT)),!vt)throw re(),new Error("THREE.KTX2Loader: .transcodeImage failed.");zt.push(on)}const je=I(zt);gt.push({data:je,width:Tt,height:Vt}),Ve.push(je.buffer)}fe.push({mipmaps:gt,width:ie,height:ue,format:Le,type:Je})}return re(),{faces:fe,buffers:Ve,width:ie,height:ue,hasAlpha:rt,dfdFlags:de,format:Le,type:Je}})(R.buffer);self.postMessage({type:"transcode",id:R.id,data:{faces:G,width:O,height:D,hasAlpha:W,format:H,type:K,dfdFlags:j}},N)}catch(G){console.error(G),self.postMessage({type:"error",id:R.id,error:G.message})}}))}var k}));const b=[{if:"astcSupported",basisFormat:[p.UASTC],transcoderFormat:[h.ASTC_4x4,h.ASTC_4x4],engineFormat:[a.RGBA_ASTC_4x4_Format,a.RGBA_ASTC_4x4_Format],engineType:[c.UnsignedByteType],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[p.ETC1S,p.UASTC],transcoderFormat:[h.BC7_M5,h.BC7_M5],engineFormat:[a.RGBA_BPTC_Format,a.RGBA_BPTC_Format],engineType:[c.UnsignedByteType],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[p.ETC1S,p.UASTC],transcoderFormat:[h.BC1,h.BC3],engineFormat:[a.RGBA_S3TC_DXT1_Format,a.RGBA_S3TC_DXT5_Format],engineType:[c.UnsignedByteType],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[p.ETC1S,p.UASTC],transcoderFormat:[h.ETC1,h.ETC2],engineFormat:[a.RGB_ETC2_Format,a.RGBA_ETC2_EAC_Format],engineType:[c.UnsignedByteType],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[p.ETC1S,p.UASTC],transcoderFormat:[h.ETC1],engineFormat:[a.RGB_ETC1_Format],engineType:[c.UnsignedByteType],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[p.ETC1S,p.UASTC],transcoderFormat:[h.PVRTC1_4_RGB,h.PVRTC1_4_RGBA],engineFormat:[a.RGB_PVRTC_4BPPV1_Format,a.RGBA_PVRTC_4BPPV1_Format],engineType:[c.UnsignedByteType],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0},{if:"bptcSupported",basisFormat:[p.UASTC_HDR],transcoderFormat:[h.BC6H],engineFormat:[a.RGB_BPTC_UNSIGNED_Format],engineType:[c.HalfFloatType],priorityHDR:1,needsPowerOfTwo:!1},{basisFormat:[p.ETC1S,p.UASTC],transcoderFormat:[h.RGBA32,h.RGBA32],engineFormat:[a.RGBAFormat,a.RGBAFormat],engineType:[c.UnsignedByteType,c.UnsignedByteType],priorityETC1S:100,priorityUASTC:100,needsPowerOfTwo:!1},{basisFormat:[p.UASTC_HDR],transcoderFormat:[h.RGBA_HALF],engineFormat:[a.RGBAFormat],engineType:[c.HalfFloatType],priorityHDR:100,needsPowerOfTwo:!1}],y={[p.ETC1S]:b.filter((E=>E.basisFormat.includes(p.ETC1S))).sort(((E,R)=>E.priorityUASTC-R.priorityUASTC)),[p.UASTC]:b.filter((E=>E.basisFormat.includes(p.UASTC))).sort(((E,R)=>E.priorityUASTC-R.priorityUASTC)),[p.UASTC_HDR]:b.filter((E=>E.basisFormat.includes(p.UASTC_HDR))).sort(((E,R)=>E.priorityHDR-R.priorityHDR))};function w(E){return E<=2||!(E&E-1)&&E!==0}function I(E){if(E.length===1)return E[0];let R=0;for(let N=0;N<E.length;N++)R+=E[N].byteLength;const k=new Uint8Array(R);let G=0;for(let N=0;N<E.length;N++){const O=E[N];k.set(O,G),G+=O.byteLength}return k}};const iAe=new Set([X.RGBAFormat,X.RGFormat,X.RedFormat]),f_={[YV]:X.RGBAFormat,[KV]:X.RGBAFormat,[WV]:X.RGBAFormat,[HV]:X.RGBAFormat,[$V]:X.RGFormat,[QV]:X.RGFormat,[zV]:X.RGFormat,[VV]:X.RGFormat,[ZV]:X.RedFormat,[XV]:X.RedFormat,[PV]:X.RedFormat,[UV]:X.RedFormat,[Vk]:X.RGBA_ASTC_4x4_Format,[qV]:X.RGBA_ASTC_6x6_Format,[jV]:X.RGBA_ASTC_6x6_Format},p_={[YV]:X.FloatType,[KV]:X.HalfFloatType,[WV]:X.UnsignedByteType,[HV]:X.UnsignedByteType,[$V]:X.FloatType,[QV]:X.HalfFloatType,[zV]:X.UnsignedByteType,[VV]:X.UnsignedByteType,[ZV]:X.FloatType,[XV]:X.HalfFloatType,[PV]:X.UnsignedByteType,[UV]:X.UnsignedByteType,[Vk]:X.HalfFloatType,[qV]:X.UnsignedByteType,[jV]:X.UnsignedByteType};function MG(r){const e=r.dataFormatDescriptor[0];return e.colorPrimaries===1?e.transferFunction===2?X.SRGBColorSpace:X.LinearSRGBColorSpace:e.colorPrimaries===10?e.transferFunction===2?"display-p3":"display-p3-linear":(e.colorPrimaries===0||console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`),X.NoColorSpace)}const Pi={c:null,u:[new X.Vector3,new X.Vector3,new X.Vector3],e:[]},es={c:null,u:[new X.Vector3,new X.Vector3,new X.Vector3],e:[]},$s=[[],[],[]],li=[[],[],[]],Ds=[],om=new X.Vector3,lm=new X.Vector3,cm=new X.Vector3,Br=new X.Vector3,_G=new X.Vector3,RG=new X.Vector3,hc=new X.Matrix3,kG=new X.Box3,NC=new X.Matrix4,BG=new X.Matrix4,LG=new X.Ray;class s2{constructor(e=new X.Vector3,n=new X.Vector3,a=new X.Matrix3){this.center=e,this.halfSize=n,this.rotation=a}set(e,n,a){return this.center=e,this.halfSize=n,this.rotation=a,this}copy(e){return this.center.copy(e.center),this.halfSize.copy(e.halfSize),this.rotation.copy(e.rotation),this}clone(){return new this.constructor().copy(this)}getSize(e){return e.copy(this.halfSize).multiplyScalar(2)}clampPoint(e,n){const a=this.halfSize;Br.subVectors(e,this.center),this.rotation.extractBasis(om,lm,cm),n.copy(this.center);const c=X.MathUtils.clamp(Br.dot(om),-a.x,a.x);n.add(om.multiplyScalar(c));const h=X.MathUtils.clamp(Br.dot(lm),-a.y,a.y);n.add(lm.multiplyScalar(h));const p=X.MathUtils.clamp(Br.dot(cm),-a.z,a.z);return n.add(cm.multiplyScalar(p)),n}containsPoint(e){return Br.subVectors(e,this.center),this.rotation.extractBasis(om,lm,cm),Math.abs(Br.dot(om))<=this.halfSize.x&&Math.abs(Br.dot(lm))<=this.halfSize.y&&Math.abs(Br.dot(cm))<=this.halfSize.z}intersectsBox3(e){return this.intersectsOBB(sAe.fromBox3(e))}intersectsSphere(e){return this.clampPoint(e.center,RG),RG.distanceToSquared(e.center)<=e.radius*e.radius}intersectsOBB(e,n=Number.EPSILON){Pi.c=this.center,Pi.e[0]=this.halfSize.x,Pi.e[1]=this.halfSize.y,Pi.e[2]=this.halfSize.z,this.rotation.extractBasis(Pi.u[0],Pi.u[1],Pi.u[2]),es.c=e.center,es.e[0]=e.halfSize.x,es.e[1]=e.halfSize.y,es.e[2]=e.halfSize.z,e.rotation.extractBasis(es.u[0],es.u[1],es.u[2]);for(let h=0;h<3;h++)for(let p=0;p<3;p++)$s[h][p]=Pi.u[h].dot(es.u[p]);Br.subVectors(es.c,Pi.c),Ds[0]=Br.dot(Pi.u[0]),Ds[1]=Br.dot(Pi.u[1]),Ds[2]=Br.dot(Pi.u[2]);for(let h=0;h<3;h++)for(let p=0;p<3;p++)li[h][p]=Math.abs($s[h][p])+n;let a,c;for(let h=0;h<3;h++)if(a=Pi.e[h],c=es.e[0]*li[h][0]+es.e[1]*li[h][1]+es.e[2]*li[h][2],Math.abs(Ds[h])>a+c)return!1;for(let h=0;h<3;h++)if(a=Pi.e[0]*li[0][h]+Pi.e[1]*li[1][h]+Pi.e[2]*li[2][h],c=es.e[h],Math.abs(Ds[0]*$s[0][h]+Ds[1]*$s[1][h]+Ds[2]*$s[2][h])>a+c)return!1;return a=Pi.e[1]*li[2][0]+Pi.e[2]*li[1][0],c=es.e[1]*li[0][2]+es.e[2]*li[0][1],!(Math.abs(Ds[2]*$s[1][0]-Ds[1]*$s[2][0])>a+c||(a=Pi.e[1]*li[2][1]+Pi.e[2]*li[1][1],c=es.e[0]*li[0][2]+es.e[2]*li[0][0],Math.abs(Ds[2]*$s[1][1]-Ds[1]*$s[2][1])>a+c||(a=Pi.e[1]*li[2][2]+Pi.e[2]*li[1][2],c=es.e[0]*li[0][1]+es.e[1]*li[0][0],Math.abs(Ds[2]*$s[1][2]-Ds[1]*$s[2][2])>a+c||(a=Pi.e[0]*li[2][0]+Pi.e[2]*li[0][0],c=es.e[1]*li[1][2]+es.e[2]*li[1][1],Math.abs(Ds[0]*$s[2][0]-Ds[2]*$s[0][0])>a+c||(a=Pi.e[0]*li[2][1]+Pi.e[2]*li[0][1],c=es.e[0]*li[1][2]+es.e[2]*li[1][0],Math.abs(Ds[0]*$s[2][1]-Ds[2]*$s[0][1])>a+c||(a=Pi.e[0]*li[2][2]+Pi.e[2]*li[0][2],c=es.e[0]*li[1][1]+es.e[1]*li[1][0],Math.abs(Ds[0]*$s[2][2]-Ds[2]*$s[0][2])>a+c||(a=Pi.e[0]*li[1][0]+Pi.e[1]*li[0][0],c=es.e[1]*li[2][2]+es.e[2]*li[2][1],Math.abs(Ds[1]*$s[0][0]-Ds[0]*$s[1][0])>a+c||(a=Pi.e[0]*li[1][1]+Pi.e[1]*li[0][1],c=es.e[0]*li[2][2]+es.e[2]*li[2][0],Math.abs(Ds[1]*$s[0][1]-Ds[0]*$s[1][1])>a+c||(a=Pi.e[0]*li[1][2]+Pi.e[1]*li[0][2],c=es.e[0]*li[2][1]+es.e[1]*li[2][0],Math.abs(Ds[1]*$s[0][2]-Ds[0]*$s[1][2])>a+c)))))))))}intersectsPlane(e){this.rotation.extractBasis(om,lm,cm);const n=this.halfSize.x*Math.abs(e.normal.dot(om))+this.halfSize.y*Math.abs(e.normal.dot(lm))+this.halfSize.z*Math.abs(e.normal.dot(cm)),a=e.normal.dot(this.center)-e.constant;return Math.abs(a)<=n}intersectRay(e,n){return this.getSize(_G),kG.setFromCenterAndSize(Br.set(0,0,0),_G),NC.setFromMatrix3(this.rotation),NC.setPosition(this.center),BG.copy(NC).invert(),LG.copy(e).applyMatrix4(BG),LG.intersectBox(kG,n)?n.applyMatrix4(NC):null}intersectsRay(e){return this.intersectRay(e,Br)!==null}fromBox3(e){return e.getCenter(this.center),e.getSize(this.halfSize).multiplyScalar(.5),this.rotation.identity(),this}equals(e){return e.center.equals(this.center)&&e.halfSize.equals(this.halfSize)&&e.rotation.equals(this.rotation)}applyMatrix4(e){const n=e.elements;let a=Br.set(n[0],n[1],n[2]).length();const c=Br.set(n[4],n[5],n[6]).length(),h=Br.set(n[8],n[9],n[10]).length();e.determinant()<0&&(a=-a),hc.setFromMatrix4(e);const p=1/a,b=1/c,y=1/h;return hc.elements[0]*=p,hc.elements[1]*=p,hc.elements[2]*=p,hc.elements[3]*=b,hc.elements[4]*=b,hc.elements[5]*=b,hc.elements[6]*=y,hc.elements[7]*=y,hc.elements[8]*=y,this.rotation.multiply(hc),this.halfSize.x*=a,this.halfSize.y*=c,this.halfSize.z*=h,Br.setFromMatrixPosition(e),this.center.add(Br),this}}const sAe=new s2,rAe=/^[og]\s*(.+)?/,aAe=/^mtllib /,oAe=/^usemtl /,lAe=/^usemap /,NG=/\s+/,DG=new X.Vector3,m_=new X.Vector3,FG=new X.Vector3,OG=new X.Vector3,Ml=new X.Vector3,DC=new X.Color;function cAe(){const r={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,n){if(this.object&&this.object.fromDeclaration===!1)return this.object.name=e,void(this.object.fromDeclaration=n!==!1);const a=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:n!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(c,h){const p=this._finalize(!1);p&&(p.inherited||p.groupCount<=0)&&this.materials.splice(p.index,1);const b={index:this.materials.length,name:c||"",mtllib:Array.isArray(h)&&h.length>0?h[h.length-1]:"",smooth:p!==void 0?p.smooth:this.smooth,groupStart:p!==void 0?p.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(y){const w={index:typeof y=="number"?y:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return w.clone=this.clone.bind(w),w}};return this.materials.push(b),b},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(c){const h=this.currentMaterial();if(h&&h.groupEnd===-1&&(h.groupEnd=this.geometry.vertices.length/3,h.groupCount=h.groupEnd-h.groupStart,h.inherited=!1),c&&this.materials.length>1)for(let p=this.materials.length-1;p>=0;p--)this.materials[p].groupCount<=0&&this.materials.splice(p,1);return c&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),h}},a&&a.name&&typeof a.clone=="function"){const c=a.clone(0);c.inherited=!0,this.object.materials.push(c)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(e,n){const a=parseInt(e,10);return 3*(a>=0?a-1:a+n/3)},parseNormalIndex:function(e,n){const a=parseInt(e,10);return 3*(a>=0?a-1:a+n/3)},parseUVIndex:function(e,n){const a=parseInt(e,10);return 2*(a>=0?a-1:a+n/2)},addVertex:function(e,n,a){const c=this.vertices,h=this.object.geometry.vertices;h.push(c[e+0],c[e+1],c[e+2]),h.push(c[n+0],c[n+1],c[n+2]),h.push(c[a+0],c[a+1],c[a+2])},addVertexPoint:function(e){const n=this.vertices;this.object.geometry.vertices.push(n[e+0],n[e+1],n[e+2])},addVertexLine:function(e){const n=this.vertices;this.object.geometry.vertices.push(n[e+0],n[e+1],n[e+2])},addNormal:function(e,n,a){const c=this.normals,h=this.object.geometry.normals;h.push(c[e+0],c[e+1],c[e+2]),h.push(c[n+0],c[n+1],c[n+2]),h.push(c[a+0],c[a+1],c[a+2])},addFaceNormal:function(e,n,a){const c=this.vertices,h=this.object.geometry.normals;DG.fromArray(c,e),m_.fromArray(c,n),FG.fromArray(c,a),Ml.subVectors(FG,m_),OG.subVectors(DG,m_),Ml.cross(OG),Ml.normalize(),h.push(Ml.x,Ml.y,Ml.z),h.push(Ml.x,Ml.y,Ml.z),h.push(Ml.x,Ml.y,Ml.z)},addColor:function(e,n,a){const c=this.colors,h=this.object.geometry.colors;c[e]!==void 0&&h.push(c[e+0],c[e+1],c[e+2]),c[n]!==void 0&&h.push(c[n+0],c[n+1],c[n+2]),c[a]!==void 0&&h.push(c[a+0],c[a+1],c[a+2])},addUV:function(e,n,a){const c=this.uvs,h=this.object.geometry.uvs;h.push(c[e+0],c[e+1]),h.push(c[n+0],c[n+1]),h.push(c[a+0],c[a+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const n=this.uvs;this.object.geometry.uvs.push(n[e+0],n[e+1])},addFace:function(e,n,a,c,h,p,b,y,w){const I=this.vertices.length;let E=this.parseVertexIndex(e,I),R=this.parseVertexIndex(n,I),k=this.parseVertexIndex(a,I);if(this.addVertex(E,R,k),this.addColor(E,R,k),b!==void 0&&b!==""){const G=this.normals.length;E=this.parseNormalIndex(b,G),R=this.parseNormalIndex(y,G),k=this.parseNormalIndex(w,G),this.addNormal(E,R,k)}else this.addFaceNormal(E,R,k);if(c!==void 0&&c!==""){const G=this.uvs.length;E=this.parseUVIndex(c,G),R=this.parseUVIndex(h,G),k=this.parseUVIndex(p,G),this.addUV(E,R,k),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const n=this.vertices.length;for(let a=0,c=e.length;a<c;a++){const h=this.parseVertexIndex(e[a],n);this.addVertexPoint(h),this.addColor(h)}},addLineGeometry:function(e,n){this.object.geometry.type="Line";const a=this.vertices.length,c=this.uvs.length;for(let h=0,p=e.length;h<p;h++)this.addVertexLine(this.parseVertexIndex(e[h],a));for(let h=0,p=n.length;h<p;h++)this.addUVLine(this.parseUVIndex(n[h],c))}};return r.startObject("",!1),r}class JV extends X.Loader{constructor(e){super(e),this.materials=null}load(e,n,a,c){const h=this,p=new X.FileLoader(this.manager);p.setPath(this.path),p.setRequestHeader(this.requestHeader),p.setWithCredentials(this.withCredentials),p.load(e,(function(b){try{n(h.parse(b))}catch(y){c?c(y):console.error(y),h.manager.itemError(e)}}),a,c)}setMaterials(e){return this.materials=e,this}parse(e){const n=new cAe;e.indexOf(`\r
`)!==-1&&(e=e.replace(/\r\n/g,`
`)),e.indexOf(`\\
`)!==-1&&(e=e.replace(/\\\n/g,""));const a=e.split(`
`);let c=[];for(let p=0,b=a.length;p<b;p++){const y=a[p].trimStart();if(y.length===0)continue;const w=y.charAt(0);if(w!=="#")if(w==="v"){const I=y.split(NG);switch(I[0]){case"v":n.vertices.push(parseFloat(I[1]),parseFloat(I[2]),parseFloat(I[3])),I.length>=7?(DC.setRGB(parseFloat(I[4]),parseFloat(I[5]),parseFloat(I[6]),X.SRGBColorSpace),n.colors.push(DC.r,DC.g,DC.b)):n.colors.push(void 0,void 0,void 0);break;case"vn":n.normals.push(parseFloat(I[1]),parseFloat(I[2]),parseFloat(I[3]));break;case"vt":n.uvs.push(parseFloat(I[1]),parseFloat(I[2]))}}else if(w==="f"){const I=y.slice(1).trim().split(NG),E=[];for(let k=0,G=I.length;k<G;k++){const N=I[k];if(N.length>0){const O=N.split("/");E.push(O)}}const R=E[0];for(let k=1,G=E.length-1;k<G;k++){const N=E[k],O=E[k+1];n.addFace(R[0],N[0],O[0],R[1],N[1],O[1],R[2],N[2],O[2])}}else if(w==="l"){const I=y.substring(1).trim().split(" ");let E=[];const R=[];if(y.indexOf("/")===-1)E=I;else for(let k=0,G=I.length;k<G;k++){const N=I[k].split("/");N[0]!==""&&E.push(N[0]),N[1]!==""&&R.push(N[1])}n.addLineGeometry(E,R)}else if(w==="p"){const I=y.slice(1).trim().split(" ");n.addPointGeometry(I)}else if((c=rAe.exec(y))!==null){const I=(" "+c[0].slice(1).trim()).slice(1);n.startObject(I)}else if(oAe.test(y))n.object.startMaterial(y.substring(7).trim(),n.materialLibraries);else if(aAe.test(y))n.materialLibraries.push(y.substring(7).trim());else if(lAe.test(y))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(w==="s"){if(c=y.split(" "),c.length>1){const E=c[1].trim().toLowerCase();n.object.smooth=E!=="0"&&E!=="off"}else n.object.smooth=!0;const I=n.object.currentMaterial();I&&(I.smooth=n.object.smooth)}else{if(y==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+y+'"')}}n.finalize();const h=new X.Group;if(h.materialLibraries=[].concat(n.materialLibraries),!(n.objects.length===1&&n.objects[0].geometry.vertices.length===0))for(let p=0,b=n.objects.length;p<b;p++){const y=n.objects[p],w=y.geometry,I=y.materials,E=w.type==="Line",R=w.type==="Points";let k=!1;if(w.vertices.length===0)continue;const G=new X.BufferGeometry;G.setAttribute("position",new X.Float32BufferAttribute(w.vertices,3)),w.normals.length>0&&G.setAttribute("normal",new X.Float32BufferAttribute(w.normals,3)),w.colors.length>0&&(k=!0,G.setAttribute("color",new X.Float32BufferAttribute(w.colors,3))),w.hasUVIndices===!0&&G.setAttribute("uv",new X.Float32BufferAttribute(w.uvs,2));const N=[];for(let D=0,W=I.length;D<W;D++){const H=I[D],K=H.name+"_"+H.smooth+"_"+k;let j=n.materials[K];if(this.materials!==null)if(j=this.materials.create(H.name),!E||!j||j instanceof X.LineBasicMaterial){if(R&&j&&!(j instanceof X.PointsMaterial)){const J=new X.PointsMaterial({size:10,sizeAttenuation:!1});X.Material.prototype.copy.call(J,j),J.color.copy(j.color),J.map=j.map,j=J}}else{const J=new X.LineBasicMaterial;X.Material.prototype.copy.call(J,j),J.color.copy(j.color),j=J}j===void 0&&(j=E?new X.LineBasicMaterial:R?new X.PointsMaterial({size:1,sizeAttenuation:!1}):new X.MeshPhongMaterial,j.name=H.name,j.flatShading=!H.smooth,j.vertexColors=k,n.materials[K]=j),N.push(j)}let O;if(N.length>1){for(let D=0,W=I.length;D<W;D++){const H=I[D];G.addGroup(H.groupStart,H.groupCount,D)}O=E?new X.LineSegments(G,N):R?new X.Points(G,N):new X.Mesh(G,N)}else O=E?new X.LineSegments(G,N[0]):R?new X.Points(G,N[0]):new X.Mesh(G,N[0]);O.name=y.name,h.add(O)}else if(n.vertices.length>0){const p=new X.PointsMaterial({size:1,sizeAttenuation:!1}),b=new X.BufferGeometry;b.setAttribute("position",new X.Float32BufferAttribute(n.vertices,3)),n.colors.length>0&&n.colors[0]!==void 0&&(b.setAttribute("color",new X.Float32BufferAttribute(n.colors,3)),p.vertexColors=!0);const y=new X.Points(b,p);h.add(y)}return h}}class eW extends X.Loader{constructor(e){super(e)}load(e,n,a,c){const h=this,p=this.path===""?X.LoaderUtils.extractUrlBase(e):this.path,b=new X.FileLoader(this.manager);b.setPath(this.path),b.setRequestHeader(this.requestHeader),b.setWithCredentials(this.withCredentials),b.load(e,(function(y){try{n(h.parse(y,p))}catch(w){c?c(w):console.error(w),h.manager.itemError(e)}}),a,c)}setMaterialOptions(e){return this.materialOptions=e,this}parse(e,n){const a=e.split(`
`);let c={};const h=/\s+/,p={};for(let y=0;y<a.length;y++){let w=a[y];if(w=w.trim(),w.length===0||w.charAt(0)==="#")continue;const I=w.indexOf(" ");let E=I>=0?w.substring(0,I):w;E=E.toLowerCase();let R=I>=0?w.substring(I+1):"";if(R=R.trim(),E==="newmtl")c={name:R},p[R]=c;else if(E==="ka"||E==="kd"||E==="ks"||E==="ke"){const k=R.split(h,3);c[E]=[parseFloat(k[0]),parseFloat(k[1]),parseFloat(k[2])]}else c[E]=R}const b=new uAe(this.resourcePath||n,this.materialOptions);return b.setCrossOrigin(this.crossOrigin),b.setManager(this.manager),b.setMaterials(p),b}}class uAe{constructor(e="",n={}){this.baseUrl=e,this.options=n,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.crossOrigin="anonymous",this.side=this.options.side!==void 0?this.options.side:X.FrontSide,this.wrap=this.options.wrap!==void 0?this.options.wrap:X.RepeatWrapping}setCrossOrigin(e){return this.crossOrigin=e,this}setManager(e){this.manager=e}setMaterials(e){this.materialsInfo=this.convert(e),this.materials={},this.materialsArray=[],this.nameLookup={}}convert(e){if(!this.options)return e;const n={};for(const a in e){const c=e[a],h={};n[a]=h;for(const p in c){let b=!0,y=c[p];const w=p.toLowerCase();switch(w){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(y=[y[0]/255,y[1]/255,y[2]/255]),this.options&&this.options.ignoreZeroRGBs&&y[0]===0&&y[1]===0&&y[2]===0&&(b=!1)}b&&(h[w]=y)}}return n}preload(){for(const e in this.materialsInfo)this.create(e)}getIndex(e){return this.nameLookup[e]}getAsArray(){let e=0;for(const n in this.materialsInfo)this.materialsArray[e]=this.create(n),this.nameLookup[n]=e,e++;return this.materialsArray}create(e){return this.materials[e]===void 0&&this.createMaterial_(e),this.materials[e]}createMaterial_(e){const n=this,a=this.materialsInfo[e],c={name:e,side:this.side};function h(p,b){if(c[p])return;const y=n.getTextureParams(b,c),w=n.loadTexture((I=n.baseUrl,typeof(E=y.url)!="string"||E===""?"":/^https?:\/\//i.test(E)?E:I+E));var I,E;w.repeat.copy(y.scale),w.offset.copy(y.offset),w.wrapS=n.wrap,w.wrapT=n.wrap,p!=="map"&&p!=="emissiveMap"||(w.colorSpace=X.SRGBColorSpace),c[p]=w}for(const p in a){const b=a[p];let y;if(b!=="")switch(p.toLowerCase()){case"kd":c.color=X.ColorManagement.toWorkingColorSpace(new X.Color().fromArray(b),X.SRGBColorSpace);break;case"ks":c.specular=X.ColorManagement.toWorkingColorSpace(new X.Color().fromArray(b),X.SRGBColorSpace);break;case"ke":c.emissive=X.ColorManagement.toWorkingColorSpace(new X.Color().fromArray(b),X.SRGBColorSpace);break;case"map_kd":h("map",b);break;case"map_ks":h("specularMap",b);break;case"map_ke":h("emissiveMap",b);break;case"norm":h("normalMap",b);break;case"map_bump":case"bump":h("bumpMap",b);break;case"map_d":h("alphaMap",b),c.transparent=!0;break;case"ns":c.shininess=parseFloat(b);break;case"d":y=parseFloat(b),y<1&&(c.opacity=y,c.transparent=!0);break;case"tr":y=parseFloat(b),this.options&&this.options.invertTrProperty&&(y=1-y),y>0&&(c.opacity=1-y,c.transparent=!0)}}return this.materials[e]=new X.MeshPhongMaterial(c),this.materials[e]}getTextureParams(e,n){const a={scale:new X.Vector2(1,1),offset:new X.Vector2(0,0)},c=e.split(/\s+/);let h;return h=c.indexOf("-bm"),h>=0&&(n.bumpScale=parseFloat(c[h+1]),c.splice(h,2)),h=c.indexOf("-s"),h>=0&&(a.scale.set(parseFloat(c[h+1]),parseFloat(c[h+2])),c.splice(h,4)),h=c.indexOf("-o"),h>=0&&(a.offset.set(parseFloat(c[h+1]),parseFloat(c[h+2])),c.splice(h,4)),a.url=c.join(" ").trim(),a}loadTexture(e,n,a,c,h){const p=this.manager!==void 0?this.manager:X.DefaultLoadingManager;let b=p.getHandler(e);b===null&&(b=new X.TextureLoader(p)),b.setCrossOrigin&&b.setCrossOrigin(this.crossOrigin);const y=b.load(e,a,c,h);return n!==void 0&&(y.mapping=n),y}}class tW{static fromCubeTexture(e){let n=0;const a=new X.Vector3,c=new X.Vector3,h=new X.Color,p=[0,0,0,0,0,0,0,0,0],b=new X.SphericalHarmonics3,y=b.coefficients;for(let I=0;I<6;I++){const E=e.image[I],R=E.width,k=E.height,G=document.createElement("canvas");G.width=R,G.height=k;const N=G.getContext("2d");N.drawImage(E,0,0,R,k);const O=N.getImageData(0,0,R,k),D=O.data,W=O.width,H=2/W;for(let K=0,j=D.length;K<j;K+=4){h.setRGB(D[K]/255,D[K+1]/255,D[K+2]/255),GG(h,e.colorSpace);const J=K/4,ee=(J%W+.5)*H-1,re=1-(Math.floor(J/W)+.5)*H;switch(I){case 0:a.set(-1,re,-ee);break;case 1:a.set(1,re,ee);break;case 2:a.set(-ee,1,-re);break;case 3:a.set(-ee,-1,re);break;case 4:a.set(-ee,re,1);break;case 5:a.set(ee,re,-1)}const Y=a.lengthSq(),ie=4/(Math.sqrt(Y)*Y);n+=ie,c.copy(a).normalize(),X.SphericalHarmonics3.getBasisAt(c,p);for(let ue=0;ue<9;ue++)y[ue].x+=p[ue]*h.r*ie,y[ue].y+=p[ue]*h.g*ie,y[ue].z+=p[ue]*h.b*ie}}const w=4*Math.PI/n;for(let I=0;I<9;I++)y[I].x*=w,y[I].y*=w,y[I].z*=w;return new X.LightProbe(b)}static async fromCubeRenderTarget(e,n){const a=e.coordinateSystem===X.WebGLCoordinateSystem?-1:1;let c=0;const h=new X.Vector3,p=new X.Vector3,b=new X.Color,y=[0,0,0,0,0,0,0,0,0],w=new X.SphericalHarmonics3,I=w.coefficients,E=n.texture.type,R=n.width;let k;e.isWebGLRenderer&&(k=E===X.HalfFloatType?new Uint16Array(R*R*4):new Uint8Array(R*R*4));for(let N=0;N<6;N++){e.isWebGLRenderer?await e.readRenderTargetPixelsAsync(n,0,0,R,R,k,N):k=await e.readRenderTargetPixelsAsync(n,0,0,R,R,0,N);const O=2/R;for(let D=0,W=k.length;D<W;D+=4){let H,K,j;E===X.HalfFloatType?(H=X.DataUtils.fromHalfFloat(k[D]),K=X.DataUtils.fromHalfFloat(k[D+1]),j=X.DataUtils.fromHalfFloat(k[D+2])):(H=k[D]/255,K=k[D+1]/255,j=k[D+2]/255),b.setRGB(H,K,j),GG(b,n.texture.colorSpace);const J=D/4,ee=(1-(J%R+.5)*O)*a,re=1-(Math.floor(J/R)+.5)*O;switch(N){case 0:h.set(-1*a,re,ee*a);break;case 1:h.set(1*a,re,-ee*a);break;case 2:h.set(ee,1,-re);break;case 3:h.set(ee,-1,re);break;case 4:h.set(ee,re,1);break;case 5:h.set(-ee,re,-1)}const Y=h.lengthSq(),ie=4/(Math.sqrt(Y)*Y);c+=ie,p.copy(h).normalize(),X.SphericalHarmonics3.getBasisAt(p,y);for(let ue=0;ue<9;ue++)I[ue].x+=y[ue]*b.r*ie,I[ue].y+=y[ue]*b.g*ie,I[ue].z+=y[ue]*b.b*ie}}const G=4*Math.PI/c;for(let N=0;N<9;N++)I[N].x*=G,I[N].y*=G,I[N].z*=G;return new X.LightProbe(w)}}function GG(r,e){switch(e){case X.SRGBColorSpace:r.convertSRGBToLinear();break;case X.LinearSRGBColorSpace:case X.NoColorSpace:break;default:console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.")}return r}var nW=function(r){var e=this;this.object=r,this.object.rotation.reorder("YXZ"),this.enabled=!0,this.deviceOrientation={},this.screenOrientation=0,this.alphaOffset=0;var n,a,c,h,p=function(w){e.deviceOrientation=w},b=function(){e.screenOrientation=window.orientation||0},y=(n=new THREE.Vector3(0,0,1),a=new THREE.Euler,c=new THREE.Quaternion,h=new THREE.Quaternion(-Math.sqrt(.5),0,0,Math.sqrt(.5)),function(w,I,E,R,k){a.set(E,I,-R,"YXZ"),w.setFromEuler(a),w.multiply(h),w.multiply(c.setFromAxisAngle(n,-k))});this.connect=function(){b(),window.addEventListener("orientationchange",b,!1),window.addEventListener("deviceorientation",p,!1),e.enabled=!0},this.disconnect=function(){window.removeEventListener("orientationchange",b,!1),window.removeEventListener("deviceorientation",p,!1),e.enabled=!1},this.update=function(){if(e.enabled!==!1){var w=e.deviceOrientation;if(w){var I=w.alpha?THREE.MathUtils.degToRad(w.alpha)+e.alphaOffset:0,E=w.beta?THREE.MathUtils.degToRad(w.beta):0,R=w.gamma?THREE.MathUtils.degToRad(w.gamma):0,k=e.screenOrientation?THREE.MathUtils.degToRad(e.screenOrientation):0;y(e.object.quaternion,I,E,R,k)}}},this.dispose=function(){e.disconnect()},this.connect()},fc=globalThis.THREE={...X};fc.DRACOLoader=FV,fc.GLTFLoader=zk,fc.KTX2Loader=qo,fc.OBJLoader=JV,fc.MTLLoader=eW,fc.OBB=s2,fc.BufferGeometryUtils=mR,fc.LightProbeGenerator=tW,fc.DeviceOrientationControls=nW,fc.Cache.enabled=!0;const iW=fc;var ur=window.AFRAME_CDN_ROOT||"https://cdn.aframe.io/",ta="aframe-injected",hAe=Nn(8878),Bv=Nn.n(hAe),UG={colors:{debug:"gray",error:"red",info:"gray",warn:"orange"}};Bv().formatArgs=function(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" "),this.useColors){var e;this.color=(e=(function(h){var p=h.split(":");return p[p.length-1]})(this.namespace),UG.colors&&UG.colors[e]||null);var n="color: "+this.color;r.splice(1,0,n,"color: inherit");var a=0,c=0;r[0].replace(/%[a-zA-Z%]/g,(function(h){h!=="%%"&&(a++,h==="%c"&&(c=a))})),r.splice(c,0,n)}};var g_=(function(){try{return window.localStorage}catch{}})();g_&&(parseInt(g_.logs,10)||g_.logs==="true")?Bv().enable("*"):Bv().enable("*:error,*:info,*:warn");const $i=Bv();var dAe=Nn(1124),fAe=Nn.n(dAe),PG=$i("device:error"),r2=!1,a2=!1,q2=navigator.xr!==void 0;if(q2){var D0=function(){var r=document.querySelector("a-scene");r?r.hasLoaded?r.components["xr-mode-ui"].updateEnterInterfaces():r.addEventListener("loaded",D0):window.addEventListener("DOMContentLoaded",D0)},zG=function(r){PG("WebXR session support error: "+r.message)};navigator.xr.isSessionSupported?(navigator.xr.isSessionSupported("immersive-vr").then((function(r){r2=r,D0()})).catch(zG),navigator.xr.isSessionSupported("immersive-ar").then((function(r){a2=r,D0()})).catch((function(){}))):navigator.xr.supportsSession?(navigator.xr.supportsSession("immersive-vr").then((function(){r2=!0,D0()})).catch(zG),navigator.xr.supportsSession("immersive-ar").then((function(){a2=!0,D0()})).catch((function(){}))):PG("WebXR has neither isSessionSupported or supportsSession?!")}function Wk(){return r2||a2}function Hk(){return a2}function FR(){return r2}var Vy,A_,ef=(Vy=!1,A_=window.navigator.userAgent||window.navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(A_)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(A_.substr(0,4)))&&(Vy=!0),(Kv()||sW()||Zk())&&(Vy=!0),Kk()&&(Vy=!1),function(){return Vy});function sW(r){var e=r||window.navigator.userAgent;return/Nexus (7|9)|xoom|sch-i800|playbook|tablet|kindle/i.test(e)||rW()}function rW(r,e,n){var a=r||window.navigator.userAgent,c=e||window.navigator.platform,h=n||window.navigator.maxTouchPoints||0;return(c==="iPad"||c==="MacIntel")&&h>0&&/Macintosh|Intel|iPad|ipad/i.test(a)&&!window.MSStream}function aW(){var r=navigator.userAgent.includes("Macintosh"),e=navigator.maxTouchPoints===5;return r&&e&&q2}function Kv(){return/iPad|iPhone|iPod/.test(window.navigator.platform)}function Xk(){return!ef()&&!Kk()&&window.orientation!==void 0}function Qk(){return/(OculusBrowser)/i.test(window.navigator.userAgent)}function oW(){return/(Mobile VR)/i.test(window.navigator.userAgent)}function Kk(){return Qk()||oW()||aW()}function Zk(){return/R7 Build/.test(window.navigator.userAgent)}function lW(){var r=window.orientation;return Zk()&&(r+=90),r===90||r===-90}var $k=typeof process>"u"||process.browser===!0,pAe=!$k,mAe=Object.freeze(Object.create(null));function gAe(){return{}}function Yk(r){var e=[],n=null;function a(c){var h,p;if((c=c===void 0?e.length:c)>0&&n==null&&(n=0),c>0)for(h=e.length,e.length+=Number(c),p=h;p<e.length;p++)e[p]=r();return e.length}return r=r||gAe,{grow:a,pool:e,recycle:function(c){c instanceof Object&&(n!==null&&n!==-1?e[--n]=c:e[e.length]=c)},size:function(){return e.length},use:function(){var c;return n!==null&&n!==e.length||a(e.length||5),c=e[n],e[n++]=mAe,jk(c),c}}}function jk(r){var e;if(r&&r.constructor===Object)for(e in r)r[e]=void 0}function Lv(r,e){var n;if(r&&r.constructor===Object)for(n in r)n in e||delete r[n]}var AAe=$i("utils:coordinates:warn"),VG=["x","y","z","w"],cW=/^\s*((-?\d*\.{0,1}\d+(e-?\d+)?)\s+){2,3}(-?\d*\.{0,1}\d+(e-?\d+)?)\s*$/,bAe=/\s+/g;function o2(r,e,n){var a,c,h,p,b,y,w,I,E=n&&typeof n=="object"?n:{};if(r&&r instanceof Object)return b=r.x===void 0?e&&e.x:r.x,y=r.y===void 0?e&&e.y:r.y,w=r.z===void 0?e&&e.z:r.z,I=r.w===void 0?e&&e.w:r.w,b!=null&&(E.x=Wy(b)),y!=null&&(E.y=Wy(y)),w!=null&&(E.z=Wy(w)),I!=null&&(E.w=Wy(I)),E;if(r==null)return typeof e=="object"?Object.assign(E,e):e;for(a=r.trim().split(bAe),p=0;p<VG.length;p++)if(h=VG[p],a[p])E[h]=parseFloat(a[p],10);else{if((c=e&&e[h])===void 0)continue;E[h]=Wy(c)}return E}function uE(r){var e;return typeof r!="object"?r:(e=r.x+" "+r.y,r.z!=null&&(e+=" "+r.z),r.w!=null&&(e+=" "+r.w),e)}function hE(r,e){return typeof r!="object"||typeof e!="object"?r===e:r.x===e.x&&r.y===e.y&&r.z===e.z&&r.w===e.w}function uW(r){return cW.test(r)}function yAe(r){return AAe("`AFRAME.utils.isCoordinate` has been renamed to `AFRAME.utils.isCoordinates`"),uW(r)}function Wy(r){return r!=null&&r.constructor===String?parseFloat(r,10):r}function vAe(r){return new X.Vector3(r.x,r.y,r.z)}var Th=(function(){var r={};return function(e,n){return n in r||(r[n]={}),e in r[n]||(r[n][e]=e.split(n)),r[n][e]}})();function J2(r,e){var n=Th(r,e=e||".");return n.length===1?n[0]:n}function hW(r,e,n){var a;return n=n||".",e.indexOf(n)!==-1?(a=J2(e,n)).constructor===String?r.getAttribute(a):r.getAttribute(a[0])[a[1]]:r.getAttribute(e)}function qk(r,e,n,a){var c;a=a||".",e.indexOf(a)===-1?r.setAttribute(e,n):(c=J2(e,a)).constructor===String?r.setAttribute(c,n):r.setAttribute(c[0],c[1],n)}function dW(r){var e=r.style.width,n=r.style.height;r.style.width=parseInt(e,10)+1+"px",r.style.height=parseInt(n,10)+1+"px",setTimeout((function(){r.style.width=e,r.style.height=n}),200)}var dE=$i("utils:src-loader:warn");function l2(r,e,n){(function(a,c){var h;a.tagName?c(a.tagName==="IMG"):((h=new XMLHttpRequest).open("HEAD",a),h.addEventListener("load",(function(p){var b;h.status>=200&&h.status<300?(b=h.getResponseHeader("Content-Type"))==null?WG(a,c):b.startsWith("image")?c(!0):c(!1):WG(a,c),h.abort()})),h.send())})(r,(function(a){a?e(r):n(r)}))}function Jk(r,e,n){var a,c,h,p="",b=[];if(typeof r=="string"){let y=function(w){b.push(w),b.length===6&&e(b)};for(c=0;c<5;c++)p+="(url\\((?:[^\\)]+)\\),\\s*)";if(p+="(url\\((?:[^\\)]+)\\)\\s*)",h=r.match(new RegExp(p))){for(c=1;c<7;c++)l2(OR(h[c]),y);return}if(!r.startsWith("#"))return void l2(OR(r)||r,n)}if(a=r.tagName?r:(function(y){try{var w=document.querySelector(y);return w||dE('No element was found matching the selector: "%s"',y),w}catch{return void dE('"%s" is not a valid selector',y)}})(r))return a.tagName==="A-CUBEMAP"&&a.srcs?e(a.srcs):a.tagName==="IMG"?n(a):void dE('Selector "%s" does not point to <a-cubemap> or <img>',r)}function fW(r,e){return Jk(r,e,(function(){dE("Expected cubemap but got image")}))}function OR(r){var e=r.match(/url\((.+)\)/);if(e)return e[1]}function WG(r,e){var n=new Image;n.addEventListener("load",(function(){e(!0)})),n.addEventListener("error",(function(){e(!1)})),n.src=r}var xAe=$i("utils:material:warn"),wAe=new Set(["emissiveMap","envMap","map","specularMap"]);function c2(r,e){var n=e.offset||{x:0,y:0},a=e.repeat||{x:1,y:1},c=e.npot||!1,h=e.anisotropy||X.Texture.DEFAULT_ANISOTROPY,p=r.wrapS,b=r.wrapT,y=r.magFilter,w=r.minFilter;c&&(p=X.ClampToEdgeWrapping,b=X.ClampToEdgeWrapping,y=X.LinearFilter,w=X.LinearFilter),a.x===1&&a.y===1||(p=X.RepeatWrapping,b=X.RepeatWrapping),r.offset.set(n.x,n.y),r.repeat.set(a.x,a.y),r.wrapS===p&&r.wrapT===b&&r.magFilter===y&&r.minFilter===w&&r.anisotropy===h||(r.wrapS=p,r.wrapT=b,r.magFilter=y,r.minFilter=w,r.anisotropy=h,r.needsUpdate=!0)}function eS(r,e,n,a){var c=n.el,h=n.material,p=c.sceneEl.systems.renderer,b=a[e];if(n.materialSrcs||(n.materialSrcs={}),!b)return delete n.materialSrcs[r],void y(null);function y(w){h[r]!==w&&(h[r]&&h[r].dispose(),h[r]=w,h.needsUpdate=!0,eB(c,w))}b===n.materialSrcs[r]&&h[r]?c2(h[r],a):(n.materialSrcs[r]=b,b instanceof X.Texture?y(b):c.sceneEl.systems.material.loadTextureSource(b,(function(w){if(n.materialSrcs[r]===b){var I=h[r];!I||w!==null&&pW(I,w)||(I=null),!I&&w&&(I=tB(w)),I&&(I.source!==w&&(I.source=w,I.needsUpdate=!0),wAe.has(r)&&p.applyColorCorrection(I),c2(I,a)),y(I)}})))}function fE(r,e){return eS("map","src",r,e)}function du(r,e,n){var a=r;r==="ambientOcclusion"&&(a="ao");var c={};return c.src=n[r+"Map"],c.offset=n[r+"TextureOffset"],c.repeat=n[r+"TextureRepeat"],c.wrap=n[r+"TextureWrap"],eS(a+"Map","src",e,c)}var b_={};function GR(r,e){var n=r.material,a=r.el,c="envMap",h=e.envMap,p=e.sphericalEnvMap,b=e.refract;if(p&&(h=p,xAe("`sphericalEnvMap` property is deprecated, using spherical map as equirectangular map instead. Use `envMap` property with a CubeMap or Equirectangular image instead.")),r.materialSrcs||(r.materialSrcs={}),!h)return delete r.materialSrcs[c],n.envMap=null,void(n.needsUpdate=!0);function y(w){r.materialSrcs[c]===h&&(n.envMap=w,n.needsUpdate=!0,eB(a,w))}r.materialSrcs[c]=h,b_[h]?b_[h].then(y):b_[h]=new Promise((function(w){Jk(h,(function(I){a.sceneEl.systems.material.loadCubeMapTexture(I,(function(E){E.mapping=b?X.CubeRefractionMapping:X.CubeReflectionMapping,y(E),w(E)}))}),(function(I){a.sceneEl.systems.material.loadTexture(I,{src:I},(function(E){E.mapping=b?X.EquirectangularRefractionMapping:X.EquirectangularReflectionMapping,y(E),w(E)}))}))}))}function eB(r,e){function n(){r.emit("materialvideoloadeddata",{src:e.image,texture:e})}function a(){r.emit("materialvideoended",{src:e.image,texture:e})}e&&(r.emit("materialtextureloaded",{src:e.image,texture:e}),e.image&&e.image.tagName==="VIDEO"&&(e.image.addEventListener("loadeddata",n),e.image.addEventListener("ended",a),e.addEventListener("dispose",(function(){e.image.removeEventListener("loadeddata",n),e.image.removeEventListener("ended",a)}))))}function pW(r,e){return r.source===e&&(e.data instanceof HTMLCanvasElement?r.isCanvasTexture:e.data instanceof HTMLVideoElement?r.isVideoTexture:r.isTexture&&!r.isCanvasTexture&&!r.isVideoTexture)}function tB(r){var e;return(e=r.data instanceof HTMLCanvasElement?new X.CanvasTexture:r.data instanceof HTMLVideoElement?new X.VideoTexture(r.data):new X.Texture).source=r,e.needsUpdate=!0,e}var CAe=/-([a-z])/g;function Nv(r,e){var n;return typeof r!="string"?r:(n=(function(a,c){var h,p,b,y,w,I;for(c=c||{},h=SAe(a),p=0;p<h.length;p++)(b=h[p])&&(y=b.indexOf(":"),w=b.substr(0,y).trim(),I=b.substr(y+1).trim(),c[mW(w)]=I);return c})(r,e),n[""]?r:n)}function EAe(r){return typeof r=="string"?r:(function(e){var n,a=0,c=0,h="";for(n in e)a++;for(n in e)h+=n+": "+e[n],c<a-1&&(h+="; "),c++;return h})(r)}function mW(r){return r.replace(CAe,IAe)}var FC,HG,SAe=(FC=[],HG=/url\([^)]+$/,function(r){var e,n="",a=0;for(FC.length=0;a<r.length;)(e=r.indexOf(";",a))===-1&&(e=r.length),n+=r.substring(a,e),HG.test(n)?(n+=";",a=e+1):(FC.push(n.trim()),n="",a=e+1);return FC});function IAe(r){return r[1].toUpperCase()}var TAe=["x","y","z","w"];function tl(r,e,n){var a,c,h=r.el;if((c=!!(a=gW(r,e,n)))===r.controllerPresent)return c;r.controllerPresent=c,c?(r.addEventListeners(),r.injectTrackedControls(a),h.emit("controllerconnected",{name:r.name,component:r})):(r.removeEventListeners(),h.emit("controllerdisconnected",{name:r.name,component:r}))}function gW(r,e,n){var a,c=r.el.sceneEl,h=c&&c.systems["tracked-controls"];return!!h&&!(!(a=h.controllers)||!a.length)&&nB(a,e,n.hand,n.index,n.iterateControllerProfiles,n.handTracking)}function nB(r,e,n,a,c,h){var p,b,y,w,I=!1;for(p=0;p<r.length;p++){if(w=(y=r[p]).profiles,h)I=y.hand;else if(c)for(b=0;b<w.length&&!(I=w[b].startsWith(e));b++);else I=w.length>0&&w[0].startsWith(e);if(I){if(y.handedness==="right"||y.handedness==="left"){if(y.handedness===n)return r[p]}else if(p===a)return r[p]}}}function Bl(r,e,n){var a,c,h,p,b;for(c in e){for(a=e[c],h=!1,b=0;b<a.length;b++)n.detail.changed[a[b]]&&(h=!0);if(h){for(p={},b=0;b<a.length;b++)p[TAe[b]]=n.detail.axis[a[b]];r.el.emit(c+"moved",p)}}}function qn(r,e,n,a){var c=(a?n.mapping[a]:n.mapping).buttons[r];n.el.emit(c+e),n.updateModel&&n.updateModel(c,e)}var iB=$i("utils:warn");function MAe(r){return r.bind.apply(r,Array.prototype.slice.call(arguments,1))}function _Ae(){return iB("`utils.checkHeadsetConnected` has moved to `utils.device.checkHeadsetConnected`"),Wk()}function RAe(){return iB("`utils.isIOS` has moved to `utils.device.isIOS`"),Kv()}function kAe(){return iB("`utils.isMobile has moved to `utils.device.isMobile`"),ef(arguments)}function BAe(r,e,n){var a;return n&&(r=r.bind(n)),function(){var c=Date.now();(a===void 0||(a===void 0?e:c-a)>=e)&&(a=c,r.apply(null,arguments))}}function AW(r,e,n){var a,c,h;n&&(r=r.bind(n));var p=function(){a=Date.now(),r.apply(this,h),c=void 0};return function(){var b=Date.now(),y=a===void 0?e:b-a;y>=e?(clearTimeout(c),c=void 0,a=b,r.apply(null,arguments)):(c=c||setTimeout(p,e-y),h=arguments)}}function LAe(r,e,n){var a;return n&&(r=r.bind(n)),function(c,h){var p=a===void 0?h:c-a;(a===void 0||p>=e)&&(a=c,r(c,p))}}function bW(r,e,n){var a;return function(){var c=this,h=arguments,p=n&&!a;clearTimeout(a),a=setTimeout((function(){a=null,n||r.apply(c,h)}),e),p&&r.apply(c,h)}}var Mo=Object.assign,jo=fAe();function sB(r){return JSON.parse(JSON.stringify(r))}var dc,um,rB=(dc=Yk((function(){return[]})),function(r,e){var n,a,c,h,p,b;if(r===void 0||e===void 0||r===null||e===null||!(r&&e&&r.constructor===Object&&e.constructor===Object||r.constructor===Array&&e.constructor===Array))return r===e;for(n in a=dc.use(),c=dc.use(),a.length=0,c.length=0,r)a.push(n);for(n in e)c.push(n);if(a.length!==c.length)return dc.recycle(a),dc.recycle(c),!1;for(h=0;h<a.length;++h)if(p=r[a[h]],b=e[a[h]],typeof p=="object"||typeof b=="object"||Array.isArray(p)&&Array.isArray(b)){if(p===b)continue;if(!rB(p,b))return dc.recycle(a),dc.recycle(c),!1}else if(p!==b)return dc.recycle(a),dc.recycle(c),!1;return dc.recycle(a),dc.recycle(c),!0}),yW=(um=[],function(r,e,n){var a,c,h,p,b,y,w;for(b in p=n||{},um.length=0,r)um.push(b);if(!e)return p;for(h in e)um.indexOf(h)===-1&&um.push(h);for(y=0;y<um.length;y++)a=r[b=um[y]],c=e[b],((w=a&&c&&a.constructor===Object&&c.constructor===Object)&&!rB(a,c)||!w&&a!==c)&&(p[b]=c);return p});function aB(r){return!r.metaKey&&document.activeElement===document.body}function NAe(r,e){e===void 0&&(e=" ");var n=new RegExp(e,"g");return(r=(r||"").replace(n,e)).split(e)}function DAe(r,e){e=e||{};var n={};return Object.keys(e).forEach((function(a){r.hasAttribute(a)&&(n[a]=r.getAttribute(a))})),n}function Dv(r){r=r.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");var e=new RegExp("[\\?&]"+r+"=([^&#]*)").exec(location.search);return e===null?"":decodeURIComponent(e[1].replace(/\+/g," "))}function vW(){return window.top!==window.self}function xW(r){for(var e=[],n=r.getElementsByTagName("*"),a=0,c=n.length;a<c;a++)n[a].isScene&&e.push(n[a]);return e}var y_,FAe=[dv({name:"viewport",content:"width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui,viewport-fit=cover"}),dv({name:"mobile-web-app-capable",content:"yes"}),dv({name:"theme-color",content:"black"})],OAe=[dv({name:"apple-mobile-web-app-capable",content:"yes"}),dv({name:"apple-mobile-web-app-status-bar-style",content:"black"}),(y_={rel:"apple-touch-icon",href:"https://aframe.io/images/aframe-logo-152.png"},{tagName:"link",attributes:y_,exists:function(){return document.querySelector('link[rel="'+y_.rel+'"]')}})];function dv(r){return{tagName:"meta",attributes:r,exists:function(){return document.querySelector('meta[name="'+r.name+'"]')}}}var mc,Wd,wW,GAe=Nn(5928),UAe=Nn.n(GAe),PAe=nA,XG="loading-screen";function v_(r){var e=mc.hasAttribute("embedded"),n=wW(mc.canvas,e,mc.maxCanvasSize,mc.is("vr-mode"));r.aspect=n.width/n.height,r.updateProjectionMatrix(),mc.renderer.setSize(n.width,n.height,!1)}const Sm=[];var CW=Bv()("core:propertyTypes:warn"),UR={},zAe=/[,> .[\]:]/,VAe=/url\((.+)\)/;function Jr(r,e,n,a,c,h){if(r in UR)throw new Error("Property type "+r+" is already registered.");UR[r]={default:e,parse:n||WAe,stringify:a||u2,equals:c||EW,isCacheable:h!==!1}}function QG(r,e){if(!Array.isArray(r)||!Array.isArray(e))return r===e;if(r.length!==e.length)return!1;for(var n=0;n<r.length;n++)if(r[n]!==e[n])return!1;return!0}function Hy(r){var e,n;return typeof r!="string"?r:(n=r.match(VAe))?n[1]:r.charAt(0)==="#"?(e=document.getElementById(r.substring(1)))?e.tagName==="CANVAS"||e.tagName==="VIDEO"||e.tagName==="IMG"?e:e.getAttribute("src"):void CW('"'+r+'" asset not found.'):r}function Xy(r){return r.getAttribute?r.getAttribute("id")?"#"+r.getAttribute("id"):r.getAttribute("src"):u2(r)}function WAe(r){return r}function u2(r){return r===null?"null":r.toString()}function EW(r,e){return r===e}function KG(r){return parseInt(r,10)}function x_(r,e,n){return o2(r,e,n)}function w_(r,e){if(r===null)return!0;if(typeof r!="object"||Object.keys(r).length!==e)return!1;var n=r.x,a=r.y,c=r.z,h=r.w;return!(typeof n!="number"||typeof a!="number"||e>2&&typeof c!="number"||e>3&&typeof h!="number")}Jr("audio","",Hy,Xy),Jr("array",[],(function(r){return Array.isArray(r)?r:r&&typeof r=="string"?r.split(",").map((function(e){return e.trim()})):[]}),(function(r){return r.join(", ")}),QG),Jr("asset","",Hy,Xy),Jr("boolean",!1,(function(r){return r!=="false"&&r!==!1})),Jr("color","#FFF"),Jr("int",0,KG),Jr("number",0,(function(r){return parseFloat(r,10)})),Jr("map","",Hy,Xy),Jr("model","",Hy,Xy),Jr("selector",null,(function(r){return r?typeof r!="string"?r:r[0]!=="#"||zAe.test(r)?document.querySelector(r):document.getElementById(r.substring(1)):null}),(function(r){return r.getAttribute?"#"+r.getAttribute("id"):u2(r)}),EW,!1),Jr("selectorAll",null,(function(r){return r?typeof r!="string"?r:Array.prototype.slice.call(document.querySelectorAll(r),0):null}),(function(r){return r instanceof Array?r.map((function(e){return"#"+e.getAttribute("id")})).join(", "):u2(r)}),QG,!1),Jr("src","",(function(r){return CW("`src` property type is deprecated. Use `asset` instead."),Hy(r)}),Xy),Jr("string",""),Jr("time",0,KG),Jr("vec2",{x:0,y:0},x_,uE,hE),Jr("vec3",{x:0,y:0,z:0},x_,uE,hE),Jr("vec4",{x:0,y:0,z:0,w:1},x_,uE,hE);var HAe=function(r,e){return(r!=="audio"||typeof e=="string")&&!(r==="array"&&!Array.isArray(e))&&(r!=="asset"||typeof e=="string")&&(r!=="boolean"||typeof e=="boolean")&&(r!=="color"||typeof e=="string")&&(r!=="int"||typeof e=="number")&&(r!=="number"||typeof e=="number")&&(r!=="map"||typeof e=="string")&&(r!=="model"||typeof e=="string")&&(r!=="selector"||typeof e=="string"||e===null)&&(r!=="selectorAll"||typeof e=="string"||e===null)&&(r!=="src"||typeof e=="string")&&(r!=="string"||typeof e=="string")&&(r!=="time"||typeof e=="number")&&(r==="vec2"?w_(e,2):r==="vec3"?w_(e,3):r!=="vec4"||w_(e,4))},XAe=UR,h2=$i("core:schema:warn");function tS(r){return"type"in r?typeof r.type=="string":"default"in r}function Zv(r,e){var n;if(tS(r))return PR(r,e);for(n in r)r[n]=PR(r[n],e);return r}function PR(r,e){var n,a,c=r.default,h=r.type;return r.type?r.type==="bool"?h="boolean":r.type==="float"&&(h="number"):h=c===void 0||typeof c!="boolean"&&typeof c!="number"?Array.isArray(c)?"array":"string":typeof c,(a=XAe[h])||h2("Unknown property type for component `"+e+"`: "+h),n=!!r.parse,r.parse=r.parse||a.parse,r.stringify=r.stringify||a.stringify,r.equals=r.equals||a.equals,r.isCacheable=r.isCacheable===!0||a.isCacheable,r.type=h,"default"in r?n||HAe(h,c)||h2("Default value `"+c+"` does not match type `"+h+"` in component `"+e+"`"):r.default=a.default,r}var Qy,SW=(Qy=[],function(r,e,n,a,c){var h,p,b,y;for(p in Qy.length=0,n?r:e)n&&r[p]===void 0||Qy.push(p);if(r===null||typeof r!="object")return r;for(p in r)r[p]===void 0||e[p]||c||h2("Unknown property `"+p+"` for component/system `"+a+"`.");for(h=0;h<Qy.length;h++){if(b=e[p=Qy[h]],y=r[p],!e[p])return;r[p]=nS(y,b)}return r});function nS(r,e,n){return r!=null&&r!==""||(r=e.default,Array.isArray(r)&&(r=r.slice())),e.parse(r,e.default,n)}function IW(r,e){var n,a,c,h,p={};for(n in r)a=e[n],typeof(h=c=r[n])=="object"&&(h=oB(c,a),a||h2("Unknown component property: "+n)),h!==void 0&&(p[n]=h);return p}function oB(r,e){return typeof r!="object"?r:e&&r!==null?e.stringify(r):JSON.stringify(r)}var hr={},nv=nS,TW=Zv,QAe=tS,KAe=IW,ZAe=oB,C_=nA,fv=$i("core:component:warn"),$Ae=document.currentScript,YAe=new RegExp("[A-Z]+"),MW={},jAe=Object.freeze({}),F0=[],qAe={get:function(r,e){return r.getComputedPropertyValue(e)},set:function(r,e,n){return e in r.schema?r.recomputeProperty(e,n):n!==void 0&&r.handleUnknownProperty(e,n),!0}},Fv=function(r,e,n){var a=this;if(this.sceneOnly&&!r.isScene)throw new Error("Component `"+this.name+"` can only be applied to <a-scene>");if(n&&!this.multiple)throw new Error("Trying to initialize multiple components of type `"+this.name+"`. There can only be one component of this type per entity.");this.el=r,this.id=n,this.attrName=this.name+(n?"__"+n:""),this.evtDetail={id:this.id,name:this.name},this.initialized=!1,this.el.components[this.attrName]=this,this.objectPool=MW[this.name];var c=this.events;this.events={},(function(h,p){var b;for(b in p)h.events[b]=p[b].bind(h)})(this,c),this.attrValue=void 0,this.isObjectBased?(this.data=this.objectPool.use(),Lv(this.data,this.schema),this.oldData=this.objectPool.use(),Lv(this.oldData,this.schema),this.attrValueProxy=new Proxy(this,qAe)):(this.data=void 0,this.oldData=void 0,this.attrValueProxy=void 0),this.deferUnknownPropertyWarnings=!!this.updateSchema,this.throttledEmitComponentChanged=AW((function(){r.emit("componentchanged",a.evtDetail,!1)}),200),this.updateProperties(e,!0)};Fv.prototype={schema:{},init:function(){},events:{},update:function(r){},updateSchema:void 0,tick:void 0,tock:void 0,play:function(){},pause:function(){},remove:function(){},stringify:function(r){var e=this.schema;return typeof r=="string"?r:this.isSingleProperty?ZAe(r,e):(r=KAe(r,e),C_.stringify(r))},flushToDOM:function(r){var e=r?this.data:this.attrValue;e!=null&&window.HTMLElement.prototype.setAttribute.call(this.el,this.attrName,this.stringify(e))},updateProperties:function(r,e){var n=this.el;this.updateData(r,e),(n.hasLoaded||n.isLoading)&&(this.initialized?this.callUpdateHandler():this.initComponent())},initComponent:function(){var r,e=this.el;e.initializingComponents[this.name]||(e.initializingComponents[this.name]=!0,this.init(),this.initialized=!0,delete e.initializingComponents[this.name],r=this.isObjectBased?jAe:void 0,this.dataChanged=!1,this.storeOldData(),this.update(r),e.isPlaying&&this.play(),e.emit("componentinitialized",this.evtDetail,!1))},updateData:function(r,e){this.isSingleProperty?this.recomputeProperty(void 0,r):(e?(jk(this.attrValue),this.recomputeData(r),this.schemaChangeRequired=!!this.updateSchema):typeof r=="string"?C_.parse(r,this.attrValueProxy):Mo(this.attrValueProxy,r),this.updateSchemaIfNeeded(r))},updateSchemaIfNeeded:function(r){if(this.schemaChangeRequired&&this.updateSchema)for(var e in F0.length=0,this.updateSchema(this.data),Lv(this.data,this.schema),this.recomputeData(r),this.schemaChangeRequired=!1,this.attrValue)this.attrValue[e]!==void 0&&F0.indexOf(e)===-1&&(e in this.schema||fv("Unknown property `"+e+"` for component `"+this.name+"`."));for(var n=0;n<F0.length;n++)fv("Unknown property `"+F0[n]+"` for component `"+this.name+"`.");F0.length=0},callUpdateHandler:function(){if(this.isPositionRotationScale||this.dataChanged){this.dataChanged=!1;var r=this.oldData;this.oldDataInUse=!0,this.update(r),r!==this.oldData&&this.objectPool.recycle(r),this.oldDataInUse=!1,this.storeOldData(),this.throttledEmitComponentChanged()}},handleMixinUpdate:function(){this.recomputeData(),this.updateSchemaIfNeeded(),this.callUpdateHandler()},resetProperty:function(r){(this.isSingleProperty||r in this.schema)&&(r?this.attrValue[r]=void 0:(this.isObjectBased&&this.objectPool.recycle(this.attrValue),this.attrValue=void 0),this.recomputeProperty(r,void 0),this.updateSchemaIfNeeded(),this.callUpdateHandler())},extendSchema:function(r){var e;e=Mo({},hr[this.name].schema),Mo(e,r),this.schema=TW(e),this.el.emit("schemachanged",this.evtDetail)},getComputedPropertyValue:function(r){var e=this.el.mixinEls,n=this.attrValue&&r?this.attrValue[r]:this.attrValue;if(n!==void 0)return n;for(var a=e.length-1;a>=0;a--){var c=e[a].getAttribute(this.attrName);if(c!==null&&(!r||r in c))return r?c[r]:c}return r?this.schema[r].default:this.schema.default},recomputeProperty:function(r,e){var n=r?this.schema[r]:this.schema;if(e!=null){this.attrValue===void 0&&this.isObjectBased&&(this.attrValue=this.objectPool.use());var a=r?this.attrValue[r]:this.attrValue;typeof(a=n.isCacheable?nv(e,n,a):e)=="string"&&(a=e===""?void 0:e),r?this.attrValue[r]=a:this.attrValue=a}this.oldDataInUse&&(this.oldData=this.objectPool.use(),Lv(this.oldData,this.schema),this.storeOldData(),this.oldDataInUse=!1);var c=r?this.oldData[r]:this.oldData,h=r?this.data[r]:this.data,p=nv(this.getComputedPropertyValue(r),n,h);return n.type!=="array"||r||(p=sB(p)),n.equals(p,c)||(this.dataChanged=!0,n.schemaChange&&(this.schemaChangeRequired=!0)),r?this.data[r]=p:this.data=p,p},handleUnknownProperty:function(r,e){this.attrValue===void 0&&(this.attrValue=this.objectPool.use()),this.attrValue[r]=e,this.deferUnknownPropertyWarnings?F0.push(r):this.silenceUnknownPropertyWarnings||fv("Unknown property `"+r+"` for component `"+this.name+"`.")},storeOldData:function(){var r;if(this.isObjectBased)if(this.isSingleProperty)this.oldData=nv(this.data,this.schema,this.oldData);else for(r in this.schema)this.data[r]!==void 0&&(this.data[r]&&typeof this.data[r]=="object"?this.oldData[r]=nv(this.data[r],this.schema[r],this.oldData[r]):this.oldData[r]=this.data[r]);else this.oldData=this.data},recomputeData:function(r){var e;if(this.isSingleProperty)this.recomputeProperty(void 0,r);else{for(e in this.schema)this.attrValueProxy[e]=void 0;r&&typeof r=="object"?Mo(this.attrValueProxy,r):typeof r=="string"&&C_.parse(r,this.attrValueProxy)}},eventsAttach:function(){var r;for(r in this.eventsDetach(),this.events)this.el.addEventListener(r,this.events[r])},eventsDetach:function(){var r;for(r in this.events)this.el.removeEventListener(r,this.events[r])},destroy:function(){this.objectPool.recycle(this.attrValue),this.objectPool.recycle(this.data),this.objectPool.recycle(this.oldData),this.attrValue=this.data=this.oldData=this.attrValueProxy=void 0}};var _W={};function kn(r,e){var n,a,c,h,p,b={};if(document.currentScript&&document.currentScript!==$Ae&&Sm.forEach((function(w){w.hasLoaded||document.currentScript.compareDocumentPosition(w)!==Node.DOCUMENT_POSITION_FOLLOWING&&(fv("The component `"+r+"` was registered in a <script> tag after the scene. Component <script> tags in an HTML file should be declared *before* the scene such that the component is available to entities during scene initialization."),window.debug&&(_W[r]=!0))})),YAe.test(r)===!0&&fv("The component name `"+r+"` contains uppercase characters, but HTML will ignore the capitalization of attribute names. Change the name to be lowercase: `"+r.toLowerCase()+"`"),r.indexOf("__")!==-1)throw new Error("The component name `"+r+"` is not allowed. The sequence __ (double underscore) is reserved to specify an id for multiple components of the same type");if(Object.keys(e).forEach((function(w){b[w]={value:e[w],writable:!0}})),hr[r])throw new Error("The component `"+r+"` has been already registered. Check that you are not loading two versions of the same component or two different components of the same name.");((n=function(w,I,E){Fv.call(this,w,I,E)}).prototype=Object.create(Fv.prototype,b)).name=r,n.prototype.isPositionRotationScale=r==="position"||r==="rotation"||r==="scale",n.prototype.constructor=n,n.prototype.system=IR&&xh[r],n.prototype.play=(h=n.prototype.play,function(){var w=this.el.sceneEl,I=this.el.isPlaying&&!this.isPlaying;this.initialized&&I&&(h.call(this),this.isPlaying=!0,this.eventsAttach(),ZG(this)&&w.addBehavior(this))}),n.prototype.pause=(p=n.prototype.pause,function(){var w=this.el.sceneEl;this.isPlaying&&(p.call(this),this.isPlaying=!1,this.eventsDetach(),ZG(this)&&w.removeBehavior(this))}),a=Mo(TW(n.prototype.schema,n.prototype.name)),n.prototype.isSingleProperty=c=QAe(n.prototype.schema),n.prototype.isObjectBased=!c||c&&($G(a.default)||$G(nv(void 0,a))),MW[r]=Yk(),hr[r]={Component:n,dependencies:n.prototype.dependencies,before:n.prototype.before,after:n.prototype.after,isSingleProperty:n.prototype.isSingleProperty,isObjectBased:n.prototype.isObjectBased,multiple:n.prototype.multiple,sceneOnly:n.prototype.sceneOnly,name:r,schema:a,stringify:n.prototype.stringify};for(var y=0;y<Sm.length;y++)Sm[y].emit("componentregistered",{name:r},!1);return n}function ZG(r){return r.tick||r.tock}function $G(r){return r&&r.constructor===Object&&!(r instanceof window.HTMLElement)}var d2=!1;function zR(){d2||(d2=!0,setTimeout((function(){document.dispatchEvent(new CustomEvent("aframeready"))})))}var JAe=nA,xh={},f2=function(r){var e=SR&&hr[this.name];this.el=r,this.sceneEl=r,e&&(e.Component.prototype.system=this),this.buildData(),this.init(),this.update({})};function kl(r,e){var n,a,c={},h=xW(document);if(Object.keys(e).forEach((function(p){c[p]={value:e[p],writable:!0}})),xh[r])throw new Error("The system `"+r+"` has been already registered. Check that you are not loading two versions of the same system or two different systems of the same name.");if(a=function(p){f2.call(this,p)},(a.prototype=Object.create(f2.prototype,c)).name=r,a.prototype.constructor=a,a.prototype.schema=Mo(Zv(a.prototype.schema)),xh[r]=a,d2)for(n=0;n<h.length;n++)h[n].initSystem(r)}f2.prototype={schema:{},init:function(){},update:function(r){},updateProperties:function(r){var e=this.data;Object.keys(this.schema).length!==0&&(this.buildData(r),this.update(e))},buildData:function(r){var e=this.schema;Object.keys(e).length!==0&&(r=r||window.HTMLElement.prototype.getAttribute.call(this.sceneEl,this.name),tS(e)?this.data=nS(r,e):this.data=SW(JAe.parse(r)||{},e,!1,this.name))},tick:void 0,tock:void 0,play:function(){},pause:function(){}};var E_=$i("core:a-node:warn"),VR={"a-scene":!0,"a-assets":!0,"a-assets-items":!0,"a-cubemap":!0,"a-mixin":!0,"a-node":!0,"a-entity":!0};function ebe(r){return r.tagName.toLowerCase()in VR||r.isANode}class na extends HTMLElement{constructor(){super(),this.computedMixinStr="",this.hasLoaded=!1,this.isANode=!0,this.mixinEls=[]}connectedCallback(){d2?this.doConnectedCallback():document.addEventListener("aframeready",this.connectedCallback.bind(this))}doConnectedCallback(){var e;this.sceneEl=this.closestScene(),this.sceneEl||E_("You are attempting to attach <"+this.tagName+"> outside of an A-Frame scene. Append this element to `<a-scene>` instead."),this.hasLoaded=!1,this.emit("nodeready",void 0,!1),this.isMixin||(e=this.getAttribute("mixin"))&&this.updateMixins(e)}attributeChangedCallback(e,n,a){a!==this.computedMixinStr&&(e!=="mixin"||this.isMixin||this.updateMixins(a,n))}closestScene(){for(var e=this;e&&!e.isScene;)e=e.parentElement;return e}closest(e){for(var n=this.matches||this.mozMatchesSelector||this.msMatchesSelector||this.oMatchesSelector||this.webkitMatchesSelector,a=this;a&&!n.call(a,e);)a=a.parentElement;return a}disconnectedCallback(){this.hasLoaded=!1}load(e,n){var a,c=this;this.hasLoaded||(n=n||ebe,a=this.getChildren().filter(n).map((function(h){return new Promise((function(p,b){if(h.hasLoaded)return p();h.addEventListener("loaded",p),h.addEventListener("error",b)}))})),Promise.allSettled(a).then((function(h){h.forEach((function(p){p.status==="rejected"&&E_("Rendering scene with errors on node: ",p.reason.target)})),c.isLoading=!0,c.setupMutationObserver(),e&&e(),c.isLoading=!1,c.hasLoaded=!0,c.emit("loaded-private",void 0,!1),c.emit("loaded",void 0,!1)})))}setupMutationObserver(){var e=this;new MutationObserver((function(n){var a;for(a=0;a<n.length;a++)if(n[a].type==="attributes"){var c=n[a].attributeName,h=window.HTMLElement.prototype.getAttribute.call(e,c),p=n[a].oldValue;e.attributeChangedCallback(c,p,h)}})).observe(this,{attributes:!0,attributeOldValue:!0})}getChildren(){return Array.prototype.slice.call(this.children,0)}updateMixins(e,n){var a,c,h,p=na.newMixinIdArray,b=na.oldMixinIdArray,y=na.mixinIds;for(p.length=0,b.length=0,c=e?Th(e.trim(),/\s+/):p,h=n?Th(n.trim(),/\s+/):b,y.newMixinIds=c,y.oldMixinIds=h,a=0;a<h.length;a++)c.indexOf(h[a])===-1&&this.unregisterMixin(h[a]);for(this.computedMixinStr="",this.mixinEls.length=0,a=0;a<c.length;a++)this.registerMixin(c[a]);return this.computedMixinStr&&(this.computedMixinStr=this.computedMixinStr.trim(),window.HTMLElement.prototype.setAttribute.call(this,"mixin",this.computedMixinStr)),c.length===0&&window.HTMLElement.prototype.removeAttribute.call(this,"mixin"),y}registerMixin(e){var n,a,c,h=document.getElementById(e);if(h){if(c=h.getAttribute("mixin"))for(n=Th(c.trim(),/\s+/),a=0;a<n.length;a++)this.registerMixin(n[a]);this.computedMixinStr=this.computedMixinStr+" "+h.id,this.mixinEls.push(h)}else E_("No mixin was found with id `%s`",e)}setAttribute(e,n){e==="mixin"&&this.updateMixins(n),window.HTMLElement.prototype.setAttribute.call(this,e,n)}unregisterMixin(e){var n,a=this.mixinEls;for(n=0;n<a.length;++n)if(e===a[n].id){a.splice(n,1);break}}emit(e,n,a,c){var h=na.evtData;a===void 0&&(a=!0),h.bubbles=!!a,h.detail=n,c&&(h=Mo({},c,h)),this.dispatchEvent(new CustomEvent(e,h))}}na.evtData={},na.newMixinIdArray=[],na.oldMixinIdArray=[],na.mixinIds={},customElements.define("a-node",na);var tbe=$i("core:a-entity:debug"),S_=$i("core:a-entity:warn"),p2="__",I_=["position","rotation","scale","visible"],nbe={once:!0};class Nr extends na{constructor(){super(),this.components={},this.initializingComponents={},this.componentsToUpdate={},this.isEntity=!0,this.isPlaying=!1,this.object3D=new X.Group,this.object3D.rotation.order="YXZ",this.object3D.el=this,this.object3DMap={},this.parentEl=null,this.rotationObj={},this.states=[]}attributeChangedCallback(e,n,a){var c=this.components[e];super.attributeChangedCallback(),c&&c.justInitialized&&a===""?delete c.justInitialized:(c||a!==null)&&this.setEntityAttribute(e,n,a)}doConnectedCallback(){var e,n,a=this;super.doConnectedCallback(),n=this.sceneEl,this.addToParent(),this.isScene||(n?!(e=n.querySelector("a-assets"))||e.hasLoaded?this.load():e.addEventListener("loaded",(function(){a.load()})):this.load())}disconnectedCallback(){var e;if(this.parentEl){for(e in this.components)this.removeComponent(e,!1);this.isScene||(this.removeFromParent(),super.disconnectedCallback(),this.object3D.el=null)}}getObject3D(e){return this.object3DMap[e]}setObject3D(e,n){var a,c=this;if(!(n instanceof X.Object3D))throw new Error("`Entity.setObject3D` was called with an object that was not an instance of THREE.Object3D.");(a=this.getObject3D(e))&&this.object3D.remove(a),n.el=this,n.children.length&&n.traverse((function(h){h.el=c})),this.object3D.add(n),this.object3DMap[e]=n,this.emit("object3dset",{object:n,type:e})}removeObject3D(e){var n=this.getObject3D(e);n?(this.object3D.remove(n),delete this.object3DMap[e],this.emit("object3dremove",{type:e})):S_("Tried to remove `Object3D` of type:",e,"which was not defined.")}getOrCreateObject3D(e,n){var a=this.getObject3D(e);return!a&&n&&(a=new n,this.setObject3D(e,a)),S_("`getOrCreateObject3D` has been deprecated. Use `setObject3D()` and `object3dset` event instead."),a}add(e){if(!e.object3D)throw new Error("Trying to add an element that doesn't have an `object3D`");this.object3D.add(e.object3D),this.emit("child-attached",{el:e})}addToParent(){var e=this.parentEl=this.parentNode;e&&e.add&&!this.attachedToParent&&(e.add(this),this.attachedToParent=!0)}removeFromParent(){var e=this.parentEl;this.parentEl.remove(this),this.attachedToParent=!1,this.parentEl=null,e.emit("child-detached",{el:this})}load(){var e=this;!this.hasLoaded&&this.parentEl&&super.load.call(this,(function(){e.parentEl&&(e.updateComponents(),(e.isScene||e.parentEl.isPlaying)&&e.play())}))}remove(e){e?this.object3D.remove(e.object3D):this.parentNode.removeChild(this)}getChildEntities(){for(var e=this.children,n=[],a=0;a<e.length;a++){var c=e[a];c instanceof Nr&&n.push(c)}return n}initComponent(e,n,a){var c,h,p,b;b=(p=Th(e,p2))[0],h=p.length>2?p.slice(1).join("__"):p[1],hr[b]&&(YG(this,e)||n!==void 0||a)&&(e in this.components||(this.initComponentDependencies(b),c=new hr[b].Component(this,n,h),this.isPlaying&&c.play(),this.hasAttribute(e)||(c.justInitialized=!0,window.HTMLElement.prototype.setAttribute.call(this,e,"")),tbe("Component initialized: %s",e)))}initComponentDependencies(e){var n,a;if(hr[e]&&(n=hr[e].dependencies))for(a=0;a<n.length;a++)this.initComponent(n[a],window.HTMLElement.prototype.getAttribute.call(this,n[a])||void 0,!0)}removeComponent(e,n){var a;(a=this.components[e])&&(a.initialized?(a.pause(),a.remove(),n&&(a.destroy(),delete this.components[e],this.hasAttribute(e)&&window.HTMLElement.prototype.removeAttribute.call(this,e)),this.emit("componentremoved",a.evtDetail,!1)):this.addEventListener("componentinitialized",(function c(h){h.detail.name===e&&(this.removeComponent(e,n),this.removeEventListener("componentinitialized",c))})))}updateComponents(){var e,n,a,c,h,p,b=this.componentsToUpdate;if(this.hasLoaded||this.isLoading){for(a=0;a<this.mixinEls.length;a++)for(c in this.mixinEls[a].componentCache)T_(c)&&(b[c]=!0);if(this.getExtraComponents)for(c in n=this.getExtraComponents())T_(c)&&(b[c]=!0);for(a=0;a<this.attributes.length;++a)c=this.attributes[a].name,I_.indexOf(c)===-1&&T_(c)&&(b[c]=!0);for(a=0;a<I_.length;a++)c=I_[a],this.hasAttribute(c)&&this.updateComponent(c,this.getDOMAttribute(c));for(c in b)h=this.getDOMAttribute(c),e=(p=n&&n[c])?p.constructor===Object?Mo(p,Nv(h||{})):h||p:h,this.updateComponent(c,e),delete b[c]}}updateComponent(e,n,a){var c=this.components[e];if(c)return n!==null||YG(this,e)?void c.updateProperties(n,a):void this.removeComponent(e,!0);this.initComponent(e,n,!1)}removeAttribute(e,n){var a=this.components[e];a&&n===void 0&&this.removeComponent(e,!0),a&&n!==void 0?a.resetProperty(n):(e==="mixin"&&this.mixinUpdate(""),window.HTMLElement.prototype.removeAttribute.call(this,e))}play(){var e,n,a;if(!this.isPlaying&&(this.hasLoaded||this.isLoading)){for(a in this.isPlaying=!0,this.components)this.components[a].play();for(e=this.getChildEntities(),n=0;n<e.length;n++)e[n].play();this.emit("play")}}pause(){var e,n,a;if(this.isPlaying){for(a in this.isPlaying=!1,this.components)this.components[a].pause();for(e=this.getChildEntities(),n=0;n<e.length;n++)e[n].pause();this.emit("pause")}}setEntityAttribute(e,n,a){if(hr[e]||this.components[e])this.updateComponent(e,a);else if(e==="mixin"){if(a===this.computedMixinStr)return;this.mixinUpdate(a,n)}}mixinUpdate(e,n,a){var c,h,p,b,y=Nr.componentsUpdated,w=this;if(a||(n=n||this.getAttribute("mixin")),this.hasLoaded){for(p=this.updateMixins(e,n),y.length=0,b=0;b<this.mixinEls.length;b++)for(c in this.mixinEls[b].componentCache)y.indexOf(c)===-1&&(this.components[c]?this.components[c].handleMixinUpdate():this.initComponent(c,null),y.push(c));for(b=0;b<p.oldMixinIds.length;b++)if(h=document.getElementById(p.oldMixinIds[b]))for(c in h.componentCache)y.indexOf(c)===-1&&this.components[c]&&(this.getDOMAttribute(c)?this.components[c].handleMixinUpdate():this.removeComponent(c,!0))}else this.addEventListener("loaded-private",(function(){w.mixinUpdate(e,n,!0)}),nbe)}setAttribute(e,n,a){var c,h,p,b,y,w=Nr.singlePropUpdate;if(p=(b=e.indexOf(p2))>0?e.substring(0,b):e,!hr[p])return e==="mixin"&&this.mixinUpdate(n),void super.setAttribute.call(this,e,n);if(!this.components[e]&&this.hasAttribute(e)&&this.updateComponent(e,window.HTMLElement.prototype.getAttribute.call(this,e)),a!==void 0&&typeof n=="string"&&n.length>0&&typeof Nv(n)=="string"){for(y in w)delete w[y];(c=w)[n]=a,h=!1}else c=n,h=a===!0;this.updateComponent(e,c,h),this.sceneEl&&this.sceneEl.getAttribute("debug")&&this.components[e].flushToDOM()}flushToDOM(e){var n,a,c,h=this.components,p=this.children;for(c in h)h[c].flushToDOM();if(e)for(a=0;a<p.length;++a)(n=p[a]).flushToDOM&&n.flushToDOM(e)}getAttribute(e){var n,a,c,h;return e==="position"?this.object3D.position:e==="rotation"?(a=X.MathUtils.radToDeg,c=this.object3D.rotation,(h=this.rotationObj).x=a(c.x),h.y=a(c.y),h.z=a(c.z),h):e==="scale"?this.object3D.scale:e==="visible"?this.object3D.visible:(n=this.components[e])?n.data:window.HTMLElement.prototype.getAttribute.call(this,e)}getDOMAttribute(e){var n=this.components[e];return n?n.attrValue:window.HTMLElement.prototype.getAttribute.call(this,e)}addState(e){this.is(e)||(this.states.push(e),this.emit("stateadded",e))}removeState(e){var n=this.states.indexOf(e);n!==-1&&(this.states.splice(n,1),this.emit("stateremoved",e))}is(e){return this.states.indexOf(e)!==-1}inspect(){this.sceneEl.components.inspector.openInspector(this)}destroy(){var e;if(this.parentNode)S_("Entity can only be destroyed if detached from scenegraph.");else for(e in this.components)this.components[e].destroy()}}function YG(r,e){return!(!r.components[e]||!r.components[e].attrValue)||(function(n,a){var c,h=!1;for(c=0;c<a.length&&!(h=a[c].hasAttribute(n));++c);return h})(e,r.mixinEls)}function T_(r){return r.indexOf(p2)!==-1&&(r=Th(r,p2)[0]),!!hr[r]}function ibe(r){if(r.data&&r.data.type==="vr")switch(r.data.data){case"enter":this.enterVR();break;case"exit":this.exitVR()}}Nr.componentsUpdated=[],Nr.singlePropUpdate={},customElements.define("a-entity",Nr),Kv()&&window.addEventListener("orientationchange",(function(){document.documentElement.style.height="initial",setTimeout((function(){document.documentElement.style.height="100%",setTimeout((function(){window.scrollTo(0,1)}),500)}),500)}));var M_=$i("core:a-scene:warn"),sbe=Kv(),jG=ef(),rbe=q2;class RW extends Nr{constructor(){var e;super(),(e=this).clock=new X.Clock,e.isIOS=sbe,e.isMobile=jG,e.hasWebXR=rbe,e.isAR=!1,e.isScene=!0,e.object3D=new X.Scene,e.resize=e.resize.bind(e),e.render=e.render.bind(e),e.systems={},e.systemNames=[],e.time=e.delta=0,e.usedOfferSession=!1,e.componentOrder=[],e.behaviors={},e.hasLoaded=!1,e.isPlaying=!1,e.originalHTML=e.innerHTML}addFullScreenStyles(){document.documentElement.classList.add("a-fullscreen")}removeFullScreenStyles(){document.documentElement.classList.remove("a-fullscreen")}doConnectedCallback(){var e=this,n=this.hasAttribute("embedded");this.setAttribute("inspector",""),this.setAttribute("keyboard-shortcuts",""),this.setAttribute("screenshot",""),this.setAttribute("xr-mode-ui",""),this.setAttribute("device-orientation-permission-ui",""),super.doConnectedCallback(),(function(a){var c;function h(){document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||a.exitVR(),document.activeElement.blur(),document.body.focus()}(c=document.createElement("canvas")).classList.add("a-canvas"),c.dataset.aframeCanvas=!0,a.appendChild(c),document.addEventListener("fullscreenchange",h),document.addEventListener("mozfullscreenchange",h),document.addEventListener("webkitfullscreenchange",h),document.addEventListener("MSFullscreenChange",h),c.addEventListener("touchmove",(function(p){p.preventDefault()}),{passive:!1}),a.canvas=c,a.emit("render-target-loaded",{target:c}),setTimeout(a.resize.bind(a),0)})(this),this.setupRenderer(),(function(a,c){wW=c;var h,p,b,y,w,I,E,R,k,G,N=(mc=a).hasAttribute(XG)?PAe.parse(mc.getAttribute(XG)):void 0,O=N&&N.dotsColor||"white",D=N&&N.backgroundColor||"#24CAFF";(N===void 0||N.enabled==="true"||N.enabled===void 0)&&(h=new X.Scene,p=new X.SphereGeometry(.2,36,18,0,2*Math.PI,0,Math.PI),b=new X.MeshBasicMaterial({color:O}),y=new X.Mesh(p,b),w=y.clone(),I=y.clone(),E=new X.PerspectiveCamera(80,window.innerWidth/window.innerHeight,5e-4,1e4),R=new X.Clock,k=0,G=function(){mc.renderer.render(h,E),k=R.getElapsedTime()%4,y.visible=k>=1,w.visible=k>=2,I.visible=k>=3},h.background=new X.Color(D),h.add(E),y.position.set(-1,0,-15),w.position.set(0,0,-15),I.position.set(1,0,-15),E.add(y),E.add(w),E.add(I),(Wd=document.createElement("div")).className="a-loader-title",Wd.innerHTML=document.title,Wd.style.display="none",Wd.setAttribute(ta,""),mc.appendChild(Wd),setTimeout((function(){mc.hasLoaded||(v_(E),Wd.style.display="block",window.addEventListener("resize",(function(){v_(E)})),mc.renderer.setAnimationLoop(G))}),200))})(this,eU),this.resize(),n||this.addFullScreenStyles(),vW()&&window.addEventListener("message",ibe.bind(this)),(function(a){var c,h=document.head,p=h.querySelector("script"),b=[];return FAe.forEach(y),a.isIOS&&OAe.forEach(y),b;function y(w){w&&!w.exists()&&(c=(function(I){if(I&&I.tagName){var E=document.createElement(I.tagName);return E.setAttribute(ta,""),Mo(E,I.attributes)}})(w),c&&(p?p.parentNode.insertBefore(c,p):h.appendChild(c),b.push(c)))}})(this),(function(a){if(a.isMobile){var c=a.wakelock=new(UAe());a.addEventListener("enter-vr",(function(){c.request()})),a.addEventListener("exit-vr",(function(){c.release()}))}})(this),this.enterVRBound=function(){e.enterVR()},this.exitVRBound=function(){e.exitVR()},window.addEventListener("sessionend",this.resize),this.addEventListener("cameraready",(function(){e.attachedCallbackPostCamera()})),this.initSystems(),this.componentOrder=qG(hr,this.componentOrder),this.addEventListener("componentregistered",(function(){e.componentOrder=qG(hr,e.componentOrder)})),this.hasWebXR&&navigator.xr&&navigator.xr.addEventListener&&navigator.xr.addEventListener("sessiongranted",(function(){e.enterVR()}))}attachedCallbackPostCamera(){var e=this;window.addEventListener("load",void 0),window.addEventListener("resize",(function(){e.isIOS?setTimeout(e.resize,100):e.resize()})),this.play(),Sm.push(this)}initSystems(){var e;for(e in this.initSystem("camera"),xh)e!=="camera"&&this.initSystem(e)}initSystem(e){this.systems[e]||(this.systems[e]=new xh[e](this),this.systemNames.push(e))}disconnectedCallback(){var e=Sm.indexOf(this);super.disconnectedCallback(),Sm.splice(e,1),window.removeEventListener("sessionend",this.resize),this.removeFullScreenStyles(),this.renderer.dispose()}addBehavior(e){var n,a,c=this.behaviors[e.name];for(a in c||(c=this.behaviors[e.name]={tick:{inUse:!1,array:[],markedForRemoval:[]},tock:{inUse:!1,array:[],markedForRemoval:[]}}),c)if(e[a]){if((n=c[a]).inUse){var h=n.markedForRemoval.indexOf(e);h!==-1&&n.markedForRemoval.splice(h,1)}n.array.indexOf(e)===-1&&n.array.push(e)}}getPointerLockElement(){return document.pointerLockElement}checkHeadsetConnected(){return Wk()}enterAR(){var e;if(!this.hasWebXR)throw e="Failed to enter AR mode, WebXR not supported.",new Error(e);if(!Hk())throw e="Failed to enter AR, WebXR immersive-ar mode not supported in your browser or device.",new Error(e);return this.enterVR(!0)}enterVR(e,n){var a,c=this,h=c.renderer.xr;if(n&&(!navigator.xr||!navigator.xr.offerSession))return Promise.resolve("OfferSession is not supported.");if(c.usedOfferSession&&n)return Promise.resolve("OfferSession was already called.");if(this.is("vr-mode"))return Promise.resolve("Already in VR.");if(this.checkHeadsetConnected()||this.isMobile){var p=c.getAttribute("renderer");if(h.enabled=!0,this.hasWebXR){this.xrSession&&this.xrSession.removeEventListener("end",this.exitVRBound);var b=this.sceneEl.systems.webxr.sessionReferenceSpaceType;h.setReferenceSpaceType(b);var y=e?"immersive-ar":"immersive-vr";return a=this.sceneEl.systems.webxr.sessionConfiguration,new Promise((function(I,E){var R=n?navigator.xr.offerSession.bind(navigator.xr):navigator.xr.requestSession.bind(navigator.xr);c.usedOfferSession|=n,R(y,a).then((function(k){n&&(c.usedOfferSession=!1),h.layersEnabled=a.requiredFeatures.indexOf("layers")!==-1,h.setSession(k).then((function(){h.setFoveation(p.foveationLevel),c.xrSession=k,c.systems.renderer.setWebXRFrameRate(k),k.addEventListener("end",c.exitVRBound),w(I)}))}),(function(k){E(new Error("Failed to enter "+(y==="immersive-ar"?"AR":"VR")+" mode (`requestSession`)",{cause:k}))}))}))}throw new Error("Failed to enter "+(e?"AR":"VR")+" no WebXR")}return w(),Promise.resolve();function w(I){var E;e?c.addState("ar-mode"):c.addState("vr-mode"),c.emit("enter-vr",{target:c}),!c.hasWebXR&&c.isMobile&&screen.orientation&&screen.orientation.lock&&screen.orientation.lock("landscape"),c.addFullScreenStyles(),c.isMobile||c.checkHeadsetConnected()||((E=c.canvas).requestFullscreen||E.webkitRequestFullscreen||E.mozRequestFullScreen||E.msRequestFullscreen).apply(E,[{navigationUI:"hide"}]),c.resize(),I&&I()}}exitVR(){var e=this,n=this.renderer.xr;if(!this.is("vr-mode")&&!this.is("ar-mode"))return Promise.resolve("Not in immersive mode.");if(this.checkHeadsetConnected()||this.isMobile){if(n.enabled=!1,!this.hasWebXR)throw Error("Failed to exit VR - no WebXR");this.xrSession.removeEventListener("end",this.exitVRBound),this.xrSession.end().then((function(){}),(function(){})),this.xrSession=void 0}else(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement)&&(document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen());return e.removeState("vr-mode"),e.removeState("ar-mode"),e.isMobile&&screen.orientation&&screen.orientation.unlock&&screen.orientation.unlock(),e.hasAttribute("embedded")&&e.removeFullScreenStyles(),e.resize(),e.isIOS&&dW(e.canvas),e.renderer.setPixelRatio(window.devicePixelRatio),e.emit("exit-vr",{target:e}),Promise.resolve()}getAttribute(e){var n=this.systems[e];return n?n.data:Nr.prototype.getAttribute.call(this,e)}getDOMAttribute(e){var n=this.systems[e];return n?n.data:Nr.prototype.getDOMAttribute.call(this,e)}setAttribute(e,n,a){if(xh[e]){na.prototype.setAttribute.call(this,e,n);var c=this.systems[e];c&&c.updateProperties(n)}else Nr.prototype.setAttribute.call(this,e,n,a)}removeBehavior(e){var n,a,c,h=this.behaviors[e.name];for(a in h)e[a]&&(c=(n=h[a]).array.indexOf(e))!==-1&&(n.inUse?n.markedForRemoval.indexOf(e)===-1&&n.markedForRemoval.push(e):(n.array[c]=n.array[n.array.length-1],n.array.pop()))}resize(){var e,n,a=this.camera,c=this.canvas,h=this.renderer.xr.isPresenting;e=this.renderer.xr.enabled&&h,!a||!c||this.is("vr-mode")&&(this.isMobile||e)||(n=eU(c,this.getAttribute("embedded")&&!this.is("vr-mode"),this.maxCanvasSize,this.is("vr-mode")),a.aspect=n.width/n.height,a.updateProjectionMatrix(),this.renderer.setSize(n.width,n.height,!1),this.emit("rendererresize",null,!1))}setupRenderer(){var e,n,a,c=this;a={alpha:!0,antialias:!jG,canvas:this.canvas,logarithmicDepthBuffer:!1,powerPreference:"high-performance"},this.maxCanvasSize={height:-1,width:-1},this.hasAttribute("renderer")&&((n=Nv(this.getAttribute("renderer"))).precision&&(a.precision=n.precision+"p"),n.antialias&&n.antialias!=="auto"&&(a.antialias=n.antialias==="true"),n.logarithmicDepthBuffer&&n.logarithmicDepthBuffer!=="auto"&&(a.logarithmicDepthBuffer=n.logarithmicDepthBuffer==="true"),n.alpha&&(a.alpha=n.alpha==="true"),n.stencil&&(a.stencil=n.stencil==="true"),n.multiviewStereo&&(a.multiviewStereo=n.multiviewStereo==="true"),this.maxCanvasSize={width:n.maxCanvasWidth?parseInt(n.maxCanvasWidth):this.maxCanvasSize.width,height:n.maxCanvasHeight?parseInt(n.maxCanvasHeight):this.maxCanvasSize.height});var h=["WebGLRenderer","WebGPURenderer"].find((function(p){return X[p]}));(e=this.renderer=new X[h](a)).xr.setPoseTarget||(e.xr.setPoseTarget=function(){}),e.setPixelRatio(window.devicePixelRatio),this.camera&&e.xr.setPoseTarget(this.camera.el.object3D),this.addEventListener("camera-set-active",(function(){e.xr.setPoseTarget(c.camera.el.object3D)}))}play(){var e=this,n=this;this.renderStarted?Nr.prototype.play.call(this):(this.addEventListener("loaded",(function(){var a=this.renderer;Nr.prototype.play.call(this),n.renderStarted||(n.resize(),n.renderer&&(window.performance&&window.performance.mark("render-started"),window.removeEventListener("resize",v_),Wd&&(Wd.style.display="none"),a.setAnimationLoop(this.render),n.renderStarted=!0,n.emit("renderstart")))})),setTimeout((function(){Nr.prototype.load.call(e)})))}updateComponent(e){e in xh||Nr.prototype.updateComponent.apply(this,arguments)}tick(e,n){var a,c=this.systems;for(this.callComponentBehaviors("tick",e,n),a=0;a<this.systemNames.length;a++)c[this.systemNames[a]].tick&&c[this.systemNames[a]].tick(e,n)}tock(e,n,a){var c,h=this.systems;for(this.callComponentBehaviors("tock",e,n),c=0;c<this.systemNames.length;c++)h[this.systemNames[c]].tock&&h[this.systemNames[c]].tock(e,n,a)}render(e,n){var a=this.renderer;this.frame=n,this.delta=1e3*this.clock.getDelta(),this.time=1e3*this.clock.elapsedTime,this.isPlaying&&this.tick(this.time,this.delta);var c=null;if(this.is("ar-mode")&&(c=this.object3D.background,this.object3D.background=null),a.render(this.object3D,this.camera),c&&(this.object3D.background=c),this.isPlaying){var h=a.xr.isPresenting?a.xr.getCamera():this.camera;this.tock(this.time,this.delta,h)}}callComponentBehaviors(e,n,a){for(var c,h=0;h<this.componentOrder.length;h++){var p=this.behaviors[this.componentOrder[h]];if(p){var b=p[e];for(b.inUse=!0,c=0;c<b.array.length;c++)b.array[c].isPlaying&&b.array[c][e](n,a);for(b.inUse=!1,c=0;c<b.markedForRemoval.length;c++)this.removeBehavior(b.markedForRemoval[c]);b.markedForRemoval.length=0}}}}function qG(r,e){var n,a,c={},h=e||[];for(a in h.length=0,r){var p=r[a];if(p!==void 0){var b=p.before?p.before.slice(0):[],y=p.after?p.after.slice(0):[];c[a]={before:b,after:y,visited:!1,done:!1}}}for(a in c)for(n=0;n<c[a].before.length;n++){var w=c[a].before[n];w in c?c[w].after.push(a):M_("Invalid ordering constraint, no component named `"+w+"` referenced by `"+a+"`")}function I(E){if(E in c&&!c[E].done)if(c[E].visited)M_("Cycle detected, ignoring one or more before/after constraints. The resulting order might be incorrect");else{c[E].visited=!0;for(var R=0;R<c[E].after.length;R++){var k=c[E].after[R];k in c||M_("Invalid before/after constraint, no component named `"+k+"` referenced in `"+E+"`"),I(k)}c[E].done=!0,h.push(E)}}for(a in c)c[a].done||I(a);return h}function JG(r,e){var n,a=window.devicePixelRatio;return!e||e.width===-1&&e.height===-1||r.width*a<e.width&&r.height*a<e.height||(n=r.width/r.height,r.width*a>e.width&&e.width!==-1&&(r.width=Math.round(e.width/a),r.height=Math.round(e.width/n/a)),r.height*a>e.height&&e.height!==-1&&(r.height=Math.round(e.height/a),r.width=Math.round(e.height*n/a))),r}function eU(r,e,n,a){return r.parentElement?e?JG({height:r.parentElement.offsetHeight,width:r.parentElement.offsetWidth},n):(function(c,h){var p;return p={height:document.body.offsetHeight,width:document.body.offsetWidth},h?p:JG(p,c)})(n,a):{height:0,width:0}}customElements.define("a-scene",RW);var abe=Zv,tf={},lB=[],WR=function(){};function eo(r,e){var n,a={};if(Object.keys(e).forEach((function(c){a[c]={value:e[c],writable:!0}})),tf[r])throw new Error("The geometry `"+r+"` has been already registered");return((n=function(){WR.call(this)}).prototype=Object.create(WR.prototype,a)).name=r,n.prototype.constructor=n,tf[r]={Geometry:n,schema:abe(n.prototype.schema)},lB.push(r),n}WR.prototype={schema:{},init:function(r){return this.geometry=new X.BufferGeometry,this.geometry},update:function(r){}};var cB=$i,obe=qk,lbe=cB("extras:primitives:debug"),tU=cB("extras:primitives:warn"),cbe=cB("extras:primitives:error"),kW={};function ja(r,e){if(r=r.toLowerCase(),!VR[r]){VR[r]=!0,lbe("Registering <%s>",r),e.defaultAttributes&&tU("The 'defaultAttributes' object is deprecated. Use 'defaultComponents' instead.");var n=e.mappings||{},a=class extends Nr{constructor(){super(),this.defaultComponentsFromPrimitive=e.defaultComponents||e.defaultAttributes||{},this.deprecated=e.deprecated||null,this.deprecatedMappings=e.deprecatedMappings||{},this.mappings=n,e.deprecated&&console.warn(e.deprecated),this.resolveMappingCollisions()}resolveMappingCollisions(){var c=this.mappings,h=this;Object.keys(c).forEach((function(p){var b;p!==p.toLowerCase()&&tU("Mapping keys should be specified in lower case. The mapping key "+p+" may not be recognized"),hr[p]&&(b=c[p].replace(".","-"),c[b]=c[p],delete c[p],console.warn("The primitive "+h.tagName.toLowerCase()+" has a mapping collision. The attribute "+p+" has the same name as a registered component and has been renamed to "+b))}))}getExtraComponents(){var c,h,p,b,y,w=this;for(h=sB(this.defaultComponentsFromPrimitive),(y=this.getAttribute("mixin"))&&(y=Th(y.trim(),/\s+/)).forEach((function(k){var G,N,O=document.getElementById(k);if(O){var D=O.rawAttributeCache,W=O.componentCache;for(var H in D){if(b=w.mappings[H])return void nU(b,D[H],h);H in W&&(h[H]=(G=h[H],N=W[H],I(G)?E(N):I(N)?E(G):R(G)&&R(N)?jo(G,N):E(N)))}}})),p=0;p<this.attributes.length;p++)c=this.attributes[p],(b=this.mappings[c.name])&&nU(b,c.value,h);return h;function I(k){return k===void 0}function E(k){return R(k)?jo({},k):k}function R(k){return k!==null&&k.constructor===Object}}attributeChangedCallback(c,h,p){var b=this.mappings[c];c in this.deprecatedMappings&&console.warn(this.deprecatedMappings[c]),c&&b?obe(this,b,p):super.attributeChangedCallback(c,h,p)}};return customElements.define(r,a),a.mappings=n,kW[r]=a,a}cbe("Trying to register primitive "+r+" that has been already previously registered")}function nU(r,e,n){var a=J2(r);a.constructor===Array?(n[a[0]]=n[a[0]]||{},n[a[0]][a[1]]=e.trim()):n[a]=e.trim()}var Au={},BW=[],ube={array:"v3",color:"v3",int:"i",number:"f",map:"t",time:"f",vec2:"v2",vec3:"v3",vec4:"v4"},HR=function(){};function Kd(r,e){var n,a={};if(Object.keys(e).forEach((function(c){a[c]={value:e[c],writable:!0}})),Au[r])throw new Error("The shader "+r+" has already been registered");return((n=function(){HR.call(this)}).prototype=Object.create(HR.prototype,a)).name=r,n.prototype.constructor=n,Au[r]={Shader:n,schema:Zv(n.prototype.schema)},BW.push(r),n}HR.prototype={schema:{},vertexShader:"void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}",fragmentShader:"void main() {gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);}",init:function(r){return this.uniforms=this.initUniforms(),this.material=new(this.raw?X.RawShaderMaterial:X.ShaderMaterial)({uniforms:this.uniforms,glslVersion:this.raw||this.glsl3?X.GLSL3:null,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader}),this.material},initUniforms:function(){var r,e,n=this.schema,a={};for(r in n)n[r].is==="uniform"&&(e=ube[n[r].type],a[r]={type:e,value:void 0});return a},update:function(r){var e,n,a=this.schema,c=this.uniforms;for(e in r)if(a[e]&&a[e].is==="uniform")if(a[e].type!=="map")c[e].value=this.parseValue(a[e].type,r[e]),c[e].needsUpdate=!0;else{if(!c[e]||c[e].value===r[e])continue;n="_texture_"+e,this.setMapOnTextureLoad(c,e,n),eS(n,e,this,r)}},parseValue:function(r,e){var n;switch(r){case"vec2":return new X.Vector2(e.x,e.y);case"vec3":return new X.Vector3(e.x,e.y,e.z);case"vec4":return new X.Vector4(e.x,e.y,e.z,e.w);case"color":return n=new X.Color(e),new X.Vector3(n.r,n.g,n.b);default:return e}},setMapOnTextureLoad:function(r,e,n){var a=this;this.el.addEventListener("materialtextureloaded",(function(){r[e].value=a.material[n],r[e].needsUpdate=!0}))}};var __=new X.FileLoader,XR=$i("core:a-assets:warn");function hbe(r){if(r.hasAttribute("autoplay")||r.getAttribute("preload")==="auto")return new Promise((function(e,n){if(r.readyState===4)return e();if(r.error)return n();function a(){for(var c=0,h=0;h<r.buffered.length;h++)c+=r.buffered.end(h)-r.buffered.start(h);c>=r.duration&&(r.tagName==="VIDEO"&&X.Cache.add(r.getAttribute("src"),r),e())}r.addEventListener("loadeddata",a,!1),r.addEventListener("progress",a,!1),r.addEventListener("error",n,!1)}))}function iU(r){var e=(function(n){var a,c,h;return n.hasAttribute("crossorigin")||(a=n.getAttribute("src"))!==null&&(a.indexOf("://")===-1||(h=(c=a).indexOf("://")>-1?c.split("/")[2]:c.split("/")[0]).substring(0,h.indexOf(":"))===window.location.host)?n:(XR('Cross-origin element (e.g., <img>) was requested without `crossorigin` set. A-Frame will re-request the asset with `crossorigin` attribute set. Please set `crossorigin` on the element (e.g., <img crossorigin="anonymous">)',a),n.crossOrigin="anonymous",n.cloneNode(!0))})(r);return e.tagName&&e.tagName.toLowerCase()==="video"&&(e.setAttribute("playsinline",""),e.setAttribute("webkit-playsinline","")),e!==r&&(r.parentNode.appendChild(e),r.parentNode.removeChild(r)),e}customElements.define("a-assets",class extends na{constructor(){super(),this.isAssets=!0,this.fileLoader=__,this.timeout=null}doConnectedCallback(){var r,e,n,a,c,h,p=this,b=[];if(super.doConnectedCallback(),!this.parentNode.isScene)throw new Error("<a-assets> must be a child of a <a-scene>.");for(c=this.querySelectorAll("img"),r=0;r<c.length;r++)a=iU(c[r]),b.push(new Promise((function(y,w){X.Cache.add(c[r].getAttribute("src"),a),a.complete?y():(a.onload=y,a.onerror=w)})));for(n=this.querySelectorAll("audio, video"),r=0;r<n.length;r++)(e=iU(n[r])).src||e.srcObject||XR("Audio/video asset has neither `src` nor `srcObject` attributes."),b.push(hbe(e));this.getChildren().forEach((function(y){y.isAssetItem&&y.hasAttribute("src")&&b.push(new Promise((function(w,I){if(y.hasLoaded)return w();y.addEventListener("loaded",w),y.addEventListener("error",I)})))})),Promise.allSettled(b).then((function(){p.timeout!==null&&p.load()})),h=parseInt(this.getAttribute("timeout"),10)||3e3,this.timeout=setTimeout((function(){p.hasLoaded||(XR("Asset loading timed out in",h,"ms"),p.timeout=null,p.emit("timeout"),p.load())}),h)}disconnectedCallback(){super.disconnectedCallback(),this.timeout&&clearTimeout(this.timeout)}load(){super.load.call(this,null,(function(){return!1}))}}),customElements.define("a-asset-item",class extends na{constructor(){super(),this.data=null,this.isAssetItem=!0}connectedCallback(){var r=this,e=this.getAttribute("src");__.setResponseType(this.getAttribute("response-type")||(function(n){var a=(function(h){var p=document.createElement("a");p.href=h;var b=p.search.replace(/^\?/,""),y=h.replace(b,"").replace("?","");return y.substring(y.lastIndexOf("/")+1)})(n),c=a.lastIndexOf(".");return c>=0&&a.slice(c,n.search(/\?|#|$/))===".glb"?"arraybuffer":"text"})(e)),__.load(e,(function(n){r.data=n,na.prototype.load.call(r)}),(function(n){r.emit("progress",{loadedBytes:n.loaded,totalBytes:n.total,xhr:n})}),(function(n){r.emit("error",{xhr:n},!1)}))}});var dbe=$i("core:cubemap:warn");class uB extends HTMLElement{constructor(e){return super(e)}onReadyStateChange(){document.readyState==="complete"&&this.doConnectedCallback()}connectedCallback(){document.readyState==="complete"?uB.prototype.doConnectedCallback.call(this):document.addEventListener("readystatechange",this.onReadyStateChange.bind(this))}doConnectedCallback(){this.srcs=this.validate()}validate(){var e,n=this.querySelectorAll("[src]"),a=[];if(n.length===6){for(e=0;e<n.length;e++)n[e].tagName==="IMG"?a.push(n[e]):a.push(n[e].getAttribute("src"));return a}dbe("<a-cubemap> did not contain exactly six elements each with a `src` attribute.")}}customElements.define("a-cubemap",uB),customElements.define("a-mixin",class extends na{constructor(){super(),this.componentCache={},this.rawAttributeCache={},this.isMixin=!0}doConnectedCallback(){super.doConnectedCallback(),this.sceneEl=this.closestScene(),this.id=this.getAttribute("id"),this.cacheAttributes(),this.updateEntities(),this.load()}attributeChangedCallback(r,e,n){super.attributeChangedCallback(),this.cacheAttribute(r,n),this.updateEntities()}setAttribute(r,e){window.HTMLElement.prototype.setAttribute.call(this,r,e),this.cacheAttribute(r,e)}cacheAttribute(r,e){var n,a;a=Th(r,"__")[0],n=hr[a],e===void 0&&(e=window.HTMLElement.prototype.getAttribute.call(this,r)),this.rawAttributeCache[r]=e,n&&(this.componentCache[r]=this.parseComponentAttrValue(n,e))}parseComponentAttrValue(r,e){var n;return typeof e!="string"?e:(r.isSingleProperty?typeof(n=r.schema.parse(e))=="string"&&(n=e):n=Nv(e),n)}getAttribute(r){return this.componentCache[r]||window.HTMLElement.prototype.getAttribute.call(this,r)}cacheAttributes(){var r,e,n=this.attributes;for(e=0;e<n.length;e++)r=n[e].name,this.cacheAttribute(r)}updateEntities(){var r,e,n;if(this.sceneEl)for(e=this.sceneEl.querySelectorAll("[mixin~="+this.id+"]"),n=0;n<e.length;n++)(r=e[n]).hasLoaded&&!r.isMixin&&r.mixinUpdate(this.id)}});const LW="1.7.0";var OC=new X.Color,GC=new X.Color,sU=hW,rU=qk,R_={},NW="color",aU="rotation",DW="components";function oU(r){r.x=X.MathUtils.degToRad(r.x),r.y=X.MathUtils.degToRad(r.y),r.z=X.MathUtils.degToRad(r.z)}function k_(r,e,n){var a;for(a=0;a<e.length;a++)r.addEventListener(e[a],n)}function B_(r,e,n){var a;for(a=0;a<e.length;a++)r.removeEventListener(e[a],n)}function lU(r,e){var n,a,c;for(a=m2(e),c=r,n=0;n<a.length;n++)c=c[a[n]];if(c===void 0)throw console.log(r),new Error("[animation] property ("+e+") could not be found");return c}function cU(r,e,n,a){var c,h,p,b;for(e.startsWith("object3D.rotation")&&(n=X.MathUtils.degToRad(n)),h=m2(e),b=r,c=0;c<h.length-1;c++)b=b[h[c]];p=h[h.length-1],a!==NW?b[p]=n:"r"in b[p]?(b[p].r=n.r,b[p].g=n.g,b[p].b=n.b):(b[p].x=n.r,b[p].y=n.g,b[p].z=n.b)}function m2(r){return r in R_||(R_[r]=r.split(".")),R_[r]}function L_(r){return r.isRawProperty||r.property.startsWith(DW)||r.property.startsWith("object3D")}kn("animation",{schema:{autoplay:{default:!0},delay:{default:0},dir:{default:""},dur:{default:1e3},easing:{default:"easeInQuad"},elasticity:{default:400},enabled:{default:!0},from:{default:""},loop:{default:0,parse:function(r){return r===!0||r==="true"||r!==!1&&r!=="false"&&parseInt(r,10)}},property:{default:""},startEvents:{type:"array"},pauseEvents:{type:"array"},resumeEvents:{type:"array"},round:{default:!1},to:{default:""},type:{default:""},isRawProperty:{default:!1}},multiple:!0,init:function(){var r=this;this.eventDetail={name:this.attrName},this.time=0,this.animation=null,this.animationIsPlaying=!1,this.onStartEvent=this.onStartEvent.bind(this),this.beginAnimation=this.beginAnimation.bind(this),this.pauseAnimation=this.pauseAnimation.bind(this),this.resumeAnimation=this.resumeAnimation.bind(this),this.fromColor={},this.toColor={},this.targets={},this.targetsArray=[],this.updateConfigForDefault=this.updateConfigForDefault.bind(this),this.updateConfigForRawColor=this.updateConfigForRawColor.bind(this),this.config={complete:function(){r.animationIsPlaying=!1,r.el.emit("animationcomplete",r.eventDetail,!1),r.id&&r.el.emit("animationcomplete__"+r.id,r.eventDetail,!1)}}},update:function(r){var e=this.config,n=this.data;this.animationIsPlaying=!1,this.data.enabled&&n.property&&(e.autoplay=!1,e.direction=n.dir,e.duration=n.dur,e.easing=n.easing,e.elasticity=n.elasticity,e.loop=n.loop,e.round=n.round,this.createAndStartAnimation())},tick:function(r,e){this.animationIsPlaying&&(this.time+=e,this.animation.tick(this.time))},remove:function(){this.pauseAnimation(),this.removeEventListeners()},pause:function(){this.paused=!0,this.pausedWasPlaying=this.animationIsPlaying,this.pauseAnimation(),this.removeEventListeners()},play:function(){this.paused&&(this.paused=!1,this.addEventListeners(),this.pausedWasPlaying&&(this.resumeAnimation(),this.pausedWasPlaying=!1))},createAndStartAnimation:function(){var r=this.data;this.updateConfig(),this.animationIsPlaying=!1,this.animation=cE(this.config),this.animation.began=!0,this.removeEventListeners(),this.addEventListeners(),!r.autoplay||r.startEvents&&r.startEvents.length||(r.delay?setTimeout(this.beginAnimation,r.delay):this.beginAnimation())},beginAnimation:function(){this.updateConfig(),this.animation.began=!0,this.time=0,this.animationIsPlaying=!0,this.stopRelatedAnimations(),this.el.emit("animationbegin",this.eventDetail,!1)},pauseAnimation:function(){this.animationIsPlaying=!1},resumeAnimation:function(){this.animationIsPlaying=!0},onStartEvent:function(){this.data.enabled&&(this.updateConfig(),this.animation&&this.animation.pause(),this.animation=cE(this.config),this.data.delay?setTimeout(this.beginAnimation,this.data.delay):this.beginAnimation())},updateConfigForRawColor:function(){var r,e,n,a=this.config,c=this.data,h=this.el;if(!this.waitComponentInitRawProperty(this.updateConfigForRawColor)){for(e in r=c.from===""?lU(h,c.property):c.from,n=c.to,this.setColorConfig(r,n),r=this.fromColor,n=this.toColor,this.targetsArray.length=0,this.targetsArray.push(r),a.targets=this.targetsArray,n)a[e]=n[e];var p;a.update=(p={},function(b){var y;(y=b.animatables[0].target).r===p.r&&y.g===p.g&&y.b===p.b||cU(h,c.property,y,c.type)})}},updateConfigForDefault:function(){var r,e,n,a,c=this.config,h=this.data,p=this.el;this.waitComponentInitRawProperty(this.updateConfigForDefault)||(r=h.from===""?L_(h)?lU(p,h.property):sU(p,h.property):h.from,n=h.to,isNaN(r||n)?(r=r&&r.toString(),n=n&&n.toString()):(r=parseFloat(r),n=parseFloat(n)),(e=h.to==="true"||h.to==="false"||h.to===!0||h.to===!1)&&(r=h.from==="true"||h.from===!0?1:0,n=h.to==="true"||h.to===!0?1:0),this.targets.aframeProperty=r,c.targets=this.targets,c.aframeProperty=n,c.update=function(b){var y;(y=b.animatables[0].target.aframeProperty)!==a&&(a=y,e&&(y=y>=1),L_(h)?cU(p,h.property,y,h.type):rU(p,h.property,y))})},updateConfigForVector:function(){var r,e,n,a,c=this.config,h=this.data,p=this.el,b=m2(h.property),y=b[0]==="object3D"?b[1]:b[0];for(r in e=h.from!==""?o2(h.from):sU(p,y),n=o2(h.to),y===aU&&(oU(e),oU(n)),this.targetsArray.length=0,this.targetsArray.push(e),c.targets=this.targetsArray,n)c[r]=n[r];c.update=y!=="position"&&y!==aU&&y!=="scale"?(function(){var w={};return function(I){var E=I.animatables[0].target;E.x===w.x&&E.y===w.y&&E.z===w.z||(w.x=E.x,w.y=E.y,w.z=E.z,rU(p,h.property,E))}})():(a={},function(w){var I=w.animatables[0].target;I.x===a.x&&I.y===a.y&&I.z===a.z||(a.x=I.x,a.y=I.y,a.z=I.z,p.object3D[y].set(I.x,I.y,I.z))})},updateConfig:function(){var r;r=(function(e,n){var a,c,h,p;return(h=n.split("."))[0]!=="object3D"||h[2]||h[1]!=="position"&&h[1]!=="rotation"&&h[1]!=="scale"?(c=h[0],p=h[1],(a=e.components[c]||hr[c])?p&&!a.schema[p]?null:p?a.schema[p].type:a.schema.type:null):"vec3"})(this.el,this.data.property),L_(this.data)&&this.data.type===NW?this.updateConfigForRawColor():r==="vec2"||r==="vec3"||r==="vec4"?this.updateConfigForVector():this.updateConfigForDefault()},waitComponentInitRawProperty:function(r){var e,n=this.data,a=this.el,c=this;return n.from===""&&!!n.property.startsWith(DW)&&(e=m2(n.property)[1],!a.components[e]&&(a.addEventListener("componentinitialized",(function h(p){p.detail.name===e&&(r(),c.animation=cE(c.config),a.removeEventListener("componentinitialized",h))})),!0))},stopRelatedAnimations:function(){var r,e;for(e in this.el.components)r=this.el.components[e],e!==this.attrName&&r.name==="animation"&&r.animationIsPlaying&&r.data.property===this.data.property&&(r.animationIsPlaying=!1)},addEventListeners:function(){var r=this.data,e=this.el;k_(e,r.startEvents,this.onStartEvent),k_(e,r.pauseEvents,this.pauseAnimation),k_(e,r.resumeEvents,this.resumeAnimation)},removeEventListeners:function(){var r=this.data,e=this.el;B_(e,r.startEvents,this.onStartEvent),B_(e,r.pauseEvents,this.pauseAnimation),B_(e,r.resumeEvents,this.resumeAnimation)},setColorConfig:function(r,e){OC.set(r),GC.set(e),r=this.fromColor,e=this.toColor,r.r=OC.r,r.g=OC.g,r.b=OC.b,e.r=GC.r,e.g=GC.g,e.b=GC.b}});var N_=$i("components:anchored:warn");kn("anchored",{schema:{persistent:{default:!1}},init:function(){var r=this.el.sceneEl.getAttribute("webxr"),e=r.optionalFeatures;e.indexOf("anchors")===-1&&(e.push("anchors"),this.el.sceneEl.setAttribute("webxr",r)),this.auxQuaternion=new X.Quaternion,this.onEnterVR=this.onEnterVR.bind(this),this.el.sceneEl.addEventListener("enter-vr",this.onEnterVR)},onEnterVR:function(){this.anchor=void 0,this.requestPersistentAnchorPending=this.data.persistent,this.requestAnchorPending=!this.data.persistent},tick:function(){var r,e,n,a=this.el.sceneEl,c=a.renderer.xr,h=this.el.object3D;(a.is("ar-mode")||a.is("vr-mode"))&&(!this.anchor&&this.requestPersistentAnchorPending&&this.restorePersistentAnchor(),!this.anchor&&this.requestAnchorPending&&this.createAnchor(),this.anchor&&(r=a.frame,e=c.getReferenceSpace(),n=r.getPose(this.anchor.anchorSpace,e),h.position.copy(n.transform.position),h.quaternion.copy(n.transform.orientation)))},createAnchor:async function(r,e){var n,a,c,h,p=this.el.sceneEl,b=p.renderer.xr,y=this.el.object3D;r=r||y.position,e=e||this.auxQuaternion.setFromEuler(y.rotation),(function(w){var I=w.renderer.xr.getSession();return I&&I.restorePersistentAnchor})(p)?(this.anchor&&this.deleteAnchor(),n=p.frame,a=b.getReferenceSpace(),c=new XRRigidTransform({x:r.x,y:r.y,z:r.z},{x:e.x,y:e.y,z:e.z,w:e.w}),this.requestAnchorPending=!1,h=await n.createAnchor(c,a),this.data.persistent&&(this.el.id?(this.persistentHandle=await h.requestPersistentHandle(),localStorage.setItem(this.el.id,this.persistentHandle)):N_("The anchor won't be persisted because the entity has no assigned id.")),p.object3D.attach(this.el.object3D),this.anchor=h):N_("This browser doesn't support the WebXR anchors module")},restorePersistentAnchor:async function(){var r,e=this.el.sceneEl.renderer.xr.getSession(),n=e.persistentAnchors;if(this.requestPersistentAnchorPending=!1,!this.el.id)return N_("The entity associated to the persistent anchor cannot be retrieved because it doesn't have an assigned id."),void(this.requestAnchorPending=!0);if(n){r=localStorage.getItem(this.el.id);for(var a=0;a<n.length;++a)if(r===n[a]){this.anchor=await e.restorePersistentAnchor(n[a]),this.anchor&&(this.persistentHandle=n[a]);break}this.anchor||(this.requestAnchorPending=!0)}else this.requestPersistentAnchorPending=!0},deleteAnchor:function(){var r,e=this.anchor;e&&(r=this.el.sceneEl.renderer.xr.getSession(),e.delete(),this.el.sceneEl.object3D.add(this.el.object3D),this.persistentHandle&&r.deletePersistentAnchor(this.persistentHandle),this.anchor=void 0)}}),kn("camera",{schema:{active:{default:!0},far:{default:1e4},fov:{default:80,min:0},near:{default:.005,min:0},spectator:{default:!1},zoom:{default:1,min:0}},init:function(){var r,e=this.el;r=this.camera=new X.PerspectiveCamera,e.setObject3D("camera",r)},update:function(r){var e=this.data,n=this.camera;n.aspect=e.aspect||window.innerWidth/window.innerHeight,n.far=e.far,n.fov=e.fov,n.near=e.near,n.zoom=e.zoom,n.updateProjectionMatrix(),this.updateActiveCamera(r),this.updateSpectatorCamera(r)},updateActiveCamera:function(r){var e=this.data,n=this.el,a=this.system;r&&r.active===e.active||e.spectator||(e.active&&a.activeCameraEl!==n?a.setActiveCamera(n):e.active||a.activeCameraEl!==n||a.disableActiveCamera())},updateSpectatorCamera:function(r){var e=this.data,n=this.el,a=this.system;r&&r.spectator===e.spectator||(e.spectator&&a.spectatorCameraEl!==n?a.setSpectatorCamera(n):e.spectator||a.spectatorCameraEl!==n||a.disableSpectatorCamera())},remove:function(){this.el.removeObject3D("camera")}});var Hd,hm,Xd,uU,hU="click",dU="mouseup",UC="cursor-fusing",D_="cursor-hovering",F_="cursor-hovered",PC={DOWN:["mousedown","touchstart"],UP:["mouseup","touchend"]},zC={DOWN:["selectstart"],UP:["selectend"]},fU="a-mouse-cursor-hover",fbe=(kn("cursor",{dependencies:["raycaster"],schema:{downEvents:{default:[]},fuse:{default:ef()},fuseTimeout:{default:1500,min:0},mouseCursorStylesEnabled:{default:!0},upEvents:{default:[]},rayOrigin:{default:"entity",oneOf:["mouse","entity","xrselect"]}},after:["tracked-controls"],multiple:!0,init:function(){var r=this;this.fuseTimeout=void 0,this.cursorDownEl=null,this.intersectedEl=null,this.canvasBounds=document.body.getBoundingClientRect(),this.isCursorDown=!1,this.activeXRInput=null,this.updateCanvasBounds=bW((function(){r.canvasBounds=r.el.sceneEl.canvas.getBoundingClientRect()}),500),this.eventDetail={},this.intersectedEventDetail={cursorEl:this.el},this.onCursorDown=this.onCursorDown.bind(this),this.onCursorUp=this.onCursorUp.bind(this),this.onIntersection=this.onIntersection.bind(this),this.onIntersectionCleared=this.onIntersectionCleared.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onEnterVR=this.onEnterVR.bind(this)},update:function(r){var e=this.data.rayOrigin;e!==r.rayOrigin&&(e==="entity"&&this.resetRaycaster(),this.updateMouseEventListeners(),e!=="xrselect"&&e!=="entity"||this.addWebXREventListeners(),r.rayOrigin!=="xrselect"&&r.rayOrigin!=="entity"||this.removeWebXREventListeners())},tick:function(){var r=this.el.sceneEl.frame,e=this.activeXRInput;this.data.rayOrigin==="xrselect"&&r&&e&&this.onMouseMove({frame:r,inputSource:e,type:"fakeselectevent"})},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},remove:function(){var r=this.el;r.removeState(D_),r.removeState(UC),clearTimeout(this.fuseTimeout),this.intersectedEl&&this.intersectedEl.removeState(F_),this.removeEventListeners()},addEventListeners:function(){var r,e=this.data,n=this.el,a=this;function c(){r=n.sceneEl.canvas,e.downEvents.length||e.upEvents.length||(PC.DOWN.forEach((function(h){r.addEventListener(h,a.onCursorDown,{passive:!1})})),PC.UP.forEach((function(h){r.addEventListener(h,a.onCursorUp,{passive:!1})})))}(r=n.sceneEl.canvas)?c():n.sceneEl.addEventListener("render-target-loaded",c),e.downEvents.forEach((function(h){n.addEventListener(h,a.onCursorDown)})),e.upEvents.forEach((function(h){n.addEventListener(h,a.onCursorUp)})),n.addEventListener("raycaster-intersection",this.onIntersection),n.addEventListener("raycaster-closest-entity-changed",this.onIntersection),n.addEventListener("raycaster-intersection-cleared",this.onIntersectionCleared),n.sceneEl.addEventListener("rendererresize",this.updateCanvasBounds),n.sceneEl.addEventListener("enter-vr",this.onEnterVR),window.addEventListener("resize",this.updateCanvasBounds),window.addEventListener("scroll",this.updateCanvasBounds),this.updateMouseEventListeners()},removeEventListeners:function(){var r,e=this.data,n=this.el,a=this;!(r=n.sceneEl.canvas)||e.downEvents.length||e.upEvents.length||(PC.DOWN.forEach((function(c){r.removeEventListener(c,a.onCursorDown)})),PC.UP.forEach((function(c){r.removeEventListener(c,a.onCursorUp)}))),e.downEvents.forEach((function(c){n.removeEventListener(c,a.onCursorDown)})),e.upEvents.forEach((function(c){n.removeEventListener(c,a.onCursorUp)})),n.removeEventListener("raycaster-intersection",this.onIntersection),n.removeEventListener("raycaster-closest-entity-changed",this.onIntersection),n.removeEventListener("raycaster-intersection-cleared",this.onIntersectionCleared),r.removeEventListener("mousemove",this.onMouseMove),r.removeEventListener("touchstart",this.onMouseMove),r.removeEventListener("touchmove",this.onMouseMove),n.sceneEl.removeEventListener("rendererresize",this.updateCanvasBounds),n.sceneEl.removeEventListener("enter-vr",this.onEnterVR),window.removeEventListener("resize",this.updateCanvasBounds),window.removeEventListener("scroll",this.updateCanvasBounds),this.removeWebXREventListeners()},updateMouseEventListeners:function(){var r,e=this.el;(r=e.sceneEl.canvas).removeEventListener("mousemove",this.onMouseMove),r.removeEventListener("touchmove",this.onMouseMove),e.setAttribute("raycaster","useWorldCoordinates",!1),this.data.rayOrigin==="mouse"&&(r.addEventListener("mousemove",this.onMouseMove),r.addEventListener("touchmove",this.onMouseMove,{passive:!1}),e.setAttribute("raycaster","useWorldCoordinates",!0),this.updateCanvasBounds())},resetRaycaster:function(){this.el.setAttribute("raycaster",{direction:new X.Vector3().set(0,0,-1),origin:new X.Vector3})},addWebXREventListeners:function(){var r=this,e=this.el.sceneEl.xrSession;e&&(zC.DOWN.forEach((function(n){e.addEventListener(n,r.onCursorDown)})),zC.UP.forEach((function(n){e.addEventListener(n,r.onCursorUp)})))},removeWebXREventListeners:function(){var r=this,e=this.el.sceneEl.xrSession;e&&(zC.DOWN.forEach((function(n){e.removeEventListener(n,r.onCursorDown)})),zC.UP.forEach((function(n){e.removeEventListener(n,r.onCursorUp)})))},onMouseMove:(Hd=new X.Vector3,hm=new X.Vector2,Xd=new X.Vector3,uU={origin:Xd,direction:Hd},function(r){var e,n,a,c,h,p,b,y,w,I=this.canvasBounds,E=this.el.sceneEl.camera;E.parent.updateMatrixWorld(),n=(a=r.type==="touchmove"||r.type==="touchstart"?r.touches.item(0):r).clientX-I.left,c=a.clientY-I.top,hm.x=n/I.width*2-1,hm.y=-c/I.height*2+1,this.data.rayOrigin!=="xrselect"||r.type!=="selectstart"&&r.type!=="fakeselectevent"?r.type==="fakeselectout"?(Hd.set(0,1,0),Xd.set(0,9999,0)):E&&E.isPerspectiveCamera?(Xd.setFromMatrixPosition(E.matrixWorld),Hd.set(hm.x,hm.y,.5).unproject(E).sub(Xd).normalize()):E&&E.isOrthographicCamera?(Xd.set(hm.x,hm.y,(E.near+E.far)/(E.near-E.far)).unproject(E),Hd.set(0,0,-1).transformDirection(E.matrixWorld)):console.error("AFRAME.Raycaster: Unsupported camera type: "+E.type):(h=r.frame,p=r.inputSource,b=this.el.sceneEl.renderer.xr.getReferenceSpace(),(y=h.getPose(p.targetRaySpace,b))&&(w=y.transform,Hd.set(0,0,-1),Hd.applyQuaternion(w.orientation),Xd.copy(w.position),(e=E.el.object3D.parent).localToWorld(Xd),Hd.transformDirection(e.matrixWorld))),this.el.setAttribute("raycaster",uU),r.type==="touchmove"&&r.preventDefault()}),onCursorDown:function(r){this.isCursorDown=!0,this.data.rayOrigin==="mouse"&&r.type==="touchstart"&&(this.onMouseMove(r),this.el.components.raycaster.checkIntersections(),r.preventDefault()),this.data.rayOrigin==="xrselect"&&r.type==="selectstart"&&(this.activeXRInput=r.inputSource,this.onMouseMove(r),this.el.components.raycaster.checkIntersections(),this.el.components.raycaster.intersectedEls.length&&this.el.sceneEl.components["ar-hit-test"]!==void 0&&this.el.sceneEl.getAttribute("ar-hit-test").enabled&&(this.el.sceneEl.setAttribute("ar-hit-test","enabled",!1),this.reenableARHitTest=!0)),this.twoWayEmit("mousedown",r),this.cursorDownEl=this.intersectedEl},onCursorUp:function(r){if(this.isCursorDown&&(this.data.rayOrigin!=="xrselect"||this.activeXRInput===r.inputSource)){this.isCursorDown=!1;var e=this.data;this.twoWayEmit(dU,r),this.reenableARHitTest===!0&&(this.el.sceneEl.setAttribute("ar-hit-test","enabled",!0),this.reenableARHitTest=void 0),this.cursorDownEl&&this.cursorDownEl!==this.intersectedEl&&(this.intersectedEventDetail.intersection=null,this.cursorDownEl.emit(dU,this.intersectedEventDetail)),e.fuse&&e.rayOrigin!=="mouse"&&e.rayOrigin!=="xrselect"||!this.intersectedEl||this.cursorDownEl!==this.intersectedEl||this.twoWayEmit(hU,r),e.rayOrigin==="xrselect"&&this.onMouseMove({type:"fakeselectout"}),this.activeXRInput=null,this.cursorDownEl=null,r.type==="touchend"&&r.preventDefault()}},onIntersection:function(r){var e,n,a,c,h=this.el;n=r.detail.els[0]===h?1:0,c=r.detail.intersections[n],(a=r.detail.els[n])&&this.intersectedEl!==a&&(this.intersectedEl&&(e=this.el.components.raycaster.getIntersection(this.intersectedEl))&&e.distance<=c.distance||(this.clearCurrentIntersection(!0),this.setIntersection(a,c)))},onIntersectionCleared:function(r){r.detail.clearedEls.indexOf(this.intersectedEl)!==-1&&this.clearCurrentIntersection()},onEnterVR:function(){var r=this.data.rayOrigin;this.clearCurrentIntersection(!0),r!=="xrselect"&&r!=="entity"||this.addWebXREventListeners()},setIntersection:function(r,e){var n=this.el,a=this.data,c=this;this.intersectedEl!==r&&(this.intersectedEl=r,n.addState(D_),r.addState(F_),this.twoWayEmit("mouseenter"),this.data.mouseCursorStylesEnabled&&this.data.rayOrigin==="mouse"&&this.el.sceneEl.canvas.classList.add(fU),a.fuseTimeout!==0&&a.fuse&&a.rayOrigin!=="xrselect"&&a.rayOrigin!=="mouse"&&(n.addState(UC),this.twoWayEmit("fusing"),this.fuseTimeout=setTimeout((function(){n.removeState(UC),c.twoWayEmit(hU)}),a.fuseTimeout)))},clearCurrentIntersection:function(r){var e,n,a=this.el;this.intersectedEl&&(this.intersectedEl.removeState(F_),a.removeState(D_),a.removeState(UC),this.twoWayEmit("mouseleave"),this.data.mouseCursorStylesEnabled&&this.data.rayOrigin==="mouse"&&this.el.sceneEl.canvas.classList.remove(fU),this.intersectedEl=null,clearTimeout(this.fuseTimeout),r!==!0&&(n=this.el.components.raycaster.intersections).length!==0&&(e=n[n[0].object.el===a?1:0])&&this.setIntersection(e.object.el,e))},twoWayEmit:function(r,e){var n,a=this.el,c=this.intersectedEl;function h(p,b){e instanceof MouseEvent?p.mouseEvent=e:typeof TouchEvent<"u"&&e instanceof TouchEvent&&(p.touchEvent=e)}n=this.el.components.raycaster.getIntersection(c),this.eventDetail.intersectedEl=c,this.eventDetail.intersection=n,h(this.eventDetail),a.emit(r,this.eventDetail),c&&(this.intersectedEventDetail.intersection=n,h(this.intersectedEventDetail),c.emit(r,this.intersectedEventDetail))}}),new X.BufferGeometry),pU=(kn("geometry",{schema:{buffer:{default:!0},primitive:{default:"box",oneOf:lB,schemaChange:!0},skipCache:{default:!1}},init:function(){this.geometry=null},update:function(r){var e,n=this.data,a=this.el,c=this.system;this.geometry&&(c.unuseGeometry(r),this.geometry=null),this.geometry=c.getOrCreateGeometry(n),(e=a.getObject3D("mesh"))?e.geometry=this.geometry:((e=new X.Mesh).geometry=this.geometry,this.el.getAttribute("material")||(e.material=new X.MeshStandardMaterial({color:16777215*Math.random(),metalness:0,roughness:.5})),a.setObject3D("mesh",e))},remove:function(){this.system.unuseGeometry(this.data),this.el.getObject3D("mesh").geometry=fbe,this.geometry=null},updateSchema:function(r){var e=this.oldData&&this.oldData.primitive,n=r.primitive,a=tf[n]&&tf[n].schema;if(!a)throw new Error("Unknown geometry schema `"+n+"`");e&&e===n||this.extendSchema(a)}}),"generic"),pbe=(kn("generic-tracked-controller-controls",{schema:{hand:{default:""},defaultModel:{default:!0},defaultModelColor:{default:"gray"},disabled:{default:!1}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1],thumbstick:[2,3]},buttons:["trigger","squeeze","touchpad","thumbstick"]},bindMethods:function(){this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var r=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){qn(e.detail.id,"down",r)},this.onButtonUp=function(e){qn(e.detail.id,"up",r)},this.onButtonTouchStart=function(e){qn(e.detail.id,"touchstart",r)},this.onButtonTouchEnd=function(e){qn(e.detail.id,"touchend",r)},this.controllerPresent=!1,this.wasControllerConnected=!1,this.bindMethods(),this.el.addEventListener("controllerconnected",(function(e){e.detail.name!==r.name&&(r.wasControllerConnected=!0,r.removeEventListeners(),r.removeControllersUpdateListener())}))},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var r=this.data,e=r.hand?r.hand:void 0;tl(this,pU,{hand:e,iterateControllerProfiles:!0})},play:function(){this.wasControllerConnected||(this.checkIfControllerPresent(),this.addControllersUpdateListener())},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var r=this.el,e=this.data;this.el.components["tracked-controls"]?this.removeEventListeners():(r.setAttribute("tracked-controls",{hand:e.hand,idPrefix:pU,iterateControllerProfiles:!0}),this.data.defaultModel&&this.initDefaultModel())},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.wasControllerConnected&&this.checkIfControllerPresent()},onButtonChanged:function(r){var e=this.mapping.buttons[r.detail.id];e&&this.el.emit(e+"changed",r.detail.state)},onAxisMoved:function(r){Bl(this,this.mapping.axes,r)},initDefaultModel:function(){var r=this.modelEl=document.createElement("a-entity");r.setAttribute("geometry",{primitive:"sphere",radius:.03}),r.setAttribute("material",{color:this.data.color}),this.el.appendChild(r),this.el.emit("controllermodelready",{name:"generic-tracked-controller-controls",model:this.modelEl,rayOrigin:{origin:{x:0,y:0,z:-.01},direction:{x:0,y:0,z:-1}}})}}),$i("components:gltf-model:warn"));kn("gltf-model",{schema:{type:"model"},init:function(){var r=this,e=this.system.getDRACOLoader(),n=this.system.getMeshoptDecoder(),a=this.system.getKTX2Loader();this.model=null,this.loader=new zk,e&&this.loader.setDRACOLoader(e),this.ready=n?n.then((function(c){r.loader.setMeshoptDecoder(c)})):Promise.resolve(),a&&this.loader.setKTX2Loader(a)},update:function(){var r=this,e=this.el,n=this.data;n&&(this.remove(),this.ready.then((function(){r.loader.load(n,(function(a){r.model=a.scene||a.scenes[0],r.model.animations=a.animations,e.setObject3D("mesh",r.model),e.emit("model-loaded",{format:"gltf",model:r.model})}),void 0,(function(a){var c=a&&a.message?a.message:"Failed to load glTF model";pbe(c),e.emit("model-error",{format:"gltf",src:n})}))})))},remove:function(){this.model&&this.el.removeObject3D("mesh")}}),kn("grabbable",{init:function(){this.el.setAttribute("obb-collider","centerModel: true")}});var VC,mbe=ur+"controllers/oculus-hands/v4/left.glb",gbe=ur+"controllers/oculus-hands/v4/right.glb",O_=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"];kn("hand-tracking-controls",{schema:{hand:{default:"right",oneOf:["left","right"]},modelStyle:{default:"mesh",oneOf:["dots","mesh"]},modelColor:{default:"white"},modelOpacity:{default:1}},after:["tracked-controls"],bindMethods:function(){this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this)},addEventListeners:function(){this.el.addEventListener("model-loaded",this.onModelLoaded);for(var r=0;r<this.jointEls.length;++r)this.jointEls[r].object3D.visible=!0},removeEventListeners:function(){this.el.removeEventListener("model-loaded",this.onModelLoaded);for(var r=0;r<this.jointEls.length;++r)this.jointEls[r].object3D.visible=!1},init:function(){var r=this.el.sceneEl,e=r.getAttribute("webxr"),n=e.optionalFeatures;n.indexOf("hand-tracking")===-1&&(n.push("hand-tracking"),r.setAttribute("webxr",e)),this.wristObject3D=new X.Object3D,this.el.sceneEl.object3D.add(this.wristObject3D),this.onModelLoaded=this.onModelLoaded.bind(this),this.onChildAttached=this.onChildAttached.bind(this),this.jointEls=[],this.controllerPresent=!1,this.isPinched=!1,this.pinchEventDetail={position:new X.Vector3,wristRotation:new X.Quaternion},this.indexTipPosition=new X.Vector3,this.hasPoses=!1,this.jointPoses=new Float32Array(16*O_.length),this.jointRadii=new Float32Array(O_.length),this.bindMethods(),this.updateReferenceSpace=this.updateReferenceSpace.bind(this),this.el.sceneEl.addEventListener("enter-vr",this.updateReferenceSpace),this.el.sceneEl.addEventListener("exit-vr",this.updateReferenceSpace),this.el.addEventListener("child-attached",this.onChildAttached),this.wristObject3D.visible=!1},onChildAttached:function(r){this.addChildEntity(r.detail.el)},update:function(){this.updateModelMaterial()},updateModelMaterial:function(){var r=this.jointEls,e=this.skinnedMesh,n=this.data.modelOpacity!==1;e&&(this.skinnedMesh.material.color.set(this.data.modelColor),this.skinnedMesh.material.transparent=n,this.skinnedMesh.material.opacity=this.data.modelOpacity);for(var a=0;a<r.length;a++)r[a].setAttribute("material",{color:this.data.modelColor,transparent:n,opacity:this.data.modelOpacity})},updateReferenceSpace:function(){var r=this,e=this.el.sceneEl.xrSession;if(this.referenceSpace=void 0,e){var n=r.el.sceneEl.systems.webxr.sessionReferenceSpaceType;e.requestReferenceSpace(n).then((function(a){r.referenceSpace=a})).catch((function(a){throw r.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(n,"tracked-controls-webxr uses reference space "+n),a}))}},checkIfControllerPresent:function(){var r=this.data;tl(this,"",{hand:r.hand?r.hand:void 0,iterateControllerProfiles:!0,handTracking:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},tick:function(){var r=this.el.sceneEl,e=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller,n=r.frame,a=this.el.components["tracked-controls"],c=this.referenceSpace;e&&n&&c&&a&&(this.hasPoses=!1,e.hand&&(this.el.object3D.position.set(0,0,0),this.el.object3D.rotation.set(0,0,0),this.hasPoses=n.fillPoses(e.hand.values(),c,this.jointPoses)&&n.fillJointRadii(e.hand.values(),this.jointRadii),this.updateHandModel(),this.detectGesture(),this.updateWristObject()))},updateWristObject:(VC=new X.Matrix4,function(){var r=this.wristObject3D;r&&this.hasPoses&&(VC.fromArray(this.jointPoses,0),r.position.setFromMatrixPosition(VC),r.quaternion.setFromRotationMatrix(VC))}),updateHandModel:function(){this.wristObject3D.visible=!0,this.el.object3D.visible=!0,this.data.modelStyle==="dots"&&this.updateHandDotsModel(),this.data.modelStyle==="mesh"&&this.updateHandMeshModel()},getBone:function(r){for(var e=this.bones,n=0;n<e.length;n++)if(e[n].name===r)return e[n];return null},updateHandMeshModel:(function(){var r=new X.Matrix4;return function(){var e=0,n=this.jointPoses,a=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller;if(a&&this.mesh&&(this.mesh.visible=!1,this.hasPoses))for(var c of a.hand.values()){var h=this.getBone(c.jointName);h!=null&&(this.mesh.visible=!0,r.fromArray(n,16*e),h.position.setFromMatrixPosition(r),h.quaternion.setFromRotationMatrix(r)),e++}}})(),updateHandDotsModel:function(){for(var r,e,n=this.jointPoses,a=this.jointRadii,c=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller,h=0;h<c.hand.size;h++)e=(r=this.jointEls[h]).object3D,r.object3D.visible=this.hasPoses,this.hasPoses&&(e.matrix.fromArray(n,16*h),e.matrix.decompose(e.position,e.rotation,e.scale),r.setAttribute("scale",{x:a[h],y:a[h],z:a[h]}))},detectGesture:function(){this.detectPinch()},detectPinch:(function(){var r=new X.Vector3,e=new X.Matrix4;return function(){var n=this.indexTipPosition,a=this.pinchEventDetail;if(this.hasPoses){r.setFromMatrixPosition(e.fromArray(this.jointPoses,64)),n.setFromMatrixPosition(e.fromArray(this.jointPoses,144)),a.wristRotation.setFromRotationMatrix(e.fromArray(this.jointPoses,0));var c=n.distanceTo(r);c<.015&&this.isPinched===!1&&(this.isPinched=!0,a.position.copy(n).add(r).multiplyScalar(.5),this.el.emit("pinchstarted",a)),c>.02&&this.isPinched===!0&&(this.isPinched=!1,a.position.copy(n).add(r).multiplyScalar(.5),this.el.emit("pinchended",a)),this.isPinched&&(a.position.copy(n).add(r).multiplyScalar(.5),this.el.emit("pinchmoved",a))}}})(),pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var r=this.el,e=this.data;r.setAttribute("tracked-controls",{id:"",hand:e.hand,iterateControllerProfiles:!0,handTrackingEnabled:!0}),this.mesh?this.mesh!==r.getObject3D("mesh")&&r.setObject3D("mesh",this.mesh):this.initDefaultModel()},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){var r,e=this.el;this.checkIfControllerPresent(),r=e.components["tracked-controls"]&&e.components["tracked-controls"].controller,this.mesh&&r&&r.hand&&r.hand instanceof XRHand&&e.setObject3D("mesh",this.mesh)},initDefaultModel:function(){var r=this.data;r.modelStyle==="dots"&&this.initDotsModel(),r.modelStyle==="mesh"&&this.initMeshHandModel(),this.el.object3D.visible=!0,this.wristObject3D.visible=!0},initDotsModel:function(){if(this.jointEls.length===0){for(var r=0;r<O_.length;++r){var e=this.jointEl=document.createElement("a-entity");e.setAttribute("geometry",{primitive:"sphere",radius:1}),e.object3D.visible=!1,this.el.appendChild(e),this.jointEls.push(e)}this.updateModelMaterial()}},initMeshHandModel:function(){var r=this.data.hand==="left"?mbe:gbe;this.el.setAttribute("gltf-model",r)},onModelLoaded:function(){var r=this.mesh=this.el.getObject3D("mesh").children[0],e=this.skinnedMesh=r.getObjectByProperty("type","SkinnedMesh");this.skinnedMesh&&(this.bones=e.skeleton.bones,this.el.removeObject3D("mesh"),r.position.set(0,0,0),r.rotation.set(0,0,0),e.frustumCulled=!1,e.material=new X.MeshStandardMaterial,this.updateModelMaterial(),this.setupChildrenEntities(),this.el.setObject3D("mesh",r),this.el.emit("controllermodelready",{name:"hand-tracking-controls",model:this.data.model,rayOrigin:new X.Vector3(0,0,0)}))},setupChildrenEntities:function(){for(var r=this.el.children,e=0;e<r.length;++e)r[e]instanceof Nr&&this.addChildEntity(r[e])},addChildEntity:function(r){r instanceof Nr&&this.wristObject3D.add(r.object3D)}}),kn("hand-tracking-grab-controls",{schema:{hand:{default:"right",oneOf:["left","right"]},color:{type:"color",default:"white"},hoverColor:{type:"color",default:"#538df1"},hoverEnabled:{default:!1}},init:function(){var r,e=this.el,n=this.data;r=n.hand==="right"?"components.hand-tracking-controls.bones.3":"components.hand-tracking-controls.bones.21",e.setAttribute("hand-tracking-controls",{hand:n.hand}),e.setAttribute("obb-collider",{trackedObject3D:r,size:.04}),this.auxMatrix=new X.Matrix4,this.onCollisionStarted=this.onCollisionStarted.bind(this),this.el.addEventListener("obbcollisionstarted",this.onCollisionStarted),this.onCollisionEnded=this.onCollisionEnded.bind(this),this.el.addEventListener("obbcollisionended",this.onCollisionEnded),this.onPinchStarted=this.onPinchStarted.bind(this),this.el.addEventListener("pinchstarted",this.onPinchStarted),this.onPinchEnded=this.onPinchEnded.bind(this),this.el.addEventListener("pinchended",this.onPinchEnded)},transferEntityOwnership:function(){for(var r,e=this.el.sceneEl.querySelectorAll("[hand-tracking-grab-controls]"),n=0;n<e.length;++n)(r=e[n].components["hand-tracking-grab-controls"])!==this&&this.grabbedEl&&this.grabbedEl===r.grabbedEl&&r.releaseGrabbedEntity();return!1},onCollisionStarted:function(r){var e=r.detail.withEl;this.collidedEl||e.getAttribute("grabbable")&&(this.collidedEl=e,this.grabbingObject3D=r.detail.trackedObject3D,this.data.hoverEnabled&&this.el.setAttribute("hand-tracking-controls","modelColor",this.data.hoverColor))},onCollisionEnded:function(){this.collidedEl=void 0,this.grabbedEl||(this.grabbingObject3D=void 0,this.data.hoverEnabled&&this.el.setAttribute("hand-tracking-controls","modelColor",this.data.color))},onPinchStarted:function(r){this.collidedEl&&(this.grabbedEl=this.collidedEl,this.transferEntityOwnership(),this.grab())},onPinchEnded:function(){this.releaseGrabbedEntity()},releaseGrabbedEntity:function(){var r=this.grabbedEl;if(r){var e=r.object3D,n=e.parent,a=this.originalParent;e.applyMatrix4(n.matrixWorld),e.applyMatrix4(this.auxMatrix.copy(a.matrixWorld).invert()),n.remove(e),a.add(e),this.el.emit("grabended",{grabbedEl:r}),this.grabbedEl=void 0,this.originalParent=void 0}},grab:function(){var r=this.grabbedEl,e=r.object3D,n=e.parent;this.originalParent=n;var a=this.el.components["hand-tracking-controls"].wristObject3D;e.applyMatrix4(n.matrixWorld),e.applyMatrix4(this.auxMatrix.copy(a.matrixWorld).invert()),n.remove(e),a.add(e),this.el.emit("grabstarted",{grabbedEl:r})}});var Abe={toonLeft:ur+"controllers/hands/leftHand.glb",toonRight:ur+"controllers/hands/rightHand.glb",lowPolyLeft:ur+"controllers/hands/leftHandLow.glb",lowPolyRight:ur+"controllers/hands/rightHandLow.glb",highPolyLeft:ur+"controllers/hands/leftHandHigh.glb",highPolyRight:ur+"controllers/hands/rightHandHigh.glb"},G_="Point",U_="Fist",mU="Thumb Up",pE={};function gU(r,e){var n;if(r)return(n=pE[r])==="grip"?n+(e?"close":"open"):n==="point"?n+(e?"up":"down"):n==="pointing"||n==="pistol"?n+(e?"start":"end"):void 0}pE[U_]="grip",pE[mU]="pistol",pE[G_]="pointing",kn("hand-controls",{schema:{color:{default:"white",type:"color"},hand:{default:"left"},handModelStyle:{default:"lowPoly",oneOf:["lowPoly","highPoly","toon"]}},after:["tracked-controls"],init:function(){var r=this,e=this.el;this.pressedButtons={},this.touchedButtons={},this.loader=new zk,this.loader.setCrossOrigin("anonymous"),this.onGripDown=function(){r.handleButton("grip","down")},this.onGripUp=function(){r.handleButton("grip","up")},this.onTrackpadDown=function(){r.handleButton("trackpad","down")},this.onTrackpadUp=function(){r.handleButton("trackpad","up")},this.onTrackpadTouchStart=function(){r.handleButton("trackpad","touchstart")},this.onTrackpadTouchEnd=function(){r.handleButton("trackpad","touchend")},this.onTriggerDown=function(){r.handleButton("trigger","down")},this.onTriggerUp=function(){r.handleButton("trigger","up")},this.onTriggerTouchStart=function(){r.handleButton("trigger","touchstart")},this.onTriggerTouchEnd=function(){r.handleButton("trigger","touchend")},this.onGripTouchStart=function(){r.handleButton("grip","touchstart")},this.onGripTouchEnd=function(){r.handleButton("grip","touchend")},this.onThumbstickDown=function(){r.handleButton("thumbstick","down")},this.onThumbstickUp=function(){r.handleButton("thumbstick","up")},this.onAorXTouchStart=function(){r.handleButton("AorX","touchstart")},this.onAorXTouchEnd=function(){r.handleButton("AorX","touchend")},this.onBorYTouchStart=function(){r.handleButton("BorY","touchstart")},this.onBorYTouchEnd=function(){r.handleButton("BorY","touchend")},this.onSurfaceTouchStart=function(){r.handleButton("surface","touchstart")},this.onSurfaceTouchEnd=function(){r.handleButton("surface","touchend")},this.onControllerConnected=this.onControllerConnected.bind(this),this.onControllerDisconnected=this.onControllerDisconnected.bind(this),e.addEventListener("controllerconnected",this.onControllerConnected),e.addEventListener("controllerdisconnected",this.onControllerDisconnected),e.object3D.visible=!1},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},tick:function(r,e){var n=this.el.getObject3D("mesh");n&&n.mixer&&n.mixer.update(e/1e3)},onControllerConnected:function(r){var e=this.el,n=this.data.hand,a=this.el.getObject3D("mesh");e.object3D.visible=!0;var c=n==="left"?Math.PI/2:-Math.PI/2,h=e.sceneEl.hasWebXR?-Math.PI/2:0;r.detail.name==="pico-controls"&&(h+=Math.PI/4),a.position.set(0,0,0),a.rotation.set(h,0,c)},onControllerDisconnected:function(){this.el.object3D.visible=!1},addEventListeners:function(){var r=this.el;r.addEventListener("gripdown",this.onGripDown),r.addEventListener("gripup",this.onGripUp),r.addEventListener("trackpaddown",this.onTrackpadDown),r.addEventListener("trackpadup",this.onTrackpadUp),r.addEventListener("trackpadtouchstart",this.onTrackpadTouchStart),r.addEventListener("trackpadtouchend",this.onTrackpadTouchEnd),r.addEventListener("triggerdown",this.onTriggerDown),r.addEventListener("triggerup",this.onTriggerUp),r.addEventListener("triggertouchstart",this.onTriggerTouchStart),r.addEventListener("triggertouchend",this.onTriggerTouchEnd),r.addEventListener("griptouchstart",this.onGripTouchStart),r.addEventListener("griptouchend",this.onGripTouchEnd),r.addEventListener("thumbstickdown",this.onThumbstickDown),r.addEventListener("thumbstickup",this.onThumbstickUp),r.addEventListener("abuttontouchstart",this.onAorXTouchStart),r.addEventListener("abuttontouchend",this.onAorXTouchEnd),r.addEventListener("bbuttontouchstart",this.onBorYTouchStart),r.addEventListener("bbuttontouchend",this.onBorYTouchEnd),r.addEventListener("xbuttontouchstart",this.onAorXTouchStart),r.addEventListener("xbuttontouchend",this.onAorXTouchEnd),r.addEventListener("ybuttontouchstart",this.onBorYTouchStart),r.addEventListener("ybuttontouchend",this.onBorYTouchEnd),r.addEventListener("surfacetouchstart",this.onSurfaceTouchStart),r.addEventListener("surfacetouchend",this.onSurfaceTouchEnd)},removeEventListeners:function(){var r=this.el;r.removeEventListener("gripdown",this.onGripDown),r.removeEventListener("gripup",this.onGripUp),r.removeEventListener("trackpaddown",this.onTrackpadDown),r.removeEventListener("trackpadup",this.onTrackpadUp),r.removeEventListener("trackpadtouchstart",this.onTrackpadTouchStart),r.removeEventListener("trackpadtouchend",this.onTrackpadTouchEnd),r.removeEventListener("triggerdown",this.onTriggerDown),r.removeEventListener("triggerup",this.onTriggerUp),r.removeEventListener("triggertouchstart",this.onTriggerTouchStart),r.removeEventListener("triggertouchend",this.onTriggerTouchEnd),r.removeEventListener("griptouchstart",this.onGripTouchStart),r.removeEventListener("griptouchend",this.onGripTouchEnd),r.removeEventListener("thumbstickdown",this.onThumbstickDown),r.removeEventListener("thumbstickup",this.onThumbstickUp),r.removeEventListener("abuttontouchstart",this.onAorXTouchStart),r.removeEventListener("abuttontouchend",this.onAorXTouchEnd),r.removeEventListener("bbuttontouchstart",this.onBorYTouchStart),r.removeEventListener("bbuttontouchend",this.onBorYTouchEnd),r.removeEventListener("xbuttontouchstart",this.onAorXTouchStart),r.removeEventListener("xbuttontouchend",this.onAorXTouchEnd),r.removeEventListener("ybuttontouchstart",this.onBorYTouchStart),r.removeEventListener("ybuttontouchend",this.onBorYTouchEnd),r.removeEventListener("surfacetouchstart",this.onSurfaceTouchStart),r.removeEventListener("surfacetouchend",this.onSurfaceTouchEnd)},update:function(r){var e,n=this.el,a=this.data.hand,c=this.data.handModelStyle,h=this.data.color,p=this;if(e={hand:a,model:!1},a!==r){var b=Abe[c+a.charAt(0).toUpperCase()+a.slice(1)];this.loader.load(b,(function(y){var w=y.scene.children[0];w.mixer=new X.AnimationMixer(w),p.clips=y.animations,n.setObject3D("mesh",w),w.traverse((function(I){I.isMesh&&(I.material.color=new X.Color(h))})),n.setAttribute("magicleap-controls",e),n.setAttribute("vive-controls",e),n.setAttribute("meta-touch-controls",e),n.setAttribute("pico-controls",e),n.setAttribute("windows-motion-controls",e),n.setAttribute("hp-mixed-reality-controls",e)}))}},remove:function(){this.el.removeObject3D("mesh")},handleButton:function(r,e){var n,a=e==="down",c=e==="touchstart";if(e.indexOf("touch")===0){if(c===this.touchedButtons[r])return;this.touchedButtons[r]=c}else{if(a===this.pressedButtons[r])return;this.pressedButtons[r]=a}n=this.gesture,this.gesture=this.determineGesture(),this.gesture!==n&&(this.animateGesture(this.gesture,n),this.emitGestureEvents(this.gesture,n))},determineGesture:function(){var r,e,n,a=this.pressedButtons.grip,c=this.pressedButtons.surface||this.touchedButtons.surface,h=this.pressedButtons.trackpad||this.touchedButtons.trackpad,p=this.pressedButtons.trigger||this.touchedButtons.trigger,b=this.touchedButtons.AorX||this.touchedButtons.BorY;return e=this.el.components["tracked-controls"],(n=e&&e.controller)&&(n.id&&n.id.indexOf("OpenVR ")===0||n.profiles&&n.profiles[0]&&n.profiles[0]==="htc-vive")?a||p?r=U_:h&&(r=G_):a?r=c||b||h?p?U_:G_:p?mU:"Point + Thumb":p&&(r="Hold"),r},getClip:function(r){var e,n;for(n=0;n<this.clips.length;n++)if((e=this.clips[n]).name===r)return e},animateGesture:function(r,e){r?this.playAnimation(r||"Open",e,!1):this.playAnimation(e,e,!0)},emitGestureEvents:function(r,e){var n,a=this.el;e!==r&&((n=gU(e,!1))&&a.emit(n),(n=gU(r,!0))&&a.emit(n))},playAnimation:function(r,e,n){var a,c,h=this.el.getObject3D("mesh");if(h){if(a=this.getClip(r),c=h.mixer.clipAction(a),n)return c.paused=!1,void(c.timeScale=-1);if(c.clampWhenFinished=!0,c.loop=X.LoopOnce,c.repetitions=0,c.timeScale=1,c.time=0,c.weight=1,!e)return h.mixer.stopAllAction(),void c.play();a=this.getClip(e),c.reset(),c.play(),h.mixer.clipAction(a).crossFadeTo(c,.15,!0)}}}),kn("hide-on-enter-ar",{init:function(){var r=this;this.el.sceneEl.addEventListener("enter-vr",(function(){r.el.sceneEl.is("ar-mode")&&(r.el.object3D.visible=!1)})),this.el.sceneEl.addEventListener("exit-vr",(function(){r.el.object3D.visible=!0}))}}),kn("hide-on-enter-vr",{init:function(){var r=this;this.el.sceneEl.addEventListener("enter-vr",(function(){r.el.sceneEl.is("vr-mode")&&(r.el.object3D.visible=!1)})),this.el.sceneEl.addEventListener("exit-vr",(function(){r.el.object3D.visible=!0}))}});var AU="hp-mixed-reality",bbe=ur+"controllers/hp/mixed-reality/",ybe={x:0,y:0,z:.06},vbe={_x:Math.PI/4,_y:0,_z:0,_order:"XYZ"},xbe=(kn("hp-mixed-reality-controls",{schema:{hand:{default:"none"},model:{default:!0}},mapping:{left:{axes:{touchpad:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton"]},right:{axes:{touchpad:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton"]}},init:function(){var r=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){qn(e.detail.id,"down",r,r.data.hand)},this.onButtonUp=function(e){qn(e.detail.id,"up",r,r.data.hand)},this.onButtonTouchEnd=function(e){qn(e.detail.id,"touchend",r,r.data.hand)},this.onButtonTouchStart=function(e){qn(e.detail.id,"touchstart",r,r.data.hand)},this.previousButtonValues={},this.bindMethods()},update:function(){var r=this.data;this.controllerIndex=r.hand==="right"?0:r.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("axismove",this.onAxisMoved),r.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("axismove",this.onAxisMoved),r.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var r=this.data;tl(this,AU,{index:this.controllerIndex,hand:r.hand})},injectTrackedControls:function(){var r=this.el,e=this.data;r.setAttribute("tracked-controls",{idPrefix:AU,hand:e.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("gltf-model",bbe+this.data.hand+".glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(r){var e,n=this.mapping[this.data.hand].buttons[r.detail.id];n&&(n==="trigger"&&(e=r.detail.state.value,console.log("analog value of trigger press: "+e)),this.el.emit(n+"changed",r.detail.state))},onModelLoaded:function(r){var e=r.detail.model;this.data.model&&(e.position.copy(ybe),e.rotation.copy(vbe),this.el.emit("controllermodelready",{name:"hp-mixed-reality-controls",model:this.data.model,rayOrigin:new X.Vector3(0,0,0)}))},onAxisMoved:function(r){Bl(this,this.mapping.axes,r)}}),$i("components:layer:warn"));function bU(r,e,n){return(e.dot(r)-e.dot(n))/e.length()}kn("layer",{schema:{type:{default:"quad",oneOf:["quad","monocubemap","stereocubemap"]},src:{type:"map"},rotateCubemap:{default:!1},width:{default:0},height:{default:0}},init:function(){var r=this.el.sceneEl.renderer.getContext();this.quaternion=new X.Quaternion,this.position=new X.Vector3,this.bindMethods(),this.needsRedraw=!1,this.frameBuffer=r.createFramebuffer();var e=this.el.sceneEl.getAttribute("webxr"),n=e.requiredFeatures;n.indexOf("layers")===-1&&(n.push("layers"),this.el.sceneEl.setAttribute("webxr",e)),this.el.sceneEl.addEventListener("enter-vr",this.onEnterVR),this.el.sceneEl.addEventListener("exit-vr",this.onExitVR)},bindMethods:function(){this.onRequestedReferenceSpace=this.onRequestedReferenceSpace.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.onExitVR=this.onExitVR.bind(this)},update:function(r){this.data.src!==r.src&&this.updateSrc()},updateSrc:function(){var r=this.data.type;this.texture=void 0,r!=="quad"?r!=="monocubemap"&&r!=="stereocubemap"||this.loadCubeMapImages():this.loadQuadImage()},loadCubeMapImages:function(){var r,e=this.xrGLFactory,n=this.el.sceneEl.frame,a=this.data.src,c=this.data.type;this.visibilityChanged=!1,this.layer&&(c!=="monocubemap"&&c!=="stereocubemap"||(a.complete?this.pendingCubeMapUpdate=!1:this.pendingCubeMapUpdate=!0,this.loadingScreen?this.loadingScreen=!1:this.loadingScreen=!0,c==="monocubemap"?(r=e.getSubImage(this.layer,n),this.loadCubeMapImage(r.colorTexture,a,0)):(r=e.getSubImage(this.layer,n,"left"),this.loadCubeMapImage(r.colorTexture,a,0),r=e.getSubImage(this.layer,n,"right"),this.loadCubeMapImage(r.colorTexture,a,6))))},loadQuadImage:function(){var r=this.data.src,e=this;this.el.sceneEl.systems.material.loadTexture(r,{src:r},(function(n){e.el.sceneEl.renderer.initTexture(n),e.texture=n,r.tagName==="VIDEO"&&setTimeout((function(){e.textureIsVideo=!0}),1e3),e.layer&&(e.layer.height=e.data.height/2||e.texture.image.height/1e3,e.layer.width=e.data.width/2||e.texture.image.width/1e3,e.needsRedraw=!0),e.updateQuadPanel()}))},preGenerateCubeMapTextures:function(r,e){this.data.type==="monocubemap"?this.generateCubeMapTextures(r,0,e):(this.generateCubeMapTextures(r,0,e),this.generateCubeMapTextures(r,6,e))},generateCubeMapTextures:function(r,e,n){for(var a,c,h=this.data,p=this.cubeFaceSize,b=Math.min(r.width,r.height),y=[],w=0;w<6;w++){var I=document.createElement("CANVAS");I.width=I.height=p;var E=I.getContext("2d");h.rotateCubemap&&(w!==2&&w!==3||(E.save(),E.translate(p,p),E.rotate(Math.PI))),E.drawImage(r,(w+e)*b,0,b,b,0,0,p,p),E.restore(),n&&n(),y.push(I)}return h.rotateCubemap&&(a=y[0],c=y[1],y[0]=c,y[1]=a,a=y[4],c=y[5],y[4]=c,y[5]=a),n&&n(),y},loadCubeMapImage:function(r,e,n){var a,c=this.el.sceneEl.renderer.getContext();c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!1),c.bindTexture(c.TEXTURE_CUBE_MAP,r),a=!e.complete||this.loadingScreen?this.loadingScreenImages:this.generateCubeMapTextures(e,n);var h=0;a.forEach((function(p,b){c.texSubImage2D(c.TEXTURE_CUBE_MAP_POSITIVE_X+b,0,0,0,c.RGBA,c.UNSIGNED_BYTE,p),h=c.getError()})),h!==0&&console.log("renderingError, WebGL Error Code: "+h),c.bindTexture(c.TEXTURE_CUBE_MAP,null)},tick:function(){this.el.sceneEl.xrSession&&this.referenceSpace&&(this.layer||!this.el.sceneEl.is("vr-mode")&&!this.el.sceneEl.is("ar-mode")||this.initLayer(),this.updateTransform(),this.data.src.complete&&(this.pendingCubeMapUpdate||this.loadingScreen||this.visibilityChanged)&&this.loadCubeMapImages(),(this.needsRedraw||this.layer.needsRedraw||this.textureIsVideo)&&(this.data.type==="quad"&&this.draw(),this.needsRedraw=!1))},initLayer:function(){var r=this,e=this.data.type;this.el.sceneEl.xrSession.onvisibilitychange=function(n){r.visibilityChanged=n.session.visibilityState!=="hidden"},e!=="quad"?e!=="monocubemap"&&e!=="stereocubemap"||this.initCubeMapLayer():this.initQuadLayer()},initQuadLayer:function(){var r=this.el.sceneEl,e=r.renderer.getContext(),n=this.xrGLFactory=new XRWebGLBinding(r.xrSession,e);this.texture&&(this.layer=n.createQuadLayer({space:this.referenceSpace,viewPixelHeight:2048,viewPixelWidth:2048,height:this.data.height/2||this.texture.image.height/1e3,width:this.data.width/2||this.texture.image.width/1e3}),this.initLoadingScreenImages(),r.renderer.xr.addLayer(this.layer))},initCubeMapLayer:function(){var r=this.data.src,e=this.el.sceneEl,n=e.renderer.getContext(),a=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),c=this.cubeFaceSize=Math.min(a,Math.min(r.width,r.height)),h=this.xrGLFactory=new XRWebGLBinding(e.xrSession,n);this.layer=h.createCubeLayer({space:this.referenceSpace,viewPixelWidth:c,viewPixelHeight:c,layout:this.data.type==="monocubemap"?"mono":"stereo",isStatic:!1}),this.initLoadingScreenImages(),this.loadCubeMapImages(),e.renderer.xr.addLayer(this.layer)},initLoadingScreenImages:function(){for(var r=this.cubeFaceSize,e=this.loadingScreenImages=[],n=0;n<6;n++){var a=document.createElement("CANVAS");a.width=a.height=r;var c=a.getContext("2d");a.width=a.height=r,c.fillStyle="black",c.fillRect(0,0,r,r),n!==2&&n!==3&&(c.translate(r,0),c.scale(-1,1),c.fillStyle="white",c.font="30px Arial",c.fillText("Loading",r/2,r/2)),e.push(a)}},destroyLayer:function(){this.layer&&(this.el.sceneEl.renderer.xr.removeLayer(this.layer),this.layer.destroy(),this.layer=void 0)},toggleCompositorLayer:function(){this.enableCompositorLayer(!this.layerEnabled)},enableCompositorLayer:function(r){this.layerEnabled=r,this.quadPanelEl.object3D.visible=!this.layerEnabled},updateQuadPanel:function(){var r=this.quadPanelEl;this.quadPanelEl||(r=this.quadPanelEl=document.createElement("a-entity"),this.el.appendChild(r)),r.setAttribute("material",{shader:"flat",src:this.data.src,transparent:!0}),r.setAttribute("geometry",{primitive:"plane",height:this.data.height||this.texture.image.height/1e3,width:this.data.width||this.texture.image.height/1e3})},draw:function(){var r=this.el.sceneEl,e=this.el.sceneEl.renderer.getContext(),n=this.xrGLFactory.getSubImage(this.layer,r.frame),a=r.renderer.properties.get(this.texture).__webglTexture,c=e.getParameter(e.FRAMEBUFFER_BINDING);e.viewport(n.viewport.x,n.viewport.y,n.viewport.width,n.viewport.height),e.bindFramebuffer(e.FRAMEBUFFER,this.frameBuffer),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n.colorTexture,0),(function(h,p,b,y){var w=h.createFramebuffer(),I=b.viewport.x,E=b.viewport.y,R=b.viewport.x+b.viewport.width,k=b.viewport.y+b.viewport.height;y.tagName==="VIDEO"&&(h.bindTexture(h.TEXTURE_2D,p),h.texSubImage2D(h.TEXTURE_2D,0,0,0,y.width,y.height,h.RGB,h.UNSIGNED_BYTE,y)),h.bindFramebuffer(h.READ_FRAMEBUFFER,w),h.framebufferTexture2D(h.READ_FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,p,0),h.readBuffer(h.COLOR_ATTACHMENT0),h.blitFramebuffer(0,0,y.width,y.height,I,E,R,k,h.COLOR_BUFFER_BIT,h.NEAREST),h.bindFramebuffer(h.READ_FRAMEBUFFER,null),h.deleteFramebuffer(w)})(e,a,n,this.data.src),e.bindFramebuffer(e.FRAMEBUFFER,c)},updateTransform:function(){var r=this.el,e=this.position,n=this.quaternion;r.object3D.updateMatrixWorld(),e.setFromMatrixPosition(r.object3D.matrixWorld),n.setFromRotationMatrix(r.object3D.matrixWorld),this.layerEnabled||e.set(0,0,1e8),this.layer.transform=new XRRigidTransform(e,n)},onEnterVR:function(){var r=this.el.sceneEl,e=r.xrSession;r.hasWebXR&&XRWebGLBinding&&e?(e.requestReferenceSpace("local-floor").then(this.onRequestedReferenceSpace),this.layerEnabled=!0,this.quadPanelEl&&(this.quadPanelEl.object3D.visible=!1),this.data.src.play&&this.data.src.play()):xbe("The layer component requires WebXR and the layers API enabled")},onExitVR:function(){this.quadPanelEl&&(this.quadPanelEl.object3D.visible=!0),this.destroyLayer()},onRequestedReferenceSpace:function(r){this.referenceSpace=r}}),kn("laser-controls",{schema:{hand:{default:"right"},model:{default:!0},defaultModelColor:{type:"color",default:"grey"}},init:function(){var r=this.config,e=this.data,n=this.el,a=this,c={hand:e.hand,model:e.model};function h(p){var b=r[p.detail.name];if(b){var y=Mo({showLine:!0},b.raycaster||{});p.detail.rayOrigin&&(y.origin=p.detail.rayOrigin.origin,y.direction=p.detail.rayOrigin.direction,y.showLine=!0),p.detail.rayOrigin||!a.modelReady?n.setAttribute("raycaster",y):n.setAttribute("raycaster","showLine",!0),n.setAttribute("cursor",Mo({fuse:!1},b.cursor))}}n.setAttribute("hp-mixed-reality-controls",c),n.setAttribute("magicleap-controls",c),n.setAttribute("oculus-go-controls",c),n.setAttribute("meta-touch-controls",c),n.setAttribute("pico-controls",c),n.setAttribute("valve-index-controls",c),n.setAttribute("vive-controls",c),n.setAttribute("vive-focus-controls",c),n.setAttribute("windows-motion-controls",c),n.setAttribute("generic-tracked-controller-controls",{hand:c.hand}),n.addEventListener("controllerconnected",h),n.addEventListener("controllerdisconnected",(function(p){r[p.detail.name]&&n.setAttribute("raycaster","showLine",!1)})),n.addEventListener("controllermodelready",(function(p){h(p),a.modelReady=!0}))},config:{"generic-tracked-controller-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"hp-mixed-reality-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:0,z:0}}},"magicleap-controls":{cursor:{downEvents:["trackpaddown","triggerdown"],upEvents:["trackpadup","triggerup"]}},"oculus-go-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:5e-4,z:0}}},"meta-touch-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:0,z:0}}},"pico-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"valve-index-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"vive-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"vive-focus-controls":{cursor:{downEvents:["trackpaddown","triggerdown"],upEvents:["trackpadup","triggerup"]}},"windows-motion-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{showLine:!1}}}});var P_,WC,HC,XC,fh,yU,z_,Ky,Zy,QC,vU=X.MathUtils.degToRad,wbe=$i("components:light:warn"),Cbe=new X.CubeTextureLoader,dm={};function xU(r,e){return!(!r||!e)&&r.x===e.x&&r.y===e.y&&r.z===e.z}kn("light",{schema:{angle:{default:60,if:{type:["spot"]}},color:{type:"color",if:{type:["ambient","directional","hemisphere","point","spot"]}},envMap:{default:"",if:{type:["probe"]}},groundColor:{type:"color",if:{type:["hemisphere"]}},decay:{default:1,if:{type:["point","spot"]}},distance:{default:0,min:0,if:{type:["point","spot"]}},intensity:{default:3.14,min:0,if:{type:["ambient","directional","hemisphere","point","spot","probe"]}},penumbra:{default:0,min:0,max:1,if:{type:["spot"]}},type:{default:"directional",oneOf:["ambient","directional","hemisphere","point","spot","probe"],schemaChange:!0},target:{type:"selector",if:{type:["spot","directional"]}},castShadow:{default:!1,if:{type:["point","spot","directional"]}},shadowBias:{default:0,if:{castShadow:!0}},shadowCameraFar:{default:500,if:{castShadow:!0}},shadowCameraFov:{default:90,if:{castShadow:!0}},shadowCameraNear:{default:.5,if:{castShadow:!0}},shadowCameraTop:{default:5,if:{castShadow:!0}},shadowCameraRight:{default:5,if:{castShadow:!0}},shadowCameraBottom:{default:-5,if:{castShadow:!0}},shadowCameraLeft:{default:-5,if:{castShadow:!0}},shadowCameraVisible:{default:!1,if:{castShadow:!0}},shadowCameraAutomatic:{default:"",if:{type:["directional"]}},shadowMapHeight:{default:512,if:{castShadow:!0}},shadowMapWidth:{default:512,if:{castShadow:!0}},shadowRadius:{default:1,if:{castShadow:!0}}},init:function(){var r=this.el;this.light=null,this.defaultTarget=null,this.system.registerLight(r)},update:function(r){var e=this.data,n=yW(e,r),a=this.light,c=this;if(!a||"type"in n)this.setLight(this.data),this.updateShadow();else{var h=!1;Object.keys(n).forEach((function(p){var b=e[p];switch(p){case"color":a.color.set(b);break;case"groundColor":a.groundColor.set(b);break;case"angle":a.angle=vU(b);break;case"target":b===null?e.type!=="spot"&&e.type!=="directional"||(a.target=c.defaultTarget):b.hasLoaded?c.onSetTarget(b,a):b.addEventListener("loaded",c.onSetTarget.bind(c,b,a));break;case"envMap":c.updateProbeMap(e,a);break;case"castShadow":case"shadowBias":case"shadowCameraFar":case"shadowCameraFov":case"shadowCameraNear":case"shadowCameraTop":case"shadowCameraRight":case"shadowCameraBottom":case"shadowCameraLeft":case"shadowCameraVisible":case"shadowMapHeight":case"shadowMapWidth":case"shadowRadius":h||(c.updateShadow(),h=!0);break;case"shadowCameraAutomatic":e.shadowCameraAutomatic?c.shadowCameraAutomaticEls=Array.from(document.querySelectorAll(e.shadowCameraAutomatic)):c.shadowCameraAutomaticEls=[];break;default:a[p]=b}}))}},tick:(P_=new X.Box3,WC=new X.Vector3,HC=new X.Vector3,XC=new X.Matrix4,fh=new X.Sphere,yU=new X.Vector3,function(){if(this.data.type==="directional"&&this.light.shadow&&this.light.shadow.camera instanceof X.OrthographicCamera&&this.shadowCameraAutomaticEls.length){var r=this.light.shadow.camera;r.getWorldDirection(WC),r.getWorldPosition(HC),XC.copy(r.matrixWorld),XC.invert(),r.near=1,r.left=1e5,r.right=-1e5,r.top=-1e5,r.bottom=1e5,this.shadowCameraAutomaticEls.forEach((function(e){P_.setFromObject(e.object3D),P_.getBoundingSphere(fh);var n,a,c,h,p,b=bU(HC,WC,fh.center),y=(n=HC,a=WC,c=fh.center,h=yU,p=bU(n,a,c),h.copy(a),h.multiplyScalar(p),h.add(c),h).applyMatrix4(XC);r.near=Math.min(-b-fh.radius-1,r.near),r.left=Math.min(-fh.radius+y.x,r.left),r.right=Math.max(fh.radius+y.x,r.right),r.top=Math.max(fh.radius+y.y,r.top),r.bottom=Math.min(-fh.radius+y.y,r.bottom)})),r.updateProjectionMatrix()}}),setLight:function(r){var e=this.el,n=this.getLight(r);n&&(this.light&&e.removeObject3D("light"),this.light=n,this.light.el=e,e.setObject3D("light",this.light),r.type!=="spot"&&r.type!=="directional"&&r.type!=="hemisphere"||e.getObject3D("light").translateY(-1),r.type==="spot"&&(e.setObject3D("light-target",this.defaultTarget),e.getObject3D("light-target").position.set(0,0,-1)),r.shadowCameraAutomatic?this.shadowCameraAutomaticEls=Array.from(document.querySelectorAll(r.shadowCameraAutomatic)):this.shadowCameraAutomaticEls=[])},updateShadow:function(){var r=this.el,e=this.data,n=this.light;n.castShadow=e.castShadow;var a=r.getObject3D("cameraHelper");if(e.shadowCameraVisible&&!a?(a=new X.CameraHelper(n.shadow.camera),r.setObject3D("cameraHelper",a)):!e.shadowCameraVisible&&a&&r.removeObject3D("cameraHelper"),!e.castShadow)return n;n.shadow.bias=e.shadowBias,n.shadow.radius=e.shadowRadius,n.shadow.mapSize.height=e.shadowMapHeight,n.shadow.mapSize.width=e.shadowMapWidth,n.shadow.camera.near=e.shadowCameraNear,n.shadow.camera.far=e.shadowCameraFar,n.shadow.camera instanceof X.OrthographicCamera?(n.shadow.camera.top=e.shadowCameraTop,n.shadow.camera.right=e.shadowCameraRight,n.shadow.camera.bottom=e.shadowCameraBottom,n.shadow.camera.left=e.shadowCameraLeft):n.shadow.camera.fov=e.shadowCameraFov,n.shadow.camera.updateProjectionMatrix(),a&&a.update()},getLight:function(r){var e=r.angle,n=new X.Color(r.color);n=n.getHex();var a=r.decay,c=r.distance,h=new X.Color(r.groundColor);h=h.getHex();var p=r.intensity,b=r.type,y=r.target,w=null;switch(b.toLowerCase()){case"ambient":return new X.AmbientLight(n,p);case"directional":return w=new X.DirectionalLight(n,p),this.defaultTarget=w.target,y&&(y.hasLoaded?this.onSetTarget(y,w):y.addEventListener("loaded",this.onSetTarget.bind(this,y,w))),w;case"hemisphere":return new X.HemisphereLight(n,h,p);case"point":return new X.PointLight(n,p,c,a);case"spot":return w=new X.SpotLight(n,p,c,vU(e),r.penumbra,a),this.defaultTarget=w.target,y&&(y.hasLoaded?this.onSetTarget(y,w):y.addEventListener("loaded",this.onSetTarget.bind(this,y,w))),w;case"probe":return w=new X.LightProbe,this.updateProbeMap(r,w),w;default:wbe("%s is not a valid light type. Choose from ambient, directional, hemisphere, point, spot.",b)}},updateProbeMap:function(r,e){r.envMap?(dm[r.envMap]===void 0&&(dm[r.envMap]=new window.Promise((function(n){fW(r.envMap,(function(a){Cbe.load(a,(function(c){var h=tW.fromCubeTexture(c);dm[r.envMap]=h,n(h)}))}))}))),dm[r.envMap]instanceof window.Promise?dm[r.envMap].then((function(n){e.copy(n)})):dm[r.envMap]instanceof X.LightProbe&&e.copy(dm[r.envMap])):e.copy(new X.LightProbe)},onSetTarget:function(r,e){e.target=r.object3D},remove:function(){var r=this.el;r.removeObject3D("light"),r.getObject3D("cameraHelper")&&r.removeObject3D("cameraHelper")}}),kn("line",{schema:{start:{type:"vec3",default:{x:0,y:0,z:0}},end:{type:"vec3",default:{x:0,y:0,z:0}},color:{type:"color",default:"#74BEC1"},opacity:{type:"number",default:1},visible:{default:!0}},multiple:!0,init:function(){var r,e,n=this.data;e=this.material=new X.LineBasicMaterial({color:n.color,opacity:n.opacity,transparent:n.opacity<1,visible:n.visible}),(r=this.geometry=new X.BufferGeometry).setAttribute("position",new X.BufferAttribute(new Float32Array(6),3)),this.line=new X.Line(r,e),this.el.setObject3D(this.attrName,this.line)},update:function(r){var e=this.data,n=this.geometry,a=!1,c=this.material,h=n.attributes.position.array;xU(e.start,r.start)||(h[0]=e.start.x,h[1]=e.start.y,h[2]=e.start.z,a=!0),xU(e.end,r.end)||(h[3]=e.end.x,h[4]=e.end.y,h[5]=e.end.z,a=!0),a&&(n.attributes.position.needsUpdate=!0,n.computeBoundingSphere()),c.color.setStyle(e.color),c.opacity=e.opacity,c.transparent=e.opacity<1,c.visible=e.visible},remove:function(){this.el.removeObject3D(this.attrName,this.line)}}),kn("link",{schema:{backgroundColor:{default:"red",type:"color"},borderColor:{default:"white",type:"color"},highlighted:{default:!1},highlightedColor:{default:"#24CAFF",type:"color"},href:{default:""},image:{type:"asset"},on:{default:"click"},peekMode:{default:!1},title:{default:""},titleColor:{default:"white",type:"color"},visualAspectEnabled:{default:!1}},init:function(){this.navigate=this.navigate.bind(this),this.previousQuaternion=void 0,this.quaternionClone=new X.Quaternion,this.hiddenEls=[]},update:function(r){var e,n,a=this.data,c=this.el;if(a.visualAspectEnabled){var h=this.el.getAttribute("scale");this.previewDistance=15*(h.x+h.y)/2,this.initVisualAspect(),e=a.highlighted?a.highlightedColor:a.backgroundColor,n=a.highlighted?a.highlightedColor:a.borderColor,c.setAttribute("material","backgroundColor",e),c.setAttribute("material","strokeColor",n),a.on!==r.on&&this.updateEventListener(),r.peekMode!==void 0&&a.peekMode!==r.peekMode&&this.updatePeekMode(),a.image&&r.image!==a.image&&c.setAttribute("material","pano",typeof a.image=="string"?a.image:a.image.src)}},updatePeekMode:function(){var r=this.el,e=this.sphereEl;this.data.peekMode?(this.hideAll(),r.getObject3D("mesh").visible=!1,e.setAttribute("visible",!0)):(this.showAll(),r.getObject3D("mesh").visible=!0,e.setAttribute("visible",!1))},play:function(){this.updateEventListener()},pause:function(){this.removeEventListener()},updateEventListener:function(){var r=this.el;r.isPlaying&&(this.removeEventListener(),r.addEventListener(this.data.on,this.navigate))},removeEventListener:function(){var r=this.data.on;r&&this.el.removeEventListener(r,this.navigate)},initVisualAspect:function(){var r,e,n,a=this.el;this.data.visualAspectEnabled&&!this.visualAspectInitialized&&(n=this.textEl=this.textEl||document.createElement("a-entity"),e=this.sphereEl=this.sphereEl||document.createElement("a-entity"),r=this.semiSphereEl=this.semiSphereEl||document.createElement("a-entity"),a.setAttribute("geometry",{primitive:"circle",radius:1,segments:64}),a.setAttribute("material",{shader:"portal",pano:this.data.image,side:"double",previewDistance:this.previewDistance}),n.setAttribute("text",{color:this.data.titleColor,align:"center",font:"kelsonsans",value:this.data.title||this.data.href,width:4}),n.setAttribute("position","0 1.5 0"),a.appendChild(n),r.setAttribute("geometry",{primitive:"sphere",radius:1,phiStart:0,segmentsWidth:64,segmentsHeight:64,phiLength:180,thetaStart:0,thetaLength:360}),r.setAttribute("material",{shader:"portal",borderEnabled:0,pano:this.data.image,side:"back",previewDistance:this.previewDistance}),r.setAttribute("rotation","0 180 0"),r.setAttribute("position","0 0 0"),r.setAttribute("visible",!1),a.appendChild(r),e.setAttribute("geometry",{primitive:"sphere",radius:10,segmentsWidth:64,segmentsHeight:64}),e.setAttribute("material",{shader:"portal",borderEnabled:0,pano:this.data.image,side:"back",previewDistance:this.previewDistance}),e.setAttribute("visible",!1),a.appendChild(e),this.visualAspectInitialized=!0)},navigate:function(){window.location=this.data.href},tick:(function(){var r=new X.Vector3,e=new X.Vector3,n=new X.Quaternion,a=new X.Vector3;return function(){var c,h,p=this.el,b=p.object3D,y=p.sceneEl.camera,w=this.textEl;if(this.data.visualAspectEnabled)if(b.updateMatrixWorld(),y.parent.updateMatrixWorld(),y.updateMatrixWorld(),b.matrix.decompose(e,n,a),e.setFromMatrixPosition(b.matrixWorld),r.setFromMatrixPosition(y.matrixWorld),(h=e.distanceTo(r))>1.33333*this.previewDistance)this.previousQuaternion||(this.quaternionClone.copy(n),this.previousQuaternion=this.quaternionClone),b.lookAt(r);else{if(c=this.calculateCameraPortalOrientation(),h<.5){if(this.semiSphereEl.getAttribute("visible")===!0)return;w.setAttribute("text","width",1.5),c<=0?(w.setAttribute("position","0 0 0.75"),w.setAttribute("rotation","0 180 0"),this.semiSphereEl.setAttribute("rotation","0 0 0")):(w.setAttribute("position","0 0 -0.75"),w.setAttribute("rotation","0 0 0"),this.semiSphereEl.setAttribute("rotation","0 180 0")),p.getObject3D("mesh").visible=!1,this.semiSphereEl.setAttribute("visible",!0),this.peekCameraPortalOrientation=c}else c<=0?w.setAttribute("rotation","0 180 0"):w.setAttribute("rotation","0 0 0"),w.setAttribute("text","width",5),w.setAttribute("position","0 1.5 0"),p.getObject3D("mesh").visible=!0,this.semiSphereEl.setAttribute("visible",!1),this.peekCameraPortalOrientation=void 0;this.previousQuaternion&&(b.quaternion.copy(this.previousQuaternion),this.previousQuaternion=void 0)}}})(),hideAll:function(){var r=this.el,e=this.hiddenEls,n=this;e.length>0||r.sceneEl.object3D.traverse((function(a){a&&a.el&&a.el.hasAttribute("link-controls")||a.el&&a!==r.sceneEl.object3D&&a.el!==r&&a.el!==n.sphereEl&&a.el!==r.sceneEl.cameraEl&&a.el.getAttribute("visible")!==!1&&a.el!==n.textEl&&a.el!==n.semiSphereEl&&(a.el.setAttribute("visible",!1),e.push(a.el))}))},showAll:function(){this.hiddenEls.forEach((function(r){r.setAttribute("visible",!0)})),this.hiddenEls=[]},calculateCameraPortalOrientation:(z_=new X.Matrix4,Ky=new X.Vector3,Zy=new X.Vector3(0,0,1),QC=new X.Vector3(0,0,0),function(){var r=this.el,e=r.sceneEl.camera;return Ky.set(0,0,0),Zy.set(0,0,1),QC.set(0,0,0),r.object3D.matrixWorld.extractRotation(z_),Zy.applyMatrix4(z_),r.object3D.updateMatrixWorld(),r.object3D.localToWorld(QC),e.parent.parent.updateMatrixWorld(),e.parent.updateMatrixWorld(),e.updateMatrixWorld(),e.localToWorld(Ky),Ky.sub(QC).normalize(),Zy.normalize(),Math.sign(Zy.dot(Ky))}),remove:function(){this.removeEventListener()}}),Kd("portal",{schema:{borderEnabled:{default:1,type:"int",is:"uniform"},backgroundColor:{default:"red",type:"color",is:"uniform"},pano:{type:"map",is:"uniform"},strokeColor:{default:"white",type:"color",is:"uniform"},previewDistance:{default:15,type:"float",is:"uniform"}},vertexShader:["vec3 portalPosition;","varying vec3 vWorldPosition;","varying float vDistanceToCenter;","varying float vDistance;","void main() {","vDistanceToCenter = clamp(length(position - vec3(0.0, 0.0, 0.0)), 0.0, 1.0);","portalPosition = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;","vDistance = length(portalPosition - cameraPosition);","vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;","gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join(`
`),fragmentShader:["#define RECIPROCAL_PI2 0.15915494","uniform sampler2D pano;","uniform vec3 strokeColor;","uniform vec3 backgroundColor;","uniform float borderEnabled;","uniform float previewDistance;","varying float vDistanceToCenter;","varying float vDistance;","varying vec3 vWorldPosition;","void main() {","vec3 direction = normalize(vWorldPosition - cameraPosition);","vec2 sampleUV;","float borderThickness = clamp(exp(-vDistance / 50.0), 0.6, 0.95);","sampleUV.y = clamp(direction.y * 0.5  + 0.5, 0.0, 1.0);","sampleUV.x = atan(direction.z, -direction.x) * -RECIPROCAL_PI2 + 0.5;","if (vDistanceToCenter > borderThickness && borderEnabled == 1.0) {","gl_FragColor = vec4(strokeColor, 1.0);","} else {","gl_FragColor = mix(texture2D(pano, sampleUV), vec4(backgroundColor, 1.0), clamp(pow((vDistance / previewDistance), 2.0), 0.0, 1.0));","}","}"].join(`
`)});var wU="logitech-mx-ink",Ebe=ur+"controllers/logitech/",CU=(kn("logitech-mx-ink-controls",{schema:{hand:{default:"left"},model:{default:!0},orientationOffset:{type:"vec3"}},mapping:{left:{buttons:["front","back","none","none","none","tip"]},right:{buttons:["front","back","none","none","none","tip"]}},init:function(){var r=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){qn(e.detail.id,"down",r,r.data.hand)},this.onButtonUp=function(e){qn(e.detail.id,"up",r,r.data.hand)},this.onButtonTouchEnd=function(e){qn(e.detail.id,"touchend",r,r.data.hand)},this.onButtonTouchStart=function(e){qn(e.detail.id,"touchstart",r,r.data.hand)},this.bindMethods()},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("axismove",this.onAxisMoved),r.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("axismove",this.onAxisMoved),r.removeEventListener("model-loaded",this.onModelLoaded),r.sceneEl.removeEventListener("enter-vr",this.onEnterVR),r.sceneEl.removeEventListener("exit-vr",this.onExitVR),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var r=this.controllerObject3D;r&&(r.visible=!1),tl(this,wU,{hand:this.data.hand,iterateControllerProfiles:!0})},injectTrackedControls:function(){var r=this.el,e=this.data,n=wU;r.setAttribute("tracked-controls",{id:n,hand:e.hand,handTrackingEnabled:!1,iterateControllerProfiles:!0,orientationOffset:e.orientationOffset}),this.loadModel()},loadModel:function(){var r=this.controllerObject3D;if(this.data.model)return r?(r.visible=this.el.sceneEl.is("vr-mode"),void this.el.setObject3D("mesh",r)):void this.el.setAttribute("gltf-model",Ebe+"logitech-mx-ink.glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(r){var e,n=this.mapping[this.data.hand].buttons[r.detail.id];n&&(n==="trigger"&&(e=r.detail.state.value,console.log("analog value of trigger press: "+e)),this.el.emit(n+"changed",r.detail.state))},onModelLoaded:function(r){r.target===this.el&&this.data.model&&(this.el.emit("controllermodelready",{name:"logitech-mx-ink-controls",model:this.data.model,rayOrigin:new X.Vector3(0,0,0)}),this.controllerObject3D=this.el.getObject3D("mesh"),this.controllerObject3D.visible=this.el.sceneEl.is("vr-mode"))},onAxisMoved:function(r){Bl(this,this.mapping.axes,r)}}),Math.PI/2),EU=(kn("look-controls",{dependencies:["position","rotation"],schema:{enabled:{default:!0},magicWindowTrackingEnabled:{default:!0},pointerLockEnabled:{default:!1},reverseMouseDrag:{default:!1},reverseTouchDrag:{default:!1},touchEnabled:{default:!0},mouseEnabled:{default:!0}},init:function(){this.deltaYaw=0,this.previousHMDPosition=new X.Vector3,this.hmdQuaternion=new X.Quaternion,this.magicWindowAbsoluteEuler=new X.Euler,this.magicWindowDeltaEuler=new X.Euler,this.position=new X.Vector3,this.magicWindowObject=new X.Object3D,this.rotation={},this.deltaRotation={},this.savedPose=null,this.pointerLocked=!1,this.setupMouseControls(),this.bindMethods(),this.previousMouseEvent={},this.setupMagicWindowControls(),this.savedPose={position:new X.Vector3,rotation:new X.Euler},(this.el.sceneEl.is("vr-mode")||this.el.sceneEl.is("ar-mode"))&&this.onEnterVR()},setupMagicWindowControls:function(){var r,e=this.data;(ef()||Xk())&&(r=this.magicWindowControls=new nW(this.magicWindowObject),typeof DeviceOrientationEvent<"u"&&DeviceOrientationEvent.requestPermission&&(r.enabled=!1,this.el.sceneEl.components["device-orientation-permission-ui"].permissionGranted?r.enabled=e.magicWindowTrackingEnabled:this.el.sceneEl.addEventListener("deviceorientationpermissiongranted",(function(){r.enabled=e.magicWindowTrackingEnabled}))))},update:function(r){var e=this.data;e.enabled!==r.enabled&&this.updateGrabCursor(e.enabled),r&&!e.magicWindowTrackingEnabled&&r.magicWindowTrackingEnabled&&(this.magicWindowAbsoluteEuler.set(0,0,0),this.magicWindowDeltaEuler.set(0,0,0)),this.magicWindowControls&&(this.magicWindowControls.enabled=e.magicWindowTrackingEnabled),r&&!e.pointerLockEnabled!==r.pointerLockEnabled&&(this.removeEventListeners(),this.addEventListeners(),this.pointerLocked&&this.exitPointerLock())},tick:function(r){this.data.enabled&&this.updateOrientation()},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners(),this.pointerLocked&&this.exitPointerLock()},remove:function(){this.removeEventListeners(),this.pointerLocked&&this.exitPointerLock()},bindMethods:function(){this.onMouseDown=this.onMouseDown.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchMove=this.onTouchMove.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.onExitVR=this.onExitVR.bind(this),this.onPointerLockChange=this.onPointerLockChange.bind(this),this.onPointerLockError=this.onPointerLockError.bind(this)},setupMouseControls:function(){this.mouseDown=!1,this.pitchObject=new X.Object3D,this.yawObject=new X.Object3D,this.yawObject.position.y=10,this.yawObject.add(this.pitchObject)},addEventListeners:function(){var r=this.el.sceneEl,e=r.canvas;e?(e.addEventListener("mousedown",this.onMouseDown,!1),window.addEventListener("mousemove",this.onMouseMove,!1),window.addEventListener("mouseup",this.onMouseUp,!1),e.addEventListener("touchstart",this.onTouchStart,{passive:!0}),window.addEventListener("touchmove",this.onTouchMove,{passive:!0}),window.addEventListener("touchend",this.onTouchEnd,{passive:!0}),r.addEventListener("enter-vr",this.onEnterVR),r.addEventListener("exit-vr",this.onExitVR),this.data.pointerLockEnabled&&(document.addEventListener("pointerlockchange",this.onPointerLockChange,!1),document.addEventListener("mozpointerlockchange",this.onPointerLockChange,!1),document.addEventListener("pointerlockerror",this.onPointerLockError,!1))):r.addEventListener("render-target-loaded",this.addEventListeners.bind(this))},removeEventListeners:function(){var r=this.el.sceneEl,e=r&&r.canvas;e&&(e.removeEventListener("mousedown",this.onMouseDown),window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("mouseup",this.onMouseUp),e.removeEventListener("touchstart",this.onTouchStart),window.removeEventListener("touchmove",this.onTouchMove),window.removeEventListener("touchend",this.onTouchEnd),r.removeEventListener("enter-vr",this.onEnterVR),r.removeEventListener("exit-vr",this.onExitVR),document.removeEventListener("pointerlockchange",this.onPointerLockChange,!1),document.removeEventListener("mozpointerlockchange",this.onPointerLockChange,!1),document.removeEventListener("pointerlockerror",this.onPointerLockError,!1))},updateOrientation:function(){var r=this.el.object3D,e=this.pitchObject,n=this.yawObject,a=this.el.sceneEl;(a.is("vr-mode")||a.is("ar-mode"))&&a.checkHeadsetConnected()||(this.updateMagicWindowOrientation(),r.rotation.x=this.magicWindowDeltaEuler.x+e.rotation.x,r.rotation.y=this.magicWindowDeltaEuler.y+n.rotation.y,r.rotation.z=this.magicWindowDeltaEuler.z)},updateMagicWindowOrientation:function(){var r=this.magicWindowAbsoluteEuler,e=this.magicWindowDeltaEuler;this.magicWindowControls&&this.magicWindowControls.enabled&&(this.magicWindowControls.update(),r.setFromQuaternion(this.magicWindowObject.quaternion,"YXZ"),this.previousMagicWindowYaw||r.y===0||(this.previousMagicWindowYaw=r.y),this.previousMagicWindowYaw&&(e.x=r.x,e.y+=r.y-this.previousMagicWindowYaw,e.z=r.z,this.previousMagicWindowYaw=r.y))},onMouseMove:function(r){var e,n,a,c=this.pitchObject,h=this.previousMouseEvent,p=this.yawObject;this.data.enabled&&(this.mouseDown||this.pointerLocked)&&(this.pointerLocked?(n=r.movementX||r.mozMovementX||0,a=r.movementY||r.mozMovementY||0):(n=r.screenX-h.screenX,a=r.screenY-h.screenY),this.previousMouseEvent.screenX=r.screenX,this.previousMouseEvent.screenY=r.screenY,e=this.data.reverseMouseDrag?1:-1,p.rotation.y+=.002*n*e,c.rotation.x+=.002*a*e,c.rotation.x=Math.max(-CU,Math.min(CU,c.rotation.x)))},onMouseDown:function(r){var e=this.el.sceneEl;if(this.data.enabled&&this.data.mouseEnabled&&(!e.is("vr-mode")&&!e.is("ar-mode")||!e.checkHeadsetConnected())&&r.button===0){var n=e&&e.canvas;this.mouseDown=!0,this.previousMouseEvent.screenX=r.screenX,this.previousMouseEvent.screenY=r.screenY,this.showGrabbingCursor(),this.data.pointerLockEnabled&&!this.pointerLocked&&(n.requestPointerLock?n.requestPointerLock():n.mozRequestPointerLock&&n.mozRequestPointerLock())}},showGrabbingCursor:function(){this.el.sceneEl.canvas.style.cursor="grabbing"},hideGrabbingCursor:function(){this.el.sceneEl.canvas.style.cursor=""},onMouseUp:function(){this.mouseDown=!1,this.hideGrabbingCursor()},onTouchStart:function(r){r.touches.length!==1||!this.data.touchEnabled||this.el.sceneEl.is("vr-mode")||this.el.sceneEl.is("ar-mode")||(this.touchStart={x:r.touches[0].pageX,y:r.touches[0].pageY},this.touchStarted=!0)},onTouchMove:function(r){var e,n,a=this.el.sceneEl.canvas,c=this.yawObject;this.touchStarted&&this.data.touchEnabled&&(n=2*Math.PI*(r.touches[0].pageX-this.touchStart.x)/a.clientWidth,e=this.data.reverseTouchDrag?1:-1,c.rotation.y-=.5*n*e,this.touchStart={x:r.touches[0].pageX,y:r.touches[0].pageY})},onTouchEnd:function(){this.touchStarted=!1},onEnterVR:function(){var r=this.el.sceneEl;r.checkHeadsetConnected()&&(this.saveCameraPose(),this.el.object3D.position.set(0,0,0),this.el.object3D.rotation.set(0,0,0),r.hasWebXR&&(this.el.object3D.matrixAutoUpdate=!1,this.el.object3D.updateMatrix()))},onExitVR:function(){this.el.sceneEl.checkHeadsetConnected()&&(this.restoreCameraPose(),this.previousHMDPosition.set(0,0,0),this.el.object3D.matrixAutoUpdate=!0)},onPointerLockChange:function(){this.pointerLocked=!(!document.pointerLockElement&&!document.mozPointerLockElement)},onPointerLockError:function(){this.pointerLocked=!1},exitPointerLock:function(){document.exitPointerLock(),this.pointerLocked=!1},updateGrabCursor:function(r){var e=this.el.sceneEl;function n(){e.canvas.classList.add("a-grab-cursor")}function a(){e.canvas.classList.remove("a-grab-cursor")}e.canvas?r?n():a():r?e.addEventListener("render-target-loaded",n):e.addEventListener("render-target-loaded",a)},saveCameraPose:function(){var r=this.el;this.savedPose.position.copy(r.object3D.position),this.savedPose.rotation.copy(r.object3D.rotation),this.hasSavedPose=!0},restoreCameraPose:function(){var r=this.el,e=this.savedPose;this.hasSavedPose&&(r.object3D.position.copy(e.position),r.object3D.rotation.copy(e.rotation),this.hasSavedPose=!1)}}),"magicleap-one"),Sbe=ur+"controllers/magicleap/magicleap-one-controller.glb",Ibe=(kn("magicleap-controls",{schema:{hand:{default:"none"},model:{default:!0}},mapping:{axes:{touchpad:[0,1]},buttons:["trigger","grip","touchpad","menu"]},init:function(){var r=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){qn(e.detail.id,"down",r)},this.onButtonUp=function(e){qn(e.detail.id,"up",r)},this.onButtonTouchEnd=function(e){qn(e.detail.id,"touchend",r)},this.onButtonTouchStart=function(e){qn(e.detail.id,"touchstart",r)},this.previousButtonValues={},this.bindMethods()},update:function(){var r=this.data;this.controllerIndex=r.hand==="right"?0:r.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("axismove",this.onAxisMoved),r.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("axismove",this.onAxisMoved),r.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var r=this.data;tl(this,EU,{index:this.controllerIndex,hand:r.hand})},injectTrackedControls:function(){var r=this.el,e=this.data;r.setAttribute("tracked-controls",{idPrefix:EU,hand:e.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("gltf-model",Sbe)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(r){var e,n=this.mapping.buttons[r.detail.id];n&&(n==="trigger"&&(e=r.detail.state.value,console.log("analog value of trigger press: "+e)),this.el.emit(n+"changed",r.detail.state))},onModelLoaded:function(r){r.detail.model.scale.set(.01,.01,.01)},onAxisMoved:function(r){Bl(this,this.mapping.axes,r)},updateModel:function(r,e){},setButtonColor:function(r,e){}}),$i("components:material:error"));function SU(r,e){r.dispose(),e.unregisterMaterial(r),Object.keys(r).filter((function(n){return r[n]&&r[n].isTexture})).forEach((function(n){r[n].dispose()}))}kn("material",{schema:{alphaTest:{default:0,min:0,max:1},depthTest:{default:!0},depthWrite:{default:!0},flatShading:{default:!1},npot:{default:!1},offset:{type:"vec2",default:{x:0,y:0}},opacity:{default:1,min:0,max:1},repeat:{type:"vec2",default:{x:1,y:1}},shader:{default:"standard",oneOf:BW,schemaChange:!0},side:{default:"front",oneOf:["front","back","double"]},transparent:{default:!1},vertexColorsEnabled:{default:!1},visible:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"]},dithering:{default:!0},anisotropy:{default:0,min:0}},init:function(){this.material=null},update:function(r){var e=this.data;this.shader&&e.shader===r.shader||this.updateShader(e.shader),this.shader.update(this.data),this.updateMaterial(r)},updateSchema:function(r){var e,n,a,c;n=r&&r.shader,e=this.oldData&&this.oldData.shader,(a=Au[c=n||e]&&Au[c].schema)||Ibe("Unknown shader schema "+c),e&&n===e||(this.extendSchema(a),this.updateBehavior())},updateBehavior:function(){var r,e,n=this.el.sceneEl,a=this.schema,c=this;function h(p,b){var y;for(y in e)e[y]=p;c.shader.update(e)}for(r in this.tick=void 0,e={},a)a[r].type==="time"&&(this.tick=h,e[r]=!0);n&&(this.tick?n.addBehavior(this):n.removeBehavior(this))},updateShader:function(r){var e,n=this.data,a=Au[r]&&Au[r].Shader;if(!a)throw new Error("Unknown shader "+r);(e=this.shader=new a).el=this.el,e.init(n),this.setMaterial(e.material),this.updateSchema(n)},updateMaterial:function(r){var e,n=this.data,a=this.material;for(e in a.alphaTest=n.alphaTest,a.depthTest=n.depthTest!==!1,a.depthWrite=n.depthWrite!==!1,a.opacity=n.opacity,a.flatShading=n.flatShading,a.side=(function(c){switch(c){case"back":return X.BackSide;case"double":return X.DoubleSide;default:return X.FrontSide}})(n.side),a.transparent=n.transparent!==!1||n.opacity<1,a.vertexColors=n.vertexColorsEnabled,a.visible=n.visible,a.blending=(function(c){switch(c){case"none":return X.NoBlending;case"additive":return X.AdditiveBlending;case"subtractive":return X.SubtractiveBlending;case"multiply":return X.MultiplyBlending;default:return X.NormalBlending}})(n.blending),a.dithering=n.dithering,r)break;!e||r.alphaTest===n.alphaTest&&r.side===n.side&&r.vertexColorsEnabled===n.vertexColorsEnabled||(a.needsUpdate=!0)},remove:function(){var r=new X.MeshBasicMaterial,e=this.material,n=this.el.getObject3D("mesh");n&&(n.material=r),SU(e,this.system)},setMaterial:function(r){var e,n=this.el,a=this.system;this.material&&SU(this.material,a),this.material=r,a.registerMaterial(r),(e=n.getObject3D("mesh"))?e.material=r:n.addEventListener("object3dset",(function c(h){h.detail.type==="mesh"&&h.target===n&&(n.getObject3D("mesh").material=r,n.removeEventListener("object3dset",c))}))}});var KC,ZC,V_,IU,W_,TU="oculus-touch",$0=ur+"controllers/oculus/oculus-touch-controller-",$C=ur+"controllers/meta/",Tbe={left:{modelUrl:$0+"left.gltf",rayOrigin:{origin:{x:.002,y:-.005,z:-.03},direction:{x:0,y:-.8,z:-1}},modelPivotOffset:new X.Vector3(-.005,.036,-.037),modelPivotRotation:new X.Euler(Math.PI/4.5,0,0)},right:{modelUrl:$0+"right.gltf",rayOrigin:{origin:{x:-.002,y:-.005,z:-.03},direction:{x:0,y:-.8,z:-1}},modelPivotOffset:new X.Vector3(.005,.036,-.037),modelPivotRotation:new X.Euler(Math.PI/4.5,0,0)}},MU="oculus-touch",fm={"oculus-touch":Tbe,"oculus-touch-v2":{left:{modelUrl:$0+"gen2-left.gltf",rayOrigin:{origin:{x:-.006,y:-.03,z:-.04},direction:{x:0,y:-.9,z:-1}},modelPivotOffset:new X.Vector3(0,-.007,-.021),modelPivotRotation:new X.Euler(-Math.PI/4,0,0)},right:{modelUrl:$0+"gen2-right.gltf",rayOrigin:{origin:{x:.006,y:-.03,z:-.04},direction:{x:0,y:-.9,z:-1}},modelPivotOffset:new X.Vector3(0,-.007,-.021),modelPivotRotation:new X.Euler(-Math.PI/4,0,0)}},"oculus-touch-v3":{left:{modelUrl:$0+"v3-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new X.Vector3(0,0,0),modelPivotRotation:new X.Euler(0,0,0)},right:{modelUrl:$0+"v3-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new X.Vector3(0,0,0),modelPivotRotation:new X.Euler(0,0,0)}},"meta-quest-touch-pro":{left:{modelUrl:$C+"quest-touch-pro-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new X.Vector3(0,0,0),modelPivotRotation:new X.Euler(0,0,0)},right:{modelUrl:$C+"quest-touch-pro-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new X.Vector3(0,0,0),modelPivotRotation:new X.Euler(0,0,0)}},"meta-quest-touch-plus":{left:{modelUrl:$C+"quest-touch-plus-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new X.Vector3(0,0,0),modelPivotRotation:new X.Euler(0,0,0)},right:{modelUrl:$C+"quest-touch-plus-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new X.Vector3(0,0,0),modelPivotRotation:new X.Euler(0,0,0)}}},_U={schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#999"},buttonTouchColor:{type:"color",default:"#8AB"},buttonHighlightColor:{type:"color",default:"#2DF"},model:{default:!0},controllerType:{default:"auto",oneOf:["auto","oculus-touch","oculus-touch-v2","oculus-touch-v3"]}},after:["tracked-controls"],mapping:{left:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton","surface"]},right:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton","surface"]}},bindMethods:function(){this.onButtonChanged=this.onButtonChanged.bind(this),this.onThumbstickMoved=this.onThumbstickMoved.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var r=this;this.onButtonDown=function(e){qn(e.detail.id,"down",r,r.data.hand)},this.onButtonUp=function(e){qn(e.detail.id,"up",r,r.data.hand)},this.onButtonTouchStart=function(e){qn(e.detail.id,"touchstart",r,r.data.hand)},this.onButtonTouchEnd=function(e){qn(e.detail.id,"touchend",r,r.data.hand)},this.controllerPresent=!1,this.previousButtonValues={},this.bindMethods(),this.triggerEuler=new X.Euler},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("axismove",this.onAxisMoved),r.addEventListener("model-loaded",this.onModelLoaded),r.addEventListener("thumbstickmoved",this.onThumbstickMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("axismove",this.onAxisMoved),r.removeEventListener("model-loaded",this.onModelLoaded),r.removeEventListener("thumbstickmoved",this.onThumbstickMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var r=this.controllerObject3D;r&&(r.visible=!1),tl(this,TU,{hand:this.data.hand,iterateControllerProfiles:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},loadModel:function(r){var e,n=this.data;if(n.model){if(this.controllerObject3D)return this.controllerObject3D.visible=!0,void this.el.setObject3D("mesh",this.controllerObject3D);if(this.displayModel=fm[n.controllerType]||fm[MU],n.controllerType==="auto"){e=MU;for(var a=Object.keys(fm),c=0;c<r.profiles.length;c++)if(a.indexOf(r.profiles[c])!==-1){e=r.profiles[c];break}this.displayModel=fm[e]}var h=this.displayModel[n.hand].modelUrl;this.isTouchV3orPROorPlus=this.displayModel===fm["oculus-touch-v3"]||this.displayModel===fm["meta-quest-touch-pro"]||this.displayModel===fm["meta-quest-touch-plus"],this.el.setAttribute("gltf-model",h)}},injectTrackedControls:function(r){var e=this.data,n=TU;this.el.setAttribute("tracked-controls",{id:n,hand:e.hand,handTrackingEnabled:!1,iterateControllerProfiles:!0}),this.loadModel(r)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(r){var e=this.mapping[this.data.hand].buttons[r.detail.id];if(e){if(this.isTouchV3orPROorPlus)this.onButtonChangedV3orPROorPlus(r);else{var n,a=this.buttonMeshes;e!=="trigger"&&e!=="grip"||(n=r.detail.state.value),a&&(e==="trigger"&&a.trigger&&(a.trigger.rotation.x=this.originalXRotationTrigger-n*(Math.PI/26)),e==="grip"&&a.grip&&(n*=this.data.hand==="left"?-1:1,a.grip.position.x=this.originalXPositionGrip+.004*n))}this.el.emit(e+"changed",r.detail.state)}},onButtonChangedV3orPROorPlus:function(r){var e,n=this.mapping[this.data.hand].buttons[r.detail.id],a=this.buttonObjects;a&&a[n]&&(e=r.detail.state.value,a[n].quaternion.slerpQuaternions(this.buttonRanges[n].min.quaternion,this.buttonRanges[n].max.quaternion,e),a[n].position.lerpVectors(this.buttonRanges[n].min.position,this.buttonRanges[n].max.position,e))},onModelLoaded:function(r){if(r.target===this.el&&this.data.model){if(this.isTouchV3orPROorPlus)this.onTouchV3orPROorPlusModelLoaded(r);else{var e,n=this.controllerObject3D=r.detail.model;(e=this.buttonMeshes={}).grip=n.getObjectByName("buttonHand"),this.originalXPositionGrip=e.grip&&e.grip.position.x,e.trigger=n.getObjectByName("buttonTrigger"),this.originalXRotationTrigger=e.trigger&&e.trigger.rotation.x,e.thumbstick=n.getObjectByName("stick"),e.xbutton=n.getObjectByName("buttonX"),e.abutton=n.getObjectByName("buttonA"),e.ybutton=n.getObjectByName("buttonY"),e.bbutton=n.getObjectByName("buttonB")}for(var a in this.buttonMeshes)this.buttonMeshes[a]&&Mbe(this.buttonMeshes[a]);this.applyOffset(r.detail.model),this.el.emit("controllermodelready",{name:"meta-touch-controls",model:this.data.model,rayOrigin:this.displayModel[this.data.hand].rayOrigin})}},applyOffset:function(r){r.position.copy(this.displayModel[this.data.hand].modelPivotOffset),r.rotation.copy(this.displayModel[this.data.hand].modelPivotRotation)},onTouchV3orPROorPlusModelLoaded:function(r){var e=this.controllerObject3D=r.detail.model,n=this.buttonObjects={},a=this.buttonMeshes={},c=this.buttonRanges={};a.grip=e.getObjectByName("squeeze"),n.grip=e.getObjectByName("xr_standard_squeeze_pressed_value"),c.grip={min:e.getObjectByName("xr_standard_squeeze_pressed_min"),max:e.getObjectByName("xr_standard_squeeze_pressed_max")},n.grip.minX=n.grip.position.x,a.thumbstick=e.getObjectByName("thumbstick"),n.thumbstick=e.getObjectByName("xr_standard_thumbstick_pressed_value"),c.thumbstick={min:e.getObjectByName("xr_standard_thumbstick_pressed_min"),max:e.getObjectByName("xr_standard_thumbstick_pressed_max")},n.thumbstickXAxis=e.getObjectByName("xr_standard_thumbstick_xaxis_pressed_value"),c.thumbstickXAxis={min:e.getObjectByName("xr_standard_thumbstick_xaxis_pressed_min"),max:e.getObjectByName("xr_standard_thumbstick_xaxis_pressed_max")},n.thumbstickYAxis=e.getObjectByName("xr_standard_thumbstick_yaxis_pressed_value"),c.thumbstickYAxis={min:e.getObjectByName("xr_standard_thumbstick_yaxis_pressed_min"),max:e.getObjectByName("xr_standard_thumbstick_yaxis_pressed_max")},a.trigger=e.getObjectByName("trigger"),n.trigger=e.getObjectByName("xr_standard_trigger_pressed_value"),c.trigger={min:e.getObjectByName("xr_standard_trigger_pressed_min"),max:e.getObjectByName("xr_standard_trigger_pressed_max")},c.trigger.diff={x:Math.abs(c.trigger.max.rotation.x)-Math.abs(c.trigger.min.rotation.x),y:Math.abs(c.trigger.max.rotation.y)-Math.abs(c.trigger.min.rotation.y),z:Math.abs(c.trigger.max.rotation.z)-Math.abs(c.trigger.min.rotation.z)};var h=this.data.hand==="left"?"x":"a",p=this.data.hand==="left"?"y":"b",b=h+"button",y=p+"button";a[b]=e.getObjectByName(h+"_button"),n[b]=e.getObjectByName(h+"_button_pressed_value"),c[b]={min:e.getObjectByName(h+"_button_pressed_min"),max:e.getObjectByName(h+"_button_pressed_max")},a[y]=e.getObjectByName(p+"_button"),n[y]=e.getObjectByName(p+"_button_pressed_value"),c[y]={min:e.getObjectByName(p+"_button_pressed_min"),max:e.getObjectByName(p+"_button_pressed_max")}},onAxisMoved:function(r){Bl(this,this.mapping[this.data.hand].axes,r)},onThumbstickMoved:function(r){if(this.buttonMeshes&&this.buttonMeshes.thumbstick)if(this.isTouchV3orPROorPlus)this.updateThumbstickTouchV3orPROorPlus(r);else for(var e in r.detail)this.buttonObjects.thumbstick.rotation[this.axisMap[e]]=this.buttonRanges.thumbstick.originalRotation[this.axisMap[e]]-Math.PI/8*r.detail[e]*(e==="y"||this.data.hand==="right"?-1:1)},axisMap:{y:"x",x:"z"},updateThumbstickTouchV3orPROorPlus:function(r){var e=(r.detail.x+1)/2;this.buttonObjects.thumbstickXAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickXAxis.min.quaternion,this.buttonRanges.thumbstickXAxis.max.quaternion,e);var n=(r.detail.y+1)/2;this.buttonObjects.thumbstickYAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickYAxis.min.quaternion,this.buttonRanges.thumbstickYAxis.max.quaternion,n)},updateModel:function(r,e){this.data.model&&this.updateButtonModel(r,e)},updateButtonModel:function(r,e){var n,a=this.buttonMeshes;a&&a[r]&&(n=e==="up"||e==="touchend"?a[r].originalColor||this.data.buttonColor:e==="touchstart"?this.data.buttonTouchColor:this.data.buttonHighlightColor,a[r].material.color.set(n))}};function Mbe(r){r.traverse((function(e){var n;e.type==="Mesh"&&(n=e.material.clone(),r.originalColor=e.material.color,e.material.dispose(),e.material=n)}))}kn("oculus-touch-controls",_U),kn("meta-touch-controls",_U),kn("obb-collider",{schema:{size:{default:0},trackedObject3D:{default:""},minimumColliderDimension:{default:.02},centerModel:{default:!1}},init:function(){this.previousScale=new X.Vector3().copy(this.el.object3D.scale),this.auxEuler=new X.Euler,this.boundingBox=new X.Box3,this.boundingBoxSize=new X.Vector3,this.updateCollider=this.updateCollider.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.updateBoundingBox=this.updateBoundingBox.bind(this),this.el.addEventListener("model-loaded",this.onModelLoaded),this.updateCollider(),this.system.addCollider(this.el)},remove:function(){this.system.removeCollider(this.el)},update:function(){this.data.trackedObject3D&&(this.trackedObject3DPath=this.data.trackedObject3D.split("."))},onModelLoaded:function(){this.data.centerModel&&this.centerModel(),this.updateCollider()},centerModel:function(){var r,e=this.el,n=e.components["gltf-model"]&&e.components["gltf-model"].model;n&&(this.el.removeObject3D("mesh"),r=new X.Box3().setFromObject(n).getCenter(new X.Vector3),n.position.x+=n.position.x-r.x,n.position.y+=n.position.y-r.y,n.position.z+=n.position.z-r.z,this.el.setObject3D("mesh",n))},updateCollider:function(){var r=this.el,e=this.boundingBoxSize,n=this.aabb=this.aabb||new s2;this.obb=this.obb||new s2,r.hasLoaded?(this.updateBoundingBox(),n.halfSize.copy(e).multiplyScalar(.5),this.el.sceneEl.systems["obb-collider"].data.showColliders&&this.showCollider()):r.addEventListener("loaded",this.updateCollider)},showCollider:function(){this.updateColliderMesh(),this.renderColliderMesh.visible=!0},updateColliderMesh:function(){var r=this.renderColliderMesh,e=this.boundingBoxSize;r?(r.geometry.dispose(),r.geometry=new X.BoxGeometry(e.x,e.y,e.z)):this.initColliderMesh()},hideCollider:function(){this.renderColliderMesh&&(this.renderColliderMesh.visible=!1)},initColliderMesh:function(){var r,e,n;r=this.boundingBoxSize,e=this.renderColliderGeometry=new X.BoxGeometry(r.x,r.y,r.z),(n=this.renderColliderMesh=new X.Mesh(e,new X.MeshLambertMaterial({color:65280,side:X.DoubleSide}))).matrixAutoUpdate=!1,n.matrixWorldAutoUpdate=!1,n.updateMatrixWorld=function(){},this.el.sceneEl.object3D.add(n)},updateBoundingBox:(KC=new X.Vector3,ZC=new X.Vector3,V_=new X.Quaternion,IU=new X.Quaternion,W_=new X.Matrix4,function(){var r=this.auxEuler,e=this.boundingBox,n=this.data.size,a=this.trackedObject3D||this.el.object3D,c=this.boundingBoxSize,h=this.data.minimumColliderDimension;if(n)return this.boundingBoxSize.x=n,this.boundingBoxSize.y=n,void(this.boundingBoxSize.z=n);r.copy(a.rotation),a.rotation.set(0,0,0),a.parent.matrixWorld.decompose(KC,V_,ZC),W_.compose(KC,IU,ZC),a.parent.matrixWorld.copy(W_),e.setFromObject(a,!0),e.getSize(c),c.x=c.x<h?h:c.x,c.y=c.y<h?h:c.y,c.z=c.z<h?h:c.z,a.parent.matrixWorld.compose(KC,V_,ZC),this.el.object3D.rotation.copy(r)}),checkTrackedObject:function(){var r,e=this.trackedObject3DPath;if(e&&e.length&&!this.trackedObject3D){r=this.el;for(var n=0;n<e.length&&(r=r[e[n]]);n++);r&&(this.trackedObject3D=r,this.updateCollider())}return this.trackedObject3D},tick:(function(){var r=new X.Vector3,e=new X.Vector3,n=new X.Quaternion,a=new X.Matrix4;return function(){var c=this.obb,h=this.renderColliderMesh,p=this.checkTrackedObject()||this.el.object3D;p&&(p.updateMatrix(),p.updateMatrixWorld(!0),p.matrixWorld.decompose(r,n,e),(Math.abs(e.x-this.previousScale.x)>1e-4||Math.abs(e.y-this.previousScale.y)>1e-4||Math.abs(e.z-this.previousScale.z)>1e-4)&&this.updateCollider(),this.previousScale.copy(e),e.set(1,1,1),a.compose(r,n,e),h&&h.matrixWorld.copy(a),c.copy(this.aabb),c.applyMatrix4(a))}})()});var _be=$i("components:obj-model:warn"),Rbe=(kn("obj-model",{schema:{mtl:{type:"model"},obj:{type:"model"}},init:function(){var r=this;this.model=null,this.objLoader=new JV,this.mtlLoader=new eW(this.objLoader.manager),this.mtlLoader.crossOrigin="",this.el.addEventListener("componentinitialized",(function(e){r.model&&e.detail.name==="material"&&r.applyMaterial()}))},update:function(){var r=this.data;r.obj&&(this.resetMesh(),this.loadObj(r.obj,r.mtl))},remove:function(){this.resetMesh()},resetMesh:function(){this.model&&this.el.removeObject3D("mesh")},loadObj:function(r,e){var n=this,a=this.el,c=this.mtlLoader,h=this.objLoader,p=this.el.sceneEl.systems.renderer,b=e.substr(0,e.lastIndexOf("/")+1);if(e)return a.hasAttribute("material")&&_be("Material component properties are ignored when a .MTL is provided"),c.setResourcePath(b),void c.load(e,(function(y){y.preload(),h.setMaterials(y),h.load(r,(function(w){n.model=w,n.model.traverse((function(I){if(I.isMesh){var E=I.material;E.map&&p.applyColorCorrection(E.map),E.emissiveMap&&p.applyColorCorrection(E.emissiveMap)}})),a.setObject3D("mesh",w),a.emit("model-loaded",{format:"obj",model:w})}))}));h.load(r,(function(y){n.model=y,n.applyMaterial(),a.setObject3D("mesh",y),a.emit("model-loaded",{format:"obj",model:y})}))},applyMaterial:function(){var r=this.el.components.material;r&&this.model.traverse((function(e){e instanceof X.Mesh&&(e.material=r.material)}))}}),ur+"controllers/oculus/go/oculus-go-controller.gltf"),RU="oculus-go",kU=(kn("oculus-go-controls",{schema:{hand:{default:""},buttonColor:{type:"color",default:"#FFFFFF"},buttonTouchedColor:{type:"color",default:"#BBBBBB"},buttonHighlightColor:{type:"color",default:"#7A7A7A"},model:{default:!0}},mapping:{axes:{touchpad:[0,1]},buttons:["trigger","none","touchpad"]},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var r=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){qn(e.detail.id,"down",r)},this.onButtonUp=function(e){qn(e.detail.id,"up",r)},this.onButtonTouchStart=function(e){qn(e.detail.id,"touchstart",r)},this.onButtonTouchEnd=function(e){qn(e.detail.id,"touchend",r)},this.controllerPresent=!1,this.bindMethods()},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("model-loaded",this.onModelLoaded),r.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("model-loaded",this.onModelLoaded),r.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){tl(this,RU,this.data.hand?{hand:this.data.hand}:{})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var r=this.el,e=this.data;r.setAttribute("tracked-controls",{hand:e.hand,idPrefix:RU}),this.data.model&&this.el.setAttribute("gltf-model",Rbe)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelLoaded:function(r){var e,n=r.detail.model;r.target===this.el&&this.data.model&&((e=this.buttonMeshes={}).trigger=n.getObjectByName("oculus_go_button_trigger"),e.trackpad=n.getObjectByName("oculus_go_touchpad"),e.touchpad=n.getObjectByName("oculus_go_touchpad"))},onButtonChanged:function(r){var e=this.mapping.buttons[r.detail.id];e&&this.el.emit(e+"changed",r.detail.state)},onAxisMoved:function(r){Bl(this,this.mapping.axes,r)},updateModel:function(r,e){this.data.model&&this.updateButtonModel(r,e)},updateButtonModel:function(r,e){var n=this.buttonMeshes;if(n&&n[r]){var a;switch(e){case"down":a=this.data.buttonHighlightColor;break;case"touchstart":a=this.data.buttonTouchedColor;break;default:a=this.data.buttonColor}n[r].material.color.set(a)}}}),"pico-4"),kbe=ur+"controllers/pico/pico4/",BU=(kn("pico-controls",{schema:{hand:{default:"none"},model:{default:!0}},mapping:{left:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton"]},right:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton"]}},init:function(){var r=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){qn(e.detail.id,"down",r,r.data.hand)},this.onButtonUp=function(e){qn(e.detail.id,"up",r,r.data.hand)},this.onButtonTouchEnd=function(e){qn(e.detail.id,"touchend",r,r.data.hand)},this.onButtonTouchStart=function(e){qn(e.detail.id,"touchstart",r,r.data.hand)},this.bindMethods()},update:function(){var r=this.data;this.controllerIndex=r.hand==="right"?0:r.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("axismove",this.onAxisMoved),r.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("axismove",this.onAxisMoved),r.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var r=this.data;tl(this,kU,{index:this.controllerIndex,hand:r.hand})},injectTrackedControls:function(){var r=this.el,e=this.data;r.setAttribute("tracked-controls",{idPrefix:kU,hand:e.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("gltf-model",kbe+this.data.hand+".glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(r){var e,n=this.mapping[this.data.hand].buttons[r.detail.id];n&&(n==="trigger"&&(e=r.detail.state.value,console.log("analog value of trigger press: "+e)),this.el.emit(n+"changed",r.detail.state))},onModelLoaded:function(r){r.target===this.el&&this.data.model&&this.el.emit("controllermodelready",{name:"pico-controls",model:this.data.model,rayOrigin:new X.Vector3(0,0,0)})},onAxisMoved:function(r){Bl(this,this.mapping[this.data.hand].axes,r)}}),kn("position",{schema:{type:"vec3"},update:function(){var r=this.el.object3D,e=this.data;r.position.set(e.x,e.y,e.z)},remove:function(){this.el.object3D.position.set(0,0,0)}}),$i("components:raycaster:warn")),Bbe=/^[\w\s-.,[\]#]*$/,Lbe={childList:!0,attributes:!0,subtree:!0},LU="raycaster-intersected-cleared",NU="raycaster-intersection-cleared";function DU(r,e){var n;for(r.length=e.length,n=0;n<e.length;n++)r[n]=e[n]}kn("raycaster",{schema:{autoRefresh:{default:!0},direction:{type:"vec3",default:{x:0,y:0,z:-1}},enabled:{default:!0},far:{default:1e3},interval:{default:0},near:{default:0},objects:{default:""},origin:{type:"vec3"},showLine:{default:!1},lineColor:{default:"white"},lineOpacity:{default:1},useWorldCoordinates:{default:!1}},multiple:!0,init:function(){this.clearedIntersectedEls=[],this.unitLineEndVec3=new X.Vector3,this.intersectedEls=[],this.intersections=[],this.newIntersectedEls=[],this.newIntersections=[],this.objects=[],this.prevCheckTime=void 0,this.prevIntersectedEls=[],this.rawIntersections=[],this.raycaster=new X.Raycaster,this.updateOriginDirection(),this.setDirty=this.setDirty.bind(this),this.updateLine=this.updateLine.bind(this),this.observer=new MutationObserver(this.setDirty),this.dirty=!0,this.lineEndVec3=new X.Vector3,this.otherLineEndVec3=new X.Vector3,this.lineData={end:this.lineEndVec3},this.getIntersection=this.getIntersection.bind(this),this.intersectedDetail={el:this.el,getIntersection:this.getIntersection},this.intersectedClearedDetail={el:this.el},this.intersectionClearedDetail={clearedEls:this.clearedIntersectedEls},this.intersectionDetail={}},update:function(r){var e=this.data,n=this.el,a=this.raycaster;a.far=e.far,a.near=e.near,!e.showLine||e.far===r.far&&e.origin===r.origin&&e.direction===r.direction&&r.showLine||(this.unitLineEndVec3.copy(e.direction).normalize(),this.drawLine()),!e.showLine&&r.showLine&&n.removeAttribute("line"),e.objects===r.objects||Bbe.test(e.objects)||BU('[raycaster] Selector "'+e.objects+'" may not update automatically with DOM changes.'),e.objects||BU('[raycaster] For performance, please define raycaster.objects when using raycaster or cursor components to whitelist which entities to intersect with. e.g., raycaster="objects: [data-raycastable]".'),e.autoRefresh!==r.autoRefresh&&n.isPlaying&&(e.autoRefresh?this.addEventListeners():this.removeEventListeners()),r.enabled&&!e.enabled&&this.clearAllIntersections(),e.objects!==r.objects&&this.setDirty()},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},remove:function(){this.data.showLine&&this.el.removeAttribute("line"),this.clearAllIntersections()},addEventListeners:function(){this.data.autoRefresh&&(this.observer.observe(this.el.sceneEl,Lbe),this.el.sceneEl.addEventListener("object3dset",this.setDirty),this.el.sceneEl.addEventListener("object3dremove",this.setDirty))},removeEventListeners:function(){this.observer.disconnect(),this.el.sceneEl.removeEventListener("object3dset",this.setDirty),this.el.sceneEl.removeEventListener("object3dremove",this.setDirty)},setDirty:function(){this.dirty=!0},refreshObjects:function(){var r,e=this.data;r=e.objects?this.el.sceneEl.querySelectorAll(e.objects):this.el.sceneEl.querySelectorAll("*"),this.objects=this.flattenObject3DMaps(r),this.dirty=!1},tock:function(r){var e=this.data,n=this.prevCheckTime;e.enabled&&(n&&r-n<e.interval||(this.prevCheckTime=r,this.checkIntersections()))},checkIntersections:function(){var r,e,n=this.clearedIntersectedEls,a=this.el,c=this.data,h=this.intersectedEls,p=this.intersections,b=this.newIntersectedEls,y=this.newIntersections,w=this.prevIntersectedEls,I=this.rawIntersections;for(this.dirty&&this.refreshObjects(),DU(this.prevIntersectedEls,this.intersectedEls),this.updateOriginDirection(),I.length=0,this.raycaster.intersectObjects(this.objects,!0,I),p.length=0,h.length=0,r=0;r<I.length;r++)e=I[r],c.showLine&&e.object===a.getObject3D("line")||e.object.el&&(p.push(e),h.push(e.object.el));for(y.length=0,b.length=0,r=0;r<p.length;r++)w.indexOf(p[r].object.el)===-1&&(y.push(p[r]),b.push(p[r].object.el));for(n.length=0,r=0;r<w.length;r++)h.indexOf(w[r])===-1&&(w[r].emit(LU,this.intersectedClearedDetail),n.push(w[r]));for(n.length&&a.emit(NU,this.intersectionClearedDetail),r=0;r<b.length;r++)b[r].emit("raycaster-intersected",this.intersectedDetail);y.length&&(this.intersectionDetail.els=b,this.intersectionDetail.intersections=y,a.emit("raycaster-intersection",this.intersectionDetail)),(w.length===0&&p.length>0||w.length>0&&p.length===0||w.length&&p.length&&w[0]!==p[0].object.el)&&(this.intersectionDetail.els=this.intersectedEls,this.intersectionDetail.intersections=p,a.emit("raycaster-closest-entity-changed",this.intersectionDetail)),c.showLine&&setTimeout(this.updateLine)},updateLine:function(){var r,e=this.el,n=this.intersections;n.length&&(r=n[0].object.el===e&&n[1]?n[1].distance:n[0].distance),this.drawLine(r)},getIntersection:function(r){var e,n;for(e=0;e<this.intersections.length;e++)if((n=this.intersections[e]).object.el===r)return n;return null},updateOriginDirection:(function(){var r=new X.Vector3,e=new X.Vector3;return function(){var n=this.el,a=this.data;a.useWorldCoordinates?this.raycaster.set(a.origin,a.direction):(n.object3D.updateMatrixWorld(),e.setFromMatrixPosition(n.object3D.matrixWorld),a.origin.x===0&&a.origin.y===0&&a.origin.z===0||(e=n.object3D.localToWorld(e.copy(a.origin))),r.copy(a.direction).transformDirection(n.object3D.matrixWorld).normalize(),this.raycaster.set(e,r))}})(),drawLine:function(r){var e,n=this.data,a=this.el;e=this.lineData.end===this.lineEndVec3?this.otherLineEndVec3:this.lineEndVec3,r===void 0&&(r=n.far===1/0?1e3:n.far),this.lineData.start=n.origin,this.lineData.end=e.copy(this.unitLineEndVec3).multiplyScalar(r).add(n.origin),this.lineData.color=n.lineColor,this.lineData.opacity=n.lineOpacity,a.setAttribute("line",this.lineData)},flattenObject3DMaps:function(r){var e,n,a=this.objects,c=this.el.sceneEl.object3D;function h(b){return b.parent?h(b.parent):b===c}for(a.length=0,n=0;n<r.length;n++){var p=r[n];if(p.isEntity&&p.object3D&&h(p.object3D))for(e in p.object3DMap)a.push(p.getObject3D(e))}return a},clearAllIntersections:function(){var r;for(r=0;r<this.intersectedEls.length;r++)this.intersectedEls[r].emit(LU,this.intersectedClearedDetail);DU(this.clearedIntersectedEls,this.intersectedEls),this.intersectedEls.length=0,this.intersections.length=0,this.el.emit(NU,this.intersectionClearedDetail)}});var FU,O0,OU,GU,H_=X.MathUtils.degToRad,X_=(kn("rotation",{schema:{type:"vec3"},update:function(){var r=this.data;this.el.object3D.rotation.set(H_(r.x),H_(r.y),H_(r.z),"YXZ")},remove:function(){this.el.object3D.rotation.set(0,0,0)}}),kn("scale",{schema:{type:"vec3",default:{x:1,y:1,z:1}},update:function(){var r=this.data;this.el.object3D.scale.set(r.x,r.y,r.z)},remove:function(){this.el.object3D.scale.set(1,1,1)}}),kn("shadow",{schema:{cast:{default:!0},receive:{default:!0}},init:function(){this.onMeshChanged=this.update.bind(this),this.el.addEventListener("object3dset",this.onMeshChanged),this.system.setShadowMapEnabled(!0)},update:function(){var r=this.data;this.updateDescendants(r.cast,r.receive)},remove:function(){this.el.removeEventListener("object3dset",this.onMeshChanged),this.updateDescendants(!1,!1)},updateDescendants:function(r,e){var n=this.el.sceneEl;this.el.object3D.traverse((function(a){if(a instanceof X.Mesh&&(a.castShadow=r,a.receiveShadow=e,n.hasLoaded&&a.material))for(var c=Array.isArray(a.material)?a.material:[a.material],h=0;h<c.length;h++)c[h].needsUpdate=!0}))}}),$i("components:sound:warn")),Nbe=(kn("sound",{schema:{autoplay:{default:!1},distanceModel:{default:"inverse",oneOf:["linear","inverse","exponential"]},loop:{default:!1},loopStart:{default:0},loopEnd:{default:0},maxDistance:{default:1e4},on:{default:""},poolSize:{default:1},positional:{default:!0},refDistance:{default:1},rolloffFactor:{default:1},src:{type:"audio"},volume:{default:1}},multiple:!0,init:function(){var r=this;this.listener=null,this.audioLoader=new X.AudioLoader,this.pool=new X.Group,this.loaded=!1,this.mustPlay=!1,this.playSoundBound=function(){r.playSound()}},update:function(r){var e,n,a=this.data,c=a.src!==r.src;if(c){if(!a.src)return;this.setupSound()}for(e=0;e<this.pool.children.length;e++)n=this.pool.children[e],a.positional&&(n.setDistanceModel(a.distanceModel),n.setMaxDistance(a.maxDistance),n.setRefDistance(a.refDistance),n.setRolloffFactor(a.rolloffFactor)),n.setLoop(a.loop),n.setLoopStart(a.loopStart),a.loopStart!==0&&a.loopEnd===0?n.setLoopEnd(n.buffer.duration):n.setLoopEnd(a.loopEnd),n.setVolume(a.volume),n.isPaused=!1;if(a.on!==r.on&&this.updateEventListener(r.on),c){var h=this;this.loaded=!1,this.audioLoader.load(a.src,(function(p){for(e=0;e<h.pool.children.length;e++)(n=h.pool.children[e]).setBuffer(p);h.loaded=!0,X.Cache.remove(a.src),(h.data.autoplay||h.mustPlay)&&h.playSound(h.processSound),h.el.emit("sound-loaded",h.evtDetail,!1)}))}},pause:function(){this.stopSound(),this.removeEventListener()},play:function(){this.data.autoplay&&this.playSound(),this.updateEventListener()},remove:function(){var r;this.removeEventListener(),this.el.getObject3D(this.attrName)&&this.el.removeObject3D(this.attrName);try{for(r=0;r<this.pool.children.length;r++)this.pool.children[r].disconnect()}catch{X_("Audio source not properly disconnected")}},updateEventListener:function(r){var e=this.el;r&&e.removeEventListener(r,this.playSoundBound),e.addEventListener(this.data.on,this.playSoundBound)},removeEventListener:function(){this.el.removeEventListener(this.data.on,this.playSoundBound)},setupSound:function(){var r,e,n=this.el,a=n.sceneEl,c=this;this.pool.children.length>0&&(this.stopSound(),n.removeObject3D("sound"));var h=this.listener=a.audioListener||new X.AudioListener;for(a.audioListener=h,a.camera&&a.camera.add(h),a.addEventListener("camera-set-active",(function(p){p.detail.cameraEl.getObject3D("camera").add(h)})),this.pool=new X.Group,r=0;r<this.data.poolSize;r++)e=this.data.positional?new X.PositionalAudio(h):new X.Audio(h),this.pool.add(e);for(n.setObject3D(this.attrName,this.pool),r=0;r<this.pool.children.length;r++)(e=this.pool.children[r]).onEnded=function(){this.isPlaying=!1,c.el.emit("sound-ended",c.evtDetail,!1)}},pauseSound:function(){var r,e;for(this.isPlaying=!1,r=0;r<this.pool.children.length;r++)(e=this.pool.children[r]).source&&e.source.buffer&&e.isPlaying&&!e.isPaused&&(e.isPaused=!0,e.pause())},playSound:function(r){var e,n,a;if(!this.loaded)return X_("Sound not loaded yet. It will be played once it finished loading"),this.mustPlay=!0,void(this.processSound=r);for(e=!1,this.isPlaying=!0,n=0;n<this.pool.children.length;n++)(a=this.pool.children[n]).isPlaying||!a.buffer||e||(r&&r(a),a.play(),a.isPaused=!1,e=!0);e?(this.mustPlay=!1,this.processSound=void 0):X_("All the sounds are playing. If you need to play more sounds simultaneously consider increasing the size of pool with the `poolSize` attribute.",this.el)},stopSound:function(){var r,e;for(this.isPlaying=!1,r=0;r<this.pool.children.length;r++){if(!(e=this.pool.children[r]).source||!e.source.buffer)return;e.stop()}}}),Nn(4433)),Dbe=Nn.n(Nbe),Fbe=Nn(5751),Obe=Nn.n(Fbe),G0=$i("components:text:error"),Gbe=$i("components:text:warn"),ph=ur+"fonts/",UU={aileronsemibold:ph+"Aileron-Semibold.fnt",dejavu:ph+"DejaVu-sdf.fnt",exo2bold:ph+"Exo2Bold.fnt",exo2semibold:ph+"Exo2SemiBold.fnt",kelsonsans:ph+"KelsonSans.fnt",monoid:ph+"Monoid.fnt",mozillavr:ph+"mozillavr.fnt",roboto:ph+"Roboto-msdf.json",sourcecodepro:ph+"SourceCodePro.fnt"},PU=["roboto"],Q_="roboto",zU=new function(){var r=this.cache={};this.get=function(e,n){return e in r||(r[e]=n()),r[e]}},VU={},YC={},Ube=/^\w+:/;function WU(r,e,n){return r||(.5+e)*n}kn("text",{multiple:!0,schema:{align:{type:"string",default:"left",oneOf:["left","right","center"]},alphaTest:{default:.5},anchor:{default:"center",oneOf:["left","right","center","align"]},baseline:{default:"center",oneOf:["top","center","bottom"]},color:{type:"color",default:"#FFF"},font:{type:"string",default:Q_},fontImage:{type:"string"},height:{type:"number"},letterSpacing:{type:"number",default:0},lineHeight:{type:"number"},negate:{type:"boolean",default:!0},opacity:{type:"number",default:1},shader:{default:"sdf",oneOf:Au},side:{default:"front",oneOf:["front","back","double"]},tabSize:{default:4},transparent:{default:!0},value:{type:"string"},whiteSpace:{default:"normal",oneOf:["normal","pre","nowrap"]},width:{type:"number"},wrapCount:{type:"number",default:40},wrapPixels:{type:"number"},xOffset:{type:"number",default:0},yOffset:{type:"number",default:0},zOffset:{type:"number",default:.001}},init:function(){this.shaderData={},this.geometry=Dbe()(),this.createOrUpdateMaterial(),this.explicitGeoDimensionsChecked=!1},update:function(r){var e=this.data,n=this.currentFont;YC[e.font]?this.texture=YC[e.font]:(this.texture=YC[e.font]=new X.Texture,this.texture.anisotropy=16),this.createOrUpdateMaterial(),r.font===e.font?n&&(this.updateGeometry(this.geometry,n),this.updateLayout()):this.updateFont()},remove:function(){this.geometry.dispose(),this.geometry=null,this.el.removeObject3D(this.attrName),this.material.dispose(),this.material=null,this.texture.dispose(),this.texture=null,this.shaderObject&&delete this.shaderObject},createOrUpdateMaterial:function(){var r,e,n,a=this.data,c=this.material,h=this.shaderData;if(n=a.shader,PU.indexOf(a.font)!==-1||a.font.indexOf("-msdf.")>=0?n="msdf":a.font in UU&&PU.indexOf(a.font)===-1&&(n="sdf"),r=(this.shaderObject&&this.shaderObject.name)!==n,h.alphaTest=a.alphaTest,h.color=a.color,h.map=this.texture,h.opacity=a.opacity,h.side=(function(p){switch(p){case"back":return X.FrontSide;case"double":return X.DoubleSide;default:return X.BackSide}})(a.side),h.transparent=a.transparent,h.negate=a.negate,!r)return this.shaderObject.update(h),c.transparent=h.transparent,void(c.side=h.side);e=(function(p,b,y){var w,I;return(I=new Au[b].Shader).el=p,I.init(y),I.update(y),(w=I.material).transparent=y.transparent,{material:w,shader:I}})(this.el,n,h),this.material=e.material,this.shaderObject=e.shader,this.material.side=h.side,this.mesh&&(this.mesh.material=this.material)},updateFont:function(){var r,e=this.data,n=this.el,a=this.geometry,c=this;e.font||Gbe("No font specified. Using the default font."),this.mesh&&(this.mesh.visible=!1),r=this.lookupFont(e.font||Q_)||e.font,zU.get(r,(function(){return(function(h,p){return new Promise((function(b,y){Obe()(h,(function(w,I){if(w)return G0("Error loading font",h),void y(w);h.indexOf("/Roboto-msdf.json")>=0&&(p=30),p&&I.chars.forEach((function(E){E.yoffset+=p})),b(I)}))}))})(r,e.yOffset)})).then((function(h){var p;if(h.pages.length!==1)throw new Error("Currently only single-page bitmap fonts are supported.");VU[r]||(h.widthFactor=VU[h]=(function(b){var y=0,w=0,I=0;return b.chars.forEach((function(E){y+=E.xadvance,E.id>=48&&E.id<=57&&(I++,w+=E.xadvance)})),I?w/I:y/b.chars.length})(h)),c.currentFont=h,p=c.getFontImageSrc(),zU.get(p,(function(){return(function(b){return new Promise((function(y,w){new X.ImageLoader().load(b,(function(I){y(I)}),void 0,(function(){G0("Error loading font image",b),w(null)}))}))})(p)})).then((function(b){var y=c.texture;y&&(y.image=b,y.needsUpdate=!0,YC[e.font]=y,c.texture=y,c.initMesh(),c.currentFont=h,c.updateGeometry(a,h),c.updateLayout(),c.mesh.visible=!0,n.emit("textfontset",{font:e.font,fontObj:h}))})).catch((function(b){G0(b.message),G0(b.stack)}))})).catch((function(h){G0(h.message),G0(h.stack)}))},initMesh:function(){this.mesh||(this.mesh=new X.Mesh(this.geometry,this.material),this.el.setObject3D(this.attrName,this.mesh))},getFontImageSrc:function(){if(this.data.fontImage)return this.data.fontImage;var r=this.lookupFont(this.data.font||Q_)||this.data.font,e=this.currentFont.pages[0];return e.match(Ube)&&e.indexOf("http")!==0?r.replace(/(\.fnt)|(\.json)/,".png"):X.LoaderUtils.extractUrlBase(r)+e},updateLayout:function(){var r,e,n,a,c,h,p,b,y,w=this.el,I=this.data,E=this.geometry,R=this.mesh;if(R&&E.layout){if(n=w.getAttribute("geometry"),a=(h=(p=I.width||n&&n.width||1)/WU(I.wrapPixels,I.wrapCount,this.currentFont.widthFactor))*((c=E.layout).height+c.descender),n&&n.primitive==="plane"&&(this.explicitGeoDimensionsChecked||(this.explicitGeoDimensionsChecked=!0,this.hasExplicitGeoWidth=!!n.width,this.hasExplicitGeoHeight=!!n.height),this.hasExplicitGeoWidth||w.setAttribute("geometry","width",p),this.hasExplicitGeoHeight||w.setAttribute("geometry","height",a)),(r=I.anchor==="align"?I.align:I.anchor)==="left")b=0;else if(r==="right")b=-1*c.width;else{if(r!=="center")throw new TypeError("Invalid text.anchor property value",r);b=-1*c.width/2}if((e=I.baseline)==="bottom")y=0;else if(e==="top")y=-1*c.height+c.ascender;else{if(e!=="center")throw new TypeError("Invalid text.baseline property value",e);y=-1*c.height/2}R.position.x=b*h+I.xOffset,R.position.y=y*h,R.position.z=I.zOffset,R.scale.set(h,-1*h,h)}},lookupFont:function(r){return UU[r]},updateGeometry:(FU={},O0={},OU=/\\n/g,GU=/\\t/g,function(r,e){var n=this.data;O0.font=e,O0.lineHeight=n.lineHeight&&isFinite(n.lineHeight)?n.lineHeight:e.common.lineHeight,O0.text=n.value.toString().replace(OU,`
`).replace(GU,"	"),O0.width=WU(n.wrapPixels,n.wrapCount,e.widthFactor),r.update(Mo(FU,n,O0))})});var U0,K_,HU=(kn("tracked-controls",{schema:{id:{type:"string",default:""},controller:{default:-1},autoHide:{default:!0},hand:{type:"string",default:""},handTrackingEnabled:{default:!1},iterateControllerProfiles:{default:!1}},init:function(){this.buttonEventDetails={},this.buttonStates=this.el.components["tracked-controls"].buttonStates={},this.axis=this.el.components["tracked-controls"].axis=[0,0,0],this.changedAxes=[],this.axisMoveEventDetail={axis:this.axis,changed:this.changedAxes},this.updateController=this.updateController.bind(this)},update:function(){this.updateController()},play:function(){var r=this.el.sceneEl;this.updateController(),r.addEventListener("controllersupdated",this.updateController)},pause:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.updateController)},isControllerPresent:function(r){return!(!this.controller||this.controller.gamepad||r.inputSource.handedness!=="none"&&r.inputSource.handedness!==this.data.hand)},updateController:function(){this.controller=nB(this.system.controllers,this.data.id,this.data.hand,this.data.controller,this.data.iterateControllerProfiles,this.data.handTrackingEnabled),this.el.components["tracked-controls"].controller=this.controller},tick:function(){var r=this.el.sceneEl,e=this.controller,n=r.frame;this.data.autoHide&&(this.el.object3D.visible=!!e),e&&r.frame&&this.system.referenceSpace&&(e.hand||(this.pose=n.getPose(e.gripSpace,this.system.referenceSpace),this.updatePose(),this.updateButtons()))},updatePose:function(){var r=this.el.object3D,e=this.pose;e&&(r.matrix.elements=e.transform.matrix,r.matrix.decompose(r.position,r.rotation,r.scale))},updateButtons:function(){var r,e,n,a=this.controller;if(a&&a.gamepad){for(n=a.gamepad,e=0;e<n.buttons.length;++e)this.buttonStates[e]||(this.buttonStates[e]={pressed:!1,touched:!1,value:0}),this.buttonEventDetails[e]||(this.buttonEventDetails[e]={id:e,state:this.buttonStates[e]}),r=n.buttons[e],this.handleButton(e,r);this.handleAxes()}},handleButton:function(r,e){return!!(this.handlePress(r,e)|this.handleTouch(r,e)|this.handleValue(r,e))&&(this.el.emit("buttonchanged",this.buttonEventDetails[r],!1),!0)},handleAxes:function(){var r,e=!1,n=this.controller.gamepad.axes,a=this.axis,c=this.changedAxes;for(this.changedAxes.splice(0,this.changedAxes.length),r=0;r<n.length;++r)c.push(a[r]!==n[r]),c[r]&&(e=!0);if(!e)return!1;for(this.axis.splice(0,this.axis.length),r=0;r<n.length;r++)this.axis.push(n[r]);return this.el.emit("axismove",this.axisMoveEventDetail,!1),!0},handlePress:function(r,e){var n,a=this.buttonStates[r];return e.pressed!==a.pressed&&(n=e.pressed?"buttondown":"buttonup",this.el.emit(n,this.buttonEventDetails[r],!1),a.pressed=e.pressed,!0)},handleTouch:function(r,e){var n,a=this.buttonStates[r];return e.touched!==a.touched&&(n=e.touched?"touchstart":"touchend",this.el.emit(n,this.buttonEventDetails[r],!1),a.touched=e.touched,!0)},handleValue:function(r,e){var n=this.buttonStates[r];return e.value!==n.value&&(n.value=e.value,!0)}}),kn("visible",{schema:{default:!0},update:function(){this.el.object3D.visible=this.data}}),ur+"controllers/valve/index/valve-index-"),Pbe={left:HU+"left.glb",right:HU+"right.glb"},XU="valve",zbe={left:{x:0,y:-.05,z:.06},right:{x:0,y:-.05,z:.06}},Vbe={left:{_x:Math.PI/3,_y:0,_z:0,_order:"XYZ"},right:{_x:Math.PI/3,_y:0,_z:0,_order:"XYZ"}},Wbe=(kn("valve-index-controls",{schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#FAFAFA"},buttonHighlightColor:{type:"color",default:"#22D1EE"},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{trackpad:[0,1],thumbstick:[2,3]},buttons:["trigger","grip","trackpad","thumbstick","abutton"]},init:function(){var r=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){qn(e.detail.id,"down",r)},this.onButtonUp=function(e){qn(e.detail.id,"up",r)},this.onButtonTouchEnd=function(e){qn(e.detail.id,"touchend",r)},this.onButtonTouchStart=function(e){qn(e.detail.id,"touchstart",r)},this.previousButtonValues={},this.bindMethods()},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("model-loaded",this.onModelLoaded),r.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("model-loaded",this.onModelLoaded),r.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var r=this.data,e=r.hand==="right"?0:r.hand==="left"?1:2;tl(this,XU,{index:e,iterateControllerProfiles:!0,hand:r.hand})},injectTrackedControls:function(){var r=this.el,e=this.data;r.setAttribute("tracked-controls",{idPrefix:XU,controller:e.hand==="right"?1:e.hand==="left"?0:2,hand:e.hand}),this.loadModel()},loadModel:function(){var r=this.data;r.model&&this.el.setAttribute("gltf-model",""+Pbe[r.hand])},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(r){var e,n=this.mapping.buttons[r.detail.id],a=this.buttonMeshes;n&&(n==="trigger"&&(e=r.detail.state.value,a&&a.trigger&&(a.trigger.rotation.x=this.triggerOriginalRotationX-e*(Math.PI/40))),this.el.emit(n+"changed",r.detail.state))},onModelLoaded:function(r){var e,n=r.detail.model,a=this;r.target===this.el&&this.data.model&&((e=this.buttonMeshes={}).grip={left:n.getObjectByName("leftgrip"),right:n.getObjectByName("rightgrip")},e.menu=n.getObjectByName("menubutton"),e.system=n.getObjectByName("systembutton"),e.trackpad=n.getObjectByName("touchpad"),e.trigger=n.getObjectByName("trigger"),this.triggerOriginalRotationX=e.trigger.rotation.x,Object.keys(e).forEach((function(c){a.setButtonColor(c,a.data.buttonColor)})),n.position.copy(Vbe[this.data.hand]),n.rotation.copy(zbe[this.data.hand]),this.el.emit("controllermodelready",{name:"valve-index-controls",model:this.data.model,rayOrigin:new X.Vector3(0,0,0)}))},onAxisMoved:function(r){Bl(this,this.mapping.axes,r)},updateModel:function(r,e){var n;this.data.model&&(e.indexOf("touch")!==-1||(n=e==="up"?this.data.buttonColor:this.data.buttonHighlightColor,this.setButtonColor(r,n)))},setButtonColor:function(r,e){}}),ur+"controllers/vive/vr_controller_vive.obj"),Hbe=ur+"controllers/vive/vr_controller_vive.mtl",QU="htc-vive",Xbe=(kn("vive-controls",{schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#FAFAFA"},buttonHighlightColor:{type:"color",default:"#22D1EE"},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1]},buttons:["trigger","grip","touchpad","none"]},init:function(){var r=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){qn(e.detail.id,"down",r)},this.onButtonUp=function(e){qn(e.detail.id,"up",r)},this.onButtonTouchEnd=function(e){qn(e.detail.id,"touchend",r)},this.onButtonTouchStart=function(e){qn(e.detail.id,"touchstart",r)},this.previousButtonValues={},this.bindMethods()},update:function(){var r=this.data;this.controllerIndex=r.hand==="right"?0:r.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("model-loaded",this.onModelLoaded),r.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("model-loaded",this.onModelLoaded),r.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var r=this.data;tl(this,QU,{index:this.controllerIndex,hand:r.hand})},injectTrackedControls:function(){var r=this.el,e=this.data;r.setAttribute("tracked-controls",{idPrefix:QU,hand:e.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("obj-model",{obj:Wbe,mtl:Hbe})},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(r){var e,n=this.mapping.buttons[r.detail.id],a=this.buttonMeshes;n&&(n==="trigger"&&(e=r.detail.state.value,a&&a.trigger&&(a.trigger.rotation.x=-e*(Math.PI/12))),this.el.emit(n+"changed",r.detail.state))},onModelLoaded:function(r){var e,n=r.detail.model,a=this;r.target===this.el&&this.data.model&&((e=this.buttonMeshes={}).grip={left:n.getObjectByName("leftgrip"),right:n.getObjectByName("rightgrip")},e.menu=n.getObjectByName("menubutton"),e.system=n.getObjectByName("systembutton"),e.trackpad=n.getObjectByName("touchpad"),e.touchpad=n.getObjectByName("touchpad"),e.trigger=n.getObjectByName("trigger"),Object.keys(e).forEach((function(c){a.setButtonColor(c,a.data.buttonColor)})),n.position.set(0,-.015,.04))},onAxisMoved:function(r){Bl(this,this.mapping.axes,r)},updateModel:function(r,e){var n;this.data.model&&(e.indexOf("touch")!==-1||(n=e==="up"?this.data.buttonColor:this.data.buttonHighlightColor,this.setButtonColor(r,n)))},setButtonColor:function(r,e){var n=this.buttonMeshes;if(n)return r==="grip"?(n.grip.left.material.color.set(e),void n.grip.right.material.color.set(e)):void n[r].material.color.set(e)}}),ur+"controllers/vive/focus-controller/focus-controller.gltf"),KU="htc-vive-focus",ZU=(kn("vive-focus-controls",{schema:{hand:{default:""},buttonTouchedColor:{type:"color",default:"#BBBBBB"},buttonHighlightColor:{type:"color",default:"#7A7A7A"},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1]},buttons:["trigger","none","touchpad","none","menu"]},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var r=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){qn(e.detail.id,"down",r)},this.onButtonUp=function(e){qn(e.detail.id,"up",r)},this.onButtonTouchStart=function(e){qn(e.detail.id,"touchstart",r)},this.onButtonTouchEnd=function(e){qn(e.detail.id,"touchend",r)},this.controllerPresent=!1,this.bindMethods()},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("model-loaded",this.onModelLoaded),r.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0,this.addControllersUpdateListener()},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("model-loaded",this.onModelLoaded),r.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1,this.removeControllersUpdateListener()},checkIfControllerPresent:function(){tl(this,KU,this.data.hand?{hand:this.data.hand}:{})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){this.el.setAttribute("tracked-controls",{idPrefix:KU}),this.data.model&&this.el.setAttribute("gltf-model",Xbe)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelLoaded:function(r){var e,n=r.detail.model;r.target===this.el&&this.data.model&&((e=this.buttonMeshes={}).trigger=n.getObjectByName("BumperKey"),e.triggerPressed=n.getObjectByName("BumperKey_Press"),e.triggerPressed&&(e.triggerPressed.visible=!1),e.touchpad=n.getObjectByName("TouchPad"),e.touchpadPressed=n.getObjectByName("TouchPad_Press"),e.trackpad=n.getObjectByName("TouchPad"),e.trackpadPressed=n.getObjectByName("TouchPad_Press"),e.trackpadPressed&&(e.trackpadPressed.visible=!1))},onButtonChanged:function(r){var e=this.mapping.buttons[r.detail.id];e&&this.el.emit(e+"changed",r.detail.state)},onAxisMoved:function(r){Bl(this,this.mapping.axes,r)},updateModel:function(r,e){this.data.model&&this.updateButtonModel(r,e)},updateButtonModel:function(r,e){var n=this.buttonMeshes,a=r+"Pressed";if(n&&n[r]&&n[a]){var c;switch(e){case"down":c=this.data.buttonHighlightColor;break;case"touchstart":c=this.data.buttonTouchedColor}c&&n[a].material.color.set(c),n[a].visible=!!c,n[r].visible=!c}}}),{38:"ArrowUp",37:"ArrowLeft",40:"ArrowDown",39:"ArrowRight",87:"KeyW",65:"KeyA",83:"KeyS",68:"KeyD"}),Qbe=aB,$U=1e-5,Kbe=["KeyW","KeyA","KeyS","KeyD","ArrowUp","ArrowLeft","ArrowRight","ArrowDown"];kn("wasd-controls",{schema:{acceleration:{default:65},adAxis:{default:"x",oneOf:["x","y","z"]},adEnabled:{default:!0},adInverted:{default:!1},enabled:{default:!0},fly:{default:!1},wsAxis:{default:"z",oneOf:["x","y","z"]},wsEnabled:{default:!0},wsInverted:{default:!1}},after:["look-controls"],init:function(){this.keys={},this.easing=1.1,this.velocity=new X.Vector3,this.onBlur=this.onBlur.bind(this),this.onContextMenu=this.onContextMenu.bind(this),this.onFocus=this.onFocus.bind(this),this.onKeyDown=this.onKeyDown.bind(this),this.onKeyUp=this.onKeyUp.bind(this),this.onVisibilityChange=this.onVisibilityChange.bind(this),this.attachVisibilityEventListeners()},tick:function(r,e){var n=this.data,a=this.el,c=this.velocity;(c[n.adAxis]||c[n.wsAxis]||!(function(h){var p;for(p in h)return!1;return!0})(this.keys))&&(e/=1e3,this.updateVelocity(e),(c[n.adAxis]||c[n.wsAxis])&&a.object3D.position.add(this.getMovementVector(e)))},update:function(r){r.adAxis!==this.data.adAxis&&(this.velocity[r.adAxis]=0),r.wsAxis!==this.data.wsAxis&&(this.velocity[r.wsAxis]=0)},remove:function(){this.removeKeyEventListeners(),this.removeVisibilityEventListeners()},play:function(){this.attachKeyEventListeners()},pause:function(){this.keys={},this.removeKeyEventListeners()},updateVelocity:function(r){var e,n,a,c,h,p=this.data,b=this.keys,y=this.velocity;if(n=p.adAxis,c=p.wsAxis,r>.2)return y[n]=0,void(y[c]=0);var w=Math.pow(1/this.easing,60*r);y[n]!==0&&(y[n]=y[n]*w),y[c]!==0&&(y[c]=y[c]*w),Math.abs(y[n])<$U&&(y[n]=0),Math.abs(y[c])<$U&&(y[c]=0),p.enabled&&(e=p.acceleration,p.adEnabled&&(a=p.adInverted?-1:1,(b.KeyA||b.ArrowLeft)&&(y[n]-=a*e*r),(b.KeyD||b.ArrowRight)&&(y[n]+=a*e*r)),p.wsEnabled&&(h=p.wsInverted?-1:1,(b.KeyW||b.ArrowUp)&&(y[c]-=h*e*r),(b.KeyS||b.ArrowDown)&&(y[c]+=h*e*r)))},getMovementVector:(U0=new X.Vector3(0,0,0),K_=new X.Euler(0,0,0,"YXZ"),function(r){var e,n=this.el.getAttribute("rotation"),a=this.velocity;return U0.copy(a),U0.multiplyScalar(r),n&&(e=this.data.fly?n.x:0,K_.set(X.MathUtils.degToRad(e),X.MathUtils.degToRad(n.y),0),U0.applyEuler(K_)),U0}),attachVisibilityEventListeners:function(){window.oncontextmenu=this.onContextMenu,window.addEventListener("blur",this.onBlur),window.addEventListener("focus",this.onFocus),document.addEventListener("visibilitychange",this.onVisibilityChange)},removeVisibilityEventListeners:function(){window.removeEventListener("blur",this.onBlur),window.removeEventListener("focus",this.onFocus),document.removeEventListener("visibilitychange",this.onVisibilityChange)},attachKeyEventListeners:function(){window.addEventListener("keydown",this.onKeyDown),window.addEventListener("keyup",this.onKeyUp)},removeKeyEventListeners:function(){window.removeEventListener("keydown",this.onKeyDown),window.removeEventListener("keyup",this.onKeyUp)},onContextMenu:function(){for(var r=Object.keys(this.keys),e=0;e<r.length;e++)delete this.keys[r[e]]},onBlur:function(){this.pause()},onFocus:function(){this.play()},onVisibilityChange:function(){document.hidden?this.onBlur():this.onFocus()},onKeyDown:function(r){var e;Qbe(r)&&(e=r.code||ZU[r.keyCode],Kbe.indexOf(e)!==-1&&(this.keys[e]=!0))},onKeyUp:function(r){var e;e=r.code||ZU[r.keyCode],delete this.keys[e]}});var Z_,jC,$y,Yy=$i("components:windows-motion-controls:debug"),P0=$i("components:windows-motion-controls:warn"),Zbe=ur+"controllers/microsoft/",YU={left:"left.glb",right:"right.glb",default:"universal.glb"},jU="windows-mixed-reality",z0=(kn("windows-motion-controls",{schema:{hand:{default:"right"},pair:{default:0},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1],thumbstick:[2,3]},buttons:["trigger","squeeze","touchpad","thumbstick","menu"],axisMeshNames:["TOUCHPAD_TOUCH_X","TOUCHPAD_TOUCH_X","THUMBSTICK_X","THUMBSTICK_Y"],buttonMeshNames:{trigger:"SELECT",menu:"MENU",squeeze:"GRASP",thumbstick:"THUMBSTICK_PRESS",touchpad:"TOUCHPAD_PRESS"},pointingPoseMeshName:"POINTING_POSE"},bindMethods:function(){this.onModelError=this.onModelError.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var r=this,e=this.el;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(n){qn(n.detail.id,"down",r)},this.onButtonUp=function(n){qn(n.detail.id,"up",r)},this.onButtonTouchStart=function(n){qn(n.detail.id,"touchstart",r)},this.onButtonTouchEnd=function(n){qn(n.detail.id,"touchend",r)},this.onControllerConnected=function(){r.setModelVisibility(!0)},this.onControllerDisconnected=function(){r.setModelVisibility(!1)},this.controllerPresent=!1,this.previousButtonValues={},this.bindMethods(),this.loadedMeshInfo={buttonMeshes:null,axisMeshes:null},this.rayOrigin={origin:new X.Vector3,direction:new X.Vector3(0,0,-1),createdFromMesh:!1},e.addEventListener("controllerconnected",this.onControllerConnected),e.addEventListener("controllerdisconnected",this.onControllerDisconnected)},addEventListeners:function(){var r=this.el;r.addEventListener("buttonchanged",this.onButtonChanged),r.addEventListener("buttondown",this.onButtonDown),r.addEventListener("buttonup",this.onButtonUp),r.addEventListener("touchstart",this.onButtonTouchStart),r.addEventListener("touchend",this.onButtonTouchEnd),r.addEventListener("axismove",this.onAxisMoved),r.addEventListener("model-error",this.onModelError),r.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var r=this.el;r.removeEventListener("buttonchanged",this.onButtonChanged),r.removeEventListener("buttondown",this.onButtonDown),r.removeEventListener("buttonup",this.onButtonUp),r.removeEventListener("touchstart",this.onButtonTouchStart),r.removeEventListener("touchend",this.onButtonTouchEnd),r.removeEventListener("axismove",this.onAxisMoved),r.removeEventListener("model-error",this.onModelError),r.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){tl(this,jU,{hand:this.data.hand,index:this.data.pair,iterateControllerProfiles:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},updateControllerModel:function(){if(this.data.model&&!this.rayOrigin.createdFromMesh){var r=this.createControllerModelUrl();this.loadModel(r)}else this.modelReady()},createControllerModelUrl:function(r){var e=this.data.hand;return Zbe+"default/"+(YU[e]||YU.default)},injectTrackedControls:function(){var r=this.data;this.el.setAttribute("tracked-controls",{idPrefix:jU,controller:r.pair,hand:r.hand}),this.updateControllerModel()},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelError:function(r){var e=this.createControllerModelUrl(!0);r.detail.src!==e?(P0("Failed to load controller model for device, attempting to load default."),this.loadModel(e)):P0("Failed to load default controller model.")},loadModel:function(r){this.el.setAttribute("gltf-model","url("+r+")")},onModelLoaded:function(r){var e,n,a,c,h=this.controllerModel=r.detail.model,p=this.loadedMeshInfo;if(r.target===this.el){if(Yy("Processing model"),p.buttonMeshes={},p.axisMeshes={},h){for(e=0;e<this.mapping.buttons.length;e++)(n=this.mapping.buttonMeshNames[this.mapping.buttons[e]])?(a=h.getObjectByName(n))?(c={index:e,value:b(a,"VALUE"),pressed:b(a,"PRESSED"),unpressed:b(a,"UNPRESSED")}).value&&c.pressed&&c.unpressed?p.buttonMeshes[this.mapping.buttons[e]]=c:P0("Missing button submesh under mesh with name: "+n+"(VALUE: "+!!c.value+", PRESSED: "+!!c.pressed+", UNPRESSED:"+!!c.unpressed+")"):P0("Missing button mesh with name: "+n):Yy("Skipping unknown button at index: "+e+" with mapped name: "+this.mapping.buttons[e]);for(e=0;e<this.mapping.axisMeshNames.length;e++)(n=this.mapping.axisMeshNames[e])?(a=h.getObjectByName(n))?(c={index:e,value:b(a,"VALUE"),min:b(a,"MIN"),max:b(a,"MAX")}).value&&c.min&&c.max?p.axisMeshes[e]=c:P0("Missing axis submesh under mesh with name: "+n+"(VALUE: "+!!c.value+", MIN: "+!!c.min+", MAX:"+!!c.max+")"):P0("Missing axis mesh with name: "+n):Yy("Skipping unknown axis at index: "+e);this.calculateRayOriginFromMesh(h),this.setModelVisibility()}Yy("Model load complete.")}function b(y,w){for(var I=0,E=y.children.length;I<E;I++){var R=y.children[I];if(R&&R.name===w)return R}}},calculateRayOriginFromMesh:(function(){var r=new X.Quaternion;return function(e){var n;if(this.rayOrigin.origin.set(0,0,0),this.rayOrigin.direction.set(0,0,-1),this.rayOrigin.createdFromMesh=!0,n=e.getObjectByName(this.mapping.pointingPoseMeshName)){var a=e.parent;a&&(e.parent=null,e.updateMatrixWorld(!0),e.parent=a),n.getWorldPosition(this.rayOrigin.origin),n.getWorldQuaternion(r),this.rayOrigin.direction.applyQuaternion(r),a&&e.updateMatrixWorld(!0)}else Yy("Mesh does not contain pointing origin data, defaulting to none.");this.modelReady()}})(),lerpAxisTransform:(function(){var r=new X.Quaternion;return function(e,n){var a=this.loadedMeshInfo.axisMeshes[e];if(a){var c=a.min,h=a.max,p=a.value,b=.5*n+.5;p.setRotationFromQuaternion(r.copy(c.quaternion).slerp(h.quaternion,b)),p.position.lerpVectors(c.position,h.position,b)}}})(),lerpButtonTransform:(function(){var r=new X.Quaternion;return function(e,n){var a=this.loadedMeshInfo.buttonMeshes[e];if(a){var c=a.unpressed,h=a.pressed,p=a.value;p.setRotationFromQuaternion(r.copy(c.quaternion).slerp(h.quaternion,n)),p.position.lerpVectors(c.position,h.position,n)}}})(),modelReady:function(){this.el.emit("controllermodelready",{name:"windows-motion-controls",model:this.data.model,rayOrigin:this.rayOrigin})},onButtonChanged:function(r){var e=this.mapping.buttons[r.detail.id];e&&(this.loadedMeshInfo&&this.loadedMeshInfo.buttonMeshes&&this.lerpButtonTransform(e,r.detail.state.value),this.el.emit(e+"changed",r.detail.state))},onAxisMoved:function(r){var e=this.mapping.axisMeshNames.length;if(this.loadedMeshInfo&&this.loadedMeshInfo.axisMeshes)for(var n=0;n<e;n++)this.lerpAxisTransform(n,r.detail.axis[n]||0);Bl(this,this.mapping.axes,r)},setModelVisibility:function(r){var e=this.el.getObject3D("mesh");this.controllerPresent&&(r=r!==void 0?r:this.modelVisible,this.modelVisible=r,e&&(e.visible=r))}}),Z_=new X.Quaternion,jC=new X.Vector3,function(r,e,n){e.position.copy(r.transform.position),e.quaternion.copy(r.transform.orientation),jC.copy(n),Z_.copy(r.transform.orientation),jC.applyQuaternion(Z_),e.position.sub(jC)});function xa(r,e){this.renderer=r,this.xrHitTestSource=null,r.xr.addEventListener("sessionend",(function(){this.xrHitTestSource=null}).bind(this)),r.xr.addEventListener("sessionstart",(function(){this.sessionStart(e)}).bind(this)),this.renderer.xr.isPresenting&&this.sessionStart(e)}function $_(r){console.warn(r.message),console.warn('Cannot requestHitTestSource Are you missing: webxr="optionalFeatures: hit-test;" from <a-scene>?')}z0.tempFakePose={transform:{orientation:new X.Quaternion,position:new X.Vector3}},xa.prototype.previousFrameAnchors=new Set,xa.prototype.anchorToObject3D=new Map,xa.prototype.sessionStart=function(r){this.session=this.renderer.xr.getSession(),"requestHitTestSource"in this.session?r.space?this.session.requestHitTestSource(r).then((function(e){this.xrHitTestSource=e}).bind(this)).catch($_):r.profile&&this.session.requestHitTestSourceForTransientInput(r).then((function(e){this.xrHitTestSource=e,this.transient=!0}).bind(this)).catch($_):$_({message:"No requestHitTestSource on the session."})},xa.prototype.anchorFromLastHitTestResult=function(r,e){var n=this.lastHitTest;if(n){var a={object3D:r,offset:e};Array.from(this.anchorToObject3D.entries()).forEach((function(c){var h=c[1].object3D,p=c[0];h===r&&(this.anchorToObject3D.delete(p),p.delete())}).bind(this)),n.createAnchor&&n.createAnchor().then((function(c){this.anchorToObject3D.set(c,a)}).bind(this)).catch((function(c){console.warn(c.message),console.warn('Cannot create anchor, are you missing: webxr="optionalFeatures: anchors;" from <a-scene>?')}))}},xa.prototype.doHit=function(r){if(this.renderer.xr.isPresenting){var e,n,a=this.renderer.xr.getReferenceSpace(),c=r.getViewerPose(a);return this.xrHitTestSource&&c?this.transient?(e=r.getHitTestResultsForTransientInput(this.xrHitTestSource)).length>0&&(n=e[0].results).length>0&&(this.lastHitTest=n[0],n[0].getPose(a)):(e=r.getHitTestResults(this.xrHitTestSource)).length>0&&(this.lastHitTest=e[0],e[0].getPose(a)):void 0}},xa.updateAnchorPoses=function(r,e){var n=r.trackedAnchors||xa.prototype.previousFrameAnchors;xa.prototype.previousFrameAnchors.forEach((function(a){n.has(a)||xa.prototype.anchorToObject3D.delete(a)})),n.forEach((function(a){var c,h,p,b;try{if(c=r.getPose(a.anchorSpace,e)){if(!(h=xa.prototype.anchorToObject3D.get(a)))return;p=h.offset,b=h.object3D,z0(c,b,p)}}catch(y){console.error("while updating anchor poses:",y)}})),xa.prototype.previousFrameAnchors=n},kn("ar-hit-test",{schema:{target:{type:"selector"},enabled:{default:!0},src:{default:"data:image/webp;base64,UklGRkQHAABXRUJQVlA4WAoAAAAQAAAA/wEA/wEAQUxQSL0DAAARDzD/ERGCjrY9sYYFfgo6aa1kJ7K0w9Lo3AadLSVeFxevQwj5kuM8RfR/Atw/C0+ozB/oUBrloFZs6ElSW88j1KA4yExNWQaqRZquIDF0JYmlq0hAuUDTFu66tng3teW7pa3cQf1V1edvur54M/Slm6Wv3Gx9zw0MXlQLntcsBN6wkHjTQuYtC4W3LTw8mGRVG57TbAROtxHfZNhInGkjc5aNwtk2Hg6Mvki14k+NkZzCwQgCxalcAv3kddRTPI1DcUrXId1FLf1uHpzaQz4tquhZVLlKesbVpqKeTj0n0F5PpXDlFN9UqmhalL/ImuZFo6KmToWLoKlddMprqlS8cKovBvHo2kTiFV2LN4msaxKZl3QNiair8xYRdDWivIvXVXmbcMqJ51UebZuFXxZt6xd4laxtciqRtA3Cv0nU1t+kEUFbI8JvCa+tvkm3FDlO/W+OR99+kWEp/YYo+tYfTVnf/K8cE/F///3vv//993eeL+a+uvjawLcX3xjYvJotBFY3kVjTRGFtE+BU2AiMbiQyhpHMWEYeBozAH5qNBYRDB5KBCaTDBKKBAZTDBoKBDjwHAN5ABeCJBsAZcAAC0YHHxAYSMYBiYgGZWEA2MYFCbCCZGAAIANFEB+AnYgMQTDQAYSJ2AN5EBZAm4gDgTDgAeSIu4DGygTIRN1CMLOCZiACykQlg4jsAycgA8AO+BxCNdJyDkcbwRirDGXGnx8w+FDPrkM3MQ9JQZMYhiiwV/RDMtIM3U1/DmXHUo+IR2kSR2ToWkQ1NIn2qf2J8LCqJKiDUiSADHY3whirhdHgZ94HKaR97PhE+twEUJUFoAcgyTct8hfSxSkShASDKdMJ/ritKHwgyQ0sD4D/miCxU5SbhOOUDTnZpccCjYP/i0bZ/8bAgtVGEoGapWIQXyzKVKLwgNJFk2rtMIgoNRJlOZF7SNSSyUEeQmbxBFKEmtYjEe8S8zOZ1AkJVCmS88FJOtF40Ksg4oUaFiygk3C8qlTVNyl8UTevCUdAE2t14PfVqU1FPp57TopKeQZWromddTQp6QOfTOEQt/ZDuipZ11w/wOiqO8dRORcc6BQEkDQMClaHcn5wV9yLbxsNZNgpn2sicYSNxuo34Js1G4FQbnuNsOPa28PCWhcKbFjJvWEi8ZiHwqgXPcxbc5db33Cx95WboSzddX7yp+vyN0+eul7ZyN7Xlu64t3jVt4c5pc4JLV5EYupJE0xUknC4nOjVlmaYpyLit53HCQ0+ScnqceNcS5dzUkd0/CwMAVlA4IGADAAAQXwCdASoAAgACP8ne6Wy/tjCpqJ/IA/A5CWlu4XYBG/Pz8AfwD8APz//f3v8E1fuHZnxKYACtfuHZnxKYACrYTb5mOslhxu843ecbvON3nG7zjd3a0VCn7G1MABVxwH/Xd25gAK1+4dmfEpe2+PHhQaj75++riG6FuYACtfuHZnxKYACRrK3q9xO8Ss3uWKnMhs/rDF1hi6wxdYYusMXWGI5QRcCFDZog5OgqNlse1NDuz/UoFa/cOzPiUwAEsAOK4/nu5eZHK2tlXxJfNYlMABWv3Dsz4bvNJ5YA/LtxJ38SmAArX7h2Z8Sk5vdZUYv7mZPiUwAFa/cOzPh21s5OgZxf1mfEpemRyFr/rM+JS9noA/LtxJ38SmAAlUJIotzAASn6TjdhK+D3Dsz4dyvB7h2Z8O2tnJ0DOL+sz4lL2nKLT4lL/+iSLOocxq639w7M34MNZdm55uJ8v8ra2cpVZnxKTq2F3PN/cNksAfl24k7+JTAASqrD37h2Z7b1W+VtbOUqsz4lJ1bC7nm/uGyWAPy7cSd/EpgAJVVh79w7M9t6rfK2tnKVWZ8Sk6thdzzf3DZLAH5duJO/iUwAEqqw9+4dme29VvlbWzlKrM+JSdWwu55v7hslgD8u3EnfxKYACVVYe/cOzPbeq3ytrZylVme0kYJ8557FLerqFrzIbPrrf3DZLAH5duJO/iUvaVMS9BoaF4p7pSDFTP1XMyfElelrM0DOL+sz4eBJ13nV1OppBGPuKb4YzXQgq9uH19uS/0+JS9t9fr6ZUlQBelDG6GMgq97otb5QMPJwtKyBTbFp8Sl7b6/X0ykkawEOsgdiE6Fi0vb/Eve6xkwsmug0Z4nGNHQO8839bpTsjpz7SWIJxKagvd1QWMa6FYT1KEw3j4XDT6vJ9Xk+nyfT5Pq8n1eEmk5dinMM/9Fcfz4Z3Dsz3KD2dw7LxBRxKrqUUGQPH/7zxr1KIfNpLEJ0MZB2ITM/0Z2EFoh12NlXnEcpYcbvON3nG7zjd5xu84vfcNIAAP7+y8ceyzbVxkakPYY4lcr72fqOnDwipv+yxC71wAADBrjKnAAAAAAAAAAAAAAw7oNGHttqWONcoFN/2WIDc2pa6WVFtFYROlsaMaTXdcOjXHz93+YxAglKa4AAAAA=",type:"map"},type:{default:"footprint",oneOf:["footprint","map"]},footprintDepth:{default:.1},mapSize:{type:"vec2",default:{x:.5,y:.5}}},sceneOnly:!0,init:function(){this.hitTest=null,this.imageDataArray=new Uint8ClampedArray(1048576),this.imageData=new ImageData(this.imageDataArray,512,512),this.textureCache=new Map,this.orthoCam=new X.OrthographicCamera,this.orthoCam.layers.set(21),this.textureTarget=new X.WebGLRenderTarget(512,512,{}),this.basicMaterial=new X.MeshBasicMaterial({color:0,side:X.DoubleSide}),this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.context.imageSmoothingEnabled=!1,this.canvas.width=512,this.canvas.height=512,this.canvasTexture=new X.CanvasTexture(this.canvas,{alpha:!0}),this.canvasTexture.flipY=!1;var r=this.el.getAttribute("webxr"),e=r.optionalFeatures;e.includes("hit-test")&&e.includes("anchors")||(e.push("hit-test"),e.push("anchors"),this.el.setAttribute("webxr",r)),this.el.sceneEl.renderer.xr.addEventListener("sessionend",(function(){this.hitTest=null}).bind(this)),this.el.sceneEl.addEventListener("enter-vr",(function(){if(this.el.is("ar-mode")){var n=this.el.sceneEl.renderer,a=this.session=n.xr.getSession();this.hasPosedOnce=!1,this.bboxMesh.visible=!1,$y||($y=new Map),a.requestReferenceSpace("viewer").then((function(b){this.viewerHitTest=this.hitTest=new xa(n,{space:b}),this.el.emit("ar-hit-test-start")}).bind(this));var c=this;this.el.sceneEl.addEventListener("controllersupdated",(function(){var b=this.xrSession&&this.xrSession.inputSources;if(b){for(var y=0;y<b.length;++y)if(b[y].targetRayMode==="tracked-pointer"){c.hitTest=new xa(n,{space:b[y].targetRaySpace}),$y.set(b[y],c.hitTest),c.viewerHitTest&&typeof c.viewerHitTest.cancel=="function"&&(c.viewerHitTest.cancel(),c.viewerHitTest=null);break}}}));var h="generic-touchscreen",p=new xa(n,{profile:h});a.addEventListener("selectstart",(function(b){if(this.data.enabled===!0){var y=b.inputSource;this.bboxMesh.visible=!0,this.hasPosedOnce===!0&&(this.el.emit("ar-hit-test-select-start",{inputSource:y,position:this.bboxMesh.position,orientation:this.bboxMesh.quaternion}),y.profiles[0]===h?this.hitTest=p:(this.hitTest=$y.get(y)||new xa(n,{space:y.targetRaySpace}),$y.set(y,this.hitTest)))}}).bind(this)),a.addEventListener("selectend",(function(b){if(this.hitTest&&this.data.enabled===!0){var y,w=b.inputSource;this.hasPosedOnce===!0&&(this.bboxMesh.visible=!1,this.data.target&&(y=this.data.target.object3D)&&(z0.tempFakePose.transform.position.copy(this.bboxMesh.position),z0.tempFakePose.transform.orientation.copy(this.bboxMesh.quaternion),z0(z0.tempFakePose,y,this.bboxOffset),y.visible=!0,this.hitTest.anchorFromLastHitTestResult(y,this.bboxOffset)),this.el.emit("ar-hit-test-select",{inputSource:w,position:this.bboxMesh.position,orientation:this.bboxMesh.quaternion}),this.hitTest=null)}else this.hitTest=null}).bind(this))}}).bind(this)),this.bboxOffset=new X.Vector3,this.update=this.update.bind(this),this.makeBBox()},update:function(){this.data.enabled===!1&&(this.hitTest=null,this.bboxMesh.visible=!1),this.data.target&&(this.data.target.object3D?(this.data.target.addEventListener("model-loaded",this.update),this.data.target.object3D.layers.enable(21),this.data.target.object3D.traverse((function(r){r.layers.enable(21)}))):this.data.target.addEventListener("loaded",this.update,{once:!0})),this.bboxNeedsUpdate=!0},makeBBox:function(){var r=new X.PlaneGeometry(1,1),e=new X.MeshBasicMaterial({transparent:!0,color:16777215});r.rotateX(-Math.PI/2),r.rotateY(-Math.PI/2),this.bbox=new X.Box3,this.bboxMesh=new X.Mesh(r,e),this.el.setObject3D("ar-hit-test",this.bboxMesh),this.bboxMesh.visible=!1},updateFootprint:function(){var r,e,n,a=this.el.sceneEl.renderer,c=a.xr.enabled;this.bboxMesh.material.map=this.canvasTexture,this.bboxMesh.material.needsUpdate=!0,this.orthoCam.rotation.set(-Math.PI/2,0,-Math.PI/2),this.orthoCam.position.copy(this.bboxMesh.position),this.orthoCam.position.y-=this.bboxMesh.scale.y/2,this.orthoCam.near=.1,this.orthoCam.far=this.orthoCam.near+this.data.footprintDepth*this.bboxMesh.scale.y,this.orthoCam.position.y+=this.orthoCam.far,this.orthoCam.right=this.bboxMesh.scale.z/2,this.orthoCam.left=-this.bboxMesh.scale.z/2,this.orthoCam.top=this.bboxMesh.scale.x/2,this.orthoCam.bottom=-this.bboxMesh.scale.x/2,this.orthoCam.updateProjectionMatrix(),e=a.getRenderTarget(),a.setRenderTarget(this.textureTarget),a.xr.enabled=!1,n=this.el.object3D.background,this.el.object3D.overrideMaterial=this.basicMaterial,this.el.object3D.background=null,a.render(this.el.object3D,this.orthoCam),this.el.object3D.background=n,this.el.object3D.overrideMaterial=null,a.xr.enabled=c,a.setRenderTarget(e),a.readRenderTargetPixels(this.textureTarget,0,0,512,512,this.imageDataArray),this.context.putImageData(this.imageData,0,0),this.context.shadowColor="white",this.context.shadowBlur=10,this.context.drawImage(this.canvas,0,0),r=this.context.getImageData(0,0,512,512);for(var h=0;h<262144;h++)r.data[4*h+3]!==0&&r.data[4*h+3]!==255&&(r.data[4*h+3]=128);this.context.putImageData(r,0,0),this.canvasTexture.needsUpdate=!0},tick:function(){var r,e,n=this.el.sceneEl.frame,a=this.el.sceneEl.renderer;n&&xa.updateAnchorPoses(n,a.xr.getReferenceSpace()),this.bboxNeedsUpdate&&(this.bboxNeedsUpdate=!1,this.data.target&&this.data.type!=="map"||(this.textureCache.has(this.data.src)?e=this.textureCache.get(this.data.src):(e=new X.TextureLoader().load(this.data.src),this.textureCache.set(this.data.src,e)),this.bboxMesh.material.map=e,this.bboxMesh.material.needsUpdate=!0),this.data.target&&this.data.target.object3D?(this.bbox.setFromObject(this.data.target.object3D),this.bbox.getCenter(this.bboxMesh.position),this.bbox.getSize(this.bboxMesh.scale),this.data.type==="footprint"&&(this.bboxMesh.scale.x*=1.04,this.bboxMesh.scale.z*=1.04,this.updateFootprint()),this.bboxMesh.position.y-=this.bboxMesh.scale.y/2,this.bboxOffset.copy(this.bboxMesh.position),this.bboxOffset.sub(this.data.target.object3D.position)):this.bboxMesh.scale.set(this.data.mapSize.x,1,this.data.mapSize.y)),this.hitTest&&(r=this.hitTest.doHit(n))&&(this.hasPosedOnce!==!0&&(this.hasPosedOnce=!0,this.el.emit("ar-hit-test-achieved")),this.bboxMesh.visible=!0,this.bboxMesh.position.copy(r.transform.position),this.bboxMesh.quaternion.copy(r.transform.orientation))}}),kn("background",{schema:{color:{type:"color",default:"black"},transparent:{default:!1}},sceneOnly:!0,update:function(){var r=this.data,e=this.el.object3D;r.transparent?e.background=null:e.background=new X.Color(r.color)},remove:function(){this.el.object3D.background=null}}),kn("debug",{schema:{default:!0},sceneOnly:!0});var qU="a-dialog-buttons-container",Y_="a-dialog-button";function JU(r,e){var n,a,c,h;return(n=document.createElement("div")).classList.add("a-modal"),n.setAttribute(ta,""),(a=document.createElement("div")).className="a-dialog",a.setAttribute(ta,""),n.appendChild(a),(c=document.createElement("div")).classList.add("a-dialog-text-container"),a.appendChild(c),(h=document.createElement("div")).classList.add("a-dialog-text"),h.innerHTML=r,c.appendChild(h),a.appendChild(e),n}kn("device-orientation-permission-ui",{schema:{enabled:{default:!0},deviceMotionMessage:{default:"This immersive website requires access to your device motion sensors."},httpsMessage:{default:"Access this site over HTTPS to enter VR mode and grant access to the device sensors."},denyButtonText:{default:"Deny"},allowButtonText:{default:"Allow"},cancelButtonText:{default:"Cancel"}},sceneOnly:!0,init:function(){var r=this;this.data.enabled&&(window.isSecureContext||this.showHTTPAlert(),typeof DeviceOrientationEvent<"u"&&DeviceOrientationEvent.requestPermission?(this.onDeviceMotionDialogAllowClicked=this.onDeviceMotionDialogAllowClicked.bind(this),this.onDeviceMotionDialogDenyClicked=this.onDeviceMotionDialogDenyClicked.bind(this),DeviceOrientationEvent.requestPermission().then((function(){r.el.emit("deviceorientationpermissiongranted"),r.permissionGranted=!0})).catch((function(){var e,n,a,c,h,p,b,y;r.devicePermissionDialogEl=(e=r.data.denyButtonText,n=r.data.allowButtonText,a=r.data.deviceMotionMessage,c=r.onDeviceMotionDialogAllowClicked,h=r.onDeviceMotionDialogDenyClicked,(p=document.createElement("div")).classList.add(qU),(b=document.createElement("button")).classList.add(Y_,"a-dialog-deny-button"),b.setAttribute(ta,""),b.innerHTML=e,p.appendChild(b),(y=document.createElement("button")).classList.add(Y_,"a-dialog-allow-button"),y.setAttribute(ta,""),y.innerHTML=n,p.appendChild(y),y.addEventListener("click",(function(w){w.stopPropagation(),c()})),b.addEventListener("click",(function(w){w.stopPropagation(),h()})),JU(a,p)),r.el.appendChild(r.devicePermissionDialogEl)}))):this.permissionGranted=!0)},remove:function(){this.devicePermissionDialogEl&&this.el.removeChild(this.devicePermissionDialogEl)},onDeviceMotionDialogDenyClicked:function(){this.remove()},showHTTPAlert:function(){var r,e,n,a,c,h=this,p=(r=h.data.cancelButtonText,e=h.data.httpsMessage,n=function(){h.el.removeChild(p)},(a=document.createElement("div")).classList.add(qU),(c=document.createElement("button")).classList.add(Y_,"a-dialog-ok-button"),c.setAttribute(ta,""),c.innerHTML=r,a.appendChild(c),c.addEventListener("click",(function(b){b.stopPropagation(),n()})),JU(e,a));this.el.appendChild(p)},onDeviceMotionDialogAllowClicked:function(){var r=this;this.el.emit("deviceorientationpermissionrequested"),DeviceOrientationEvent.requestPermission().then((function(e){e==="granted"?(r.el.emit("deviceorientationpermissiongranted"),r.permissionGranted=!0):r.el.emit("deviceorientationpermissionrejected"),r.remove()})).catch(console.error)}}),kn("embedded",{dependencies:["xr-mode-ui"],schema:{default:!0},sceneOnly:!0,update:function(){var r=this.el,e=r.querySelector(".a-enter-vr");this.data===!0?(e&&e.classList.add("embedded"),r.removeFullScreenStyles()):(e&&e.classList.remove("embedded"),r.addFullScreenStyles())}});var $be="https://unpkg.com/aframe-inspector@"+(function(){var r=LW.split(".");return r[2]="x",r.join(".")})()+"/dist/aframe-inspector.min.js";kn("inspector",{schema:{url:{default:$be}},sceneOnly:!0,init:function(){this.firstPlay=!0,this.onKeydown=this.onKeydown.bind(this),this.onMessage=this.onMessage.bind(this),this.initOverlay(),window.addEventListener("keydown",this.onKeydown),window.addEventListener("message",this.onMessage)},play:function(){var r;this.firstPlay&&(r=Dv("inspector"))!=="false"&&r&&(this.openInspector(),this.firstPlay=!1)},initOverlay:function(){this.loadingMessageEl=document.createElement("div"),this.loadingMessageEl.classList.add("a-inspector-loader"),this.loadingMessageEl.innerHTML='Loading Inspector<span class="dots"><span>.</span><span>.</span><span>.</span></span>'},remove:function(){this.removeEventListeners()},onKeydown:function(r){r.keyCode===73&&(r.ctrlKey&&r.altKey||r.getModifierState("AltGraph"))&&this.openInspector()},showLoader:function(){document.body.appendChild(this.loadingMessageEl)},hideLoader:function(){document.body.removeChild(this.loadingMessageEl)},onMessage:function(r){r.data==="INJECT_AFRAME_INSPECTOR"&&this.openInspector()},openInspector:function(r){var e,n=this;AFRAME.INSPECTOR||AFRAME.inspectorInjected?AFRAME.INSPECTOR.open(r):(this.showLoader(),(e=document.createElement("script")).src=this.data.url,e.setAttribute("data-name","aframe-inspector"),e.setAttribute(ta,""),e.onload=function(){AFRAME.INSPECTOR.open(r),n.hideLoader(),n.removeEventListeners()},e.onerror=function(){n.loadingMessageEl.innerHTML="Error loading Inspector"},document.head.appendChild(e),AFRAME.inspectorInjected=!0)},removeEventListeners:function(){window.removeEventListener("keydown",this.onKeydown),window.removeEventListener("message",this.onMessage)}}),kn("fog",{schema:{color:{type:"color",default:"#000"},density:{default:25e-5},far:{default:1e3,min:0},near:{default:1,min:0},type:{default:"linear",oneOf:["linear","exponential"]}},sceneOnly:!0,update:function(){var r=this.data,e=this.el,n=this.el.object3D.fog;n&&r.type===n.name?Object.keys(this.schema).forEach((function(a){var c=r[a];a==="color"&&(c=new X.Color(c)),n[a]=c})):e.object3D.fog=(function(a){var c;return(c=a.type==="exponential"?new X.FogExp2(a.color,a.density):new X.Fog(a.color,a.near,a.far)).name=a.type,c})(r)},remove:function(){var r=this.el;this.el.object3D.fog&&(r.object3D.fog=null)}}),kn("keyboard-shortcuts",{schema:{enterVR:{default:!0},exitVR:{default:!0}},sceneOnly:!0,init:function(){this.onKeyup=this.onKeyup.bind(this)},play:function(){window.addEventListener("keyup",this.onKeyup,!1)},pause:function(){window.removeEventListener("keyup",this.onKeyup)},onKeyup:function(r){var e=this.el;aB(r)&&(this.data.enterVR&&r.keyCode===70&&e.enterVR(),this.data.exitVR&&r.keyCode===27&&e.exitVR())}});var jy=$i("components:pool:warn");kn("pool",{schema:{container:{default:""},mixin:{default:""},size:{default:0},dynamic:{default:!1}},sceneOnly:!0,multiple:!0,initPool:function(){var r;for(this.availableEls=[],this.usedEls=[],this.data.mixin||jy("No mixin provided for pool component."),this.data.container&&(this.container=document.querySelector(this.data.container),this.container||jy("Container "+this.data.container+" not found.")),this.container=this.container||this.el,r=0;r<this.data.size;++r)this.createEntity()},update:function(r){var e=this.data;r.mixin===e.mixin&&r.size===e.size||this.initPool()},createEntity:function(){var r;(r=document.createElement("a-entity")).play=this.wrapPlay(r.play),r.setAttribute("mixin",this.data.mixin),r.object3D.visible=!1,r.pause(),this.container.appendChild(r),this.availableEls.push(r);var e=this.usedEls;r.addEventListener("loaded",(function(){e.indexOf(r)===-1&&(r.object3DParent=r.object3D.parent,r.object3D.parent.remove(r.object3D))}))},wrapPlay:function(r){var e=this.usedEls;return function(){e.indexOf(this)!==-1&&r.call(this)}},requestEntity:function(){var r;if(this.availableEls.length===0){if(this.data.dynamic===!1)return void jy("Requested entity from empty pool: "+this.attrName);jy("Requested entity from empty pool. This pool is dynamic and will resize automatically. You might want to increase its initial size: "+this.attrName),this.createEntity()}return r=this.availableEls.shift(),this.usedEls.push(r),r.object3DParent&&(r.object3DParent.add(r.object3D),this.updateRaycasters()),r.object3D.visible=!0,r},returnEntity:function(r){var e=this.usedEls.indexOf(r);if(e!==-1)return this.usedEls.splice(e,1),this.availableEls.push(r),r.object3DParent=r.object3D.parent,r.object3D.parent.remove(r.object3D),this.updateRaycasters(),r.object3D.visible=!1,r.pause(),r;jy("The returned entity was not previously pooled from "+this.attrName)},updateRaycasters:function(){document.querySelectorAll("[raycaster]").forEach((function(r){r.components.raycaster.setDirty()}))}}),kn("real-world-meshing",{schema:{filterLabels:{type:"array"},meshesEnabled:{default:!0},meshMixin:{default:!0},planesEnabled:{default:!0},planeMixin:{default:""}},sceneOnly:!0,init:function(){var r=this.el.getAttribute("webxr"),e=r.requiredFeatures;e.indexOf("mesh-detection")===-1&&(e.push("mesh-detection"),this.el.setAttribute("webxr",r)),e.indexOf("plane-detection")===-1&&(e.push("plane-detection"),this.el.setAttribute("webxr",r)),this.meshEntities=[],this.initWorldMeshEntity=this.initWorldMeshEntity.bind(this)},tick:function(){this.el.is("ar-mode")&&(this.detectMeshes(),this.updateMeshes())},detectMeshes:function(){var r,e,n,a=this.data,c=this.el,h=this.meshEntities,p=!1,b=[],y=this.data.filterLabels;r=(n=c.frame).detectedMeshes,e=n.detectedPlanes;for(var w=0;w<h.length;w++)h[w].present=!1;if(a.meshesEnabled){for(var I of r.values())if(!y.length||y.indexOf(I.semanticLabel)!==-1){for(w=0;w<h.length;w++)if(I===h[w].mesh){p=!0,h[w].present=!0,h[w].lastChangedTime<I.lastChangedTime&&this.updateMeshGeometry(h[w].el,I),h[w].lastChangedTime=I.lastChangedTime;break}p||b.push(I),p=!1}}if(a.planesEnabled){for(I of e.values())if(!y.length||y.indexOf(I.semanticLabel)!==-1){for(w=0;w<h.length;w++)if(I===h[w].mesh){p=!0,h[w].present=!0,h[w].lastChangedTime<I.lastChangedTime&&this.updateMeshGeometry(h[w].el,I),h[w].lastChangedTime=I.lastChangedTime;break}p||b.push(I),p=!1}}this.deleteMeshes(),this.createNewMeshes(b)},updateMeshes:(function(){var r=new X.Matrix4;return function(){for(var e,n,a,c=this.el,h=c.frame,p=this.meshEntities,b=c.renderer.xr.getReferenceSpace(),y=0;y<p.length;y++)a=p[y].mesh.meshSpace||p[y].mesh.planeSpace,e=h.getPose(a,b),(n=p[y].el).hasLoaded&&(r.fromArray(e.transform.matrix),r.decompose(n.object3D.position,n.object3D.quaternion,n.object3D.scale))}})(),deleteMeshes:function(){for(var r=this.meshEntities,e=[],n=0;n<r.length;n++)r[n].present?e.push(r[n]):this.el.removeChild(r[n]);this.meshEntities=e},createNewMeshes:function(r){for(var e,n=0;n<r.length;n++)e=document.createElement("a-entity"),this.meshEntities.push({mesh:r[n],el:e}),e.addEventListener("loaded",this.initWorldMeshEntity),this.el.appendChild(e)},initMeshGeometry:function(r){var e,n,a;if(r instanceof XRPlane){n=new X.Shape,a=r.polygon;for(var c=0;c<a.length;++c)c===0?n.moveTo(a[c].x,a[c].z):n.lineTo(a[c].x,a[c].z);return(e=new X.ShapeGeometry(n)).rotateX(Math.PI/2),e}return(e=new X.BufferGeometry).setAttribute("position",new X.BufferAttribute(r.vertices,3)),e.setIndex(new X.BufferAttribute(r.indices,1)),e},initWorldMeshEntity:function(r){for(var e,n,a,c=r.target,h=this.meshEntities,p=0;p<h.length;p++)if(h[p].el===c){a=h[p];break}e=this.initMeshGeometry(a.mesh),n=new X.Mesh(e,new X.MeshBasicMaterial({color:16777215*Math.random(),side:X.DoubleSide})),c.setObject3D("mesh",n),a.mesh instanceof XRPlane&&this.data.planeMixin?c.setAttribute("mixin",this.data.planeMixin):this.data.meshMixin&&c.setAttribute("mixin",this.data.meshMixin),c.setAttribute("data-world-mesh",a.mesh.semanticLabel)},updateMeshGeometry:function(r,e){var n=r.getObject3D("mesh");n.geometry.dispose(),n.geometry=this.initMeshGeometry(e)}}),kn("reflection",{schema:{directionalLight:{type:"selector"}},sceneOnly:!0,init:function(){var r=this;this.cubeRenderTarget=new X.WebGLCubeRenderTarget(16),this.cubeCamera=new X.CubeCamera(.1,1e3,this.cubeRenderTarget),this.lightingEstimationTexture=new X.WebGLCubeRenderTarget(16).texture,this.needsVREnvironmentUpdate=!0;var e=this.el.getAttribute("webxr"),n=e.optionalFeatures;n.includes("light-estimation")||(n.push("light-estimation"),this.el.setAttribute("webxr",e)),this.el.addEventListener("enter-vr",(function(){r.el.is("ar-mode")&&r.el.renderer.xr.getSession().requestLightProbe&&r.startLightProbe()})),this.el.addEventListener("exit-vr",(function(){r.xrLightProbe&&r.stopLightProbe()})),this.el.object3D.environment=this.cubeRenderTarget.texture},stopLightProbe:function(){this.xrLightProbe=null,this.probeLight&&(this.probeLight.components.light.light.intensity=0),this.needsVREnvironmentUpdate=!0,this.el.object3D.environment=this.cubeRenderTarget.texture},startLightProbe:function(){this.needsLightProbeUpdate=!0},setupLightProbe:function(){var r=this.el.renderer,e=r.xr.getSession(),n=this,a=r.getContext();if(!this.probeLight){var c=document.createElement("a-light");c.setAttribute("type","probe"),c.setAttribute("intensity",0),this.el.appendChild(c),this.probeLight=c}switch(e.preferredReflectionFormat){case"srgba8":a.getExtension("EXT_sRGB");break;case"rgba16f":a.getExtension("OES_texture_half_float")}this.glBinding=new XRWebGLBinding(e,a),a.getExtension("EXT_sRGB"),a.getExtension("OES_texture_half_float"),e.requestLightProbe().then((function(h){n.xrLightProbe=h,h.addEventListener("reflectionchange",n.updateXRCubeMap.bind(n))})).catch((function(h){console.warn("Lighting estimation not supported: "+h.message),console.warn('Are you missing: webxr="optionalFeatures: light-estimation;" from <a-scene>?')}))},updateXRCubeMap:function(){var r=this.el.renderer,e=this.glBinding.getReflectionCubeMap(this.xrLightProbe);e&&(r.properties.get(this.lightingEstimationTexture).__webglTexture=e,this.lightingEstimationTexture.needsPMREMUpdate=!0,this.el.object3D.environment=this.lightingEstimationTexture)},tick:function(){var r=this.el.object3D,e=this.el.renderer,n=this.el.frame;if(n&&this.xrLightProbe){var a=n.getLightEstimate(this.xrLightProbe);a&&(function(c,h,p,b){var y=Math.max(c.primaryLightIntensity.x,Math.max(c.primaryLightIntensity.y,c.primaryLightIntensity.z));h.sh.fromArray(c.sphericalHarmonicsCoefficients),h.intensity=3.14,p&&(p.color.setRGB(c.primaryLightIntensity.x/y,c.primaryLightIntensity.y/y,c.primaryLightIntensity.z/y),p.intensity=y,b.copy(c.primaryLightDirection))})(a,this.probeLight.components.light.light,this.data.directionalLight&&this.data.directionalLight.components.light.light,this.data.directionalLight&&this.data.directionalLight.object3D.position)}this.needsVREnvironmentUpdate&&(r.environment=null,this.needsVREnvironmentUpdate=!1,this.cubeCamera.position.set(0,1.6,0),this.cubeCamera.update(e,r),r.environment=this.cubeRenderTarget.texture),this.needsLightProbeUpdate&&n&&(this.setupLightProbe(),this.needsLightProbeUpdate=!1)},remove:function(){this.el.object3D.environment=null,this.probeLight&&this.el.removeChild(this.probeLight)}});var Ybe=["attribute vec3 position;","attribute vec2 uv;","uniform mat4 projectionMatrix;","uniform mat4 modelViewMatrix;","varying vec2 vUv;","void main()  {","  vUv = vec2( 1.- uv.x, uv.y );","  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join(`
`),jbe=["precision mediump float;","uniform samplerCube map;","varying vec2 vUv;","#define M_PI 3.141592653589793238462643383279","void main() {","  vec2 uv = vUv;","  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;","  float latitude = uv.y * M_PI;","  vec3 dir = vec3(","    - sin( longitude ) * sin( latitude ),","    cos( latitude ),","    - cos( longitude ) * sin( latitude )","  );","  normalize( dir );","  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );","}"].join(`
`),qbe=(kn("screenshot",{schema:{width:{default:4096},height:{default:2048},camera:{type:"selector"}},sceneOnly:!0,setup:function(){var r=this.el;if(!this.canvas){var e=r.renderer.getContext();e&&(this.cubeMapSize=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),this.material=new X.RawShaderMaterial({uniforms:{map:{type:"t",value:null}},vertexShader:Ybe,fragmentShader:jbe,side:X.DoubleSide}),this.quad=new X.Mesh(new X.PlaneGeometry(1,1),this.material),this.quad.visible=!1,this.camera=new X.OrthographicCamera(-.5,.5,.5,-.5,-1e4,1e4),this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d"),r.object3D.add(this.quad),this.onKeyDown=this.onKeyDown.bind(this))}},getRenderTarget:function(r,e){return new X.WebGLRenderTarget(r,e,{colorSpace:this.el.sceneEl.renderer.outputColorSpace,minFilter:X.LinearFilter,magFilter:X.LinearFilter,wrapS:X.ClampToEdgeWrapping,wrapT:X.ClampToEdgeWrapping,format:X.RGBAFormat,type:X.UnsignedByteType})},resize:function(r,e){this.quad.scale.set(r,e,1),this.camera.left=-1*r/2,this.camera.right=r/2,this.camera.top=e/2,this.camera.bottom=-1*e/2,this.camera.updateProjectionMatrix(),this.canvas.width=r,this.canvas.height=e},play:function(){window.addEventListener("keydown",this.onKeyDown)},onKeyDown:function(r){var e=r.keyCode===83&&r.ctrlKey&&r.altKey;if(this.data&&e){var n=r.shiftKey?"equirectangular":"perspective";this.capture(n)}},setCapture:function(r){var e,n,a,c,h=this.el;return r==="perspective"?(this.quad.visible=!1,n=this.data.camera&&this.data.camera.components.camera.camera||h.camera,e={width:this.data.width,height:this.data.height}):(n=this.camera,c=new X.WebGLCubeRenderTarget(Math.min(this.cubeMapSize,2048),{format:X.RGBFormat,generateMipmaps:!0,minFilter:X.LinearMipmapLinearFilter,colorSpace:X.SRGBColorSpace}),a=new X.CubeCamera(h.camera.near,h.camera.far,c),h.camera.getWorldPosition(a.position),h.camera.getWorldQuaternion(a.quaternion),a.update(h.renderer,h.object3D),this.quad.material.uniforms.map.value=a.renderTarget.texture,e={width:this.data.width,height:this.data.height},this.quad.visible=!0),{camera:n,size:e,projection:r}},capture:function(r){var e,n=this.el.renderer.xr.enabled,a=this.el.renderer;this.setup(),a.xr.enabled=!1,e=this.setCapture(r),this.renderCapture(e.camera,e.size,e.projection),this.saveCapture(),a.xr.enabled=n},getCanvas:function(r){var e=this.el.renderer.xr.enabled,n=this.el.renderer;this.setup();var a=this.setCapture(r);return n.xr.enabled=!1,this.renderCapture(a.camera,a.size,a.projection),n.xr.enabled=e,this.canvas},renderCapture:function(r,e,n){var a,c,h,p=this.el.renderer.autoClear,b=this.el,y=b.renderer;c=this.getRenderTarget(e.width,e.height),h=new Uint8Array(4*e.width*e.height),this.resize(e.width,e.height),y.autoClear=!0,y.clear(),y.setRenderTarget(c),y.render(b.object3D,r),y.autoClear=p,y.readRenderTargetPixels(c,0,0,e.width,e.height,h),y.setRenderTarget(null),n==="perspective"&&(h=this.flipPixelsVertically(h,e.width,e.height)),a=new ImageData(new Uint8ClampedArray(h),e.width,e.height),this.quad.visible=!1,this.ctx.putImageData(a,0,0)},flipPixelsVertically:function(r,e,n){for(var a=r.slice(0),c=0;c<e;++c)for(var h=0;h<n;++h)a[4*c+h*e*4]=r[4*c+(n-h)*e*4],a[4*c+1+h*e*4]=r[4*c+1+(n-h)*e*4],a[4*c+2+h*e*4]=r[4*c+2+(n-h)*e*4],a[4*c+3+h*e*4]=r[4*c+3+(n-h)*e*4];return a},saveCapture:function(){this.canvas.toBlob((function(r){var e="screenshot-"+document.title.toLowerCase()+"-"+Date.now()+".png",n=document.createElement("a"),a=URL.createObjectURL(r);n.href=a,n.setAttribute("download",e),n.innerHTML="downloading...",n.style.display="none",document.body.appendChild(n),setTimeout((function(){n.click(),document.body.removeChild(n)}),1)}),"image/png")}}),Nn(282)),Jbe=Nn.n(qbe),eye=(Nn(3729),Nn(8132),window.aframeStats),eP="a-hidden",tye=window.threeStats;kn("stats",{schema:{default:!0},sceneOnly:!0,init:function(){var r=this.el;Dv("stats")!=="false"&&(this.stats=(function(e){var n=new tye(e.renderer),a=new eye(e),c=e.isMobile?[]:[n,a];return new(Jbe())({css:[],values:{fps:{caption:"fps",below:30}},groups:[{caption:"Framerate",values:["fps","raf"]}],plugins:c})})(r),this.statsEl=document.querySelector(".rs-base"),this.hideBound=this.hide.bind(this),this.showBound=this.show.bind(this),r.addEventListener("enter-vr",this.hideBound),r.addEventListener("exit-vr",this.showBound))},update:function(){if(this.stats)return this.data?this.show():this.hide()},remove:function(){this.el.removeEventListener("enter-vr",this.hideBound),this.el.removeEventListener("exit-vr",this.showBound),this.statsEl&&this.statsEl.parentNode.removeChild(this.statsEl)},tick:function(){var r=this.stats;r&&(r("rAF").tick(),r("FPS").frame(),r().update())},hide:function(){this.statsEl.classList.add(eP)},show:function(){this.statsEl.classList.remove(eP)}});var pm="a-hidden";function tP(r){r.addEventListener("touchstart",(function(){r.classList.remove("resethover")}),{passive:!0}),r.addEventListener("touchend",(function(){r.classList.add("resethover")}),{passive:!0})}kn("xr-mode-ui",{dependencies:["canvas"],schema:{enabled:{default:!0},enterVRButton:{default:""},enterVREnabled:{default:!0},enterARButton:{default:""},enterAREnabled:{default:!0},XRMode:{default:"vr",oneOf:["vr","ar","xr"]}},sceneOnly:!0,init:function(){var r=this,e=this.el;Dv("ui")!=="false"&&(this.insideLoader=!1,this.enterVREl=null,this.enterAREl=null,this.orientationModalEl=null,this.bindMethods(),e.addEventListener("enter-vr",this.updateEnterInterfaces),e.addEventListener("exit-vr",this.updateEnterInterfaces),e.addEventListener("update-vr-devices",this.updateEnterInterfaces),window.addEventListener("message",(function(n){n.data.type==="loaderReady"&&(r.insideLoader=!0,r.remove())})),window.addEventListener("orientationchange",this.toggleOrientationModalIfNeeded))},bindMethods:function(){this.onEnterVRButtonClick=this.onEnterVRButtonClick.bind(this),this.onEnterARButtonClick=this.onEnterARButtonClick.bind(this),this.onModalClick=this.onModalClick.bind(this),this.toggleOrientationModalIfNeeded=this.toggleOrientationModalIfNeeded.bind(this),this.updateEnterInterfaces=this.updateEnterInterfaces.bind(this)},onModalClick:function(){this.el.exitVR()},onEnterVRButtonClick:function(){this.el.enterVR()},onEnterARButtonClick:function(){this.el.enterAR()},update:function(){var r,e,n,a=this.data,c=this.el;if(!a.enabled||this.insideLoader||Dv("ui")==="false")return this.remove();this.enterVREl||this.enterAREl||this.orientationModalEl||(this.enterVREl||!a.enterVREnabled||a.XRMode!=="xr"&&a.XRMode!=="vr"||(a.enterVRButton?(this.enterVREl=document.querySelector(a.enterVRButton),this.enterVREl.addEventListener("click",this.onEnterVRButtonClick)):(this.enterVREl=(r=this.onEnterVRButtonClick,(n=document.createElement("div")).classList.add("a-enter-vr"),n.setAttribute(ta,""),(e=document.createElement("button")).className="a-enter-vr-button",e.setAttribute("title","Enter VR mode with a headset or fullscreen without"),e.setAttribute(ta,""),ef()&&tP(e),n.appendChild(e),e.addEventListener("click",(function(h){r(),h.stopPropagation()})),n),c.appendChild(this.enterVREl))),this.enterAREl||!a.enterAREnabled||a.XRMode!=="xr"&&a.XRMode!=="ar"||(a.enterARButton?(this.enterAREl=document.querySelector(a.enterARButton),this.enterAREl.addEventListener("click",this.onEnterARButtonClick)):(this.enterAREl=(function(h,p){var b,y;return(y=document.createElement("div")).classList.add("a-enter-ar"),p&&y.classList.add("xr"),y.setAttribute(ta,""),(b=document.createElement("button")).className="a-enter-ar-button",b.setAttribute("title","Enter AR mode with a headset or handheld device."),b.setAttribute(ta,""),ef()&&tP(b),y.appendChild(b),b.addEventListener("click",(function(w){h(),w.stopPropagation()})),y})(this.onEnterARButtonClick,a.XRMode==="xr"),c.appendChild(this.enterAREl))),this.orientationModalEl=(function(h){var p=document.createElement("div");p.className="a-orientation-modal",p.classList.add(pm),p.setAttribute(ta,"");var b=document.createElement("button");return b.setAttribute(ta,""),b.innerHTML="Exit VR",b.addEventListener("click",h),p.appendChild(b),p})(this.onModalClick),c.appendChild(this.orientationModalEl),this.updateEnterInterfaces())},remove:function(){[this.enterVREl,this.enterAREl,this.orientationModalEl].forEach((function(r){r&&r.parentNode&&r.parentNode.removeChild(r)})),this.enterVREl=void 0,this.enterAREl=void 0,this.orientationModalEl=void 0},updateEnterInterfaces:function(){this.toggleEnterVRButtonIfNeeded(),this.toggleEnterARButtonIfNeeded(),this.toggleOrientationModalIfNeeded()},toggleEnterVRButtonIfNeeded:function(){var r=this.el;this.enterVREl&&(r.is("vr-mode")||(r.isMobile||Xk())&&!FR()?this.enterVREl.classList.add(pm):(FR()||this.enterVREl.classList.add("fullscreen"),this.enterVREl.classList.remove(pm),r.enterVR(!1,!0)))},toggleEnterARButtonIfNeeded:function(){var r=this.el;this.enterAREl&&(r.is("vr-mode")||!Hk()?this.enterAREl.classList.add(pm):(this.enterAREl.classList.remove(pm),r.enterVR(!0,!0)))},toggleOrientationModalIfNeeded:function(){var r=this.el,e=this.orientationModalEl;e&&r.isMobile&&(!lW()&&r.is("vr-mode")?e.classList.remove(pm):e.classList.add(pm))}}),eo("box",{schema:{depth:{default:1,min:0},height:{default:1,min:0},width:{default:1,min:0},segmentsHeight:{default:1,min:1,max:20,type:"int"},segmentsWidth:{default:1,min:1,max:20,type:"int"},segmentsDepth:{default:1,min:1,max:20,type:"int"}},init:function(r){this.geometry=new X.BoxGeometry(r.width,r.height,r.depth,r.segmentsWidth,r.segmentsHeight,r.segmentsDepth)}});var nP=X.MathUtils.degToRad;eo("circle",{schema:{radius:{default:1,min:0},segments:{default:32,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(r){this.geometry=new X.CircleGeometry(r.radius,r.segments,nP(r.thetaStart),nP(r.thetaLength))}});var iP=X.MathUtils.degToRad;eo("cone",{schema:{height:{default:1,min:0},openEnded:{default:!1},radiusBottom:{default:1,min:0},radiusTop:{default:.01,min:0},segmentsHeight:{default:18,min:1,type:"int"},segmentsRadial:{default:36,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(r){this.geometry=new X.CylinderGeometry(r.radiusTop,r.radiusBottom,r.height,r.segmentsRadial,r.segmentsHeight,r.openEnded,iP(r.thetaStart),iP(r.thetaLength))}});var sP=X.MathUtils.degToRad;eo("cylinder",{schema:{height:{default:1,min:0},openEnded:{default:!1},radius:{default:1,min:0},segmentsHeight:{default:18,min:1,type:"int"},segmentsRadial:{default:36,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(r){this.geometry=new X.CylinderGeometry(r.radius,r.radius,r.height,r.segmentsRadial,r.segmentsHeight,r.openEnded,sP(r.thetaStart),sP(r.thetaLength))}}),eo("dodecahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(r){this.geometry=new X.DodecahedronGeometry(r.radius,r.detail)}}),eo("icosahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(r){this.geometry=new X.IcosahedronGeometry(r.radius,r.detail)}}),eo("octahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(r){this.geometry=new X.OctahedronGeometry(r.radius,r.detail)}}),eo("plane",{schema:{height:{default:1,min:0},width:{default:1,min:0},segmentsHeight:{default:1,min:1,max:20,type:"int"},segmentsWidth:{default:1,min:1,max:20,type:"int"}},init:function(r){this.geometry=new X.PlaneGeometry(r.width,r.height,r.segmentsWidth,r.segmentsHeight)}});var rP=X.MathUtils.degToRad;eo("ring",{schema:{radiusInner:{default:.8,min:0},radiusOuter:{default:1.2,min:0},segmentsPhi:{default:10,min:1,type:"int"},segmentsTheta:{default:32,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(r){this.geometry=new X.RingGeometry(r.radiusInner,r.radiusOuter,r.segmentsTheta,r.segmentsPhi,rP(r.thetaStart),rP(r.thetaLength))}});var qC=X.MathUtils.degToRad;eo("sphere",{schema:{radius:{default:1,min:0},phiLength:{default:360},phiStart:{default:0,min:0},thetaLength:{default:180,min:0},thetaStart:{default:0},segmentsHeight:{default:18,min:2,type:"int"},segmentsWidth:{default:36,min:3,type:"int"}},init:function(r){this.geometry=new X.SphereGeometry(r.radius,r.segmentsWidth,r.segmentsHeight,qC(r.phiStart),qC(r.phiLength),qC(r.thetaStart),qC(r.thetaLength))}}),eo("tetrahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(r){this.geometry=new X.TetrahedronGeometry(r.radius,r.detail)}});var nye=X.MathUtils.degToRad;eo("torus",{schema:{arc:{default:360},radius:{default:1,min:0},radiusTubular:{default:.2,min:0},segmentsRadial:{default:36,min:2,type:"int"},segmentsTubular:{default:32,min:3,type:"int"}},init:function(r){this.geometry=new X.TorusGeometry(r.radius,2*r.radiusTubular,r.segmentsRadial,r.segmentsTubular,nye(r.arc))}}),eo("torusKnot",{schema:{p:{default:2,min:1},q:{default:3,min:1},radius:{default:1,min:0},radiusTubular:{default:.2,min:0},segmentsRadial:{default:8,min:3,type:"int"},segmentsTubular:{default:100,min:3,type:"int"}},init:function(r){this.geometry=new X.TorusKnotGeometry(r.radius,2*r.radiusTubular,r.segmentsTubular,r.segmentsRadial,r.p,r.q)}});var JC=new X.Quaternion,iye=new X.Vector3(0,0,1),qy=new X.Vector2,aP=new X.Vector2,eE=new X.Vector2;function oP(r,e){return e.color.set(r.color),e.fog=r.fog,e.wireframe=r.wireframe,e.toneMapped=r.toneMapped,e.wireframeLinewidth=r.wireframeLinewidth,e}function lP(r,e){return e.color.set(r.color),e.emissive.set(r.emissive),e.emissiveIntensity=r.emissiveIntensity,e.fog=r.fog,e.metalness=r.metalness,e.roughness=r.roughness,e.wireframe=r.wireframe,e.wireframeLinewidth=r.wireframeLinewidth,r.normalMap&&(e.normalScale=r.normalScale),r.ambientOcclusionMap&&(e.aoMapIntensity=r.ambientOcclusionMapIntensity),r.displacementMap&&(e.displacementScale=r.displacementScale,e.displacementBias=r.displacementBias),e}function cP(r,e){switch(e.color.set(r.color),e.specular.set(r.specular),e.emissive.set(r.emissive),e.emissiveIntensity=r.emissiveIntensity,e.fog=r.fog,e.transparent=r.transparent,e.wireframe=r.wireframe,e.wireframeLinewidth=r.wireframeLinewidth,e.shininess=r.shininess,e.flatShading=r.flatShading,e.wireframe=r.wireframe,e.wireframeLinewidth=r.wireframeLinewidth,e.reflectivity=r.reflectivity,e.refractionRatio=r.refractionRatio,r.combine){case"mix":e.combine=X.MixOperation;break;case"multiply":e.combine=X.MultiplyOperation;break;case"add":e.combine=X.AddOperation}return r.normalMap&&(e.normalScale=r.normalScale),r.ambientOcclusionMap&&(e.aoMapIntensity=r.ambientOcclusionMapIntensity),r.bumpMap&&(e.bumpScale=r.bumpMapScale),r.displacementMap&&(e.displacementScale=r.displacementScale,e.displacementBias=r.displacementBias),e}eo("triangle",{schema:{vertexA:{type:"vec3",default:{x:0,y:.5,z:0}},vertexB:{type:"vec3",default:{x:-.5,y:-.5,z:0}},vertexC:{type:"vec3",default:{x:.5,y:-.5,z:0}}},init:function(r){var e,n,a,c,h,p,b,y,w;(a=new X.Triangle).a.set(r.vertexA.x,r.vertexA.y,r.vertexA.z),a.b.set(r.vertexB.x,r.vertexB.y,r.vertexB.z),a.c.set(r.vertexC.x,r.vertexC.y,r.vertexC.z),n=a.getNormal(new X.Vector3),JC.setFromUnitVectors(n,iye),c=a.a.clone().applyQuaternion(JC),h=a.b.clone().applyQuaternion(JC),p=a.c.clone().applyQuaternion(JC),qy.set(Math.min(c.x,h.x,p.x),Math.min(c.y,h.y,p.y)),aP.set(Math.max(c.x,h.x,p.x),Math.max(c.y,h.y,p.y)),eE.set(0,0).subVectors(aP,qy),c=new X.Vector2().subVectors(c,qy).divide(eE),h=new X.Vector2().subVectors(h,qy).divide(eE),p=new X.Vector2().subVectors(p,qy).divide(eE),e=this.geometry=new X.BufferGeometry,b=[a.a.x,a.a.y,a.a.z,a.b.x,a.b.y,a.b.z,a.c.x,a.c.y,a.c.z],y=[n.x,n.y,n.z,n.x,n.y,n.z,n.x,n.y,n.z],w=[c.x,c.y,h.x,h.y,p.x,p.y],e.setAttribute("position",new X.Float32BufferAttribute(b,3)),e.setAttribute("normal",new X.Float32BufferAttribute(y,3)),e.setAttribute("uv",new X.Float32BufferAttribute(w,2))}}),Kd("flat",{schema:{color:{type:"color"},fog:{default:!0},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},src:{type:"map"},wireframe:{default:!1},wireframeLinewidth:{default:2},toneMapped:{default:!0}},init:function(r){this.materialData={color:new X.Color},oP(r,this.materialData),this.material=new X.MeshBasicMaterial(this.materialData)},update:function(r){this.updateMaterial(r),fE(this,r)},updateMaterial:function(r){var e;for(e in oP(r,this.materialData),this.materialData)this.material[e]=this.materialData[e]}}),Kd("standard",{schema:{ambientOcclusionMap:{type:"map"},ambientOcclusionMapIntensity:{default:1},ambientOcclusionTextureOffset:{type:"vec2"},ambientOcclusionTextureRepeat:{type:"vec2",default:{x:1,y:1}},color:{type:"color"},displacementMap:{type:"map"},displacementScale:{default:1},displacementBias:{default:.5},displacementTextureOffset:{type:"vec2"},displacementTextureRepeat:{type:"vec2",default:{x:1,y:1}},emissive:{type:"color",default:"#000"},emissiveIntensity:{default:1},envMap:{default:""},fog:{default:!0},metalness:{default:0,min:0,max:1},metalnessMap:{type:"map"},metalnessTextureOffset:{type:"vec2"},metalnessTextureRepeat:{type:"vec2",default:{x:1,y:1}},normalMap:{type:"map"},normalScale:{type:"vec2",default:{x:1,y:1}},normalTextureOffset:{type:"vec2"},normalTextureRepeat:{type:"vec2",default:{x:1,y:1}},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},roughness:{default:.5,min:0,max:1},roughnessMap:{type:"map"},roughnessTextureOffset:{type:"vec2"},roughnessTextureRepeat:{type:"vec2",default:{x:1,y:1}},sphericalEnvMap:{type:"map"},src:{type:"map"},wireframe:{default:!1},wireframeLinewidth:{default:2}},init:function(r){this.materialData={color:new X.Color,emissive:new X.Color},lP(r,this.materialData),this.material=new X.MeshStandardMaterial(this.materialData)},update:function(r){this.updateMaterial(r),fE(this,r),du("normal",this,r),du("displacement",this,r),du("ambientOcclusion",this,r),du("metalness",this,r),du("roughness",this,r),GR(this,r)},updateMaterial:function(r){var e,n=this.material;for(e in lP(r,this.materialData),this.materialData)n[e]=this.materialData[e]}}),Kd("phong",{schema:{color:{type:"color"},emissive:{type:"color",default:"black"},emissiveIntensity:{default:1},specular:{type:"color",default:"#111111"},transparent:{default:!1},fog:{default:!0},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},src:{type:"map"},envMap:{default:""},sphericalEnvMap:{type:"map"},shininess:{default:30},flatShading:{default:!1},wireframe:{default:!1},wireframeLinewidth:{default:2},combine:{oneOF:["multiply","mix","add"],default:"mix"},reflectivity:{default:.9},refractionRatio:{default:.98},refract:{default:!1},normalMap:{type:"map"},normalScale:{type:"vec2",default:{x:1,y:1}},normalTextureOffset:{type:"vec2"},normalTextureRepeat:{type:"vec2",default:{x:1,y:1}},ambientOcclusionMap:{type:"map"},ambientOcclusionMapIntensity:{default:1},displacementMap:{type:"map"},displacementScale:{default:1},displacementBias:{default:.5},displacementTextureOffset:{type:"vec2"},displacementTextureRepeat:{type:"vec2",default:{x:1,y:1}},bumpMap:{type:"map"},bumpMapScale:{default:1},bumpTextureOffset:{type:"vec2"},bumpTextureRepeat:{type:"vec2",default:{x:1,y:1}}},init:function(r){this.materialData={color:new X.Color,specular:new X.Color,emissive:new X.Color},cP(r,this.materialData),this.material=new X.MeshPhongMaterial(this.materialData);var e=this.el.sceneEl;Object.defineProperty(this.material,"envMap",{get:function(){return this._envMap||e.object3D.environment},set:function(n){this._envMap=n}})},update:function(r){this.updateMaterial(r),fE(this,r),du("normal",this,r),du("displacement",this,r),du("ambientOcclusion",this,r),du("bump",this,r),GR(this,r)},updateMaterial:function(r){var e;for(e in cP(r,this.materialData),this.materialData)this.material[e]=this.materialData[e]}}),Kd("sdf",{schema:{alphaTest:{type:"number",is:"uniform",default:.5},color:{type:"color",is:"uniform",default:"white"},map:{type:"map",is:"uniform"},opacity:{type:"number",is:"uniform",default:1}},vertexShader:["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","out vec2 vUV;","void main(void) {","  vUV = uv;","  #include <begin_vertex>","  #include <project_vertex>","  #include <logdepthbuf_vertex>","  #include <fog_vertex>","}"].join(`
`),fragmentShader:["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform float alphaTest;","uniform float opacity;","uniform sampler2D map;","uniform vec3 color;","in vec2 vUV;","float contour(float width, float value) {","  return smoothstep(0.5 - value, 0.5 + value, width);","}","#define BIG_ENOUGH 0.001","#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)","void main() {","  vec2 uv = vUV;","  vec4 texColor = texture(map, uv);","  float dist = texColor.a;","  float width = fwidth(dist);","  float alpha = contour(dist, width);","  float dscale = 0.353505;","  vec2 duv = dscale * (dFdx(uv) + dFdy(uv));","  float isBigEnough = max(abs(duv.x), abs(duv.y));","  if (isBigEnough > BIG_ENOUGH) {","    float ratio = BIG_ENOUGH / isBigEnough;","    alpha = ratio * alpha + (1.0 - ratio) * dist;","  }","  if (isBigEnough <= BIG_ENOUGH) {","    vec4 box = vec4 (uv - duv, uv + duv);","    alpha = (alpha + 0.5 * (","      contour(texture(map, box.xy).a, width)","      + contour(texture(map, box.zw).a, width)","      + contour(texture(map, box.xw).a, width)","      + contour(texture(map, box.zy).a, width)","    )) / 3.0;","  }","  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }","  gl_FragColor = vec4(color, opacity * alpha);","  #include <logdepthbuf_fragment>","  #include <tonemapping_fragment>","  #include <colorspace_fragment>","  #include <fog_fragment>","}"].join(`
`),init:function(){return this.uniforms=this.initUniforms(),X.UniformsUtils&&(this.uniforms=X.UniformsUtils.merge([X.UniformsLib.fog,this.uniforms])),this.material=new X.ShaderMaterial({uniforms:this.uniforms,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader,fog:!0}),this.material}}),Kd("msdf",{schema:{alphaTest:{type:"number",is:"uniform",default:.5},color:{type:"color",is:"uniform",default:"white"},map:{type:"map",is:"uniform"},negate:{type:"boolean",is:"uniform",default:!0},opacity:{type:"number",is:"uniform",default:1}},vertexShader:["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","out vec2 vUV;","void main(void) {","  vUV = uv;","  #include <begin_vertex>","  #include <project_vertex>","  #include <logdepthbuf_vertex>","  #include <fog_vertex>","}"].join(`
`),fragmentShader:["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform bool negate;","uniform float alphaTest;","uniform float opacity;","uniform sampler2D map;","uniform vec3 color;","in vec2 vUV;","float median(float r, float g, float b) {","  return max(min(r, g), min(max(r, g), b));","}","#define BIG_ENOUGH 0.001","#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)","void main() {","  vec3 sampleColor = texture(map, vUV).rgb;","  if (negate) { sampleColor = 1.0 - sampleColor; }","  float sigDist = median(sampleColor.r, sampleColor.g, sampleColor.b) - 0.5;","  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);","  float dscale = 0.353505;","  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));","  float isBigEnough = max(abs(duv.x), abs(duv.y));","  // Do modified alpha test.","  if (isBigEnough > BIG_ENOUGH) {","    float ratio = BIG_ENOUGH / isBigEnough;","    alpha = ratio * alpha + (1.0 - ratio) * (sigDist + 0.5);","  }","  // Do modified alpha test.","  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }","  gl_FragColor = vec4(color.xyz, alpha * opacity);","  #include <logdepthbuf_fragment>","  #include <tonemapping_fragment>","  #include <colorspace_fragment>","  #include <fog_fragment>","}"].join(`
`),init:function(){return this.uniforms=this.initUniforms(),X.UniformsUtils&&(this.uniforms=X.UniformsUtils.merge([X.UniformsLib.fog,this.uniforms])),this.material=new X.ShaderMaterial({uniforms:this.uniforms,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader,fog:!0}),this.material}}),Kd("shadow",{schema:{opacity:{default:.5},transparent:{default:!0},alphaToCoverage:{default:!0}},init:function(r){this.material=new X.ShadowMaterial},update:function(r){this.material.opacity=r.opacity,this.material.alphaToCoverage=r.alphaToCoverage,this.material.transparent=r.transparent}});var uP="data-aframe-default-camera";function hP(r){var e=r.primitive,n=tf[e]&&tf[e].Geometry,a=new n;if(!n)throw new Error("Unknown geometry `"+e+"`");return a.init(r),a.geometry}kl("camera",{init:function(){this.activeCameraEl=null,this.render=this.render.bind(this),this.unwrapRender=this.unwrapRender.bind(this),this.wrapRender=this.wrapRender.bind(this),this.initialCameraFound=!1,this.numUserCameras=0,this.numUserCamerasChecked=0,this.setupInitialCamera()},setupInitialCamera:function(){var r,e,n=this.sceneEl,a=this;if(!n.camera||n.camera.el.getAttribute("camera").spectator)if((r=n.querySelectorAll("a-camera, :not(a-mixin)[camera]")).length)for(this.numUserCameras=r.length,e=0;e<r.length;e++)r[e].addEventListener("object3dset",(function(c){c.detail.type==="camera"&&a.checkUserCamera(this)})),r[e].isANode?r[e].load():r[e].addEventListener("nodeready",(function(){this.load()}));else this.createDefaultCamera();else n.emit("cameraready",{cameraEl:n.camera.el})},checkUserCamera:function(r){var e,n=this.el.sceneEl;this.numUserCamerasChecked++,this.initialCameraFound||((e=r.getAttribute("camera")).active&&!e.spectator?(this.initialCameraFound=!0,n.camera=r.getObject3D("camera"),n.emit("cameraready",{cameraEl:r})):this.numUserCamerasChecked===this.numUserCameras&&this.createDefaultCamera())},createDefaultCamera:function(){var r,e=this.sceneEl;(r=document.createElement("a-entity")).setAttribute("camera",{active:!0}),r.setAttribute("position",{x:0,y:1.6,z:0}),r.setAttribute("wasd-controls",""),r.setAttribute("look-controls",""),r.setAttribute(ta,""),r.addEventListener("object3dset",(function(n){n.detail.type==="camera"&&(e.camera=n.detail.object,e.emit("cameraready",{cameraEl:r}))})),e.appendChild(r)},disableActiveCamera:function(){var r;(r=this.sceneEl.querySelectorAll(":not(a-mixin)[camera]"))[r.length-1].setAttribute("camera","active",!0)},setActiveCamera:function(r){var e,n,a,c,h=this.activeCameraEl,p=this.sceneEl;if((c=r.getObject3D("camera"))&&r!==this.activeCameraEl){var b=p.querySelector("["+uP+"]");for(r!==(b&&b.querySelector(":not(a-mixin)[camera]"))&&(function(y){var w;y.camera&&(w=y.querySelector("["+uP+"]"))&&y.removeChild(w)})(p),this.activeCameraEl=r,this.activeCameraEl.play(),p.camera=c,h&&h.setAttribute("camera","active",!1),n=p.querySelectorAll(":not(a-mixin)[camera]"),a=0;a<n.length;a++)(e=n[a]).isEntity&&r!==e&&(e.setAttribute("camera","active",!1),e.pause());p.emit("camera-set-active",{cameraEl:r})}},setSpectatorCamera:function(r){var e,n=this.spectatorCameraEl,a=this.sceneEl;r.getObject3D("camera")&&r!==this.spectatorCameraEl&&(n&&n.setAttribute("camera","spectator",!1),e=this.spectatorCameraEl=r,a.addEventListener("enter-vr",this.wrapRender),a.addEventListener("exit-vr",this.unwrapRender),e.setAttribute("camera","active",!1),e.play(),a.emit("camera-set-spectator",{cameraEl:r}))},disableSpectatorCamera:function(){this.spectatorCameraEl=void 0},wrapRender:function(){this.spectatorCameraEl&&!this.originalRender&&(this.originalRender=this.sceneEl.renderer.render,this.sceneEl.renderer.render=this.render)},unwrapRender:function(){this.originalRender&&(this.sceneEl.renderer.render=this.originalRender,this.originalRender=void 0)},render:function(r,e){var n,a,c=this.sceneEl;n=c.renderer.xr.enabled,this.originalRender.call(c.renderer,r,e),this.spectatorCameraEl&&!c.isMobile&&n&&(a=this.spectatorCameraEl.components.camera.camera,c.renderer.xr.enabled=!1,this.originalRender.call(c.renderer,r,a),c.renderer.xr.enabled=n)}}),kl("geometry",{init:function(){this.cache={},this.cacheCount={}},clearCache:function(){this.cache={},this.cacheCount={}},getOrCreateGeometry:function(r){var e,n,a=this.cache;return r.skipCache?hP(r):(e=a[n=this.hash(r)],(function(c,h){c[h]=c[h]===void 0?1:c[h]+1})(this.cacheCount,n),e||(e=hP(r),a[n]=e,e))},unuseGeometry:function(r){var e,n=this.cache,a=this.cacheCount;r.skipCache||n[e=this.hash(r)]&&((function(c,h){c[h]--})(a,e),a[e]>0||(n[e].dispose(),delete n[e],delete a[e]))},hash:function(r){return JSON.stringify(r)}}),kl("gltf-model",{schema:{dracoDecoderPath:{default:"https://www.gstatic.com/draco/versioned/decoders/1.5.7/"},basisTranscoderPath:{default:""},meshoptDecoderPath:{default:""}},init:function(){this.update()},update:function(){var r=this.data.dracoDecoderPath,e=this.data.basisTranscoderPath,n=this.data.meshoptDecoderPath;!this.dracoLoader&&r&&(this.dracoLoader=new FV,this.dracoLoader.setDecoderPath(r)),!this.ktx2Loader&&e&&(this.ktx2Loader=new qo,this.ktx2Loader.setTranscoderPath(e).detectSupport(this.el.renderer)),!this.meshoptDecoder&&n&&(this.meshoptDecoder=(function(a){return new Promise((function(c,h){var p=document.createElement("script");document.body.appendChild(p),p.onload=c,p.onerror=h,p.async=!0,p.src=a}))})(n).then((function(){return window.MeshoptDecoder.ready})).then((function(){return window.MeshoptDecoder})))},getDRACOLoader:function(){return this.dracoLoader},getKTX2Loader:function(){return this.ktx2Loader},getMeshoptDecoder:function(){return this.meshoptDecoder}});var tE="data-aframe-default-light",FW=(kl("light",{schema:{defaultLightsEnabled:{default:!0}},init:function(){this.defaultLights=!1,this.userDefinedLights=!1,this.sceneEl.addEventListener("loaded",this.setupDefaultLights.bind(this))},registerLight:function(r){r.hasAttribute(tE)||(this.removeDefaultLights(),this.userDefinedLights=!0)},removeDefaultLights:function(){var r,e=this.sceneEl;if(this.defaultLights){r=document.querySelectorAll("["+tE+"]");for(var n=0;n<r.length;n++)e.removeChild(r[n]);this.defaultLights=!1}},setupDefaultLights:function(){var r,e,n=this.sceneEl;this.userDefinedLights||this.defaultLights||!this.data.defaultLightsEnabled||((r=document.createElement("a-entity")).setAttribute("light",{color:"#BBB",type:"ambient"}),r.setAttribute(tE,""),r.setAttribute(ta,""),n.appendChild(r),(e=document.createElement("a-entity")).setAttribute("light",{color:"#FFF",intensity:1.884,castShadow:!0}),e.setAttribute("position",{x:-.5,y:1,z:1}),e.setAttribute(tE,""),e.setAttribute(ta,""),n.appendChild(e),this.defaultLights=!0)}}),$i),sye=FW("components:texture:error"),dP=FW("components:texture:warn"),rye=new X.ImageLoader;kl("material",{init:function(){this.materials={},this.sourceCache={}},clearTextureSourceCache:function(){this.sourceCache={}},loadTexture:function(r,e,n){this.loadTextureSource(r,(function(a){var c=tB(a);c2(c,e),n(c)}))},loadTextureSource:function(r,e){var n=this,a=this.sourceCache,c=this.hash(r);function h(p){a[c]=Promise.resolve(p),a[c].then(e)}a[c]?a[c].then(e):r.tagName!=="CANVAS"?h(new Promise((function(p,b){l2(r,(function(y){n.loadImage(y,p)}),(function(y){n.loadVideo(y,p)}))}))):h(new X.Source(r))},loadCubeMapTexture:function(r,e){var n=this,a=0,c=new X.CubeTexture;function h(b){n.loadTextureSource(r[b],(function(y){c.images[b]=y.data,++a==6&&(c.needsUpdate=!0,e(c))}))}if(c.colorSpace=X.SRGBColorSpace,r.length===6)for(var p=0;p<r.length;p++)h(p);else dP("Cube map texture requires exactly 6 sources, got only %s sources",r.length)},loadImage:function(r,e){e(typeof r=="string"?(function(n){return new Promise((function(a,c){rye.load(n,(function(h){a(new X.Source(h))}),(function(){}),(function(h){sye("`$s` could not be fetched (Error code: %s; Response: %s)",h.status,h.statusText)}))}))})(r):new X.Source(r))},loadVideo:function(r,e){var n;typeof r!="string"&&(function(a){a.autoplay=a.hasAttribute("autoplay")&&a.getAttribute("autoplay")!=="false",a.controls=a.hasAttribute("controls")&&a.getAttribute("controls")!=="false",a.getAttribute("loop")==="false"&&a.removeAttribute("loop"),a.getAttribute("preload")==="false"&&(a.preload="none"),a.crossOrigin=a.crossOrigin||"anonymous",a.setAttribute("playsinline",""),a.setAttribute("webkit-playsinline","")})(n=r),n=n||(function(a){var c=document.createElement("video");return c.setAttribute("playsinline",""),c.setAttribute("webkit-playsinline",""),c.autoplay=!0,c.loop=!0,c.crossOrigin="anonymous",c.addEventListener("error",(function(){dP("`%s` is not a valid video",a)}),!0),c.src=a,c})(r),e(new X.Source(n))},hash:function(r){return r.tagName&&(r.id||r.src)||r},registerMaterial:function(r){this.materials[r.uuid]=r},unregisterMaterial:function(r){delete this.materials[r.uuid]}}),kl("obb-collider",{schema:{showColliders:{default:!1}},init:function(){this.collisions=[],this.colliderEls=[]},addCollider:function(r){this.colliderEls.push(r),this.data.showColliders?r.components["obb-collider"].showCollider():r.components["obb-collider"].hideCollider(),this.tick=this.detectCollisions},removeCollider:function(r){var e=this.colliderEls,n=e.indexOf(r);r.components["obb-collider"].hideCollider(),n>-1&&e.splice(n,1),e.length===0&&(this.tick=void 0)},registerCollision:function(r,e){var n=this.collisions,a=!1,c=r.obb,h=e.obb,p=r.renderColliderMesh,b=e.renderColliderMesh;p&&p.material.color.set(16711680),b&&b.material.color.set(16711680);for(var y=0;y<n.length;y++)if(n[y].componentA.obb===c&&n[y].componentB.obb===h||n[y].componentA.obb===h&&n[y].componentB.obb===c){a=!0,n[y].detected=!0;break}a||(n.push({componentA:r,componentB:e,detected:!0}),r.el.emit("obbcollisionstarted",{trackedObject3D:r.trackedObject3D,withEl:e.el}),e.el.emit("obbcollisionstarted",{trackedObject3D:e.trackedObject3D,withEl:r.el}))},resetCollisions:function(){for(var r=this.collisions,e=0;e<r.length;e++)r[e].detected=!1},clearCollisions:function(){for(var r,e,n,a,c=this.collisions,h=[],p=0;p<c.length;p++)c[p].detected?h.push(c[p]):(r=c[p].componentA,e=c[p].componentB,n=r.renderColliderMesh,a=e.renderColliderMesh,n&&n.material.color.set(65280),r.el.emit("obbcollisionended",{trackedObject3D:this.trackedObject3D,withEl:e.el}),a&&a.material.color.set(65280),e.el.emit("obbcollisionended",{trackedObject3D:this.trackedObject3D,withEl:r.el}));this.collisions=h},detectCollisions:function(){var r,e,n,a,c=this.colliderEls;if(!(c.length<2)){this.resetCollisions();for(var h=0;h<c.length;h++)if(n=c[h].components["obb-collider"],(r=c[h].components["obb-collider"].obb).halfSize.x!==0&&r.halfSize.y!==0&&r.halfSize.z!==0)for(var p=h+1;p<c.length;p++)(e=(a=c[p].components["obb-collider"]).obb).halfSize.x!==0&&e.halfSize.y!==0&&e.halfSize.z!==0&&r.intersectsOBB(e)&&this.registerCollision(n,a);this.clearCollisions()}}});var j_=$i("components:renderer:warn");function aye(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.z-e.z}function oye(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder-e.renderOrder}function lye(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:e.z-r.z}kl("renderer",{schema:{antialias:{default:"auto",oneOf:["true","false","auto"]},highRefreshRate:{default:Qk()},logarithmicDepthBuffer:{default:"auto",oneOf:["true","false","auto"]},maxCanvasWidth:{default:-1},maxCanvasHeight:{default:-1},multiviewStereo:{default:!1},exposure:{default:1,if:{toneMapping:["ACESFilmic","linear","reinhard","cineon","AgX","neutral"]}},toneMapping:{default:"no",oneOf:["no","ACESFilmic","linear","reinhard","cineon","AgX","neutral"]},precision:{default:"high",oneOf:["high","medium","low"]},anisotropy:{default:1},sortTransparentObjects:{default:!1},colorManagement:{default:!0},alpha:{default:!0},stencil:{default:!1},foveationLevel:{default:1}},init:function(){var r=this.data,e=this.el,n=this.data.toneMapping.charAt(0).toUpperCase()+this.data.toneMapping.slice(1),a=e.renderer;a.toneMapping=X[n+"ToneMapping"],X.Texture.DEFAULT_ANISOTROPY=r.anisotropy,X.ColorManagement.enabled=r.colorManagement,a.outputColorSpace=r.colorManagement?X.SRGBColorSpace:X.LinearSRGBColorSpace,e.hasAttribute("antialias")&&j_('Component `antialias` is deprecated. Use `renderer="antialias: true"` instead.'),e.hasAttribute("logarithmicDepthBuffer")&&j_('Component `logarithmicDepthBuffer` is deprecated. Use `renderer="logarithmicDepthBuffer: true"` instead.'),a.sortObjects=!0,a.setOpaqueSort(aye)},update:function(){var r=this.data,e=this.el.renderer,n=this.data.toneMapping.charAt(0).toUpperCase()+this.data.toneMapping.slice(1);e.toneMapping=X[n+"ToneMapping"],e.toneMappingExposure=r.exposure,e.xr.setFoveation(r.foveationLevel),r.sortObjects&&j_('`sortObjects` property is deprecated. Use `renderer="sortTransparentObjects: true"` instead.'),r.sortTransparentObjects?e.setTransparentSort(lye):e.setTransparentSort(oye)},applyColorCorrection:function(r){this.data.colorManagement&&r&&r.isTexture&&r.colorSpace!==X.SRGBColorSpace&&(r.colorSpace=X.SRGBColorSpace,r.needsUpdate=!0)},setWebXRFrameRate:function(r){var e,n=this.data,a=r.supportedFrameRates;a&&r.updateTargetFrameRate&&(e=a.includes(90)?n.highRefreshRate?90:72:n.highRefreshRate?72:60,r.updateTargetFrameRate(e).catch((function(c){console.warn("failed to set target frame rate of "+e+". Error info: "+c)})))}});var cye={basic:X.BasicShadowMap,pcf:X.PCFShadowMap,pcfsoft:X.PCFSoftShadowMap};kl("shadow",{schema:{enabled:{default:!0},autoUpdate:{default:!0},type:{default:"pcf",oneOf:["basic","pcf","pcfsoft"]}},init:function(){var r=this.sceneEl,e=this.data;this.shadowMapEnabled=!1,r.renderer.shadowMap.type=cye[e.type],r.renderer.shadowMap.autoUpdate=e.autoUpdate},update:function(r){r.enabled!==this.data.enabled&&this.setShadowMapEnabled(this.shadowMapEnabled)},setShadowMapEnabled:function(r){var e=this.sceneEl,n=this.sceneEl.renderer;this.shadowMapEnabled=r;var a=this.data.enabled&&this.shadowMapEnabled;n&&a!==n.shadowMap.enabled&&(n.shadowMap.enabled=a,(function(c){c.hasLoaded&&c.object3D.traverse((function(h){if(h.material)for(var p=Array.isArray(h.material)?h.material:[h.material],b=0;b<p.length;b++)p[b].needsUpdate=!0}))})(e))}}),kl("tracked-controls",{init:function(){this.controllers=[],this.onInputSourcesChange=this.onInputSourcesChange.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.el.addEventListener("enter-vr",this.onEnterVR),this.onExitVR=this.onExitVR.bind(this),this.el.addEventListener("exit-vr",this.onExitVR)},onEnterVR:function(){this.el.xrSession&&this.el.xrSession.addEventListener("inputsourceschange",this.onInputSourcesChange)},onExitVR:function(){this.referenceSpace=void 0,this.controllers=[],this.el.emit("controllersupdated",void 0,!1)},onInputSourcesChange:function(){var r=this,e=this.el.xrSession,n=this.el.sceneEl.systems.webxr.sessionReferenceSpaceType;e.requestReferenceSpace(n).then((function(a){r.referenceSpace=a})).catch((function(a){throw r.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(n,'tracked-controls uses reference space "'+n+'".'),a})),this.controllers=e.inputSources,this.el.emit("controllersupdated",void 0,!1)}});var uye=$i("systems:webxr:warn"),OW=(kl("webxr",{schema:{referenceSpaceType:{type:"string",default:"local-floor"},requiredFeatures:{type:"array",default:["local-floor"]},optionalFeatures:{type:"array",default:["bounded-floor"]},overlayElement:{type:"selector"}},update:function(){var r=this.data;this.sessionConfiguration={requiredFeatures:r.requiredFeatures,optionalFeatures:r.optionalFeatures},this.sessionReferenceSpaceType=r.referenceSpaceType,r.overlayElement&&(r.overlayElement.classList.remove("a-dom-overlay"),r.optionalFeatures.includes("dom-overlay")||(r.optionalFeatures.push("dom-overlay"),this.el.setAttribute("webxr",r)),this.warnIfFeatureNotRequested("dom-overlay"),this.sessionConfiguration.domOverlay={root:r.overlayElement},r.overlayElement.classList.add("a-dom-overlay"))},wasFeatureRequested:function(r){return r==="viewer"||r==="local"||!(!this.sessionConfiguration.requiredFeatures.includes(r)&&!this.sessionConfiguration.optionalFeatures.includes(r))},warnIfFeatureNotRequested:function(r,e){this.wasFeatureRequested(r)||uye((e?e+" ":"")+'Please add the feature "'+r+`" to a-scene's webxr system options in requiredFeatures/optionalFeatures.`)}}),{});function fP(r){var e=r.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();r==="fog"&&(e="material-fog"),r==="visible"&&(e="material-visible"),OW[e]="material."+r}function wh(){return{defaultComponents:{material:{}},mappings:Mo({},OW)}}Object.keys(hr.material.schema).forEach(fP),Object.keys(Au.standard.schema).forEach(fP);var nE=new X.Vector3,hye=new X.Vector3;kn("pivot",{dependencies:["position"],schema:{type:"vec3"},init:function(){var r=this.data,e=this.el,n=e.object3D.parent,a=e.object3D,c=new X.Group;nE.copy(a.position),hye.copy(a.rotation),n.remove(a),c.add(a),n.add(c),e.object3D=c,a.position.set(-1*r.x,-1*r.y,-1*r.z),c.position.set(r.x+nE.x,r.y+nE.y,r.z+nE.z),c.rotation.copy(a.rotation),a.rotation.set(0,0,0)}}),ja("a-camera",{defaultComponents:{camera:{},"look-controls":{},"wasd-controls":{},position:{x:0,y:1.6,z:0}},mappings:{active:"camera.active",far:"camera.far",fov:"camera.fov","look-controls-enabled":"look-controls.enabled",near:"camera.near","pointer-lock-enabled":"look-controls.pointerLockEnabled","wasd-controls-enabled":"wasd-controls.enabled","reverse-mouse-drag":"look-controls.reverseMouseDrag",zoom:"camera.zoom"}}),ja("a-cursor",jo({},wh(),{defaultComponents:{cursor:{},geometry:{primitive:"ring",radiusOuter:.016,radiusInner:.01,segmentsTheta:32},material:{color:"#000",shader:"flat",opacity:.8},position:{x:0,y:0,z:-1}},mappings:{far:"raycaster.far",fuse:"cursor.fuse","fuse-timeout":"cursor.fuseTimeout",interval:"raycaster.interval",objects:"raycaster.objects"}})),ja("a-curvedimage",jo({},wh(),{defaultComponents:{geometry:{height:1,primitive:"cylinder",radius:2,segmentsRadial:48,thetaLength:270,openEnded:!0,thetaStart:0},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0,repeat:"-1 1"}},mappings:{height:"geometry.height","open-ended":"geometry.openEnded",radius:"geometry.radius",segments:"geometry.segmentsRadial",start:"geometry.thetaStart","theta-length":"geometry.thetaLength","theta-start":"geometry.thetaStart",width:"geometry.thetaLength"}})),ja("a-gltf-model",{mappings:{src:"gltf-model"}}),ja("a-image",jo({},wh(),{defaultComponents:{geometry:{primitive:"plane"},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0}},mappings:{height:"geometry.height",width:"geometry.width"}})),ja("a-light",{defaultComponents:{light:{}},mappings:{angle:"light.angle",color:"light.color","ground-color":"light.groundColor",decay:"light.decay",distance:"light.distance",intensity:"light.intensity",penumbra:"light.penumbra",type:"light.type",target:"light.target",envmap:"light.envMap","shadow-camera-automatic":"light.shadowCameraAutomatic"}}),ja("a-link",{defaultComponents:{link:{visualAspectEnabled:!0}},mappings:{href:"link.href",image:"link.image",title:"link.title"}}),ja("a-obj-model",jo({},wh(),{defaultComponents:{"obj-model":{}},mappings:{src:"obj-model.obj",mtl:"obj-model.mtl"}}));const GW={},dye=GW;function pP(r){return r.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}var q_,iE;lB.forEach((function(r){var e=tf[r],n=pP(r),a={};Object.keys(e.schema).forEach((function(p){a[pP(p)]="geometry."+p}));var c="a-"+n,h=ja(c,jo({},wh(),{defaultComponents:{geometry:{primitive:r}},mappings:a}));GW[c]=h})),ja("a-sky",jo({},wh(),{defaultComponents:{geometry:{primitive:"sphere",radius:500,segmentsWidth:64,segmentsHeight:32},material:{color:"#FFF",side:"back",shader:"flat",npot:!0},scale:"-1 1 1"},mappings:jo({},dye["a-sphere"].mappings)})),ja("a-sound",{defaultComponents:{sound:{}},mappings:{src:"sound.src",on:"sound.on",autoplay:"sound.autoplay",loop:"sound.loop",volume:"sound.volume"}}),q_={text:{anchor:"align",width:5}},iE=iE||{},Object.keys(q_).forEach((function(r){(function(e,n){var a=hr[e].schema;Object.keys(a).forEach((function(c){var h=c.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();n[h]!==void 0&&(h=e+"-"+c),n[h]=e+"."+c}))})(r,iE)})),ja("a-text",jo({},null,{defaultComponents:q_,mappings:iE})),ja("a-video",jo({},wh(),{defaultComponents:{geometry:{primitive:"plane"},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0}},mappings:{height:"geometry.height",width:"geometry.width"}})),ja("a-videosphere",jo({},wh(),{defaultComponents:{geometry:{primitive:"sphere",radius:500,segmentsWidth:64,segmentsHeight:32},material:{color:"#FFF",shader:"flat",side:"back",npot:!0},scale:"-1 1 1"},mappings:{radius:"geometry.radius","segments-height":"geometry.segmentsHeight","segments-width":"geometry.segmentsWidth"}}));var hB=$i,fye=hB("A-Frame:error"),pye=hB("A-Frame:warn");window.document.currentScript&&window.document.currentScript.parentNode!==window.document.head&&!window.debug&&pye("Put the A-Frame <script> tag in the <head> of the HTML *before* the scene to ensure everything for A-Frame is properly registered before they are used from HTML."),window.cordova||window.location.protocol!=="file:"||fye("This HTML file is currently being served via the file:// protocol. Assets, textures, and models WILL NOT WORK due to cross-origin policy! Please use a local or hosted server: https://aframe.io/docs/1.4.0/introduction/installation.html#use-a-local-server."),$k&&(window.logs=hB,Nn(7180),Nn(9379)),console.log("A-Frame Version: 1.7.0 (Date 2025-03-12, Commit #1b9650f1)"),console.log("THREE Version (https://github.com/supermedium/three.js):",iW.REVISION),window.AFRAME_ASYNC||(document.readyState!=="complete"?document.addEventListener("readystatechange",(function r(){document.readyState==="complete"&&(document.removeEventListener("readystatechange",r),zR())})):zR());const mye=globalThis.AFRAME={AComponent:Fv,AEntity:Nr,ANode:na,ANIME:cE,AScene:RW,components:hr,coreComponents:Object.keys(hr),geometries:tf,registerComponent:kn,registerGeometry:eo,registerPrimitive:ja,registerShader:Kd,registerSystem:kl,primitives:{getMeshMixin:wh,primitives:kW},scenes:Sm,schema:ER,shaders:Au,systems:xh,emitReady:zR,THREE:iW,utils:CR,version:LW};xV.A;var mP={},sE={exports:{}},gP;function gye(){return gP||(gP=1,(function(r,e){var n=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof W0<"u")return W0;throw new Error("unable to locate global object")},a=n();r.exports=e=a.fetch,a.fetch&&(e.default=a.fetch.bind(a)),e.Headers=a.Headers,e.Request=a.Request,e.Response=a.Response})(sE,sE.exports)),sE.exports}const Aye={},bye=Object.freeze(Object.defineProperty({__proto__:null,default:Aye},Symbol.toStringTag,{value:"Module"})),yye=mle(bye);var AP;function vye(){return AP||(AP=1,(function(){function r(s,t){for(var i=0;i<t.length;i++){const o=t[i];if(typeof o!="string"&&!Array.isArray(o)){for(const l in o)if(l!=="default"&&!(l in s)){const u=Object.getOwnPropertyDescriptor(o,l);u&&Object.defineProperty(s,l,u.get?u:{enumerable:!0,get:()=>o[l]})}}}return Object.freeze(Object.defineProperty(s,Symbol.toStringTag,{value:"Module"}))}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const e=1e-7,n=1e-4;class a{constructor(t,i){this.backend=t,this.dataMover=i,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,i){this.dataIdsCount++,this.data.set(t,i)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class c{refCount(t){return h("refCount")}incRef(t){return h("incRef")}timerAvailable(){return!0}time(t){return h("time")}read(t){return h("read")}readSync(t){return h("readSync")}readToGPU(t,i){return h("readToGPU")}numDataIds(){return h("numDataIds")}disposeData(t,i){return h("disposeData")}write(t,i,o){return h("write")}move(t,i,o,l,u){return h("move")}memory(){return h("memory")}floatPrecision(){return h("floatPrecision")}epsilon(){return this.floatPrecision()===32?e:n}dispose(){return h("dispose")}}function h(s){throw new Error(`'${s}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function p(s){let t=s.length,i=0;for(;t>0;)i=Math.random()*t|0,t--,w(s,t,i)}function b(s,t,i){return Math.max(s,Math.min(t,i))}function y(s){return s%2===0?s:s+1}function w(s,t,i){const o=s[t];s[t]=s[i],s[i]=o}function I(s){let t=0;for(let i=0;i<s.length;i++)t+=s[i];return t}function E(s,t){if(!s)throw new Error(typeof t=="string"?t:t())}function R(s,t,i=""){E(O(s,t),()=>i+` Shapes ${s} and ${t} must match`)}function k(s){E(s!=null,()=>"The input to the tensor constructor must be a non-null value.")}function G(s,t=[],i=!1){if(t==null&&(t=[]),Array.isArray(s)||_e(s)&&!i)for(let o=0;o<s.length;++o)G(s[o],t,i);else t.push(s);return t}function N(s){if(s.length===0)return 1;let t=s[0];for(let i=1;i<s.length;i++)t*=s[i];return t}function O(s,t){if(s===t)return!0;if(s==null||t==null||s.length!==t.length)return!1;for(let i=0;i<s.length;i++)if(s[i]!==t[i])return!1;return!0}function D(s){return s%1===0}function W(s){const t=Math.ceil(Math.sqrt(s));return[t,Math.ceil(s/t)]}function H(s,t){return t<=s.length?s:s+" ".repeat(t-s.length)}function K(s,t=l=>0,i,o=setTimeout){return new Promise((l,u)=>{let f=0;const g=()=>{if(s()){l();return}f++;const A=t(f);if(i!=null&&f>=i){u();return}o(g,A)};g()})}function j(s,t){let i=1,o=-1;for(let u=0;u<s.length;++u)if(s[u]>=0)i*=s[u];else if(s[u]===-1){if(o!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${o} and dim ${u}`);o=u}else if(s[u]<0)throw Error(`Shapes can not be < 0. Found ${s[u]} at dim ${u}`);if(o===-1){if(t>0&&t!==i)throw Error(`Size(${t}) must match the product of shape ${s}`);return s}if(i===0)throw Error(`Cannot infer the missing size in [${s}] when there are 0 elements`);if(t%i!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${i}`);const l=s.slice();return l[o]=t/i,l}function J(s,t){const i=t.length;return s=s==null?t.map((o,l)=>l):[].concat(s),E(s.every(o=>o>=-i&&o<i),()=>`All values in axis param must be in range [-${i}, ${i}) but got axis ${s}`),E(s.every(o=>D(o)),()=>`All values in axis param must be integers but got axis ${s}`),s.map(o=>o<0?i+o:o)}function ee(s,t){const i=[],o=[],l=t!=null&&Array.isArray(t)&&t.length===0,u=t==null||l?null:J(t,s).sort();let f=0;for(let g=0;g<s.length;++g){if(u!=null){if(u[f]===g&&s[g]!==1)throw new Error(`Can't squeeze axis ${g} since its dim '${s[g]}' is not 1`);(u[f]==null||u[f]>g)&&s[g]===1&&(i.push(s[g]),o.push(g)),u[f]<=g&&f++}s[g]!==1&&(i.push(s[g]),o.push(g))}return{newShape:i,keptDims:o}}function re(s,t){let i=null;if(s==null||s==="float32")i=new Float32Array(t);else if(s==="int32")i=new Int32Array(t);else if(s==="bool")i=new Uint8Array(t);else throw new Error(`Unknown data type ${s}`);return i}function Y(s,t){let i=null;if(s==null||s==="float32")i=new Float32Array(t);else if(s==="int32")i=new Int32Array(t);else if(s==="bool")i=new Uint8Array(t);else if(s==="string")i=new Array(t);else throw new Error(`Unknown data type ${s}`);return i}function ie(s,t){for(let i=0;i<s.length;i++){const o=s[i];if(isNaN(o)||!isFinite(o))throw Error(`A tensor of type ${t} being uploaded contains ${o}.`)}}function ue(s){return s==="bool"||s==="complex64"||s==="float32"||s==="int32"||s==="string"}function Re(s,t){return!(t==="complex64"||t==="float32"&&s!=="complex64"||t==="int32"&&s!=="float32"&&s!=="complex64"||t==="bool"&&s==="bool")}function _e(s){return s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array||s instanceof Uint8ClampedArray}function Pe(s){if(s==="float32"||s==="int32")return 4;if(s==="complex64")return 8;if(s==="bool")return 1;throw new Error(`Unknown dtype ${s}`)}function rt(s){if(s==null)return 0;let t=0;return s.forEach(i=>t+=i.length),t}function de(s){return typeof s=="string"||s instanceof String}function we(s){return typeof s=="boolean"}function Le(s){return typeof s=="number"}function Je(s){return Array.isArray(s)?Je(s[0]):s instanceof Float32Array?"float32":s instanceof Int32Array||s instanceof Uint8Array||s instanceof Uint8ClampedArray?"int32":Le(s)?"float32":de(s)?"string":we(s)?"bool":"float32"}function fe(s){return!!(s&&s.constructor&&s.call&&s.apply)}function Ve(s,t){for(let i=t;i<s;++i)if(s%i===0)return i;return s}function Ne(s){const t=s.length;if(t<2)return[];const i=new Array(t-1);i[t-2]=s[t-1];for(let o=t-3;o>=0;--o)i[o]=i[o+1]*s[o+1];return i}function gt(s,t,i,o=!1){const l=new Array;if(t.length===1){const u=t[0]*(o?2:1);for(let f=0;f<u;f++)l[f]=i[s+f]}else{const u=t[0],f=t.slice(1),g=f.reduce((A,v)=>A*v)*(o?2:1);for(let A=0;A<u;A++)l[A]=gt(s+A*g,f,i,o)}return l}function bt(s,t,i=!1){if(s.length===0)return t[0];const o=s.reduce((l,u)=>l*u)*(i?2:1);if(o===0)return[];if(o!==t.length)throw new Error(`[${s}] does not match the input size ${t.length}${i?" for a complex tensor":""}.`);return gt(0,s,t,i)}function zt(s,t){const i=Tt(s,t);for(let o=0;o<i.length;o++)i[o]=1;return i}function Tt(s,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(s);if(t==="int32")return new Int32Array(s);if(t==="bool")return new Uint8Array(s);throw new Error(`Unknown data type ${t}`)}function Vt(s,t){const i=s.reduce((o,l)=>o*l,1);if(t==null||t==="float32")return bt(s,new Float32Array(i));if(t==="int32")return bt(s,new Int32Array(i));if(t==="bool")return bt(s,new Uint8Array(i));throw new Error(`Unknown data type ${t}`)}function je(s){s.forEach(t=>{E(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${s}].`)})}function _t(s,t,i){if(t===0)return 0;if(t===1)return s[0];let o=s[s.length-1];for(let l=0;l<s.length-1;++l)o+=i[l]*s[l];return o}function Ot(s,t,i){if(t===0)return[];if(t===1)return[s];const o=new Array(t);for(let l=0;l<o.length-1;++l)o[l]=Math.floor(s/i[l]),s-=o[l]*i[l];return o[o.length-1]=s,o}function on(s){return s&&s.then&&typeof s.then=="function"}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vt="tfjsflags";class Mt{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Bt,this.populateURLFlags()}setPlatform(t,i){this.platform!=null&&(Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=i}registerFlag(t,i,o){if(this.flagRegistry[t]={evaluationFn:i,setHook:o},this.urlFlags[t]!=null){const l=this.urlFlags[t];Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${l}.`),this.set(t,l)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const i=this.evaluateFlag(t);if(on(i))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=i,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,i){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=i,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(i)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);vt in t&&t[vt].split(",").forEach(i=>{const[o,l]=i.split(":");this.urlFlags[o]=Kt(o,l)})}}function Bt(s){const t={};return s.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(i,...o)=>(ve(t,o[0],o[1]),o.join("="))),t}function ve(s,t,i){s[decodeURIComponent(t)]=decodeURIComponent(i||"")}function Kt(s,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${s}.`)}function Ee(){return Q}let Q=null;function Z(s){Q=s}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let ae;function Ae(){if(ae==null){let s;if(typeof window<"u")s=window;else if(typeof W0<"u")s=W0;else if(typeof process<"u")s=process;else if(typeof self<"u")s=self;else throw new Error("Could not find a global object");ae=s}return ae}function Ie(){const s=Ae();return s._tfGlobals==null&&(s._tfGlobals=new Map),s._tfGlobals}function Ze(s,t){const i=Ie();if(i.has(s))return i.get(s);{const o=t();return i.set(s,o),i.get(s)}}const At="Abs",dn="Acos",ge="Acosh",se="Add",Ge="AddN",ut="All",kt="Any",xt="ArgMax",fn="ArgMin",Gt="Asin",Jt="Asinh",Ln="Atan",Zt="Atanh",bn="Atan2",Jn="AvgPool",ke="AvgPoolGrad",wt="AvgPool3D",Wt="AvgPool3DGrad",jt="BatchMatMul",tn="BatchToSpaceND",cn="Bincount",Vn="BroadcastTo",nn="BroadcastArgs",qt="Cast",mn="Ceil",fi="ClipByValue",Ki="Complex",Ts="ComplexAbs",ir="Concat",ro="Conv2D",xc="Conv2DBackpropFilter",ao="Conv2DBackpropInput",wc="Conv3D",Cc="Conv3DBackpropFilterV2",nl="Conv3DBackpropInputV2",oo="Cos",Ea="Cosh",Sa="Cumprod",ko="Cumsum",Bo="CropAndResize",Vs="DenseBincount",Bh="DepthToSpace",Cu="DepthwiseConv2dNative",Lo="DepthwiseConv2dNativeBackpropFilter",il="DepthwiseConv2dNativeBackpropInput",Lm="Diag",ce="Dilation2D",We="Dilation2DBackpropInput",st="Dilation2DBackpropFilter",ot="RealDiv",Xe="Einsum",Nt="Elu",sn="EluGrad",un="Erf",ln="Equal",Dn="Exp",Un="ExpandDims",Mn="Expm1",Ai="FFT",Yn="Fill",ys="FlipLeftRight",ss="Floor",ei="FloorDiv",Fs="FusedBatchNorm",xn="GatherV2",Ec="GatherNd",Qn="Greater",Ws="GreaterEqual",Sr="Identity",Ia="IFFT",Xr="Imag",Si="IsFinite",Cs="IsInf",sr="IsNan",vs="LeakyRelu",lo="Less",co="LessEqual",Eu="LinSpace",of="Log",lf="Log1p",Su="LogicalAnd",Lh="LogicalNot",Nh="LogicalOr",Dh="LogSoftmax",Ll="LRN",Nm="LRNGrad",Fh="Max",Oh="Maximum",Sc="MaxPool",No="MaxPoolGrad",Gh="MaxPool3D",Iu="MaxPool3DGrad",Nl="MaxPoolWithArgmax",Uh="Mean",Tu="Min",Ph="Minimum",Mu="MirrorPad",Ic="Mod",cA="Multinomial",dr="Multiply",sl="Neg",_u="NotEqual",Ru="NonMaxSuppressionV3",uA="NonMaxSuppressionV4",cf="NonMaxSuppressionV5",zh="OnesLike",Tc="OneHot",ku="Pack",uf="PadV2",hf="Pow",Dm="Prelu",Fm="Prod",Om="RaggedGather",$v="RaggedTensorToTensor",hA="Range",dA="Real",df="Reciprocal",ff="Relu",pf="Reshape",Gm="ResizeNearestNeighbor",fA="ResizeNearestNeighborGrad",Um="ResizeBilinear",pA="ResizeBilinearGrad",Bu="Relu6",Pm="Reverse",mf="Round",gf="Rsqrt",mA="ScatterNd",Yv="SearchSorted",zm="Select",Af="Selu",Vm="Slice",bf="Sin",yf="Sinh",vf="Sign",xf="Sigmoid",wf="Softplus",Lu="Sqrt",Mc="Sum",Wm="SpaceToBatchND",Cf="SplitV",Ef="Softmax",gA="SparseFillEmptyRows",AA="SparseReshape",bA="SparseSegmentMean",Nu="SparseSegmentSum",jv="SparseToDense",Sf="SquaredDifference",yA="Square",Hm="StridedSlice",vA="StringNGrams",Vh="StringSplit",Wh="StringToHashBucketFast",If="Sub",_c="Tan",Hh="Tanh",Xh="Tile",Tf="TopK",Mf="Transform",Du="Transpose",Xm="Unique",_f="Unpack",Qm="UnsortedSegmentSum",Km="ZerosLike",Rf="Step",xA="FromPixels",wA="RotateWithOffset",Gr="_FusedMatMul",Rc="FusedConv2D",CA="FusedDepthwiseConv2D";/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sa(...s){Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(...s)}function qv(...s){Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.log(...s)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kf=Ze("kernelRegistry",()=>new Map),Bf=Ze("gradRegistry",()=>new Map);function EA(s,t){const i=IA(s,t);return kf.get(i)}function Fu(s){return Bf.get(s)}function Zm(s){const t=kf.entries(),i=[];for(;;){const{done:o,value:l}=t.next();if(o)break;const[u,f]=l,[g]=u.split("_");g===s&&i.push(f)}return i}function Ir(s){const{kernelName:t,backendName:i}=s,o=IA(t,i);kf.has(o)&&sa(`The kernel '${t}' for backend '${i}' is already registered`),kf.set(o,s)}function SA(s){const{kernelName:t}=s;Bf.has(t)&&Ee().getBool("DEBUG")&&sa(`Overriding the gradient for '${t}'`),Bf.set(t,s)}function IA(s,t){return`${t}_${s}`}var ra=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof W0<"u"?W0:typeof self<"u"?self:{};function Qh(s){if(s.__esModule)return s;var t=s.default;if(typeof t=="function"){var i=function o(){if(this instanceof o){var l=[null];l.push.apply(l,arguments);var u=Function.bind.apply(t,l);return new u}return t.apply(this,arguments)};i.prototype=t.prototype}else i={};return Object.defineProperty(i,"__esModule",{value:!0}),Object.keys(s).forEach(function(o){var l=Object.getOwnPropertyDescriptor(s,o);Object.defineProperty(i,o,l.get?l:{enumerable:!0,get:function(){return s[o]}})}),i}var Lf=Oi,Ta=null;try{Ta=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Oi(s,t,i){this.low=s|0,this.high=t|0,this.unsigned=!!i}Oi.prototype.__isLong__,Object.defineProperty(Oi.prototype,"__isLong__",{value:!0});function Qr(s){return(s&&s.__isLong__)===!0}Oi.isLong=Qr;var TA={},MA={};function Ou(s,t){var i,o,l;return t?(s>>>=0,(l=0<=s&&s<256)&&(o=MA[s],o)?o:(i=ds(s,(s|0)<0?-1:0,!0),l&&(MA[s]=i),i)):(s|=0,(l=-128<=s&&s<128)&&(o=TA[s],o)?o:(i=ds(s,s<0?-1:0,!1),l&&(TA[s]=i),i))}Oi.fromInt=Ou;function uo(s,t){if(isNaN(s))return t?rl:Kr;if(t){if(s<0)return rl;if(s>=_a)return Pu}else{if(s<=-Gu)return aa;if(s+1>=Gu)return Df}return s<0?uo(-s,t).neg():ds(s%Tr|0,s/Tr|0,t)}Oi.fromNumber=uo;function ds(s,t,i){return new Oi(s,t,i)}Oi.fromBits=ds;var Nf=Math.pow;function $m(s,t,i){if(s.length===0)throw Error("empty string");if(s==="NaN"||s==="Infinity"||s==="+Infinity"||s==="-Infinity")return Kr;if(typeof t=="number"?(i=t,t=!1):t=!!t,i=i||10,i<2||36<i)throw RangeError("radix");var o;if((o=s.indexOf("-"))>0)throw Error("interior hyphen");if(o===0)return $m(s.substring(1),t,i).neg();for(var l=uo(Nf(i,8)),u=Kr,f=0;f<s.length;f+=8){var g=Math.min(8,s.length-f),A=parseInt(s.substring(f,f+g),i);if(g<8){var v=uo(Nf(i,g));u=u.mul(v).add(uo(A))}else u=u.mul(l),u=u.add(uo(A))}return u.unsigned=t,u}Oi.fromString=$m;function Ma(s,t){return typeof s=="number"?uo(s,t):typeof s=="string"?$m(s,t):ds(s.low,s.high,typeof t=="boolean"?t:s.unsigned)}Oi.fromValue=Ma;var ho=65536,Jv=1<<24,Tr=ho*ho,_a=Tr*Tr,Gu=_a/2,Ym=Ou(Jv),Kr=Ou(0);Oi.ZERO=Kr;var rl=Ou(0,!0);Oi.UZERO=rl;var kc=Ou(1);Oi.ONE=kc;var Uu=Ou(1,!0);Oi.UONE=Uu;var jm=Ou(-1);Oi.NEG_ONE=jm;var Df=ds(-1,2147483647,!1);Oi.MAX_VALUE=Df;var Pu=ds(-1,-1,!0);Oi.MAX_UNSIGNED_VALUE=Pu;var aa=ds(0,-2147483648,!1);Oi.MIN_VALUE=aa;var Ht=Oi.prototype;Ht.toInt=function(){return this.unsigned?this.low>>>0:this.low},Ht.toNumber=function(){return this.unsigned?(this.high>>>0)*Tr+(this.low>>>0):this.high*Tr+(this.low>>>0)},Ht.toString=function(s){if(s=s||10,s<2||36<s)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(aa)){var t=uo(s),i=this.div(t),o=i.mul(t).sub(this);return i.toString(s)+o.toInt().toString(s)}else return"-"+this.neg().toString(s);for(var l=uo(Nf(s,6),this.unsigned),u=this,f="";;){var g=u.div(l),A=u.sub(g.mul(l)).toInt()>>>0,v=A.toString(s);if(u=g,u.isZero())return v+f;for(;v.length<6;)v="0"+v;f=""+v+f}},Ht.getHighBits=function(){return this.high},Ht.getHighBitsUnsigned=function(){return this.high>>>0},Ht.getLowBits=function(){return this.low},Ht.getLowBitsUnsigned=function(){return this.low>>>0},Ht.getNumBitsAbs=function(){if(this.isNegative())return this.eq(aa)?64:this.neg().getNumBitsAbs();for(var s=this.high!=0?this.high:this.low,t=31;t>0&&!(s&1<<t);t--);return this.high!=0?t+33:t+1},Ht.isZero=function(){return this.high===0&&this.low===0},Ht.eqz=Ht.isZero,Ht.isNegative=function(){return!this.unsigned&&this.high<0},Ht.isPositive=function(){return this.unsigned||this.high>=0},Ht.isOdd=function(){return(this.low&1)===1},Ht.isEven=function(){return(this.low&1)===0},Ht.equals=function(s){return Qr(s)||(s=Ma(s)),this.unsigned!==s.unsigned&&this.high>>>31===1&&s.high>>>31===1?!1:this.high===s.high&&this.low===s.low},Ht.eq=Ht.equals,Ht.notEquals=function(s){return!this.eq(s)},Ht.neq=Ht.notEquals,Ht.ne=Ht.notEquals,Ht.lessThan=function(s){return this.comp(s)<0},Ht.lt=Ht.lessThan,Ht.lessThanOrEqual=function(s){return this.comp(s)<=0},Ht.lte=Ht.lessThanOrEqual,Ht.le=Ht.lessThanOrEqual,Ht.greaterThan=function(s){return this.comp(s)>0},Ht.gt=Ht.greaterThan,Ht.greaterThanOrEqual=function(s){return this.comp(s)>=0},Ht.gte=Ht.greaterThanOrEqual,Ht.ge=Ht.greaterThanOrEqual,Ht.compare=function(s){if(Qr(s)||(s=Ma(s)),this.eq(s))return 0;var t=this.isNegative(),i=s.isNegative();return t&&!i?-1:!t&&i?1:this.unsigned?s.high>>>0>this.high>>>0||s.high===this.high&&s.low>>>0>this.low>>>0?-1:1:this.sub(s).isNegative()?-1:1},Ht.comp=Ht.compare,Ht.negate=function(){return!this.unsigned&&this.eq(aa)?aa:this.not().add(kc)},Ht.neg=Ht.negate,Ht.add=function(s){Qr(s)||(s=Ma(s));var t=this.high>>>16,i=this.high&65535,o=this.low>>>16,l=this.low&65535,u=s.high>>>16,f=s.high&65535,g=s.low>>>16,A=s.low&65535,v=0,C=0,S=0,M=0;return M+=l+A,S+=M>>>16,M&=65535,S+=o+g,C+=S>>>16,S&=65535,C+=i+f,v+=C>>>16,C&=65535,v+=t+u,v&=65535,ds(S<<16|M,v<<16|C,this.unsigned)},Ht.subtract=function(s){return Qr(s)||(s=Ma(s)),this.add(s.neg())},Ht.sub=Ht.subtract,Ht.multiply=function(s){if(this.isZero())return Kr;if(Qr(s)||(s=Ma(s)),Ta){var t=Ta.mul(this.low,this.high,s.low,s.high);return ds(t,Ta.get_high(),this.unsigned)}if(s.isZero())return Kr;if(this.eq(aa))return s.isOdd()?aa:Kr;if(s.eq(aa))return this.isOdd()?aa:Kr;if(this.isNegative())return s.isNegative()?this.neg().mul(s.neg()):this.neg().mul(s).neg();if(s.isNegative())return this.mul(s.neg()).neg();if(this.lt(Ym)&&s.lt(Ym))return uo(this.toNumber()*s.toNumber(),this.unsigned);var i=this.high>>>16,o=this.high&65535,l=this.low>>>16,u=this.low&65535,f=s.high>>>16,g=s.high&65535,A=s.low>>>16,v=s.low&65535,C=0,S=0,M=0,_=0;return _+=u*v,M+=_>>>16,_&=65535,M+=l*v,S+=M>>>16,M&=65535,M+=u*A,S+=M>>>16,M&=65535,S+=o*v,C+=S>>>16,S&=65535,S+=l*A,C+=S>>>16,S&=65535,S+=u*g,C+=S>>>16,S&=65535,C+=i*v+o*A+l*g+u*f,C&=65535,ds(M<<16|_,C<<16|S,this.unsigned)},Ht.mul=Ht.multiply,Ht.divide=function(s){if(Qr(s)||(s=Ma(s)),s.isZero())throw Error("division by zero");if(Ta){if(!this.unsigned&&this.high===-2147483648&&s.low===-1&&s.high===-1)return this;var t=(this.unsigned?Ta.div_u:Ta.div_s)(this.low,this.high,s.low,s.high);return ds(t,Ta.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?rl:Kr;var i,o,l;if(this.unsigned){if(s.unsigned||(s=s.toUnsigned()),s.gt(this))return rl;if(s.gt(this.shru(1)))return Uu;l=rl}else{if(this.eq(aa)){if(s.eq(kc)||s.eq(jm))return aa;if(s.eq(aa))return kc;var u=this.shr(1);return i=u.div(s).shl(1),i.eq(Kr)?s.isNegative()?kc:jm:(o=this.sub(s.mul(i)),l=i.add(o.div(s)),l)}else if(s.eq(aa))return this.unsigned?rl:Kr;if(this.isNegative())return s.isNegative()?this.neg().div(s.neg()):this.neg().div(s).neg();if(s.isNegative())return this.div(s.neg()).neg();l=Kr}for(o=this;o.gte(s);){i=Math.max(1,Math.floor(o.toNumber()/s.toNumber()));for(var f=Math.ceil(Math.log(i)/Math.LN2),g=f<=48?1:Nf(2,f-48),A=uo(i),v=A.mul(s);v.isNegative()||v.gt(o);)i-=g,A=uo(i,this.unsigned),v=A.mul(s);A.isZero()&&(A=kc),l=l.add(A),o=o.sub(v)}return l},Ht.div=Ht.divide,Ht.modulo=function(s){if(Qr(s)||(s=Ma(s)),Ta){var t=(this.unsigned?Ta.rem_u:Ta.rem_s)(this.low,this.high,s.low,s.high);return ds(t,Ta.get_high(),this.unsigned)}return this.sub(this.div(s).mul(s))},Ht.mod=Ht.modulo,Ht.rem=Ht.modulo,Ht.not=function(){return ds(~this.low,~this.high,this.unsigned)},Ht.and=function(s){return Qr(s)||(s=Ma(s)),ds(this.low&s.low,this.high&s.high,this.unsigned)},Ht.or=function(s){return Qr(s)||(s=Ma(s)),ds(this.low|s.low,this.high|s.high,this.unsigned)},Ht.xor=function(s){return Qr(s)||(s=Ma(s)),ds(this.low^s.low,this.high^s.high,this.unsigned)},Ht.shiftLeft=function(s){return Qr(s)&&(s=s.toInt()),(s&=63)===0?this:s<32?ds(this.low<<s,this.high<<s|this.low>>>32-s,this.unsigned):ds(0,this.low<<s-32,this.unsigned)},Ht.shl=Ht.shiftLeft,Ht.shiftRight=function(s){return Qr(s)&&(s=s.toInt()),(s&=63)===0?this:s<32?ds(this.low>>>s|this.high<<32-s,this.high>>s,this.unsigned):ds(this.high>>s-32,this.high>=0?0:-1,this.unsigned)},Ht.shr=Ht.shiftRight,Ht.shiftRightUnsigned=function(s){if(Qr(s)&&(s=s.toInt()),s&=63,s===0)return this;var t=this.high;if(s<32){var i=this.low;return ds(i>>>s|t<<32-s,t>>>s,this.unsigned)}else return s===32?ds(t,0,this.unsigned):ds(t>>>s-32,0,this.unsigned)},Ht.shru=Ht.shiftRightUnsigned,Ht.shr_u=Ht.shiftRightUnsigned,Ht.toSigned=function(){return this.unsigned?ds(this.low,this.high,!1):this},Ht.toUnsigned=function(){return this.unsigned?this:ds(this.low,this.high,!0)},Ht.toBytes=function(s){return s?this.toBytesLE():this.toBytesBE()},Ht.toBytesLE=function(){var s=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,s&255,s>>>8&255,s>>>16&255,s>>>24]},Ht.toBytesBE=function(){var s=this.high,t=this.low;return[s>>>24,s>>>16&255,s>>>8&255,s&255,t>>>24,t>>>16&255,t>>>8&255,t&255]},Oi.fromBytes=function(s,t,i){return i?Oi.fromBytesLE(s,t):Oi.fromBytesBE(s,t)},Oi.fromBytesLE=function(s,t){return new Oi(s[0]|s[1]<<8|s[2]<<16|s[3]<<24,s[4]|s[5]<<8|s[6]<<16|s[7]<<24,t)},Oi.fromBytesBE=function(s,t){return new Oi(s[4]<<24|s[5]<<16|s[6]<<8|s[7],s[0]<<24|s[1]<<16|s[2]<<8|s[3],t)};const _A=r({__proto__:null,default:Lf},[Lf]);/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Zr=Lf||_A;function Ff(s){return Zr.fromString(s,!0,16)}const Of=Ff("c3a5c85c97cb3127"),Ra=Ff("b492b66fbe98f273"),fr=Ff("9ae16a3b2f90404f");function Gf(s){return s.xor(s.shru(47))}function zu(s,t,i){const o=s.slice(t,t+i);return Zr.fromBytes(Array.from(o),!0,!0)}function Gi(s,t){return zu(s,t,8)}function Uf(s,t){return zu(s,t,4)}function Os(s,t){return t===0?s:s.shru(t).or(s.shl(64-t))}function rr(s,t,i=Ff("9ddfea08eb382d69")){let o=s.xor(t).mul(i);o=o.xor(o.shru(47));let l=t.xor(o).mul(i);return l=l.xor(l.shru(47)),l=l.mul(i),l}function fo(s,t,i,o,l,u){l=l.add(s),u=Os(u.add(l).add(o),21);const f=l;return l=l.add(t),l=l.add(i),u=u.add(Os(l,44)),[l.add(o),u.add(f)]}function al(s,t,i,o){return fo(Gi(s,t),Gi(s,t+8),Gi(s,t+16),Gi(s,t+24),i,o)}function Dl(s,t=s.length){if(t>=8){const i=fr.add(t*2),o=Gi(s,0).add(fr),l=Gi(s,t-8),u=Os(l,37).mul(i).add(o),f=Os(o,25).add(l).mul(i);return rr(u,f,i)}if(t>=4){const i=fr.add(t*2),o=Uf(s,0);return rr(o.shl(3).add(t),Uf(s,t-4),i)}if(t>0){const i=s[0],o=s[t>>1],l=s[t-1],u=i+(o<<8),f=t+(l<<2);return Gf(fr.mul(u).xor(Of.mul(f))).mul(fr)}return fr}function Fl(s,t=s.length){const i=fr.add(t*2),o=Gi(s,0).mul(Ra),l=Gi(s,8),u=Gi(s,t-8).mul(i),f=Gi(s,t-16).mul(fr);return rr(Os(o.add(l),43).add(Os(u,30)).add(f),o.add(Os(l.add(fr),18)).add(u),i)}function Vu(s,t=s.length){const i=fr.add(t*2),o=Gi(s,0).mul(fr),l=Gi(s,8),u=Gi(s,t-8).mul(i),f=Gi(s,t-16).mul(fr),g=Os(o.add(l),43).add(Os(u,30)).add(f),A=rr(g,o.add(Os(l.add(fr),18)).add(u),i),v=Gi(s,16).mul(i),C=Gi(s,24),S=g.add(Gi(s,t-32)).mul(i),M=A.add(Gi(s,t-24)).mul(i);return rr(Os(v.add(C),43).add(Os(S,30)).add(M),v.add(Os(C.add(o),18)).add(S),i)}function RA(s,t=s.length){const i=Zr.fromNumber(81,!0);if(t<=32)return t<=16?Dl(s,t):Fl(s,t);if(t<=64)return Vu(s,t);let o=i,l=i.mul(Ra).add(113),u=Gf(l.mul(fr).add(113)).mul(fr),f=[Zr.UZERO,Zr.UZERO],g=[Zr.UZERO,Zr.UZERO];o=o.mul(fr).add(Gi(s,0));let A=0;const v=(t-1>>6)*64,C=v+(t-1&63)-63;do o=Os(o.add(l).add(f[0]).add(Gi(s,A+8)),37).mul(Ra),l=Os(l.add(f[1]).add(Gi(s,A+48)),42).mul(Ra),o=o.xor(g[1]),l=l.add(f[0]).add(Gi(s,A+40)),u=Os(u.add(g[0]),33).mul(Ra),f=al(s,A,f[1].mul(Ra),o.add(g[0])),g=al(s,A+32,u.add(g[1]),l.add(Gi(s,A+16))),[u,o]=[o,u],A+=64;while(A!==v);const S=Ra.add(u.and(255).shl(1));return A=C,g[0]=g[0].add(t-1&63),f[0]=f[0].add(g[0]),g[0]=g[0].add(f[0]),o=Os(o.add(l).add(f[0]).add(Gi(s,A+8)),37).mul(S),l=Os(l.add(f[1]).add(Gi(s,A+48)),42).mul(S),o=o.xor(g[1].mul(9)),l=l.add(f[0].mul(9).add(Gi(s,A+40))),u=Os(u.add(g[0]),33).mul(S),f=al(s,A,f[1].mul(S),o.add(g[0])),g=al(s,A+32,u.add(g[1]),l.add(Gi(s,A+16))),[u,o]=[o,u],rr(rr(f[0],g[0],S).add(Gf(l).mul(Of)).add(u),rr(f[1],g[1],S).add(o),S)}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Do(s,t){return t==="string"?ri(s):Gs([s],t)}function kA(s,t){return s instanceof Float32Array&&t==="float32"||s instanceof Int32Array&&t==="int32"||s instanceof Uint8Array&&t==="bool"}function Gs(s,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(s)&&(s=G(s)),Ee().getBool("DEBUG")&&ie(s,t),kA(s,t))return s;if(t==null||t==="float32"||t==="complex64")return new Float32Array(s);if(t==="int32")return new Int32Array(s);if(t==="bool"){const i=new Uint8Array(s.length);for(let o=0;o<i.length;++o)Math.round(s[o])!==0&&(i[o]=1);return i}else throw new Error(`Unknown data type ${t}`)}function wi(){return Ee().platform.now()}function ri(s,t="utf-8"){return t=t||"utf-8",Ee().platform.encode(s,t)}function oa(s,t="utf-8"){return t=t||"utf-8",Ee().platform.decode(s,t)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ol{constructor(t,i){this.backendTimer=t,this.logger=i,i==null&&(this.logger=new Wu)}profileKernel(t,i,o){let l;const u=()=>{l=o()};let f;const g=wi();if(this.backendTimer.timerAvailable())f=this.backendTimer.time(u);else{u();for(const A of l)A.dataSync();f=Promise.resolve({kernelMs:wi()-g})}if(Ee().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let A=0;A<l.length;A++){const v=l[A];v.data().then(C=>{BA(C,v.dtype,t)})}return{kernelName:t,outputs:l,inputs:i,timeMs:f.then(A=>A.kernelMs),extraInfo:f.then(A=>A.getExtraProfileInfo!=null?A.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:i,outputs:o,timeMs:l,inputs:u,extraInfo:f}=t;o.forEach(g=>{Promise.all([g.data(),l,f]).then(A=>{this.logger.logKernelProfile(i,g,A[0],A[1],u,A[2])})})}}function BA(s,t,i){if(t!=="float32")return!1;for(let o=0;o<s.length;o++){const l=s[o];if(isNaN(l)||!isFinite(l))return console.warn(`Found ${l} in the result of '${i}'`),!0}return!1}class Wu{logKernelProfile(t,i,o,l,u,f){const g=typeof l=="number"?H(`${l}ms`,9):l.error,A=H(t,25),v=i.rank,C=i.size,S=H(i.shape.toString(),14);let M="";for(const _ in u){const B=u[_];if(B!=null){const F=B.shape||i.shape,P=F.length;M+=`${_}: ${P}D ${P>0?F:""} `}}console.log(`%c${A}	%c${g}	%c${v}D ${S}	%c${C}	%c${M}	%c${f}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ex(s,t,i){const o={},l={};for(let A=0;A<t.length;A++)o[t[A].id]=!0;for(let A=0;A<s.length;A++){const v=s[A],C=v.inputs;for(const S in C){const M=C[S];let _=!1;for(let B=0;B<t.length;B++)if(o[M.id]){v.outputs.forEach(F=>o[F.id]=!0),_=!0,l[v.id]=!0;break}if(_)break}}const u={};u[i.id]=!0;const f={};for(let A=s.length-1;A>=0;A--){const v=s[A],C=v.inputs;for(let S=0;S<v.outputs.length;S++)if(u[v.outputs[S].id]){for(const M in C)u[C[M].id]=!0,f[v.id]=!0;break}}const g=[];for(let A=0;A<s.length;A++){const v=s[A];if(l[v.id]&&f[v.id]){const C={};for(const M in v.inputs){const _=v.inputs[M];o[_.id]&&(C[M]=_)}const S=Object.assign({},v);S.inputs=C,S.outputs=v.outputs,g.push(S)}}return g}function tx(s,t,i,o){for(let l=t.length-1;l>=0;l--){const u=t[l],f=[];if(u.outputs.forEach(A=>{const v=s[A.id];v!=null?f.push(v):f.push(null)}),u.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${u.kernelName}.`);const g=u.gradient(f);for(const A in u.inputs){if(!(A in g))throw new Error(`Cannot backprop through input ${A}. Available gradients found: ${Object.keys(g)}.`);const v=i(()=>g[A]());if(v.dtype!=="float32")throw new Error(`Error in gradient for op ${u.kernelName}. The gradient of input ${A} must have 'float32' dtype, but has '${v.dtype}'`);const C=u.inputs[A];if(!O(v.shape,C.shape))throw new Error(`Error in gradient for op ${u.kernelName}. The gradient of input '${A}' has shape '${v.shape}', which does not match the shape of the input '${C.shape}'`);if(s[C.id]==null)s[C.id]=v;else{const S=s[C.id];s[C.id]=o(S,v),S.dispose()}}}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Kh=20,Ol=3,qm=7;function Pf(s,t,i,o){const l=Ne(t),u=LA(s,t,i,l),f=t.length,g=Oo(s,t,i,l,u),A=["Tensor"];return o&&(A.push(`  dtype: ${i}`),A.push(`  rank: ${f}`),A.push(`  shape: [${t}]`),A.push("  values:")),A.push(g.map(v=>"    "+v).join(`
`)),A.join(`
`)}function LA(s,t,i,o){const l=N(t),u=o[o.length-1],f=new Array(u).fill(0),g=t.length,A=i==="complex64"?ka(s):s;if(g>1)for(let v=0;v<l/u;v++){const C=v*u;for(let S=0;S<u;S++)f[S]=Math.max(f[S],Fo(A[C+S],0,i).length)}return f}function Fo(s,t,i){let o;return Array.isArray(s)?o=`${parseFloat(s[0].toFixed(qm))} + ${parseFloat(s[1].toFixed(qm))}j`:de(s)?o=`'${s}'`:i==="bool"?o=ll(s):o=parseFloat(s.toFixed(qm)).toString(),H(o,t)}function ll(s){return s===0?"false":"true"}function Oo(s,t,i,o,l,u=!0){const f=i==="complex64"?2:1,g=t[0],A=t.length;if(A===0){if(i==="complex64"){const F=ka(s);return[Fo(F[0],0,i)]}return i==="bool"?[ll(s[0])]:[s[0].toString()]}if(A===1){if(g>Kh){const F=Ol*f;let P=Array.from(s.slice(0,F)),U=Array.from(s.slice((g-Ol)*f,g*f));return i==="complex64"&&(P=ka(P),U=ka(U)),["["+P.map((V,$)=>Fo(V,l[$],i)).join(", ")+", ..., "+U.map((V,$)=>Fo(V,l[g-Ol+$],i)).join(", ")+"]"]}return["["+(i==="complex64"?ka(s):Array.from(s)).map((F,P)=>Fo(F,l[P],i)).join(", ")+"]"]}const v=t.slice(1),C=o.slice(1),S=o[0]*f,M=[];if(g>Kh){for(let F=0;F<Ol;F++){const P=F*S,U=P+S;M.push(...Oo(s.slice(P,U),v,i,C,l,!1))}M.push("...");for(let F=g-Ol;F<g;F++){const P=F*S,U=P+S;M.push(...Oo(s.slice(P,U),v,i,C,l,F===g-1))}}else for(let F=0;F<g;F++){const P=F*S,U=P+S;M.push(...Oo(s.slice(P,U),v,i,C,l,F===g-1))}const _=A===2?",":"";M[0]="["+M[0]+_;for(let F=1;F<M.length-1;F++)M[F]=" "+M[F]+_;let B=`,
`;for(let F=2;F<A;F++)B+=`
`;return M[M.length-1]=" "+M[M.length-1]+"]"+(u?"":B),M}function ka(s){const t=[];for(let i=0;i<s.length;i+=2)t.push([s[i],s[i+1]]);return t}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Hs{constructor(t,i,o){if(this.dtype=i,this.shape=t.slice(),this.size=N(t),o!=null){const l=o.length;E(l===this.size,()=>`Length of values '${l}' does not match the size inferred by the shape '${this.size}'.`)}if(i==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=o||Y(i,this.size),this.strides=Ne(t)}set(t,...i){i.length===0&&(i=[0]),E(i.length===this.rank,()=>`The number of provided coordinates (${i.length}) must match the rank (${this.rank})`);const o=this.locToIndex(i);this.values[o]=t}get(...t){t.length===0&&(t=[0]);let i=0;for(const l of t){if(l<0||l>=this.shape[i]){const u=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(u)}i++}let o=t[t.length-1];for(let l=0;l<t.length-1;++l)o+=this.strides[l]*t[l];return this.values[o]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let i=t[t.length-1];for(let o=0;o<t.length-1;++o)i+=this.strides[o]*t[o];return i}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const i=new Array(this.shape.length);for(let o=0;o<i.length-1;++o)i[o]=Math.floor(t/this.strides[o]),t-=i[o]*this.strides[o];return i[i.length-1]=t,i}get rank(){return this.shape.length}toTensor(){return Ba().makeTensor(this.values,this.shape,this.dtype)}}let Ba=null,cl=null;function Jm(s){Ba=s}function Hu(s){cl=s}class Ci{constructor(t,i,o,l){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=i||"float32",this.size=N(t),this.strides=Ne(t),this.dataId=o,this.id=l,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return cl.buffer(this.shape,this.dtype,t)}bufferSync(){return cl.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return bt(this.shape,t,this.dtype==="complex64")}arraySync(){return bt(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Ba().read(this.dataId);if(this.dtype==="string"){const i=await t;try{return i.map(o=>oa(o))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Ba().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Ba().readSync(this.dataId);if(this.dtype==="string")try{return t.map(i=>oa(i))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Ba().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Ba().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return cl.print(this,t)}clone(){return this.throwIfDisposed(),cl.clone(this)}toString(t=!1){const i=this.dataSync();return Pf(i,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),cl.cast(this,t)}variable(t=!0,i,o){return this.throwIfDisposed(),Ba().makeVariable(this,t,i,o)}}Object.defineProperty(Ci,Symbol.hasInstance,{value:s=>!!s&&s.data!=null&&s.dataSync!=null&&s.throwIfDisposed!=null});function dt(){return Ze("Tensor",()=>Ci)}dt();class zf extends Ci{constructor(t,i,o,l){super(t.shape,t.dtype,t.dataId,l),this.trainable=i,this.name=o}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!O(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Ba().disposeTensor(this),this.dataId=t.dataId,Ba().incRef(this,null)}dispose(){Ba().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(zf,Symbol.hasInstance,{value:s=>s instanceof Ci&&s.assign!=null&&s.assign instanceof Function});/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var nx;(function(s){s.R0="R0",s.R1="R1",s.R2="R2",s.R3="R3",s.R4="R4",s.R5="R5",s.R6="R6"})(nx||(nx={}));var NA;(function(s){s.float32="float32",s.int32="int32",s.bool="int32",s.complex64="complex64"})(NA||(NA={}));var DA;(function(s){s.float32="float32",s.int32="int32",s.bool="bool",s.complex64="complex64"})(DA||(DA={}));var Xs;(function(s){s.float32="float32",s.int32="float32",s.bool="float32",s.complex64="complex64"})(Xs||(Xs={}));var Vf;(function(s){s.float32="complex64",s.int32="complex64",s.bool="complex64",s.complex64="complex64"})(Vf||(Vf={}));const Wf={float32:Xs,int32:NA,bool:DA,complex64:Vf};function ar(s,t){if(s==="string"||t==="string"){if(s==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${s} with ${t}`)}return Wf[s][t]}function Hf(s){return ar(s,"int32")}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rs(s,t){if(s.dtype===t.dtype)return[s,t];const i=ar(s.dtype,t.dtype);return[s.cast(i),t.cast(i)]}function Xu(s){const t=[];return ix(s,t,new Set),t}function ix(s,t,i){if(s==null)return;if(s instanceof Ci){t.push(s);return}if(!sx(s))return;const o=s;for(const l in o){const u=o[l];i.has(u)||(i.add(u),ix(u,t,i))}}function sx(s){return Array.isArray(s)||typeof s=="object"}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function FA(s){return s.kernelName!=null}class OA{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class po{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new OA}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let i=0;i<t.length;i++){const o=t[i];if(await this.initializeBackend(o).success){await this.setBackend(o);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:i}=this.initializeBackendsAndReturnBest();if(i)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:i}=this.initializeBackend(t);if(i)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,i,o=1){return t in this.registryFactory?(sa(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:i,priority:o},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:i,asyncInit:o}=this.initializeBackend(t);if(!(o?await i:i))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new ol(this.backendInstance),!0}setupRegisteredKernels(){Zm(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Zm(t).forEach(i=>{i.disposeFunc!=null&&i.disposeFunc(this.registry[t])})}initializeBackend(t){const i=this.registryFactory[t];if(i==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const o=i.factory();if(o&&!(o instanceof c)&&typeof o.then=="function"){const l=++this.pendingBackendInitId,u=o.then(f=>l<this.pendingBackendInitId?!1:(this.registry[t]=f,this.pendingBackendInit=null,!0)).catch(f=>(l<this.pendingBackendInitId||(this.pendingBackendInit=null,sa(`Initialization of backend ${t} failed`),sa(f.stack||f.message)),!1));return this.pendingBackendInit=u,{success:u,asyncInit:!0}}else return this.registry[t]=o,{success:!0,asyncInit:!1}}catch(o){return sa(`Initialization of backend ${t} failed`),sa(o.stack||o.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,i)=>this.registryFactory[i].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let i=0;i<t.length;i++){const o=t[i],{success:l,asyncInit:u}=this.initializeBackend(o);if(u||l)return{name:o,asyncInit:u}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,i){const o=this.state.tensorInfo.get(i),l=o.backend,u=this.readSync(i),f=l.refCount(i);l.disposeData(i,!0),o.backend=t,t.move(i,u,o.shape,o.dtype,f),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,i){let o=null;if(i==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");i=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof i!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=t}let l;return this.scopedRun(()=>this.startScope(o),()=>this.endScope(l),()=>(l=i(),l instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),l))}scopedRun(t,i,o){t();try{const l=o();return i(),l}catch(l){throw i(),l}}nextTensorId(){return po.nextTensorId++}nextVariableId(){return po.nextVariableId++}clone(t){const i=ze.runKernel(Sr,{x:t}),o={x:t},l=f=>({x:()=>{const g="float32",A={x:f},v={dtype:g};return ze.runKernel(qt,A,v)}}),u=[];return this.addTapeNode(this.state.activeScope.name,o,[i],l,u,{}),i}runKernel(t,i,o){if(this.backendName==null&&this.backend,EA(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:i,attrs:o})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,i,o){const l=this.backend.numDataIds();let u=0;o.forEach(A=>{u+=A.dtype==="complex64"?3:1});const f=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],g=l-i-u-f;if(g>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${g} data ids) after running '${t}'`)}runKernelFunc(t){let i,o=[];const l=this.isTapeOn(),u=this.state.numBytes,f=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let g;this.backendName==null&&this.backend;let A;const v=FA(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(FA(t)){const{kernelName:B,inputs:F,attrs:P}=t;this.backendName==null&&this.backend;const U=EA(B,this.backendName);E(U!=null,()=>`Cannot find registered kernel '${B}' for backend '${this.backendName}'`),g=()=>{const V=this.backend.numDataIds();A=U.kernelFunc({inputs:F,attrs:P,backend:this.backend});const $=Array.isArray(A)?A:[A];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(B,V,$);const q=$.map(ne=>ne.rank!=null?ne:this.makeTensorFromTensorInfo(ne));if(l){const ne=this.getTensorsForGradient(B,F,q);o=this.saveTensorsForBackwardMode(ne)}return q}}else{const{forwardFunc:B}=t,F=P=>{l&&(o=P.map(U=>this.keep(this.clone(U))))};g=()=>{const P=this.backend.numDataIds();A=this.tidy(()=>B(this.backend,F));const U=Array.isArray(A)?A:[A];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(v,P,U),U}}const{inputs:C,attrs:S}=t,M=FA(t)?null:t.backwardsFunc;let _;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?i=g():(_=this.profiler.profileKernel(v,C,()=>g()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(_),i=_.outputs)}),l&&this.addTapeNode(v,C,i,M,o,S),this.state.profiling&&this.state.activeProfile.kernels.push({name:v,bytesAdded:this.state.numBytes-u,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-f,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(C).map(B=>C[B]!=null?C[B].shape:null),outputShapes:i.map(B=>B.shape),kernelTimeMs:_.timeMs,extraInfo:_.extraInfo}),Array.isArray(A)?i:i[0]}saveTensorsForBackwardMode(t){return t.map(i=>this.keep(this.clone(i)))}getTensorsForGradient(t,i,o){const l=Fu(t);if(l!=null){const u=l.inputsToSave||[],f=l.outputsToSave||[];let g;l.saveAllInputs?(E(Array.isArray(i),()=>"saveAllInputs is true, expected inputs to be an array."),g=Object.keys(i).map(v=>i[v])):g=u.map(v=>i[v]);const A=o.filter((v,C)=>f[C]);return g.concat(A)}return[]}makeTensor(t,i,o,l){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");o=o||"float32",l=l||this.backend;let u=t;o==="string"&&de(t[0])&&(u=t.map(A=>ri(A)));const f=l.write(u,i,o),g=new Ci(i,o,f,this.nextTensorId());if(this.trackTensor(g,l),o==="string"){const A=this.state.tensorInfo.get(f),v=rt(u);this.state.numBytes+=v-A.bytes,A.bytes=v}return g}makeTensorFromDataId(t,i,o,l){o=o||"float32";const u={dataId:t,shape:i,dtype:o};return this.makeTensorFromTensorInfo(u,l)}makeTensorFromTensorInfo(t,i){const{dataId:o,shape:l,dtype:u}=t,f=new Ci(l,u,o,this.nextTensorId());return this.trackTensor(f,i),f}makeVariable(t,i=!0,o,l){o=o||this.nextVariableId().toString(),l!=null&&l!==t.dtype&&(t=t.cast(l));const u=new zf(t,i,o,this.nextTensorId());if(this.state.registeredVariables[u.name]!=null)throw new Error(`Variable with name ${u.name} was already registered`);return this.state.registeredVariables[u.name]=u,this.incRef(u,this.backend),u}trackTensor(t,i){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let o=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(o=t.size*Pe(t.dtype)),this.state.numBytes+=o,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:i||this.backend,dtype:t.dtype,shape:t.shape,bytes:o})),t instanceof zf||this.track(t)}incRef(t,i){this.trackTensor(t,i),this.backend.incRef(t.dataId)}removeDataId(t,i){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===i&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const i=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=i.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const o=t.size*Pe(t.dtype);this.state.numBytes-=o}i.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,i.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const i=this.state.registeredVariables[t];this.disposeVariable(i)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const i=this.state.numBytes,o=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(l=>l.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-i,this.state.activeProfile.newTensors=this.state.numTensors-o;for(const l of this.state.activeProfile.kernels)l.kernelTimeMs=await l.kernelTimeMs,l.extraInfo=await l.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,i,o,l,u,f){const g={id:this.state.nextTapeNodeId++,kernelName:t,inputs:i,outputs:o,saved:u},A=Fu(t);A!=null&&(l=A.gradFunc),l!=null&&(g.gradient=v=>(v=v.map((C,S)=>{if(C==null){const M=o[S],_=Tt(M.size,M.dtype);return this.makeTensor(_,M.shape,M.dtype)}return C}),l(v.length>1?v:v[0],u,f))),this.state.activeTape.push(g)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const i={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(i.name=t),this.state.scopeStack.push(i),this.state.activeScope=i}endScope(t){const i=Xu(t),o=new Set(i.map(u=>u.id));for(let u=0;u<this.state.activeScope.track.length;u++){const f=this.state.activeScope.track[u];!f.kept&&!o.has(f.id)&&f.dispose()}const l=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],i.forEach(u=>{!u.kept&&u.scopeId===l.id&&this.track(u)})}gradients(t,i,o,l=!1){if(E(i.length>0,()=>"gradients() received an empty list of xs."),o!=null&&o.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${o.dtype}'`);const u=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));E(u instanceof Ci,()=>"The result y returned by f() must be a tensor.");const f=ex(this.state.activeTape,i,u);if(!l&&f.length===0&&i.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const g={};g[u.id]=o??GA(u.shape),tx(g,f,v=>this.tidy(v),Qf);const A=i.map(v=>g[v.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(v=>{for(const C of v.saved)C.dispose()}),this.state.activeTape=null),{value:u,grads:A}})}customGrad(t){return E(fe(t),()=>"The f passed in customGrad(f) must be a function."),(...i)=>{E(i.every(g=>g instanceof Ci),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let o;const l={};i.forEach((g,A)=>{l[A]=g});const u=(g,A)=>(o=t(...i,A),E(o.value instanceof Ci,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),E(fe(o.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o.value),f=(g,A)=>{const v=o.gradFunc(g,A),C=Array.isArray(v)?v:[v];E(C.length===i.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),E(C.every(M=>M instanceof Ci),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const S={};return C.forEach((M,_)=>{S[_]=()=>M}),S};return this.runKernelFunc({forwardFunc:u,backwardsFunc:f,inputs:l})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,i){return this.state.tensorInfo.get(t).backend.readToGPU(t,i)}async time(t){const i=wi(),o=await this.backend.time(t);return o.wallMs=wi()-i,o}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new OA;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}po.nextTensorId=0,po.nextVariableId=0;function GA(s){const t=zt(N(s),"float32");return ze.makeTensor(t,s,"float32")}function Xf(){const s=Ae();if(s._tfengine==null){const t=new Mt(s);s._tfengine=new po(t)}return Z(s._tfengine.ENV),Jm(()=>s._tfengine),s._tfengine}const ze=Xf();function Qf(s,t){const i={a:s,b:t};return ze.runKernel(se,i)}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rx(){return typeof navigator<"u"&&navigator!=null}function Kf(s){if(s||rx()){if(s||(s=navigator),s.product==="ReactNative")return!0;const t=s.userAgent||s.vendor||(typeof window<"u"?window.opera:"");if(!t){const i=s;return i.userAgentData&&i.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function eg(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $r=Ee();$r.registerFlag("DEBUG",()=>!1,s=>{s&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),$r.registerFlag("IS_BROWSER",()=>eg()),$r.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),$r.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),$r.registerFlag("PROD",()=>!1),$r.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>$r.getBool("DEBUG")),$r.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),$r.registerFlag("IS_TEST",()=>!1),$r.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),$r.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),$r.registerFlag("ENGINE_COMPILE_ONLY",()=>!1),$r.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),$r.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Bc(s,t){let i=s;if(_e(s))return t==="string"?[]:[s.length];if(!Array.isArray(s))return[];const o=[];for(;Array.isArray(i)||_e(i)&&t!=="string";)o.push(i.length),i=i[0];return Array.isArray(s)&&Ee().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&UA(s,o,[]),o}function UA(s,t,i){if(i=i||[],!Array.isArray(s)&&!_e(s)){E(t.length===0,()=>`Element arr[${i.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}E(t.length>0,()=>`Element arr[${i.join("][")}] should be a primitive, but is an array of ${s.length} elements`),E(s.length===t[0],()=>`Element arr[${i.join("][")}] should have ${t[0]} elements, but has ${s.length} elements`);const o=t.slice(1);for(let l=0;l<s.length;++l)UA(s[l],o,i.concat(l))}function Zh(s,t,i,o){if(s!=="string_or_numeric"){if(s==null)throw new Error("Expected dtype cannot be null.");if(s!=="numeric"&&s!==t||s==="numeric"&&t==="string")throw new Error(`Argument '${i}' passed to '${o}' must be ${s} tensor, but got ${t} tensor`)}}function Se(s,t,i,o="numeric"){if(s instanceof Ci)return Zh(o,s.dtype,t,i),s;let l=Je(s);if(l!=="string"&&["bool","int32","float32"].indexOf(o)>=0&&(l=o),Zh(o,l,t,i),s==null||!_e(s)&&!Array.isArray(s)&&typeof s!="number"&&typeof s!="boolean"&&typeof s!="string"){const g=s==null?"null":s.constructor.name;throw new Error(`Argument '${t}' passed to '${i}' must be a Tensor or TensorLike, but got '${g}'`)}const u=Bc(s,l);!_e(s)&&!Array.isArray(s)&&(s=[s]);const f=l!=="string"?Gs(s,l):G(s,[],!0);return ze.makeTensor(f,u,l)}function PA(s,t,i,o="numeric"){if(!Array.isArray(s))throw new Error(`Argument ${t} passed to ${i} must be a \`Tensor[]\` or \`TensorLike[]\``);return s.map((l,u)=>Se(l,`${t}[${u}]`,i,o))}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Lc="__op";function Qe(s){const t=Object.keys(s);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let i=t[0];const o=s[i];i.endsWith("_")&&(i=i.substring(0,i.length-1)),i=i+Lc;const l=(...u)=>{ze.startScope(i);try{const f=o(...u);return on(f)&&console.error("Cannot return a Promise inside of tidy."),ze.endScope(f),f}catch(f){throw ze.endScope(null),f}};return Object.defineProperty(l,"name",{value:i,configurable:!0}),l}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zA(s,t){const i=Se(s,"real","complex"),o=Se(t,"imag","complex");R(i.shape,o.shape,`real and imag shapes, ${i.shape} and ${o.shape}, must match in call to tf.complex().`);const l={real:i,imag:o};return ze.runKernel(Ki,l)}const La=Qe({complex_:zA});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mo(s,t,i,o){if(o==null&&(o=Je(s)),o==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!_e(s)&&!Array.isArray(s)&&typeof s!="number"&&typeof s!="boolean"&&typeof s!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){je(t);const l=N(t),u=N(i);E(l===u,()=>`Based on the provided shape, [${t}], the tensor should have ${l} values but has ${u}`);for(let f=0;f<i.length;++f){const g=i[f],A=f===i.length-1?g!==N(t.slice(f)):!0;E(i[f]===t[f]||!A,()=>`Error creating a new Tensor. Inferred shape (${i}) does not match the provided shape (${t}). `)}}return!_e(s)&&!Array.isArray(s)&&(s=[s]),t=t||i,s=o!=="string"?Gs(s,o):G(s,[],!0),ze.makeTensor(s,t,o)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ur(s,t,i){const o=Bc(s,i);return mo(s,t,o,i)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tg=4;async function ng(s,t){const i=[],o=[],l=Array.isArray(s)?s.map(f=>f.name):Object.keys(s);for(let f=0;f<l.length;++f){const g=l[f],A=Array.isArray(s)?s[f].tensor:s[g];if(A.dtype!=="float32"&&A.dtype!=="int32"&&A.dtype!=="bool"&&A.dtype!=="string"&&A.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${g}': ${A.dtype}`);const v={name:g,shape:A.shape,dtype:A.dtype};if(A.dtype==="string"){const C=new Promise(async S=>{const M=await A.bytes(),_=M.reduce((P,U)=>P+U.length,0)+tg*M.length,B=new Uint8Array(_);let F=0;for(let P=0;P<M.length;P++){const U=M[P],V=new Uint8Array(new Uint32Array([U.length]).buffer);B.set(V,F),F+=tg,B.set(U,F),F+=U.length}S(B)});o.push(C)}else o.push(A.data());t!=null&&(v.group=t),i.push(v)}const u=await Promise.all(o);return{data:Zf(u),specs:i}}function Zf(s){if(s===null)throw new Error(`Invalid input value: ${JSON.stringify(s)}`);let t=0;const i=[];s.forEach(u=>{if(t+=u.byteLength,i.push(u.byteLength===u.buffer.byteLength?u:new u.constructor(u)),!(u instanceof Float32Array||u instanceof Int32Array||u instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${u.constructor.name}`)});const o=new Uint8Array(t);let l=0;return i.forEach(u=>{o.set(new Uint8Array(u.buffer),l),l+=u.byteLength}),o.buffer}const Qu=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function VA(s){return Qu?Buffer.byteLength(s):new Blob([s]).size}function ax(s){if(Qu)return Buffer.from(s).toString("base64");const t=new Uint8Array(s);let i="";for(let o=0,l=t.length;o<l;o++)i+=String.fromCharCode(t[o]);return btoa(i)}function $h(s){if(Qu){const o=Buffer.from(s,"base64");return o.buffer.slice(o.byteOffset,o.byteOffset+o.byteLength)}const t=atob(s),i=new Uint8Array(t.length);for(let o=0;o<t.length;++o)i.set([t.charCodeAt(o)],o);return i.buffer}function ig(s){if(s.length===1)return s[0];let t=0;s.forEach(l=>{t+=l.byteLength});const i=new Uint8Array(t);let o=0;return s.forEach(l=>{i.set(new Uint8Array(l),o),o+=l.byteLength}),i.buffer}function WA(s){if(s.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:s.modelTopology==null?0:VA(JSON.stringify(s.modelTopology)),weightSpecsBytes:s.weightSpecs==null?0:VA(JSON.stringify(s.weightSpecs)),weightDataBytes:s.weightData==null?0:s.weightData.byteLength}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class pr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return pr.instance==null&&(pr.instance=new pr),pr.instance}static registerSaveRouter(t){pr.getInstance().saveRouters.push(t)}static registerLoadRouter(t){pr.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return pr.getHandlers(t,"save")}static getLoadHandlers(t,i){return pr.getHandlers(t,"load",i)}static getHandlers(t,i,o){const l=[];return(i==="load"?pr.getInstance().loadRouters:pr.getInstance().saveRouters).forEach(u=>{const f=u(t,o);f!==null&&l.push(f)}),l}}const HA=s=>pr.getSaveHandlers(s);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ul="tensorflowjs",ai=1,_i="models_store",as="model_info_store";function $f(){if(!Ee().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const s=typeof window>"u"?self:window,t=s.indexedDB||s.mozIndexedDB||s.webkitIndexedDB||s.msIndexedDB||s.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Nc(s){const t=s.result;t.createObjectStore(_i,{keyPath:"modelPath"}),t.createObjectStore(as,{keyPath:"modelPath"})}class Na{constructor(t){if(this.indexedDB=$f(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,i){return new Promise((o,l)=>{const u=this.indexedDB.open(ul,ai);u.onupgradeneeded=()=>Nc(u),u.onsuccess=()=>{const f=u.result;if(i==null){const g=f.transaction(_i,"readonly"),A=g.objectStore(_i).get(this.modelPath);A.onsuccess=()=>{if(A.result==null)return f.close(),l(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));o(A.result.modelArtifacts)},A.onerror=v=>(f.close(),l(A.error)),g.oncomplete=()=>f.close()}else{const g=WA(i),A=f.transaction(as,"readwrite");let v=A.objectStore(as);const C=v.put({modelPath:this.modelPath,modelArtifactsInfo:g});let S;C.onsuccess=()=>{S=f.transaction(_i,"readwrite");const M=S.objectStore(_i).put({modelPath:this.modelPath,modelArtifacts:i,modelArtifactsInfo:g});M.onsuccess=()=>o({modelArtifactsInfo:g}),M.onerror=_=>{v=A.objectStore(as);const B=v.delete(this.modelPath);B.onsuccess=()=>(f.close(),l(M.error)),B.onerror=F=>(f.close(),l(M.error))}},C.onerror=M=>(f.close(),l(C.error)),A.oncomplete=()=>{S==null?f.close():S.oncomplete=()=>f.close()}}},u.onerror=f=>l(u.error)})}}Na.URL_SCHEME="indexeddb://";const Yf=s=>Ee().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(Na.URL_SCHEME)?jf(s.slice(Na.URL_SCHEME.length)):null;pr.registerSaveRouter(Yf),pr.registerLoadRouter(Yf);function jf(s){return new Na(s)}function Yh(s){return s.startsWith(Na.URL_SCHEME)?s.slice(Na.URL_SCHEME.length):s}class iS{constructor(){this.indexedDB=$f()}async listModels(){return new Promise((t,i)=>{const o=this.indexedDB.open(ul,ai);o.onupgradeneeded=()=>Nc(o),o.onsuccess=()=>{const l=o.result,u=l.transaction(as,"readonly"),f=u.objectStore(as).getAll();f.onsuccess=()=>{const g={};for(const A of f.result)g[A.modelPath]=A.modelArtifactsInfo;t(g)},f.onerror=g=>(l.close(),i(f.error)),u.oncomplete=()=>l.close()},o.onerror=l=>i(o.error)})}async removeModel(t){return t=Yh(t),new Promise((i,o)=>{const l=this.indexedDB.open(ul,ai);l.onupgradeneeded=()=>Nc(l),l.onsuccess=()=>{const u=l.result,f=u.transaction(as,"readwrite"),g=f.objectStore(as),A=g.get(t);let v;A.onsuccess=()=>{if(A.result==null)return u.close(),o(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const C=g.delete(t),S=()=>{v=u.transaction(_i,"readwrite");const M=v.objectStore(_i).delete(t);M.onsuccess=()=>i(A.result.modelArtifactsInfo),M.onerror=_=>o(A.error)};C.onsuccess=S,C.onerror=M=>(S(),u.close(),o(A.error))}},A.onerror=C=>(u.close(),o(A.error)),f.oncomplete=()=>{v==null?u.close():v.oncomplete=()=>u.close()}},l.onerror=u=>o(l.error)})}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Yi="/",Dc="tensorflowjs_models",sg="info",ox="model_topology",lx="weight_specs",sS="weight_data",XA="model_metadata";function rg(s){return{info:[Dc,s,sg].join(Yi),topology:[Dc,s,ox].join(Yi),weightSpecs:[Dc,s,lx].join(Yi),weightData:[Dc,s,sS].join(Yi),modelMetadata:[Dc,s,XA].join(Yi)}}function ag(s){for(const t of Object.values(s))window.localStorage.removeItem(t)}function la(s){const t=s.split(Yi);if(t.length<3)throw new Error(`Invalid key format: ${s}`);return t.slice(1,t.length-1).join(Yi)}function js(s){return s.startsWith(Gl.URL_SCHEME)?s.slice(Gl.URL_SCHEME.length):s}class Gl{constructor(t){if(!Ee().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=rg(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const i=JSON.stringify(t.modelTopology),o=JSON.stringify(t.weightSpecs),l=WA(t);try{this.LS.setItem(this.keys.info,JSON.stringify(l)),this.LS.setItem(this.keys.topology,i),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,ax(t.weightData));const u={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(u)),{modelArtifactsInfo:l}}catch{throw ag(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${l.modelTopologyBytes}, weightSpecsBytes=${l.weightSpecsBytes}, weightDataBytes=${l.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const i={},o=JSON.parse(this.LS.getItem(this.keys.topology));if(o==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);i.modelTopology=o;const l=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(l==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);i.weightSpecs=l;const u=this.LS.getItem(this.keys.modelMetadata);if(u!=null){const g=JSON.parse(u);i.format=g.format,i.generatedBy=g.generatedBy,i.convertedBy=g.convertedBy,g.signature!=null&&(i.signature=g.signature),g.userDefinedMetadata!=null&&(i.userDefinedMetadata=g.userDefinedMetadata),g.modelInitializer!=null&&(i.modelInitializer=g.modelInitializer),g.trainingConfig!=null&&(i.trainingConfig=g.trainingConfig)}const f=this.LS.getItem(this.keys.weightData);if(f==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return i.weightData=$h(f),i}}Gl.URL_SCHEME="localstorage://";const jh=s=>Ee().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(Gl.URL_SCHEME)?og(s.slice(Gl.URL_SCHEME.length)):null;pr.registerSaveRouter(jh),pr.registerLoadRouter(jh);function og(s){return new Gl(s)}class QA{constructor(){E(Ee().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),E(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},i=Dc+Yi,o=Yi+sg;for(let l=0;l<this.LS.length;++l){const u=this.LS.key(l);if(u.startsWith(i)&&u.endsWith(o)){const f=la(u);t[f]=JSON.parse(this.LS.getItem(u))}}return t}async removeModel(t){t=js(t);const i=rg(t);if(this.LS.getItem(i.info)==null)throw new Error(`Cannot find model at path '${t}'`);const o=JSON.parse(this.LS.getItem(i.info));return ag(i),o}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hl="://";class Da{constructor(){this.managers={}}static getInstance(){return Da.instance==null&&(Da.instance=new Da),Da.instance}static registerManager(t,i){E(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(hl)&&(t=t.slice(0,t.indexOf(hl))),E(t.length>0,()=>"scheme must not be an empty string.");const o=Da.getInstance();E(o.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),o.managers[t]=i}static getManager(t){const i=Da.getInstance().managers[t];if(i==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return i}static getSchemes(){return Object.keys(Da.getInstance().managers)}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class KA{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,i){return fetch(t,i)}now(){return performance.now()}encode(t,i){if(i!=="utf-8"&&i!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${i}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,i){return new TextDecoder(i).decode(t)}setTimeoutCustom(t,i){if(!window||!Ee().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,i);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},i),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",o=>{if(o.source===window&&o.data.name===this.messageName){o.stopPropagation();const l=this.functionRefs[o.data.index];l(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}}if(Ee().get("IS_BROWSER")){Ee().setPlatform("browser",new KA);try{Da.registerManager(Gl.URL_SCHEME,new QA)}catch{}try{Da.registerManager(Na.URL_SCHEME,new iS)}catch{}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ZA={importFetch:()=>gye()};let lg;class cx{constructor(){this.util=yye,this.textEncoder=new this.util.TextEncoder}fetch(t,i){return Ee().global.fetch!=null?Ee().global.fetch(t,i):(lg==null&&(lg=ZA.importFetch()),lg(t,i))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,i){if(i!=="utf-8"&&i!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${i}`);return this.textEncoder.encode(t)}decode(t,i){return t.length===0?"":new this.util.TextDecoder(i).decode(t)}}Ee().get("IS_NODE")&&!Ee().get("IS_BROWSER")&&Ee().setPlatform("node",new cx);/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function On(s,t="float32",i){return t=t||"float32",je(s),new Hs(s,t,i)}/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ux(s,t){const i=Se(s,"x","cast");if(!ue(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&i.dtype!=="string"||t!=="string"&&i.dtype==="string")throw new Error("Only strings can be casted to strings");const o={x:i},l={dtype:t};return ze.runKernel(qt,o,l)}const hn=Qe({cast_:ux});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hx(s){const t={x:Se(s,"x","clone","string_or_numeric")};return ze.runKernel(Sr,t)}const Ul=Qe({clone_:hx});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dx(s,t=!1){console.log(s.toString(t))}/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Xf(),Hu({buffer:On,cast:hn,clone:Ul,print:dx});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rS(s,t,i=!1,o=!1){let l=Se(s,"a","matMul"),u=Se(t,"b","matMul");[l,u]=rs(l,u);const f={a:l,b:u},g={transposeA:i,transposeB:o};return ze.runKernel(jt,f,g)}const Li=Qe({matMul_:rS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fx(s,t,i=1,o=0,l="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const u={indices:Se(s,"indices","oneHot","int32")},f={dtype:l,depth:t,onValue:i,offValue:o};return ze.runKernel(Tc,u,f)}const $A=Qe({oneHot_:fx});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function os(){return ze}function cg(){return ze.memory()}function $e(s,t){return ze.tidy(s,t)}function ci(s){Xu(s).forEach(t=>t.dispose())}function ca(s){return ze.keep(s)}function YA(s,t,i=1){return ze.registerBackend(s,t,i)}function Fc(){return ze.backend}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function px(s){const t={input:Se(s,"input","imag")};return ze.runKernel(Xr,t)}const Oc=Qe({imag_:px});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ug(s){const t={x:Se(s,"x","neg")};return ze.runKernel(sl,t)}const Us=Qe({neg_:ug});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hg(s){const t={input:Se(s,"input","real")};return ze.runKernel(dA,t)}const Gc=Qe({real_:hg});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mx(s,t,i){const o=Se(s,"x","transpose");if(t==null&&(t=o.shape.map((f,g)=>g).reverse()),E(o.rank===t.length,()=>`Error in transpose: rank of input ${o.rank} must match length of perm ${t}.`),t.forEach(f=>{E(f>=0&&f<o.rank,()=>`All entries in 'perm' must be between 0 and ${o.rank-1} but got ${t}`)}),o.rank<=1)return o.clone();const l={x:o},u={perm:t};return o.dtype==="complex64"?$e(()=>{let f=Gc(o),g=Oc(o);return f=ze.runKernel(Du,{x:f},u),g=ze.runKernel(Du,{x:g},u),i&&(g=Us(g)),La(f,g)}):ze.runKernel(Du,l,u)}const bi=Qe({transpose_:mx});/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pl(s,t){const i=s.length,o=[];for(let l=0;l<i;l++){const u=i-1-l,f=s[u]||1;(t[t.length-1-l]||1)>1&&f===1&&o.unshift(u)}return o}function Qs(s,t){const i=[];for(let o=0;o<t.length;o++){const l=s[s.length-o-1],u=t.length-o-1,f=t[u];(l==null||l===1&&f>1)&&i.unshift(u)}return i}function $n(s,t){const i=[],o=Math.max(s.length,t.length);for(let l=0;l<o;l++){let u=s[s.length-l-1];u==null&&(u=1);let f=t[t.length-l-1];if(f==null&&(f=1),u===1)i.unshift(f);else if(f===1)i.unshift(u);else if(u!==f){const g=`Operands could not be broadcast together with shapes ${s} and ${t}.`;throw Error(g)}else i.unshift(u)}return i}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gx(s,t,i){if(k(s),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const o=Bc(s,i);if(o.length!==3&&o.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(o.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return mo(s,t,o,i)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let zl;function Ax(s,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let i=!1,o=!1,l=!1,u=!1,f=!1,g=!1;if(s.data instanceof Uint8Array)i=!0;else if(typeof ImageData<"u"&&s instanceof ImageData)o=!0;else if(typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement)l=!0;else if(typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement)u=!0;else if(s.getContext!=null)f=!0;else if(typeof ImageBitmap<"u"&&s instanceof ImageBitmap)g=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${s.constructor.name}`);if(EA(xA,ze.backendName)!=null){const M={pixels:s},_={numChannels:t};return ze.runKernel(xA,M,_)}const[A,v]=l?[s.videoWidth,s.videoHeight]:[s.width,s.height];let C;if(f)C=s.getContext("2d").getImageData(0,0,A,v).data;else if(o||i)C=s.data;else if(u||l||g){if(zl==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")zl=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else zl=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});zl.canvas.width=A,zl.canvas.height=v,zl.drawImage(s,0,0,A,v),C=zl.getImageData(0,0,A,v).data}let S;if(t===4)S=new Int32Array(C);else{const M=A*v;S=new Int32Array(M*t);for(let _=0;_<M;_++)for(let B=0;B<t;++B)S[_*t+B]=C[_*4+B]}return gx(S,[v,A,t],"int32")}const bx=Qe({fromPixels_:Ax});function qf(s,t){const i=s.shape.length,o=t.shape.length;if(i<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${i}.`);if(o<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${o}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[o-1]>i)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[o-1]} vs. ${i}`);if(N(s.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${s.shape}.`);const l=t.shape,u=l[l.length-1];let f=1;for(let S=0;S<l.length-1;++S)f*=l[S];const g=s.shape,A=l.slice();A.pop();let v=1;for(let S=u;S<i;++S)v*=g[S],A.push(g[S]);const C=[...Ne(s.shape).map(S=>S/v),1].slice(0,u);return[A,f,v,C]}function jA(s,t,i){const o=t.rank>1?t.shape[t.rank-1]:1,l=t.rank>1?t.rank-1:1,u=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${i.shape}, indices.shape: ${t.shape}, shape: ${s}, sliceDim: ${o}, and batchDim: ${l}.`;if(i.rank<l)throw new Error(u+` update.rank < ${l}. `);if(s.length<o+(i.rank-l))throw new Error(u+` Output shape length < ${o+(i.rank-l)}`);if(i.rank!==l+s.length-o)throw new Error(u+` update.rank != ${l+s.length-o}`);for(let f=0;f<l;++f)if(i.shape[f]!==t.shape[f])throw new Error(u+` updates.shape[${f}] (${i.shape[f]}) != indices.shape[${f}] (${t.shape[f]}).`);for(let f=0;f<i.rank-l;++f)if(i.shape[f+l]!==s[f+o])throw new Error(u+` updates.shape[${f+l}] (${i.shape[f+l]}) != shape[${f+l}] (${s[f+l]})`)}function yx(s,t,i){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(s.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${s.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(i.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${i}`);if(i.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(s.size===0)throw new Error(`Updates specified for empty output. updates shape: ${s.shape}`)}jA(i,t,s)}function Jf(s,t,i){const o=t.shape.length,l=o>1?t.shape[o-1]:1,u=i.length;let f=1;for(let S=l;S<u;++S)f*=i[S];const g=l<1?1:l,A=N(t.shape)/g,v=[...Ne(i.slice(0,l)),1],C=N(i);return{sliceRank:l,numUpdates:A,sliceSize:f,strides:v,outputSize:C}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ep=-2,vx=-1;function dg(s,t,i){const o=s.shape.length;E(o===t.length,()=>`Error in slice${o}D: Length of begin ${t} must match the rank of the array (${o}).`),E(o===i.length,()=>`Error in slice${o}D: Length of size ${i} must match the rank of the array (${o}).`);for(let l=0;l<o;++l)E(t[l]+i[l]<=s.shape[l],()=>`Error in slice${o}D: begin[${l}] + size[${l}] (${t[l]+i[l]}) would overflow input.shape[${l}] (${s.shape[l]})`)}function qA(s){const t=[];let i=0;for(;s>0;)s&1&&t.push(i),s/=2,i++;return t}function fg(s,t,i){const o=[];for(let l=0;l<s.length;l++)o[l]=Math.ceil((t[l]-s[l])/i[l]);return o}function JA(s,t,i,o){const l=[...s];for(let u=l.length;u<o.length;u++)l.push(1);for(let u=0;u<i;u++)u===0?l[t]=1:(l.splice(t,0,1),l.pop());return l}function xx(s,t,i){return i<=s?i:i-(t-1)}function wx(s,t){const i=[];for(let o=0;o<s;o++)i.push(t+o);return i}function Cx(s,t,i,o,l,u,f,g,A){const v=s.length;let C=new Array(v),S=new Array(v),M=new Array(v);if(t.length&&i>0){const _=t[0],B=i+1;C=qh(f,_,B,o,s),S=pg(g,_,B,l,s),M=JA(u,_,B,s)}else for(let _=0;_<v;_++)C[_]=eb(f,o,u,s,_,A),S[_]=tb(g,l,u,s,_,A),M[_]=tp(u,_,A);return{begin:C,end:S,strides:M}}function qh(s,t,i,o,l){const u=[...l],f=wx(i,t);for(let g=0;g<u.length;g++)if(f.indexOf(g)>-1)u[g]=0;else{const A=xx(t,i,g);let v=o[A];s&1<<A&&(v=0),u[g]=v}return u}function pg(s,t,i,o,l){const u=[...l],f=wx(i,t);for(let g=0;g<u.length;g++)if(f.indexOf(g)>-1)u[g]=Number.MAX_SAFE_INTEGER;else{const A=xx(t,i,g);let v=o[A];s&1<<A&&(v=Number.MAX_SAFE_INTEGER),u[g]=v}for(let g=0;g<u.length;g++){const A=l[g];u[g]<0&&(u[g]+=A),u[g]=b(0,u[g],l[g])}return u}function tp(s,t,i){let o=s[t];return(i&1<<t||o==null)&&(o=1),o}function eb(s,t,i,o,l,u){let f=t[l];const g=i[l]||1;(s&1<<l||u&1<<l||f==null)&&(g>0?f=Number.MIN_SAFE_INTEGER:f=Number.MAX_SAFE_INTEGER);const A=o[l];return f<0&&(f+=A),f=b(0,f,A-1),f}function tb(s,t,i,o,l,u){let f=t[l];const g=i[l]||1;(s&1<<l||u&1<<l||f==null)&&(g>0?f=Number.MAX_SAFE_INTEGER:f=Number.MIN_SAFE_INTEGER);const A=o[l];return f<0&&(f+=A),g>0?f=b(0,f,A):f=b(-1,f,A-1),f}function Ku(s,t,i){let o=i.length;for(let l=0;l<i.length;l++)if(i[l]>1){o=l;break}for(let l=o+1;l<i.length;l++)if(t[l]>0||i[l]!==s[l])return!1;return!0}function np(s,t){let i=s.length>0?s[s.length-1]:1;for(let o=0;o<s.length-1;o++)i+=s[o]*t[o];return i}function ip(s,t,i){let o;const l=s.shape.length;typeof t=="number"?o=[t,...new Array(l-1).fill(0)]:t.length<l?o=t.concat(new Array(l-t.length).fill(0)):o=t.slice(),o.forEach(f=>{E(f!==-1,()=>"slice() does not support negative begin indexing.")});let u;return i==null?u=new Array(l).fill(-1):typeof i=="number"?u=[i,...new Array(l-1).fill(-1)]:i.length<l?u=i.concat(new Array(l-i.length).fill(-1)):u=i,u=u.map((f,g)=>f>=0?f:(E(f===-1,()=>`Negative size values should be exactly -1 but got ${f} for the slice() size at index ${g}.`),s.shape[g]-o[g])),[o,u]}function nb(s,t,i,o,l,u,f,g,A){let v;if(o==null?(v=new Array(t.length),v.fill(1)):v=o,f!=null&&f&f-1)throw new Error("Multiple ellipses in slice is not allowed.");let C=!1;const S={dims:v.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:i.slice(),strides:v.slice(),beginMask:l,endMask:u,ellipsisMask:f,newAxisMask:g,shrinkAxisMask:A};for(let V=0;V<S.dims;V++)C&&1<<V&g&&S.numAddAxisAfterEllipsis++,1<<V&f&&(C=!0);C||(S.ellipsisMask|=1<<S.dims,S.dims++);const M={dims:s.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Jh(S,M);let _=!0,B=!0,F=!0;const P=[],U=[];for(let V=0;V<s.length;++V){if(M.strides[V]===0)throw Error(`strides[${V}] must be non-zero`);const $=!!(M.shrinkAxisMask&1<<V),q=s[V];if(q===-1){P.push($?1:-1);continue}const ne=[M.beginMask&1<<V,M.endMask&1<<V],he=[M.strides[V]>0?0:-1,M.strides[V]>0?q:q-1];if($&&M.strides[V]<=0)throw Error("only stride 1 allowed on non-range indexing.");F=F&&M.strides[V]===1;const me=!!(M.beginMask&1<<V&&M.endMask&1<<V);if(M.beginValid&&M.endValid){if($){const Ye=M.begin[V]<0?q+M.begin[V]:M.begin[V];if(M.begin[V]=Ye,M.end[V]=M.begin[V]+1,Ye<0||Ye>=q)throw Error(`slice index ${M.begin[V]} of dimension ${V} out of bounds.`)}else M.begin[V]=ed(M.begin[V],0,M.strides[V],q,ne,he),M.end[V]=ed(M.end[V],1,M.strides[V],q,ne,he);const Te=M.strides[V]===1&&M.begin[V]===0&&M.end[V]===q;_=_&&Te,B=B&&(V===0&&M.strides[V]===1||Te)}else _=_&&M.strides[V]===1&&me,B=B&&(V===0&&M.strides[V]===1||me);let pe,ye=!1;if(M.beginValid&&M.endValid?(pe=M.end[V]-M.begin[V],ye=!0):$?(pe=1,ye=!0):me&&q>=0&&(M.strides[V]<0?pe=-q:pe=q,ye=!0),ye){let Te;pe===0||pe<0!=M.strides[V]<0?Te=0:Te=Math.trunc(pe/M.strides[V])+(pe%M.strides[V]!==0?1:0),P.push(Te)}else P.push(-1)}for(let V=0;V<M.finalShapeGatherIndices.length;++V){const $=M.finalShapeGatherIndices[V];$>=0?U.push(P[$]):$===ep&&U.push(1)}return{finalShapeSparse:U.filter((V,$)=>M.finalShapeGatherIndices[$]!==ep),finalShape:U,isIdentity:_,sliceDim0:B,isSimpleSlice:F,begin:M.begin,end:M.end,strides:M.strides}}function Jh(s,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let i=0;t.beginValid=s.begin!=null,t.endValid=s.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let o=0;o<s.dims;o++)if(1<<o&s.ellipsisMask){const l=Math.min(t.dims-(s.dims-o)+1+s.numAddAxisAfterEllipsis,t.dims);for(;i<l;i++)t.begin[i]=0,t.end[i]=0,t.strides[i]=1,t.beginMask|=1<<i,t.endMask|=1<<i,t.finalShapeGatherIndices.push(i),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[i]=o}else if(1<<o&s.newAxisMask)t.finalShapeGatherIndices.push(ep),t.finalShapeGatherIndicesSparse.push(-1);else{if(i===t.begin.length)throw Error(`Index out of range using input dim ${i}; input has only ${t.dims} dims, ${t.begin.length}.`);s.begin!=null&&(t.begin[i]=s.begin[o]),s.end!=null&&(t.end[i]=s.end[o]),t.strides[i]=s.strides[o],s.beginMask&1<<o&&(t.beginMask|=1<<i),s.endMask&1<<o&&(t.endMask|=1<<i),s.shrinkAxisMask&1<<o?(t.finalShapeGatherIndices.push(vx),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<i):(t.finalShapeGatherIndices.push(i),t.finalShapeGatherIndicesSparse.push(o)),t.inputShapeGatherIndicesSparse[i]=o,i++}}function ed(s,t,i,o,l,u){if(l[t])return i>0?u[t]:u[t+1&1];{const f=s<0?o+s:s;return f<u[0]?u[0]:f>u[1]?u[1]:f}}const mg=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:dg,computeFlatOffset:np,computeOutShape:fg,getNormalizedAxes:Cx,isSliceContinous:Ku,maskToAxes:qA,parseSliceParams:ip,sliceInfo:nb,startForAxis:eb,startIndicesWithElidedDims:qh,stopForAxis:tb,stopIndicesWithElidedDims:pg,stridesForAxis:tp,stridesWithElidedDims:JA},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class dl{getClassName(){return this.constructor.className}static fromConfig(t,i){return new t(i)}}class Yr{constructor(){this.classNameMap={}}static getMap(){return Yr.instance==null&&(Yr.instance=new Yr),Yr.instance}static register(t){Yr.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Lt(s){E(s.className!=null,()=>"Class being registered does not have the static className property defined."),E(typeof s.className=="string",()=>"className is required to be a string, but got type "+typeof s.className),E(s.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Yr.register(s)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ex(s,t){let i=Se(s,"a","add"),o=Se(t,"b","add");[i,o]=rs(i,o);const l={a:i,b:o};return ze.runKernel(se,l)}const Ut=Qe({add_:Ex});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Sx(s,t){let i=Se(s,"a","floorDiv"),o=Se(t,"b","floorDiv");[i,o]=rs(i,o);const l={a:i,b:o};return ze.runKernel(ei,l)}const Fa=Qe({floorDiv_:Sx});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fl(s,t){let i=Se(s,"a","div"),o=Se(t,"b","div");if([i,o]=rs(i,o),i.dtype==="int32"&&o.dtype==="int32")return Fa(i,o);const l={a:i,b:o},u={};return ze.runKernel(ot,l,u)}const En=Qe({div_:fl});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ix(s,t){let i=Se(s,"a","mul"),o=Se(t,"b","mul");[i,o]=rs(i,o);const l={a:i,b:o};return ze.runKernel(dr,l)}const Oe=Qe({mul_:Ix});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vl(s){const t=Se(s,"x","abs");if(t.dtype==="complex64"){const i={x:t};return ze.runKernel(Ts,i)}else{const i={x:t};return ze.runKernel(At,i)}}const Ri=Qe({abs_:Vl});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gg(s){const t={x:Se(s,"x","acos")};return ze.runKernel(dn,t)}const ib=Qe({acos_:gg});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function sb(s){const t={x:Se(s,"x","acosh")};return ze.runKernel(ge,t)}const Tx=Qe({acosh_:sb});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mx(s,t=null,i=!1){const o={x:Se(s,"x","all","bool")},l={axis:t,keepDims:i};return ze.runKernel(ut,o,l)}const Uc=Qe({all_:Mx});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ag(s,t=null,i=!1){const o={x:Se(s,"x","any","bool")},l={axis:t,keepDims:i};return ze.runKernel(kt,o,l)}const bg=Qe({any_:Ag});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _x(s,t=0){const i={x:Se(s,"x","argMax")},o={axis:t};return ze.runKernel(xt,i,o)}const td=Qe({argMax_:_x});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yg(s,t=0){const i={x:Se(s,"x","argMin")},o={axis:t};return ze.runKernel(fn,i,o)}const Rx=Qe({argMin_:yg});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rb(s){const t={x:Se(s,"x","asin")};return ze.runKernel(Gt,t)}const kx=Qe({asin_:rb});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Bx(s){const t={x:Se(s,"x","asinh")};return ze.runKernel(Jt,t)}const aS=Qe({asinh_:Bx});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lx(s){const t={x:Se(s,"x","atan")};return ze.runKernel(Ln,t)}const mr=Qe({atan_:Lx});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mr(s,t){let i=Se(s,"a","atan2"),o=Se(t,"b","atan2");[i,o]=rs(i,o);const l={a:i,b:o};return ze.runKernel(bn,l)}const Nx=Qe({atan2_:Mr});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dx(s){const t={x:Se(s,"x","atanh")};return ze.runKernel(Zt,t)}const Fx=Qe({atanh_:Dx});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nd(s,t,i,o,l="NHWC",u){const f=s[3],g=[...t,f],A=pl(l);return qs(s,g,i,u,o,null,null,A)}function Oa(s,t,i,o,l,u,f="channelsLast"){const[g,A]=id(t);let v;if(f==="channelsLast")v=[g,A,s[3],s[3]];else if(f==="channelsFirst")v=[g,A,s[1],s[1]];else throw new Error(`Unknown dataFormat ${f}`);return qs(s,v,i,o,l,u,!1,f)}function go(s,t,i,o,l,u,f="NDHWC"){const[g,A,v]=rp(t);let C,S;if(f==="NDHWC")S="channelsLast",C=[g,A,v,s[4],s[4]];else if(f==="NCDHW")S="channelsFirst",C=[g,A,v,s[1],s[1]];else throw new Error(`Unknown dataFormat ${f}`);return Wl(s,C,i,o,l,!1,S,u)}function qs(s,t,i,o,l,u,f=!1,g="channelsLast"){let[A,v,C,S]=[-1,-1,-1,-1];if(g==="channelsLast")[A,v,C,S]=s;else if(g==="channelsFirst")[A,S,v,C]=s;else throw new Error(`Unknown dataFormat ${g}`);const[M,_,,B]=t,[F,P]=id(i),[U,V]=id(o),$=Zu(M,U),q=Zu(_,V),{padInfo:ne,outHeight:he,outWidth:me}=ab(l,v,C,F,P,$,q,u,g),pe=f?B*S:B;let ye;return g==="channelsFirst"?ye=[A,pe,he,me]:g==="channelsLast"&&(ye=[A,he,me,pe]),{batchSize:A,dataFormat:g,inHeight:v,inWidth:C,inChannels:S,outHeight:he,outWidth:me,outChannels:pe,padInfo:ne,strideHeight:F,strideWidth:P,filterHeight:M,filterWidth:_,effectiveFilterHeight:$,effectiveFilterWidth:q,dilationHeight:U,dilationWidth:V,inShape:s,outShape:ye,filterShape:t}}function Wl(s,t,i,o,l,u=!1,f="channelsLast",g){let[A,v,C,S,M]=[-1,-1,-1,-1,-1];if(f==="channelsLast")[A,v,C,S,M]=s;else if(f==="channelsFirst")[A,M,v,C,S]=s;else throw new Error(`Unknown dataFormat ${f}`);const[_,B,F,,P]=t,[U,V,$]=rp(i),[q,ne,he]=rp(o),me=Zu(_,q),pe=Zu(B,ne),ye=Zu(F,he),{padInfo:Te,outDepth:Ye,outHeight:et,outWidth:nt}=vg(l,v,C,S,U,V,$,me,pe,ye,g),ht=u?P*M:P;let ct;return f==="channelsFirst"?ct=[A,ht,Ye,et,nt]:f==="channelsLast"&&(ct=[A,Ye,et,nt,ht]),{batchSize:A,dataFormat:f,inDepth:v,inHeight:C,inWidth:S,inChannels:M,outDepth:Ye,outHeight:et,outWidth:nt,outChannels:ht,padInfo:Te,strideDepth:U,strideHeight:V,strideWidth:$,filterDepth:_,filterHeight:B,filterWidth:F,effectiveFilterDepth:me,effectiveFilterHeight:pe,effectiveFilterWidth:ye,dilationDepth:q,dilationHeight:ne,dilationWidth:he,inShape:s,outShape:ct,filterShape:t}}function Ox(s,t,i,o,l){o==null&&(o=sp(s,t,i));const u=s[0],f=s[1],g=Hl((u-t+2*o)/i+1,l),A=Hl((f-t+2*o)/i+1,l);return[g,A]}function Gx(s,t,i,o,l,u){l==null&&(l=sp(s,t,o));const f=s[0],g=s[1],A=s[2],v=Hl((f-t+2*l)/o+1,u),C=Hl((g-t+2*l)/o+1,u),S=Hl((A-t+2*l)/o+1,u);return[v,C,S,i]}function sp(s,t,i,o=1){const l=Zu(t,o);return Math.floor((s[0]*(i-1)-i+l)/2)}function id(s){return typeof s=="number"?[s,s,s]:s.length===2?[s[0],s[1],1]:s}function rp(s){return typeof s=="number"?[s,s,s]:s}function Zu(s,t){return t<=1?s:s+(s-1)*(t-1)}function ab(s,t,i,o,l,u,f,g,A){let v,C,S;if(typeof s=="number"){v={top:s,bottom:s,left:s,right:s,type:s===0?"VALID":"NUMBER"};const M=Ox([t,i],u,o,s,g);C=M[0],S=M[1]}else if(s==="same"){C=Math.ceil(t/o),S=Math.ceil(i/l);const M=Math.max(0,(C-1)*o+u-t),_=Math.max(0,(S-1)*l+f-i),B=Math.floor(M/2),F=M-B,P=Math.floor(_/2),U=_-P;v={top:B,bottom:F,left:P,right:U,type:"SAME"}}else if(s==="valid")v={top:0,bottom:0,left:0,right:0,type:"VALID"},C=Math.ceil((t-u+1)/o),S=Math.ceil((i-f+1)/l);else if(typeof s=="object"){const M=A==="channelsLast"?s[1][0]:s[2][0],_=A==="channelsLast"?s[1][1]:s[2][1],B=A==="channelsLast"?s[2][0]:s[3][0],F=A==="channelsLast"?s[2][1]:s[3][1];v={top:M,bottom:_,left:B,right:F,type:M===0&&_===0&&B===0&&F===0?"VALID":"EXPLICIT"},C=Hl((t-u+M+_)/o+1,g),S=Hl((i-f+B+F)/l+1,g)}else throw Error(`Unknown padding parameter: ${s}`);return{padInfo:v,outHeight:C,outWidth:S}}function vg(s,t,i,o,l,u,f,g,A,v,C){let S,M,_,B;if(typeof s=="number"){S={top:s,bottom:s,left:s,right:s,front:s,back:s,type:s===0?"VALID":"NUMBER"};const F=Gx([t,i,o,1],g,1,l,s,C);M=F[0],_=F[1],B=F[2]}else if(s==="same"){M=Math.ceil(t/l),_=Math.ceil(i/u),B=Math.ceil(o/f);const F=(M-1)*l+g-t,P=(_-1)*u+A-i,U=(B-1)*f+v-o,V=Math.floor(F/2),$=F-V,q=Math.floor(P/2),ne=P-q,he=Math.floor(U/2),me=U-he;S={top:q,bottom:ne,left:he,right:me,front:V,back:$,type:"SAME"}}else if(s==="valid")S={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},M=Math.ceil((t-g+1)/l),_=Math.ceil((i-A+1)/u),B=Math.ceil((o-v+1)/f);else throw Error(`Unknown padding parameter: ${s}`);return{padInfo:S,outDepth:M,outHeight:_,outWidth:B}}function Hl(s,t){if(!t)return Math.trunc(s);switch(t){case"round":return Math.round(s);case"ceil":return Math.ceil(s);case"floor":return Math.floor(s);default:throw new Error(`Unknown roundingMode ${t}`)}}function Pc(s){const[t,i,o]=id(s);return t===1&&i===1&&o===1}function or(s,t){return Pc(s)||Pc(t)}function pl(s){if(s==="NHWC")return"channelsLast";if(s==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${s}`)}function Ms(s,t,i){if(i!=null){if(typeof t=="string")throw Error(`Error in ${s}: pad must be an integer when using dimRoundingMode ${i} but got pad ${t}.`);if(typeof t=="number")E(D(t),()=>`Error in ${s}: pad must be an integer when using dimRoundingMode ${i} but got pad ${t}.`);else if(typeof t=="object")t.forEach(o=>{o.forEach(l=>{E(D(l),()=>`Error in ${s}: pad must be an integer when using dimRoundingMode ${i} but got pad ${l}.`)})});else throw Error(`Error in ${s}: Unknown padding parameter: ${t}`)}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ob(s,t){const i={x:Se(s,"x","reshape","string_or_numeric")},o={shape:t};return ze.runKernel(pf,i,o)}const He=Qe({reshape_:ob});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ux(s,t,i,o,l){const u=Se(s,"x","avgPool","float32"),f=1;E(or(i,f),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${f}'`);let g=u,A=!1;u.rank===3&&(A=!0,g=He(u,[1,u.shape[0],u.shape[1],u.shape[2]])),E(g.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${g.rank}.`),Ms("avgPool",o,l);const v={x:g},C={filterSize:t,strides:i,pad:o,dimRoundingMode:l};let S=ze.runKernel(Jn,v,C);return S=hn(S,u.dtype),A?He(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const Go=Qe({avgPool_:Ux});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Px(s,t,i,o,l,u="NDHWC"){const f=Se(s,"x","avgPool3d","float32");let g=f,A=!1;f.rank===4&&(A=!0,g=He(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]])),E(g.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${g.rank}.`),E(u==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${u}`),Ms("avgPool3d",o,l);const v={x:g},C={filterSize:t,strides:i,pad:o,dimRoundingMode:l,dataFormat:u};let S=ze.runKernel(wt,v,C);return S=hn(S,g.dtype),A?He(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}const xg=Qe({avgPool3d_:Px});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ap(s,t=0){E(s.length>=1,()=>"Pass at least one tensor to concat");const i=PA(s,"tensors","concat","string_or_numeric");if(i[0].dtype==="complex64"&&i.forEach(u=>{if(u.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${u.dtype}. `)}),i.length===1)return Ul(i[0]);const o=i,l={axis:t};return ze.runKernel(ir,o,l)}const yi=Qe({concat_:ap});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oS(s){const t={x:Se(s,"x","sigmoid","float32")};return ze.runKernel(xf,t)}const sd=Qe({sigmoid_:oS});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zx(s,t,i){const o=Se(s,"x","slice","string_or_numeric");if(o.rank===0)throw new Error("Slicing scalar is not possible");const l={x:o},u={begin:t,size:i};return ze.runKernel(Vm,l,u)}const Vi=Qe({slice_:zx});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zc(s){const t={x:Se(s,"x","tanh","float32")};return ze.runKernel(Hh,t)}const wg=Qe({tanh_:zc});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vx(s,t,i){const o=Se(s,"x","batchToSpaceND"),l=t.reduce((g,A)=>g*A);E(o.rank>=1+t.length,()=>`input rank is ${o.rank} but should be > than blockShape.length ${t.length}`),E(i.length===t.length,()=>`crops.length is ${i.length} but should be equal to blockShape.length  ${t.length}`),E(o.shape[0]%l===0,()=>`input tensor batch is ${o.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${l}`);const u={x:o},f={blockShape:t,crops:i};return ze.runKernel(tn,u,f)}const $u=Qe({batchToSpaceND_:Vx});function ml(s){let t;return s.rank===0||s.rank===1?t=He(s,[1,1,1,s.size]):s.rank===2?t=He(s,[1,1,s.shape[0],s.shape[1]]):s.rank===3?t=He(s,[1,s.shape[0],s.shape[1],s.shape[2]]):t=s,t}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Wx(s,t,i,o,l,u){u==null&&(u=.001);const f=Se(s,"x","batchNorm"),g=Se(t,"mean","batchNorm"),A=Se(i,"variance","batchNorm");let v;l!=null&&(v=Se(l,"scale","batchNorm"));let C;o!=null&&(C=Se(o,"offset","batchNorm")),E(g.rank===A.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E(C==null||g.rank===C.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E(v==null||g.rank===v.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const S={x:ml(f),scale:v,offset:C,mean:g,variance:A},M={varianceEpsilon:u},_=ze.runKernel(Fs,S,M);return He(_,f.shape)}const rd=Qe({batchNorm_:Wx});function Hx(s,t,i,o,l,u){const f=Se(s,"x","batchNorm"),g=Se(t,"mean","batchNorm"),A=Se(i,"variance","batchNorm");let v;l!=null&&(v=Se(l,"scale","batchNorm"));let C;return o!=null&&(C=Se(o,"offset","batchNorm")),E(f.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${f.rank}.`),E(g.rank===2||g.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${g.rank}.`),E(A.rank===2||A.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${A.rank}.`),v!=null&&E(v.rank===2||v.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${v.rank}.`),C!=null&&E(C.rank===2||C.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${C.rank}.`),rd(f,g,A,C,v,u)}const lb=Qe({batchNorm2d_:Hx});function cb(s,t,i,o,l,u){const f=Se(s,"x","batchNorm"),g=Se(t,"mean","batchNorm"),A=Se(i,"variance","batchNorm");let v;l!=null&&(v=Se(l,"scale","batchNorm"));let C;return o!=null&&(C=Se(o,"offset","batchNorm")),E(f.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${f.rank}.`),E(g.rank===3||g.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${g.rank}.`),E(A.rank===3||A.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${A.rank}.`),v!=null&&E(v.rank===3||v.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${v.rank}.`),C!=null&&E(C.rank===3||C.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${C.rank}.`),rd(f,g,A,C,v,u)}const Cg=Qe({batchNorm3d_:cb});function Xx(s,t,i,o,l,u){const f=Se(s,"x","batchNorm"),g=Se(t,"mean","batchNorm"),A=Se(i,"variance","batchNorm");let v;l!=null&&(v=Se(l,"scale","batchNorm"));let C;return o!=null&&(C=Se(o,"offset","batchNorm")),E(f.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${f.rank}.`),E(g.rank===4||g.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${g.rank}.`),E(A.rank===4||A.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${A.rank}.`),v!=null&&E(v.rank===4||v.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${v.rank}.`),C!=null&&E(C.rank===4||C.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${C.rank}.`),rd(f,g,A,C,v,u)}const Xl=Qe({batchNorm4d_:Xx});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ks(s,t,i){const o=Se(s,"x","bincount"),l=Se(t,"weights","bincount");E(o.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${o.dtype}`),E(i>=0,()=>`size must be non-negative, but got ${i}.`),E(l.size===o.size||l.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${o.shape}, weights shape: ${l.shape}.`);const u={x:o,weights:l},f={size:i};return ze.runKernel(cn,u,f)}const ub=Qe({bincount_:Ks});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Qx(s,t){let i=Se(s,"broadcastTo","x");const o=i.shape;if(t.some(A=>!(A>0)||A%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<i.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${i.rank}.`);if(t.length>i.rank){const A=i.shape.slice();for(;A.length<t.length;)A.unshift(1);i=He(i,A)}const l=i.shape,u=Array.from(t);for(let A=t.length-1;A>=0;A--)if(l[A]===t[A])u[A]=1;else if(i.shape[A]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${t}].`);if(u.map((A,v)=>A>1?v:-1).filter(A=>A>=0).length===0)return Ul(i);const f={x:i},g={reps:u};return ze.runKernel(Xh,f,g)}const _s=Qe({broadcastTo_:Qx});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lS(s){const t={x:Se(s,"x","ceil","float32")};return ze.runKernel(mn,t)}const Kx=Qe({ceil_:lS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function op(s,t,i){const o={shape:s,value:t,dtype:i};return ze.runKernel(Yn,{},o)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Es(s,t,i){const o=Se(s,"x","clipByValue");if(E(t<=i,()=>`Error in clip: min (${t}) must be less than or equal to max (${i}).`),t===i)return op(o.shape,t,o.dtype);const l={x:o},u={clipValueMin:t,clipValueMax:i};return ze.runKernel(fi,l,u)}const fs=Qe({clipByValue_:Es});function Ql(s){return yi(s,0)}const Zx=Qe({concat1d_:Ql});function $x(s,t){return yi(s,t)}const cS=Qe({concat2d_:$x});function hb(s,t){return yi(s,t)}const Ga=Qe({concat3d_:hb});function Uo(s,t){return yi(s,t)}const Yx=Qe({concat4d_:Uo});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ua(s,t,i,o,l="NHWC",u=[1,1],f){const g=Se(s,"x","conv2d","float32"),A=Se(t,"filter","conv2d","float32");let v=g,C=!1;g.rank===3&&(C=!0,v=He(g,[1,g.shape[0],g.shape[1],g.shape[2]])),E(v.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${v.rank}.`),E(A.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${A.rank}.`),Ms("conv2d",o,f);const S=l==="NHWC"?v.shape[3]:v.shape[1];E(S===A.shape[2],()=>`Error in conv2d: depth of input (${S}) must match input depth for filter ${A.shape[2]}.`),E(or(i,u),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const M={x:v,filter:A},_={strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:f},B=ze.runKernel(ro,M,_);return C?He(B,[B.shape[1],B.shape[2],B.shape[3]]):B}const Vc=Qe({conv2d_:Ua});function Wc(s,t,i,o,l="NWC",u=1,f){const g=Se(s,"x","conv1d"),A=Se(t,"filter","conv1d");let v=g,C=!1;g.rank===2&&(C=!0,v=He(g,[1,g.shape[0],g.shape[1]])),E(v.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${v.rank}.`),E(A.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${A.rank}.`),Ms("conv1d",o,f),E(v.shape[2]===A.shape[1],()=>`Error in conv1d: depth of input (${v.shape[2]}) must match input depth for filter ${A.shape[1]}.`),E(or(i,u),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${i} and dilation '${u}'`),E(l==="NWC",()=>`Error in conv1d: got dataFormat of ${l} but only NWC is currently supported.`);const S=He(A,[1,A.shape[0],A.shape[1],A.shape[2]]),M=He(v,[v.shape[0],1,v.shape[1],v.shape[2]]),_=Vc(M,S,[1,i],o,"NHWC",[1,u],f);return C?He(_,[_.shape[2],_.shape[3]]):He(_,[_.shape[0],_.shape[2],_.shape[3]])}const Hc=Qe({conv1d_:Wc});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xc(s,t,i,o,l,u="NHWC",f){E(s.length===t.rank,()=>`Length of inShape (${s.length}) and rank of dy (${t.rank}) must match`);let g=s,A=t,v=!1;t.rank===3&&(v=!0,A=He(t,[1,t.shape[0],t.shape[1],t.shape[2]]),g=[1,s[0],s[1],s[2]]),E(g.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${g.length}.`),E(A.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${A.rank}`),E(i.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${i.rank}`);const C=u==="NHWC"?g[3]:g[1],S=u==="NHWC"?A.shape[3]:A.shape[1];E(C===i.shape[2],()=>`Error in conv2dDerInput: depth of input (${C}) must match input depth for filter ${i.shape[2]}.`),E(S===i.shape[3],()=>`Error in conv2dDerInput: depth of output (${S}) must match output depth for filter ${i.shape[3]}.`),Ms("conv2dDerInput",l,f);const M={dy:A,filter:i},_={strides:o,pad:l,dataFormat:u,dimRoundingMode:f,inputShape:g},B=ze.runKernel(ao,M,_);return v?He(B,[B.shape[1],B.shape[2],B.shape[3]]):B}const lp=Qe({conv2DBackpropInput_:Xc});function db(s,t,i,o,l,u){const f=Se(s,"x","conv2dTranspose"),g=Se(t,"filter","conv2dTranspose");return lp(i,f,g,o,l,"NHWC",u)}const Po=Qe({conv2dTranspose_:db});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jx(s,t,i,o,l="NDHWC",u=[1,1,1]){const f=Se(s,"x","conv3d"),g=Se(t,"filter","conv3d");let A=f,v=!1;f.rank===4&&(v=!0,A=He(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]])),E(A.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${A.rank}.`),E(g.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${g.rank}.`),E(A.shape[4]===g.shape[3],()=>`Error in conv3d: depth of input (${A.shape[4]}) must match input depth for filter ${g.shape[3]}.`),E(or(i,u),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`),E(l==="NDHWC",()=>`Error in conv3d: got dataFormat of ${l} but only NDHWC is currently supported.`);const C={x:A,filter:g},S={strides:i,pad:o,dataFormat:l,dilations:u},M=ze.runKernel(wc,C,S);return v?He(M,[M.shape[1],M.shape[2],M.shape[3],M.shape[4]]):M}const ad=Qe({conv3d_:jx});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cp(s,t,i,o,l){E(s.length===t.rank,()=>`Length of inShape (${s.length}) and rank of dy (${t.rank}) must match`);let u=s,f=t,g=!1;t.rank===4&&(g=!0,f=He(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),u=[1,s[0],s[1],s[2],s[3]]);const A=u[4],v=f.shape[4];E(u.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${u.length}.`),E(f.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${f.rank}`),E(i.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${i.rank}`),E(A===i.shape[3],()=>`Error in conv3dDerInput: depth of input (${A}) must match input depth for filter ${i.shape[3]}.`),E(v===i.shape[4],()=>`Error in conv3dDerInput: depth of output (${v}) must match output depth for filter ${i.shape[4]}.`);const C={dy:f,filter:i},S={pad:l,strides:o,inputShape:u},M=ze.runKernel(nl,C,S);return g?He(M,[M.shape[1],M.shape[2],M.shape[3],M.shape[4]]):M}const od=Qe({conv3DBackpropInput_:cp});function ld(s,t,i,o,l){const u=Se(s,"x","conv3dTranspose"),f=Se(t,"filter","conv3dTranspose");return od(i,u,f,o,l)}const qx=Qe({conv3dTranspose_:ld});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Jx(s){const t={x:Se(s,"x","cos","float32")};return ze.runKernel(oo,t)}const Yu=Qe({cos_:Jx});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function e1(s){const t={x:Se(s,"x","cosh","float32")};return ze.runKernel(Ea,t)}const up=Qe({cosh_:e1});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function t1(s,t=0,i=!1,o=!1){const l={x:Se(s,"x","cumprod")},u={axis:t,exclusive:i,reverse:o};return ze.runKernel(Sa,l,u)}const fb=Qe({cumprod_:t1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uS(s,t=0,i=!1,o=!1){const l={x:Se(s,"x","cumsum")},u={axis:t,exclusive:i,reverse:o};return ze.runKernel(ko,l,u)}const Zi=Qe({cumsum_:uS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ps(s,t,i="NHWC"){const o=Se(s,"x","depthToSpace","float32"),l=i==="NHWC"?o.shape[1]:o.shape[2],u=i==="NHWC"?o.shape[2]:o.shape[3],f=i==="NHWC"?o.shape[3]:o.shape[1];E(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),E(l*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${l} and ${t}  for depthToSpace with input shape
    ${o.shape}`),E(u*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${u} and ${t} for depthToSpace with input shape
        ${o.shape}`),E(f%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${f} for depthToSpace with input shape ${o.shape}`);const g={x:o},A={blockSize:t,dataFormat:i};return ze.runKernel(Bh,g,A)}const vi=Qe({depthToSpace_:ps});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ki(s,t,i,o,l="NHWC",u=[1,1],f){const g=Se(s,"x","depthwiseConv2d","float32"),A=Se(t,"filter","depthwiseConv2d","float32");let v=g,C=!1;g.rank===3&&(C=!0,v=He(g,[1,g.shape[0],g.shape[1],g.shape[2]])),E(v.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${v.rank}.`),E(A.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${A.rank}.`);const S=l==="NHWC"?v.shape[3]:v.shape[1];E(S===A.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${S}) must match the inChannels dimension in filter ${A.shape[2]}.`),Ms("depthwiseConv2d",o,f);const M={x:v,filter:A},_={strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:f},B=ze.runKernel(Cu,M,_);return C?He(B,[B.shape[1],B.shape[2],B.shape[3]]):B}const Wi=Qe({depthwiseConv2d_:ki});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pa(s,t,i,o,l=[1,1],u="NHWC"){const f=Se(s,"x","dilation2d"),g=Se(t,"filter","dilation2d");E(f.rank===3||f.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${f.rank}.`),E(g.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${g.rank}.`),E(u==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${u}`);let A=f,v=!1;f.rank===3&&(A=He(f,[1,f.shape[0],f.shape[1],f.shape[2]]),v=!0);const C={x:A,filter:g},S={strides:i,pad:o,dilations:l},M=ze.runKernel(ce,C,S);return v?He(M,[M.shape[1],M.shape[2],M.shape[3]]):M}const Qc=Qe({dilation2d_:Pa});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cd(s,t){let i=Se(s,"a","equal","string_or_numeric"),o=Se(t,"b","equal","string_or_numeric");[i,o]=rs(i,o),$n(i.shape,o.shape);const l={a:i,b:o};return ze.runKernel(ln,l)}const Ao=Qe({equal_:cd});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kl(s,t,i){const o=Se(t,"a","where"),l=Se(i,"b","where"),u=Se(s,"condition","where","bool"),f=$n($n(u.shape,o.shape),l.shape),g=_s(u,f),A=_s(o,f),v=_s(l,f),C={condition:g,t:A,e:v};return ze.runKernel(zm,C)}const Ii=Qe({where_:Kl});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kc(s){const t={x:Se(s,"x","zerosLike")};return ze.runKernel(Km,t)}const oi=Qe({zerosLike_:Kc});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pb(s,t){let i=Se(s,"a","div"),o=Se(t,"b","div");[i,o]=rs(i,o);const l=En(i,o),u=oi(l),f=Ao(o,u);return Ii(f,u,l)}const bo=Qe({divNoNan_:pb});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ud(s,t){const i=Se(s,"t1","dot"),o=Se(t,"t2","dot");E((i.rank===1||i.rank===2)&&(o.rank===1||o.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${i.rank} and ${o.rank}.`);const l=i.rank===1?i.size:i.shape[1],u=o.rank===1?o.size:o.shape[0];if(E(l===u,()=>`Error in dot: inner dimensions of inputs must match, but got ${l} and ${u}.`),i.rank===1&&o.rank===1){const f=He(i,[1,-1]),g=He(o,[-1,1]),A=Li(f,g);return He(A,[])}else if(i.rank===1&&o.rank===2){const f=He(i,[1,-1]),g=He(o,[o.shape[0],o.shape[1]]),A=Li(f,g);return He(A,[A.size])}else if(i.rank===2&&o.rank===1){const f=He(o,[-1,1]),g=Li(i,f);return He(g,[g.size])}else{const f=He(o,[o.shape[0],o.shape[1]]);return Li(i,f)}}const hp=Qe({dot_:ud});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ua(s){const t={x:Se(s,"x","elu","float32")};return ze.runKernel(Nt,t)}const hd=Qe({elu_:ua});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mb(s){let t=Se(s,"x","erf");E(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=hn(t,"float32"));const i={x:t};return ze.runKernel(un,i)}const Eg=Qe({erf_:mb});/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dd(s,t){for(let i=0;i<s.length;++i)if(s[s.length-i-1]!==t-1-i)return!1;return!0}function Zl(s,t,i){const o=s.length+t.length,l=[];let u=0,f=0;for(let g=0;g<o;g++)i.indexOf(g)===-1?l.push(s[u++]):l.push(t[f++]);return l}function Ei(s,t){const i=[],o=s.length;for(let u=0;u<o;u++)t.indexOf(u)===-1&&i.push(s[u]);const l=t.map(u=>s[u]);return[i,l]}function ts(s,t){const i=t.map(o=>1);return Zl(s,i,t)}function Rs(s,t,i){E(dd(t,i),()=>`${s} supports only inner-most axes for now. Got axes ${t} and rank-${i} input.`)}function ji(s,t){if(dd(s,t))return null;const i=[];for(let o=0;o<t;++o)s.indexOf(o)===-1&&i.push(o);return s.forEach(o=>i.push(o)),i}function gl(s){return s.map((t,i)=>[i,t]).sort((t,i)=>t[1]-i[1]).map(t=>t[0])}function Ss(s,t){const i=[];for(let o=t-s;o<t;++o)i.push(o);return i}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n1(s,t=null,i=!1){const o={x:Se(s,"x","max")},l={reductionIndices:t,keepDims:i};return ze.runKernel(Fh,o,l)}const ha=Qe({max_:n1});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gb(s,t=null,i=!1){const o={x:Se(s,"x","min")},l={axis:t,keepDims:i};return ze.runKernel(Tu,o,l)}const jr=Qe({min_:gb});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function i1(s,t){let i=Se(s,"base","pow"),o=Se(t,"exp","pow");[i,o]=rs(i,o);const l={a:i,b:o};return ze.runKernel(hf,l)}const gr=Qe({pow_:i1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ni(s,t){if((_e(s)&&t!=="string"||Array.isArray(s))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&_e(s)&&!(s instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return mo(s,[],[],t)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function s1(s){const t={x:Se(s,"x","sqrt","float32")};return ze.runKernel(Lu,t)}const Pr=Qe({sqrt_:s1});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zc(s){const t=Se(s,"x","square"),i={};return ze.runKernel("Square",{x:t},i)}const qi=Qe({square_:Zc});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ab(s,t=null,i=!1){let o=Se(s,"x","sum");o.dtype==="bool"&&(o=hn(o,"int32"));const l={x:o},u={axis:t,keepDims:i};return ze.runKernel(Mc,l,u)}const wn=Qe({sum_:Ab});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function r1(s,t="euclidean",i=null,o=!1){s=Se(s,"x","norm");const l=bb(s,t,i);let u=l.shape;if(o){const f=J(i,s.shape);u=ts(l.shape,f)}return He(l,u)}function bb(s,t,i=null){if(s.rank===0)return Ri(s);if(s.rank!==1&&i===null)return bb(He(s,[-1]),t,i);if(s.rank===1||typeof i=="number"||Array.isArray(i)&&i.length===1){if(t===1)return wn(Ri(s),i);if(t===1/0)return ha(Ri(s),i);if(t===-1/0)return jr(Ri(s),i);if(t==="euclidean"||t===2)return Pr(wn(gr(Ri(s),Ni(2,"int32")),i));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(i)&&i.length===2){if(t===1)return ha(wn(Ri(s),i[0]),i[1]-1);if(t===1/0)return ha(wn(Ri(s),i[1]),i[0]);if(t===-1/0)return jr(wn(Ri(s),i[1]),i[0]);if(t==="fro"||t==="euclidean")return Pr(wn(qi(s),i));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${i}`)}const dp=Qe({norm_:r1});/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yb(s,t=null,i=!1){return dp(s,"euclidean",t,i)}const vb=Qe({euclideanNorm_:yb});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hS(s){const t={x:Se(s,"x","exp")};return ze.runKernel(Dn,t)}const $l=Qe({exp_:hS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dS(s,t=0){const i=Se(s,"x","expandDims","string_or_numeric");E(t<=i.rank,()=>"Axis must be <= rank of the tensor");const o={input:i},l={dim:t};return ze.runKernel(Un,o,l)}const za=Qe({expandDims_:dS});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function a1(s){const t={x:Se(s,"x","expm1")};return ze.runKernel(Mn,t)}const fd=Qe({expm1_:a1});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Sg(s,t){const i=Se(s,"x","tile","string_or_numeric");E(i.rank===t.length,()=>`Error in transpose: rank of input ${i.rank} must match length of reps ${t}.`);const o={x:i},l={reps:t};return ze.runKernel(Xh,o,l)}const yo=Qe({tile_:Sg});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function o1(s,t,i,o="float32"){t==null&&(t=s);const l=On([s,t],o),u=s<=t?s:t;for(let g=0;g<u;++g)l.set(1,g,g);const f=He(l.toTensor(),[s,t]);if(i==null)return f;if(i.length===1)return yo(za(f,0),[i[0],1,1]);if(i.length===2)return yo(za(za(f,0),0),[i[0],i[1],1,1]);if(i.length===3)return yo(za(za(za(f,0),0),0),[i[0],i[1],i[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${i.length}D.`)}const xb=Qe({eye_:o1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function l1(s){const t={x:Se(s,"x","floor","float32")};return ze.runKernel(ss,t)}const fp=Qe({floor_:l1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function c1(s,t,i=0,o=0){const l=Se(s,"x","gather"),u=Se(t,"indices","gather","int32"),f={x:l,indices:u},g={axis:i,batchDims:o};return ze.runKernel(xn,f,g)}const pd=Qe({gather_:c1});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function u1(s,t){let i=Se(s,"a","greater","string_or_numeric"),o=Se(t,"b","greater","string_or_numeric");[i,o]=rs(i,o),$n(i.shape,o.shape);const l={a:i,b:o};return ze.runKernel(Qn,l)}const Va=Qe({greater_:u1});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ls(s,t){let i=Se(s,"a","greaterEqual","string_or_numeric"),o=Se(t,"b","greaterEqual","string_or_numeric");[i,o]=rs(i,o),$n(i.shape,o.shape);const l={a:i,b:o};return ze.runKernel(Ws,l)}const $c=Qe({greaterEqual_:ls});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fS(s){const t={x:Se(s,"x","isFinite")};return ze.runKernel(Si,t)}const h1=Qe({isFinite_:fS});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pS(s){const t={x:Se(s,"x","isInf")};return ze.runKernel(Cs,t)}const mS=Qe({isInf_:pS});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gS(s){const t={x:Se(s,"x","isNaN")};return ze.runKernel(sr,t)}const Ig=Qe({isNaN_:gS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function md(s,t=.2){const i={x:Se(s,"x","leakyRelu")},o={alpha:t};return ze.runKernel(vs,i,o)}const pp=Qe({leakyRelu_:md});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Tg(s,t){let i=Se(s,"a","less","string_or_numeric"),o=Se(t,"b","less","string_or_numeric");[i,o]=rs(i,o),$n(i.shape,o.shape);const l={a:i,b:o};return ze.runKernel(lo,l)}const Mg=Qe({less_:Tg});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ju(s,t){let i=Se(s,"a","lessEqual","string_or_numeric"),o=Se(t,"b","lessEqual","string_or_numeric");[i,o]=rs(i,o),$n(i.shape,o.shape);const l={a:i,b:o};return ze.runKernel(co,l)}const qr=Qe({lessEqual_:ju});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mp(s,t=5,i=1,o=1,l=.5){const u=Se(s,"x","localResponseNormalization");E(u.rank===4||u.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${u.rank}.`),E(D(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let f=u,g=!1;u.rank===3&&(g=!0,f=He(u,[1,u.shape[0],u.shape[1],u.shape[2]]));const A={x:f},v={depthRadius:t,bias:i,alpha:o,beta:l},C=ze.runKernel(Ll,A,v);return g?He(C,[C.shape[1],C.shape[2],C.shape[3]]):C}const AS=Qe({localResponseNormalization_:mp});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function d1(s){const t={x:Se(s,"x","log","float32")};return ze.runKernel(of,t)}const zo=Qe({log_:d1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function f1(s){const t={x:Se(s,"x","log1p")};return ze.runKernel(lf,t)}const wb=Qe({log1p_:f1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bS(s,t){E(fe(s),()=>"The f passed in variableGrads(f) must be a function"),E(t==null||Array.isArray(t)&&t.every(v=>v instanceof zf),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const i=t!=null;if(!i){t=[];for(const v in ze.registeredVariables)t.push(ze.registeredVariables[v])}const o=i?t.filter(v=>!v.trainable):null,l=t.length;t=t.filter(v=>v.trainable),E(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${l} variables is trainable.`);const u=!0,{value:f,grads:g}=ze.gradients(s,t,null,u);E(g.some(v=>v!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),E(f.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${f.rank} tensor`);const A={};return t.forEach((v,C)=>{g[C]!=null&&(A[v.name]=g[C])}),o?.forEach(v=>A[v.name]=null),{value:f,grads:A}}function Yc(s){return ze.customGrad(s)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function p1(s){const t={x:Se(s,"x","softplus")};return ze.runKernel(wf,t)}const gd=Qe({softplus_:p1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yS(s){const t=Se(s,"x","logSigmoid");return Yc(i=>({value:Us(gd(Us(i))),gradFunc:o=>Oe(o,sd(Us(i)))}))(t)}const Cb=Qe({logSigmoid_:yS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Eb(s,t){let i=Se(s,"a","sub"),o=Se(t,"b","sub");[i,o]=rs(i,o);const l={a:i,b:o};return ze.runKernel(If,l)}const Wn=Qe({sub_:Eb});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vS(s,t=-1){const i=Se(s,"logits","logSoftmax");if(t===-1&&(t=i.rank-1),t!==i.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${i.rank} and axis was ${t}`);return Yc((o,l)=>{const u=ha(o,t,!0),f=Wn(o,u),g=Wn(hn(f,"float32"),zo(wn($l(f),t,!0)));return l([g]),{value:g,gradFunc:(A,v)=>{const[C]=v,S=!0,M=$l(C);return Wn(A,Oe(wn(A,t,S),M))}}})(i)}const Ad=Qe({logSoftmax_:vS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xS(s,t=null,i=!1){const o=Se(s,"x","logSumExp"),l=J(t,o.shape),u=ha(o,l,!0),f=Wn(o,u),g=$l(f),A=wn(g,l),v=zo(A),C=Ut(He(u,v.shape),v);if(i){const S=ts(C.shape,l);return He(C,S)}return C}const m1=Qe({logSumExp_:xS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xi(s,t){const i=Se(s,"a","logicalAnd","bool"),o=Se(t,"b","logicalAnd","bool");$n(i.shape,o.shape);const l={a:i,b:o};return ze.runKernel(Su,l)}const Vo=Qe({logicalAnd_:xi});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _g(s){const t={x:Se(s,"x","logicalNot","bool")};return ze.runKernel(Lh,t)}const gp=Qe({logicalNot_:_g});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function g1(s,t){const i=Se(s,"a","logicalOr","bool"),o=Se(t,"b","logicalOr","bool");$n(i.shape,o.shape);const l={a:i,b:o};return ze.runKernel(Nh,l)}const Rg=Qe({logicalOr_:g1});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ap(s,t){const i=Se(s,"a","logicalXor","bool"),o=Se(t,"b","logicalXor","bool");return $n(i.shape,o.shape),Vo(Rg(s,t),gp(Vo(s,t)))}const kg=Qe({logicalXor_:Ap});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bd(s,t,i,o,l){const u=Se(s,"x","maxPool"),f=1;let g=u,A=!1;u.rank===3&&(A=!0,g=He(u,[1,u.shape[0],u.shape[1],u.shape[2]])),E(g.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${g.rank}.`),E(or(i,f),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${f}'`),Ms("maxPool",o,l);const v={x:g},C={filterSize:t,strides:i,pad:o,dimRoundingMode:l},S=ze.runKernel(Sc,v,C);return A?He(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const Bg=Qe({maxPool_:bd});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wS(s,t=[1,1,1],i,o,l,u="NDHWC"){const f=Se(s,"x","maxPool3d");let g=f,A=!1;f.rank===4&&(A=!0,g=He(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]])),E(g.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${g.rank}.`),E(u==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${u}`),Ms("maxPool3d",o,l);const v={x:g},C={filterSize:t,strides:i,pad:o,dimRoundingMode:l,dataFormat:u},S=ze.runKernel(Gh,v,C);return A?He(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}const CS=Qe({maxPool3d_:wS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function A1(s,t){let i=Se(s,"a","maximum"),o=Se(t,"b","maximum");[i,o]=rs(i,o),i.dtype==="bool"&&(i=hn(i,"int32"),o=hn(o,"int32")),$n(i.shape,o.shape);const l={a:i,b:o};return ze.runKernel(Oh,l)}const Yl=Qe({maximum_:A1});/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lg(s,t=null,i=!1){const o={x:Se(s,"x","mean")},l={axis:t,keepDims:i};return ze.runKernel(Uh,o,l)}const Hn=Qe({mean_:Lg});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zs(s,t="float32"){if(t==="complex64"){const o=Zs(s,"float32"),l=Zs(s,"float32");return La(o,l)}const i=Tt(N(s),t);return ze.makeTensor(i,s,t)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ks(s,t="float32"){if(t==="complex64"){const o=ks(s,"float32"),l=Zs(s,"float32");return La(o,l)}const i=zt(N(s),t);return ze.makeTensor(i,s,t)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ES(s,t){let i=Se(s,"a","minimum"),o=Se(t,"b","minimum");[i,o]=rs(i,o),i.dtype==="bool"&&(i=hn(i,"int32"),o=hn(o,"int32")),$n(i.shape,o.shape);const l={a:i,b:o};return ze.runKernel(Ph,l)}const bp=Qe({minimum_:ES});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Sb(s,t,i){E(i==="reflect"||i==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${i}.`);const o=Se(s,"x","mirrorPad");if(o.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");E(t.length===o.rank,()=>`Padding doesn't match input. Must be ${o.rank}. Got ${t.length}.`);const l=i==="reflect"?1:0;for(let g=0;g<o.rank;g++)E(t[g].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),E(t[g][0]>=0&&t[g][0]<=o.shape[g]-l&&t[g][1]>=0&&t[g][1]<=o.shape[g]-l,()=>`Padding in dimension ${g} cannot be greater than or equal to ${o.shape[g]-l} or less than 0 for input of shape ${o.shape}`);const u={paddings:t,mode:i},f={x:o};return ze.runKernel(Mu,f,u)}const Ng=Qe({mirrorPad_:Sb});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function b1(s,t){let i=Se(s,"a","mod"),o=Se(t,"b","mod");[i,o]=rs(i,o);const l={a:i,b:o};return ze.runKernel(Ic,l)}const y1=Qe({mod_:b1});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ib(s,t=null,i=!1){s=Se(s,"x","moments");const o=J(t,s.shape),l=Hn(s,o,i);let u=l.shape;i||(u=ts(l.shape,o));const f=qi(Wn(hn(s,"float32"),He(l,u))),g=Hn(f,o,i);return{mean:l,variance:g}}const yp=Qe({moments_:Ib});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function SS(s,t){let i=Se(s,"a","notEqual","string_or_numeric"),o=Se(t,"b","notEqual","string_or_numeric");[i,o]=rs(i,o),$n(i.shape,o.shape);const l={a:i,b:o};return ze.runKernel(_u,l)}const vp=Qe({notEqual_:SS});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function IS(s){const t={x:Se(s,"x","onesLike")};return ze.runKernel(zh,t)}const Wa=Qe({onesLike_:IS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function TS(s,t,i=0){const o=Se(s,"x","pad");if(o.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const l={paddings:t,constantValue:i},u={x:o};return ze.runKernel(uf,u,l)}const Tb=Qe({pad_:TS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jc(s,t,i){const o=Se(s,"x","spaceToBatchND");E(o.rank>=1+t.length,()=>`input rank ${o.rank} should be > than [blockShape] ${t.length}`),E(i.length===t.length,()=>`paddings.shape[0] ${i.length} must be equal to [blockShape] ${t.length}`),E(o.shape.reduce((f,g,A)=>A>0&&A<=t.length?f&&(g+i[A-1][0]+i[A-1][1])%t[A-1]===0:f,!0),()=>`input spatial dimensions ${o.shape.slice(1)} with paddings ${i.toString()} must be divisible by blockShapes ${t.toString()}`);const l={x:o},u={blockShape:t,paddings:i};return ze.runKernel(Wm,l,u)}const Dg=Qe({spaceToBatchND_:jc});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mb(s,t,i,o,l,u,f){l==null&&(l=[1,1]),u==null&&(u=1),o===0&&(o="valid");const g=Se(s,"x","maxPool");let A=g,v=!1;g.rank===3&&(v=!0,A=He(g,[1,g.shape[0],g.shape[1],g.shape[2]])),E(or(u,l),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${u} and dilations '${l}'`);const C=Oa(A.shape,t,u,l,o),S=[C.dilationHeight,C.dilationWidth];let M;o==="same"?M=_S([C.filterHeight,C.filterWidth],S):M=[[0,0],[0,0]];const _=S[0]===1&&S[1]===1,[B,F]=MS([C.inHeight,C.inWidth],S,M),P=_?o:"valid",U=_?A:Dg(A,S,B),V=(i==="avg"?()=>Go(U,t,u,P,f):()=>Bg(U,t,u,P,f))(),$=_?V:$u(V,S,F);return v?He($,[$.shape[1],$.shape[2],$.shape[3]]):$}function MS(s,t,i){const o=i.map(C=>C[0]),l=i.map(C=>C[1]),u=s.concat(o,l),f=t.map((C,S)=>(C-u[S]%C)%C),g=l.map((C,S)=>C+f[S]),A=t.map((C,S)=>[o[S],g[S]]),v=t.map((C,S)=>[0,f[S]]);return[A,v]}function _S(s,t){const i=s.map((u,f)=>u+(u-1)*(t[f]-1)).map(u=>u-1),o=i.map(u=>Math.floor(u/2)),l=i.map((u,f)=>u-o[f]);return i.map((u,f)=>[o[f],l[f]])}const _b=Qe({pool_:Mb});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RS(s,t){const i=Se(s,"x","prelu"),o=Se(t,"alpha","prelu"),l={x:i,alpha:o};return ze.runKernel(Dm,l)}const Ha=Qe({prelu_:RS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rb(s,t=null,i=!1){let o=Se(s,"x","prod");o.dtype==="bool"&&(o=hn(o,"int32"));const l={x:o},u={axis:t,keepDims:i};return ze.runKernel(Fm,l,u)}const v1=Qe({prod_:Rb});var Fg={},xp={get exports(){return Fg},set exports(s){Fg=s}};(function(s){(function(t,i,o){function l(A){var v=this,C=g();v.next=function(){var S=2091639*v.s0+v.c*23283064365386963e-26;return v.s0=v.s1,v.s1=v.s2,v.s2=S-(v.c=S|0)},v.c=1,v.s0=C(" "),v.s1=C(" "),v.s2=C(" "),v.s0-=C(A),v.s0<0&&(v.s0+=1),v.s1-=C(A),v.s1<0&&(v.s1+=1),v.s2-=C(A),v.s2<0&&(v.s2+=1),C=null}function u(A,v){return v.c=A.c,v.s0=A.s0,v.s1=A.s1,v.s2=A.s2,v}function f(A,v){var C=new l(A),S=v&&v.state,M=C.next;return M.int32=function(){return C.next()*4294967296|0},M.double=function(){return M()+(M()*2097152|0)*11102230246251565e-32},M.quick=M,S&&(typeof S=="object"&&u(S,C),M.state=function(){return u(C,{})}),M}function g(){var A=4022871197,v=function(C){C=String(C);for(var S=0;S<C.length;S++){A+=C.charCodeAt(S);var M=.02519603282416938*A;A=M>>>0,M-=A,M*=A,A=M>>>0,M-=A,A+=M*4294967296}return(A>>>0)*23283064365386963e-26};return v}i&&i.exports?i.exports=f:this.alea=f})(ra,s)})(xp);var da={},x1={get exports(){return da},set exports(s){da=s}};(function(s){(function(t,i,o){function l(g){var A=this,v="";A.x=0,A.y=0,A.z=0,A.w=0,A.next=function(){var S=A.x^A.x<<11;return A.x=A.y,A.y=A.z,A.z=A.w,A.w^=A.w>>>19^S^S>>>8},g===(g|0)?A.x=g:v+=g;for(var C=0;C<v.length+64;C++)A.x^=v.charCodeAt(C)|0,A.next()}function u(g,A){return A.x=g.x,A.y=g.y,A.z=g.z,A.w=g.w,A}function f(g,A){var v=new l(g),C=A&&A.state,S=function(){return(v.next()>>>0)/4294967296};return S.double=function(){do var M=v.next()>>>11,_=(v.next()>>>0)/4294967296,B=(M+_)/(1<<21);while(B===0);return B},S.int32=v.next,S.quick=S,C&&(typeof C=="object"&&u(C,v),S.state=function(){return u(v,{})}),S}i&&i.exports?i.exports=f:this.xor128=f})(ra,s)})(x1);var yd={},jl={get exports(){return yd},set exports(s){yd=s}};(function(s){(function(t,i,o){function l(g){var A=this,v="";A.next=function(){var S=A.x^A.x>>>2;return A.x=A.y,A.y=A.z,A.z=A.w,A.w=A.v,(A.d=A.d+362437|0)+(A.v=A.v^A.v<<4^(S^S<<1))|0},A.x=0,A.y=0,A.z=0,A.w=0,A.v=0,g===(g|0)?A.x=g:v+=g;for(var C=0;C<v.length+64;C++)A.x^=v.charCodeAt(C)|0,C==v.length&&(A.d=A.x<<10^A.x>>>4),A.next()}function u(g,A){return A.x=g.x,A.y=g.y,A.z=g.z,A.w=g.w,A.v=g.v,A.d=g.d,A}function f(g,A){var v=new l(g),C=A&&A.state,S=function(){return(v.next()>>>0)/4294967296};return S.double=function(){do var M=v.next()>>>11,_=(v.next()>>>0)/4294967296,B=(M+_)/(1<<21);while(B===0);return B},S.int32=v.next,S.quick=S,C&&(typeof C=="object"&&u(C,v),S.state=function(){return u(v,{})}),S}i&&i.exports?i.exports=f:this.xorwow=f})(ra,s)})(jl);var kb={},kS={get exports(){return kb},set exports(s){kb=s}};(function(s){(function(t,i,o){function l(g){var A=this;A.next=function(){var C=A.x,S=A.i,M,_;return M=C[S],M^=M>>>7,_=M^M<<24,M=C[S+1&7],_^=M^M>>>10,M=C[S+3&7],_^=M^M>>>3,M=C[S+4&7],_^=M^M<<7,M=C[S+7&7],M=M^M<<13,_^=M^M<<9,C[S]=_,A.i=S+1&7,_};function v(C,S){var M,_=[];if(S===(S|0))_[0]=S;else for(S=""+S,M=0;M<S.length;++M)_[M&7]=_[M&7]<<15^S.charCodeAt(M)+_[M+1&7]<<13;for(;_.length<8;)_.push(0);for(M=0;M<8&&_[M]===0;++M);for(M==8?_[7]=-1:_[M],C.x=_,C.i=0,M=256;M>0;--M)C.next()}v(A,g)}function u(g,A){return A.x=g.x.slice(),A.i=g.i,A}function f(g,A){g==null&&(g=+new Date);var v=new l(g),C=A&&A.state,S=function(){return(v.next()>>>0)/4294967296};return S.double=function(){do var M=v.next()>>>11,_=(v.next()>>>0)/4294967296,B=(M+_)/(1<<21);while(B===0);return B},S.int32=v.next,S.quick=S,C&&(C.x&&u(C,v),S.state=function(){return u(v,{})}),S}i&&i.exports?i.exports=f:this.xorshift7=f})(ra,s)})(kS);var qc={},w1={get exports(){return qc},set exports(s){qc=s}};(function(s){(function(t,i,o){function l(g){var A=this;A.next=function(){var C=A.w,S=A.X,M=A.i,_,B;return A.w=C=C+1640531527|0,B=S[M+34&127],_=S[M=M+1&127],B^=B<<13,_^=_<<17,B^=B>>>15,_^=_>>>12,B=S[M]=B^_,A.i=M,B+(C^C>>>16)|0};function v(C,S){var M,_,B,F,P,U=[],V=128;for(S===(S|0)?(_=S,S=null):(S=S+"\0",_=0,V=Math.max(V,S.length)),B=0,F=-32;F<V;++F)S&&(_^=S.charCodeAt((F+32)%S.length)),F===0&&(P=_),_^=_<<10,_^=_>>>15,_^=_<<4,_^=_>>>13,F>=0&&(P=P+1640531527|0,M=U[F&127]^=_+P,B=M==0?B+1:0);for(B>=128&&(U[(S&&S.length||0)&127]=-1),B=127,F=512;F>0;--F)_=U[B+34&127],M=U[B=B+1&127],_^=_<<13,M^=M<<17,_^=_>>>15,M^=M>>>12,U[B]=_^M;C.w=P,C.X=U,C.i=B}v(A,g)}function u(g,A){return A.i=g.i,A.w=g.w,A.X=g.X.slice(),A}function f(g,A){g==null&&(g=+new Date);var v=new l(g),C=A&&A.state,S=function(){return(v.next()>>>0)/4294967296};return S.double=function(){do var M=v.next()>>>11,_=(v.next()>>>0)/4294967296,B=(M+_)/(1<<21);while(B===0);return B},S.int32=v.next,S.quick=S,C&&(C.X&&u(C,v),S.state=function(){return u(v,{})}),S}i&&i.exports?i.exports=f:this.xor4096=f})(ra,s)})(w1);var Bb={},BS={get exports(){return Bb},set exports(s){Bb=s}};(function(s){(function(t,i,o){function l(g){var A=this,v="";A.next=function(){var S=A.b,M=A.c,_=A.d,B=A.a;return S=S<<25^S>>>7^M,M=M-_|0,_=_<<24^_>>>8^B,B=B-S|0,A.b=S=S<<20^S>>>12^M,A.c=M=M-_|0,A.d=_<<16^M>>>16^B,A.a=B-S|0},A.a=0,A.b=0,A.c=-1640531527,A.d=1367130551,g===Math.floor(g)?(A.a=g/4294967296|0,A.b=g|0):v+=g;for(var C=0;C<v.length+20;C++)A.b^=v.charCodeAt(C)|0,A.next()}function u(g,A){return A.a=g.a,A.b=g.b,A.c=g.c,A.d=g.d,A}function f(g,A){var v=new l(g),C=A&&A.state,S=function(){return(v.next()>>>0)/4294967296};return S.double=function(){do var M=v.next()>>>11,_=(v.next()>>>0)/4294967296,B=(M+_)/(1<<21);while(B===0);return B},S.int32=v.next,S.quick=S,C&&(typeof C=="object"&&u(C,v),S.state=function(){return u(v,{})}),S}i&&i.exports?i.exports=f:this.tychei=f})(ra,s)})(BS);var Lb={},LS={get exports(){return Lb},set exports(s){Lb=s}};const NS=Qh(Object.freeze(Object.defineProperty({__proto__:null,default:{}},Symbol.toStringTag,{value:"Module"})));(function(s){(function(t,i,o){var l=256,u=6,f=52,g="random",A=o.pow(l,u),v=o.pow(2,f),C=v*2,S=l-1,M;function _(q,ne,he){var me=[];ne=ne==!0?{entropy:!0}:ne||{};var pe=U(P(ne.entropy?[q,$(i)]:q??V(),3),me),ye=new B(me),Te=function(){for(var Ye=ye.g(u),et=A,nt=0;Ye<v;)Ye=(Ye+nt)*l,et*=l,nt=ye.g(1);for(;Ye>=C;)Ye/=2,et/=2,nt>>>=1;return(Ye+nt)/et};return Te.int32=function(){return ye.g(4)|0},Te.quick=function(){return ye.g(4)/4294967296},Te.double=Te,U($(ye.S),i),(ne.pass||he||function(Ye,et,nt,ht){return ht&&(ht.S&&F(ht,ye),Ye.state=function(){return F(ye,{})}),nt?(o[g]=Ye,et):Ye})(Te,pe,"global"in ne?ne.global:this==o,ne.state)}function B(q){var ne,he=q.length,me=this,pe=0,ye=me.i=me.j=0,Te=me.S=[];for(he||(q=[he++]);pe<l;)Te[pe]=pe++;for(pe=0;pe<l;pe++)Te[pe]=Te[ye=S&ye+q[pe%he]+(ne=Te[pe])],Te[ye]=ne;(me.g=function(Ye){for(var et,nt=0,ht=me.i,ct=me.j,pt=me.S;Ye--;)et=pt[ht=S&ht+1],nt=nt*l+pt[S&(pt[ht]=pt[ct=S&ct+et])+(pt[ct]=et)];return me.i=ht,me.j=ct,nt})(l)}function F(q,ne){return ne.i=q.i,ne.j=q.j,ne.S=q.S.slice(),ne}function P(q,ne){var he=[],me=typeof q,pe;if(ne&&me=="object")for(pe in q)try{he.push(P(q[pe],ne-1))}catch{}return he.length?he:me=="string"?q:q+"\0"}function U(q,ne){for(var he=q+"",me,pe=0;pe<he.length;)ne[S&pe]=S&(me^=ne[S&pe]*19)+he.charCodeAt(pe++);return $(ne)}function V(){try{var q;return M&&(q=M.randomBytes)?q=q(l):(q=new Uint8Array(l),(t.crypto||t.msCrypto).getRandomValues(q)),$(q)}catch{var ne=t.navigator,he=ne&&ne.plugins;return[+new Date,t,he,t.screen,$(i)]}}function $(q){return String.fromCharCode.apply(0,q)}if(U(o.random(),i),s.exports){s.exports=_;try{M=NS}catch{}}else o["seed"+g]=_})(typeof self<"u"?self:ra,[],Math)})(LS);var DS=Fg,FS=da,C1=yd,vd=kb,wp=qc,E1=Bb,qu=Lb;qu.alea=DS,qu.xor128=FS,qu.xorwow=C1,qu.xorshift7=vd,qu.xor4096=wp,qu.tychei=E1;var Jc=qu;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class xd{constructor(t,i,o,l,u){this.mean=t,this.stdDev=i,this.dtype=o,this.nextVal=NaN,this.truncated=l,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const f=u||Math.random();this.random=Jc.alea(f.toString())}nextValue(){if(!isNaN(this.nextVal)){const l=this.nextVal;return this.nextVal=NaN,l}let t,i,o=!1;for(;!o;){let l,u,f;do l=2*this.random()-1,u=2*this.random()-1,f=l*l+u*u;while(f>=1||f===0);const g=Math.sqrt(-2*Math.log(f)/f);t=this.mean+this.stdDev*l*g,i=this.mean+this.stdDev*u*g,(!this.truncated||this.isValidTruncated(t))&&(o=!0)}return(!this.truncated||this.isValidTruncated(i))&&(this.nextVal=this.convertValue(i)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class S1{constructor(t=0,i=1,o,l){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=i-t,this.dtype=o,l==null&&(l=Math.random()),typeof l=="number"&&(l=l.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${i} <= 1 and dtype is not float`);this.random=Jc.alea(l)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Og(s,t=0,i=1,o,l){if(o!=null&&o==="bool")throw new Error(`Unsupported data type ${o}`);const u=new xd(t,i,o,!1,l),f=On(s,o);for(let g=0;g<f.values.length;g++)f.values[g]=u.nextValue();return f.toTensor()}const Nb=Qe({randomNormal_:Og});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Db(s,t=0,i=1,o="float32",l){const u=On(s,o),f=new S1(t,i,null,l);for(let g=0;g<u.values.length;g++)u.values[g]=f.nextValue();return u.toTensor()}const Ju=Qe({randomUniform_:Db});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Cp(s,t,i=1,o="float32"){if(i===0)throw new Error("Cannot have a step of zero");const l={start:s,stop:t,step:i,dtype:o};return ze.runKernel(hA,{},l)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function I1(s){const t={x:Se(s,"x","reciprocal")};return ze.runKernel(df,t)}const OS=Qe({reciprocal_:I1});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function T1(s){const t={x:Se(s,"x","relu")};return ze.runKernel(ff,t)}const Wo=Qe({relu_:T1});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GS(s){const t={x:Se(s,"x","relu6")};return ze.runKernel(Bu,t)}const M1=Qe({relu6_:GS});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function US(s,t){const i={x:Se(s,"x","reverse")},o={dims:t};return ze.runKernel(Pm,i,o)}const Al=Qe({reverse_:US});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gg(s){const t={x:Se(s,"x","round")};return ze.runKernel(mf,t)}const Ug=Qe({round_:Gg});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PS(s){const t={x:Se(s,"x","rsqrt","float32")};return ze.runKernel(gf,t)}const wd=Qe({rsqrt_:PS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zS(s){const t={x:Se(s,"x","selu")};return ze.runKernel(Af,t)}const Fb=Qe({selu_:zS});function _1(s,t,i,o,l,u=[1,1],f="NHWC"){const g=Se(s,"x","separableConv2d"),A=Se(t,"depthwiseFilter","separableConv2d"),v=Se(i,"pointwiseFilter","separableConv2d");let C=g,S=!1;if(g.rank===3&&(S=!0,C=He(g,[1,g.shape[0],g.shape[1],g.shape[2]])),f==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");E(C.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${C.rank}.`),E(A.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${A.rank}.`),E(v.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${A.rank}.`),E(v.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${v.shape[0]}.`),E(v.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${v.shape[1]}.`);const M=A.shape[2],_=A.shape[3];E(v.shape[2]===M*_,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${M*_}, but got ${v.shape[2]}.`);const B=Wi(C,A,o,l,f,u),F=Vc(B,v,1,"valid",f);return S?He(F,[F.shape[1],F.shape[2],F.shape[3]]):F}const Ob=Qe({separableConv2d_:_1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function R1(s){const t={x:Se(s,"x","sign")};return ze.runKernel(vf,t)}const Gb=Qe({sign_:R1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function k1(s){const t={x:Se(s,"x","sin","float32")};return ze.runKernel(bf,t)}const Ep=Qe({sin_:k1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VS(s){const t={x:Se(s,"x","sinh")};return ze.runKernel(yf,t)}const B1=Qe({sinh_:VS});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ub(s,t,i){const o=Se(s,"x","slice1d");return E(o.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${o.rank} tensor`),Vi(o,[t],[i])}const Sp=Qe({slice1d_:Ub});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pg(s,t,i){const o=Se(s,"x","slice2d");return E(o.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${o.rank} tensor`),Vi(o,t,i)}const zg=Qe({slice2d_:Pg});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function L1(s,t,i){const o=Se(s,"x","slice3d");return E(o.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${o.rank} tensor`),Vi(o,t,i)}const Ip=Qe({slice3d_:L1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eu(s,t,i){const o=Se(s,"x","slice4d");return E(o.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${o.rank} tensor`),Vi(o,t,i)}const Ho=Qe({slice4d_:eu});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tu(s,t=-1){const i=Se(s,"logits","softmax","float32");if(t===-1&&(t=i.rank-1),t!==i.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i.rank} and dim was ${t}`);const o={logits:i},l={dim:t};return ze.runKernel(Ef,o,l)}const eh=Qe({softmax_:tu});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Tp(s){E(s.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${s.dtype}.`);const t={input:s};return ze.runKernel(Ai,t)}const ql=Qe({fft_:Tp});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WS(s){E(s.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${s.dtype}.`);const t={input:s};return ze.runKernel(Ia,t)}const Vg=Qe({ifft_:WS});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mp(s){const t=s.shape[s.shape.length-1],i=s.size/t;let o;if(t<=2){const l=He(s,[i,t]);o=Vg(l)}else{const l=[i,2*(t-1)],u=He(Gc(s),[i,t]),f=He(Oc(s),[i,t]),g=Al(Vi(u,[0,1],[i,t-2]),1),A=Oe(Al(Vi(f,[0,1],[i,t-2]),1),Ni(-1)),v=yi([u,g],1),C=yi([f,A],1),S=He(La(v,C),[l[0],l[1]]);o=Vg(S)}if(o=Gc(o),s.rank===3&&s.shape[0]!==0){const l=o,u=s.shape[0];o=He(o,[u,o.shape[0]/u,o.shape[1]]),l.dispose()}return o}const HS=Qe({irfft_:Mp});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function N1(s,t,i=0){const o={x:Se(s,"x","split")},l={numOrSizeSplits:t,axis:i};return ze.runKernel(Cf,o,l)}const zr=Qe({split_:N1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function D1(s,t){E(s.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${s.dtype}`);let i=s.shape[s.shape.length-1];const o=s.size/i;let l;if(t!=null&&t<i){const B=s.shape.map(P=>0),F=s.shape.map(P=>P);F[s.shape.length-1]=t,l=Vi(s,B,F),i=t}else if(t!=null&&t>i){const B=s.shape.map(F=>F);B[s.shape.length-1]=t-i,l=yi([s,Zs(B)],s.shape.length-1),i=t}else l=s;const u=oi(l),f=He(La(l,u),[o,i]),g=ql(f),A=Math.floor(i/2)+1,v=Gc(g),C=Oc(g),S=zr(v,[A,i-A],v.shape.length-1),M=zr(C,[A,i-A],C.shape.length-1),_=l.shape.slice();return _[l.shape.length-1]=A,He(La(S[0],M[0]),_)}const XS=Qe({rfft_:D1});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Wg(s,t){let i=Se(s,"a","squaredDifference"),o=Se(t,"b","squaredDifference");[i,o]=rs(i,o),$n(i.shape,o.shape);const l={a:i,b:o},u={};return ze.runKernel(Sf,l,u)}const Hg=Qe({squaredDifference_:Wg});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function F1(s,t){const i=Se(s,"x","squeeze","string_or_numeric");return He(i,ee(i.shape,t).newShape)}const Jl=Qe({squeeze_:F1});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pb(s,t=0){const i=PA(s,"tensors","stack","string_or_numeric");E(i.length>=1,()=>"Pass at least one tensor to tf.stack"),i.length>0&&E(t<=i[0].rank,()=>"Axis must be <= rank of the tensor");const o=i,l={axis:t};return ze.runKernel(ku,o,l)}const Xo=Qe({stack_:Pb});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function O1(s,t=0){const i={x:Se(s,"x","step")},o={alpha:t};return ze.runKernel(Rf,i,o)}const _p=Qe({step_:O1});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xg(s,t,i,o,l=0,u=0,f=0,g=0,A=0){const v={x:Se(s,"x","stridedSlice","string_or_numeric")},C={begin:t,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:f,newAxisMask:g,shrinkAxisMask:A};return ze.runKernel(Hm,v,C)}const d=Qe({stridedSlice_:Xg});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function m(s){const t={x:Se(s,"x","tan","float32")};return ze.runKernel(_c,t)}const x=Qe({tan_:m});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function T(s,t){k(s);const i=Bc(s,t);if(i.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return mo(s,null,i,t)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function L(s,t,i){if(k(s),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const o=Bc(s,i);if(o.length!==2&&o.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(o.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return mo(s,t,o,i)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function z(s,t=1,i=!0){const o=Se(s,"x","topk");if(o.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const l=o.shape[o.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>l)throw new Error(`'k' passed to topk() must be <= the last dimension (${l}) but got ${t}`);const u={x:o},f={k:t,sorted:i},[g,A]=ze.runKernel(Tf,u,f);return{values:g,indices:A}}const te=Qe({topk_:z});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function le(s,t=0,i=1,o,l){if(o!=null&&o==="bool")throw new Error("Unsupported data type $ { dtype }");const u=new xd(t,i,o,!0,l),f=On(s,o);for(let g=0;g<f.values.length;g++)f.values[g]=u.nextValue();return f.toTensor()}const Ce=Qe({truncatedNormal_:le});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function it(s,t=0){const i=Se(s,"x","unique","string_or_numeric");E(i.rank>0,()=>"The input tensor must be at least 1D");const o={x:i},l={axis:t},[u,f]=ze.runKernel(Xm,o,l);return{values:u,indices:f}}const Ct=Qe({unique_:it});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rt(s,t,i){const o=Se(s,"x","unsortedSegmentSum"),l=Se(t,"segmentIds","unsortedSegmentSum","int32");E(D(i),()=>"numSegments must be of dtype int");const u={x:o,segmentIds:l},f={numSegments:i};return ze.runKernel(Qm,u,f)}const at=Qe({unsortedSegmentSum_:Rt});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lt(s,t=0){const i=Se(s,"x","unstack","string_or_numeric");E(t>=-i.shape.length&&t<i.shape.length,()=>`Axis = ${t} is not in [-${i.shape.length}, ${i.shape.length})`);const o={value:i},l={axis:t};return ze.runKernel(_f,o,l)}const Fn=Qe({unstack_:lt});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pn(s,t=!0,i,o){return ze.makeVariable(s,t,i,o)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ji(s,t){const i=[];for(let u=0;u<t.length;u++)t[u]&&i.push(u);const o=On(s,"int32"),l=On([i.length,s.length],"int32");for(let u=0;u<i.length;u++){const f=o.indexToLoc(i[u]),g=u*s.length;l.values.set(f,g)}return l.toTensor()}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ke(s,t){if(t==null)return s.shape.slice();if(O(s.shape,t))return t;if(s.shape.length===t.length){const i=[];for(let o=0;o<s.shape.length;o++)t[o]==null&&s.shape[o]!=null?i.push(s.shape[o]):i.push(t[o]);return i}return t}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fe(s,t,i,o){const l=Se(s,"x","dropout");if(E(l.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${l.dtype} tensor instead.`),E(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return s instanceof Ci?l.clone():l;const u=Ke(l,i),f=1-t,g=En(fp(Ut(Ju(u,0,1,"float32",o),f)),f);return Oe(l,g)}const qe=Qe({dropout_:Fe});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function St(s,t,i,o,l,u="NHWC",f){let g=s;s.rank===3&&(g=He(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let A=t;A.rank===3&&(A=He(t,[1,t.shape[0],t.shape[1],t.shape[2]])),E(g.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${g.shape}.`),E(A.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${A.shape}.`),E(i.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${i}.`);const v=u==="NHWC"?g.shape[3]:g.shape[1],C=u==="NHWC"?A.shape[3]:A.shape[1];E(v===i[2],()=>`Error in conv2dDerFilter: depth of input ${v}) must match input depth in filter (${i[2]}.`),E(C===i[3],()=>`Error in conv2dDerFilter: depth of dy (${C}) must match output depth for filter (${i[3]}).`),Ms("conv2dDerFilter",l,f);const S={x:g,dy:A},M={strides:o,pad:l,dataFormat:u,dimRoundingMode:f,filterShape:i};return ze.runKernel(xc,S,M)}const gn=Qe({conv2DBackpropFilter_:St});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ui(s,t,i){if(i==null||i==="linear")return s;if(i==="relu")return Oe(s,_p(t));throw new Error(`Cannot compute gradient for fused activation ${i}.`)}function Sn(s,t){let i=t;const o=Qs(s.shape,t.shape);return o.length>0&&(i=wn(i,o)),He(i,s.shape)}function Gn(s,t,i,o){if(t==="linear")return s;if(t==="relu")return Wo(s);if(t==="elu")return hd(s);if(t==="relu6")return M1(s);if(t==="prelu")return Ha(s,i);if(t==="leakyrelu")return pp(s,o);if(t==="sigmoid")return sd(s);throw new Error(`Unknown fused activation ${t}.`)}const Js=(s,t)=>!(s>0)||t==="linear";/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ui({x:s,filter:t,strides:i,pad:o,dataFormat:l="NHWC",dilations:u=[1,1],dimRoundingMode:f,bias:g,activation:A="linear",preluActivationWeights:v,leakyreluAlpha:C}){if(A=A||"linear",Js(ze.state.gradientDepth,A)===!1){E(l==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${l} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let he=Vc(s,t,i,o,l,u,f);return g!=null&&(he=Ut(he,g)),Gn(he,A,v,C)}const S=Se(s,"x","conv2d","float32"),M=Se(t,"filter","conv2d","float32");let _=S,B=!1;S.rank===3&&(B=!0,_=He(S,[1,S.shape[0],S.shape[1],S.shape[2]])),E(_.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${_.rank}.`),E(M.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${M.rank}.`),Ms("fused conv2d",o,f);const F=l==="NHWC"?_.shape[3]:_.shape[1];E(M.shape[2]===F,()=>`Error in conv2d: depth of input (${F}) must match input depth for filter ${M.shape[2]}.`),E(or(i,u),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const P=qs(_.shape,M.shape,i,u,o,f);let U;g!=null&&(U=Se(g,"bias","fused conv2d"),[U]=rs(U,S),l==="NHWC"?$n(P.outShape,U.shape):(E(U.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${U.shape.length}.`),E(U.shape.length===0||U.shape[0]===P.outChannels||U.shape[0]===1,()=>`Error in fused conv2d: bias shape (${U.shape}) is not compatible with the number of output channels (${P.outChannels})`)));let V;if(v!=null){const he=v.shape;if(E(he.length<=1||he.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${he.length}.`),he.length===1)E(he[0]===1||he[0]===P.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${he}) is not compatible with the number of output channels (${P.outChannels}).`);else if(he.length===3)try{$n(he,P.outShape)}catch{const me=`Error in fused conv2d: PReLU activation weights (${he}) is not compatible with the output shape of the conv2d (${P.outShape}).`;throw Error(me)}V=Se(v,"prelu weights","fused conv2d")}const $=(he,me)=>{E(l==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${l} but only NHWC is currently supported.`);const[pe,ye,Te,Ye]=me,et=ui(he,Te,A);E(Pc(u),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${u}'`);const nt=lp(ye.shape,et,pe,i,o),ht=gn(ye,et,pe.shape,i,o),ct=[nt,ht];if(Ye!=null){const pt=Sn(Ye,et);ct.push(pt)}return ct},q={x:_,filter:M,bias:U,preluActivationWeights:V},ne={strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:f,activation:A,leakyreluAlpha:C};return g==null?Yc((he,me,pe)=>{let ye=ze.runKernel(Rc,q,ne);return pe([me,he,ye]),B&&(ye=He(ye,[ye.shape[1],ye.shape[2],ye.shape[3]])),{value:ye,gradFunc:$}})(_,M):Yc((he,me,pe,ye)=>{let Te=ze.runKernel(Rc,q,ne);return ye([me,he,Te,pe]),B&&(Te=He(Te,[Te.shape[1],Te.shape[2],Te.shape[3]])),{value:Te,gradFunc:$}})(_,M,U)}const nu=Qe({fusedConv2d_:Ui});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function QS(s,t,i,o,l,u=[1,1],f){let g=s;s.rank===3&&(g=He(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let A=t;A.rank===3&&(A=He(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const v={x:g,dy:A},C={strides:o,pad:l,dimRoundingMode:f,dilations:u,filterShape:i};return ze.runKernel(Lo,v,C)}const UW=Qe({depthwiseConv2dNativeBackpropFilter_:QS});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PW(s,t,i,o,l,u=[1,1],f){let g=t,A=!1;t.rank===3&&(A=!0,g=He(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const v={dy:g,filter:i},C={strides:o,pad:l,dimRoundingMode:f,dilations:u,inputShape:s},S=ze.runKernel(il,v,C);return A?He(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const zW=Qe({depthwiseConv2dNativeBackpropInput_:PW});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function VW({a:s,b:t,transposeA:i=!1,transposeB:o=!1,bias:l,activation:u="linear",preluActivationWeights:f,leakyreluAlpha:g=.2}){if(Js(ze.state.gradientDepth,u)===!1){let Te=Li(s,t,i,o);return l!=null&&(Te=Ut(Te,l)),Gn(Te,u,f,g)}let A=Se(s,"a","fused matMul"),v=Se(t,"b","fused matMul");[A,v]=rs(A,v);const C=i?A.shape[A.rank-2]:A.shape[A.rank-1],S=o?v.shape[v.rank-1]:v.shape[v.rank-2],M=i?A.shape[A.rank-1]:A.shape[A.rank-2],_=o?v.shape[v.rank-2]:v.shape[v.rank-1],B=A.shape.slice(0,-2),F=v.shape.slice(0,-2),P=N(B),U=N(F);E(C===S,()=>`Error in fused matMul: inner shapes (${C}) and (${S}) of Tensors with shapes ${A.shape} and ${v.shape} and transposeA=${i} and transposeB=${o} must match.`);const V=$n(A.shape.slice(0,-2),v.shape.slice(0,-2)).concat([M,_]),$=i?He(A,[P,C,M]):He(A,[P,M,C]),q=o?He(v,[U,_,S]):He(v,[U,S,_]);let ne;l!=null&&(ne=Se(l,"bias","fused matMul"),[ne]=rs(ne,A),$n(V,ne.shape));let he;f!=null&&(he=Se(f,"prelu weights","fused matMul"));const me=(Te,Ye)=>{const[et,nt,ht,ct]=Ye,pt=ui(He(Te,ht.shape),ht,u);let Et,yt;if(!i&&!o?(Et=Li(pt,nt,!1,!0),yt=Li(et,pt,!0,!1)):!i&&o?(Et=Li(pt,nt,!1,!1),yt=Li(pt,et,!0,!1)):i&&!o?(Et=Li(nt,pt,!1,!0),yt=Li(et,pt,!1,!1)):(Et=Li(nt,pt,!0,!0),yt=Li(pt,et,!0,!0)),l!=null){const It=Sn(ct,pt);return[Et,yt,It]}else return[Et,yt]},pe={a:$,b:q,bias:ne,preluActivationWeights:he},ye={transposeA:i,transposeB:o,activation:u,leakyreluAlpha:g};return l==null?Yc((Te,Ye,et)=>{const nt=ze.runKernel(Gr,pe,ye);return et([Te,Ye,nt]),{value:He(nt,V),gradFunc:me}})($,q):Yc((Te,Ye,et,nt)=>{const ht=ze.runKernel(Gr,pe,ye);return nt([Te,Ye,ht,et]),{value:He(ht,V),gradFunc:me}})($,q,ne)}const dB=Qe({fusedMatMul_:VW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WW(s,t,i,o,l="bilinear",u=0){const f=Se(s,"image","cropAndResize"),g=Se(t,"boxes","cropAndResize","float32"),A=Se(i,"boxInd","cropAndResize","int32"),v=g.shape[0];E(f.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${f.rank}.`),E(g.rank===2&&g.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${v},4] but had shape ${g.shape}.`),E(A.rank===1&&A.shape[0]===v,()=>`Error in cropAndResize: boxInd must be have size [${v}] but had shape ${g.shape}.`),E(o.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${o.length}.`),E(o[0]>=1&&o[1]>=1,()=>`cropSize must be atleast [1,1], but was ${o}`),E(l==="bilinear"||l==="nearest",()=>`method must be bilinear or nearest, but was ${l}`);const C={image:f,boxes:g,boxInd:A},S={method:l,extrapolationValue:u,cropSize:o};return ze.runKernel(Bo,C,S)}const HW=Qe({cropAndResize_:WW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XW(s){const t=Se(s,"image","flipLeftRight","float32");E(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const i={image:t};return ze.runKernel(ys,i,{})}const QW=Qe({flipLeftRight_:XW});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KW(s){const t=Se(s,"image","grayscaleToRGB"),i=t.rank-1,o=t.shape[i];E(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),E(o===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${o}.`);const l=new Array(t.rank);return l.fill(1,0,i),l[i]=3,yo(t,l)}const ZW=Qe({grayscaleToRGB_:KW});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $W(s,t,i=0,o=.5){const l=Se(s,"image","rotateWithOffset","float32");E(l.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${l.rank}.`);const u={image:l},f={radians:t,fillValue:i,center:o};return ze.runKernel(wA,u,f)}const YW=Qe({rotateWithOffset_:$W});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Qg(s,t,i,o,l,u){o==null&&(o=.5),l==null&&(l=Number.NEGATIVE_INFINITY),u==null&&(u=0);const f=s.shape[0];return i=Math.min(i,f),E(0<=o&&o<=1,()=>`iouThreshold must be in [0, 1], but was '${o}'`),E(s.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${s.rank}'`),E(s.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${s.shape[1]}`),E(t.rank===1,()=>"scores must be a 1D tensor"),E(t.shape[0]===f,()=>`scores has incompatible shape with boxes. Expected ${f}, but was ${t.shape[0]}`),E(0<=u&&u<=1,()=>`softNmsSigma must be in [0, 1], but was '${u}'`),{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jW(s,t,i,o=.5,l=Number.NEGATIVE_INFINITY){const u=Se(s,"boxes","nonMaxSuppression","float32"),f=Se(t,"scores","nonMaxSuppression","float32"),g=Qg(u,f,i,o,l);i=g.maxOutputSize,o=g.iouThreshold,l=g.scoreThreshold;const A={maxOutputSize:i,iouThreshold:o,scoreThreshold:l};return ze.runKernel(Ru,{boxes:u,scores:f},A)}const qW=Qe({nonMaxSuppression_:jW});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JW(s,t,i){const o=e5(s,t,i),l=o<0?-(o+1):o;s.splice(l,0,t)}function e5(s,t,i){return n5(s,t,i||t5)}function t5(s,t){return s>t?1:s<t?-1:0}function n5(s,t,i){let o=0,l=s.length,u=0,f=!1;for(;o<l;){u=o+(l-o>>>1);const g=i(t,s[u]);g>0?o=u+1:(l=u,f=!g)}return f?o:-o-1}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KS(s,t,i,o,l){return YS(s,t,i,o,l,0)}function ZS(s,t,i,o,l,u){return YS(s,t,i,o,l,0,!1,u,!0)}function $S(s,t,i,o,l,u){return YS(s,t,i,o,l,u,!0)}function YS(s,t,i,o,l,u,f=!1,g=!1,A=!1){const v=[];for(let P=0;P<t.length;P++)t[P]>l&&v.push({score:t[P],boxIndex:P,suppressBeginIndex:0});v.sort(fB);const C=u>0?-.5/u:0,S=[],M=[];for(;S.length<i&&v.length>0;){const P=v.pop(),{score:U,boxIndex:V,suppressBeginIndex:$}=P;if(U<l)break;let q=!1;for(let ne=S.length-1;ne>=$;--ne){const he=i5(s,V,S[ne]);if(he>=o){q=!0;break}if(P.score=P.score*s5(o,C,he),P.score<=l)break}P.suppressBeginIndex=S.length,q||(P.score===U?(S.push(V),M.push(P.score)):P.score>l&&JW(v,P,fB))}const _=S.length,B=i-_;g&&B>0&&(S.push(...new Array(B).fill(0)),M.push(...new Array(B).fill(0)));const F={selectedIndices:S};return f&&(F.selectedScores=M),A&&(F.validOutputs=_),F}function i5(s,t,i){const o=s.subarray(t*4,t*4+4),l=s.subarray(i*4,i*4+4),u=Math.min(o[0],o[2]),f=Math.min(o[1],o[3]),g=Math.max(o[0],o[2]),A=Math.max(o[1],o[3]),v=Math.min(l[0],l[2]),C=Math.min(l[1],l[3]),S=Math.max(l[0],l[2]),M=Math.max(l[1],l[3]),_=(g-u)*(A-f),B=(S-v)*(M-C);if(_<=0||B<=0)return 0;const F=Math.max(u,v),P=Math.max(f,C),U=Math.min(g,S),V=Math.min(A,M),$=Math.max(U-F,0)*Math.max(V-P,0);return $/(_+B-$)}function s5(s,t,i){const o=Math.exp(t*i*i);return i<=s?o:0}function fB(s,t){return s.score-t.score||s.score===t.score&&t.boxIndex-s.boxIndex}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function r5(s,t,i,o=.5,l=Number.NEGATIVE_INFINITY){const u=Se(s,"boxes","nonMaxSuppressionAsync"),f=Se(t,"scores","nonMaxSuppressionAsync"),g=Qg(u,f,i,o,l);i=g.maxOutputSize,o=g.iouThreshold,l=g.scoreThreshold;const A=await Promise.all([u.data(),f.data()]),v=A[0],C=A[1],{selectedIndices:S}=KS(v,C,i,o,l);return u!==s&&u.dispose(),f!==t&&f.dispose(),T(S,"int32")}const a5=r5;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function o5(s,t,i,o=.5,l=Number.NEGATIVE_INFINITY,u=0){const f=Se(s,"boxes","nonMaxSuppression"),g=Se(t,"scores","nonMaxSuppression"),A=Qg(f,g,i,o,l,u);i=A.maxOutputSize,o=A.iouThreshold,l=A.scoreThreshold,u=A.softNmsSigma;const v={boxes:f,scores:g},C={maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u},S=ze.runKernel(cf,v,C);return{selectedIndices:S[0],selectedScores:S[1]}}const l5=Qe({nonMaxSuppressionWithScore_:o5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function c5(s,t,i,o=.5,l=Number.NEGATIVE_INFINITY,u=0){const f=Se(s,"boxes","nonMaxSuppressionAsync"),g=Se(t,"scores","nonMaxSuppressionAsync"),A=Qg(f,g,i,o,l,u);i=A.maxOutputSize,o=A.iouThreshold,l=A.scoreThreshold,u=A.softNmsSigma;const v=await Promise.all([f.data(),g.data()]),C=v[0],S=v[1],{selectedIndices:M,selectedScores:_}=$S(C,S,i,o,l,u);return f!==s&&f.dispose(),g!==t&&g.dispose(),{selectedIndices:T(M,"int32"),selectedScores:T(_)}}const u5=c5;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function h5(s,t,i,o=.5,l=Number.NEGATIVE_INFINITY,u=!1){const f=Se(s,"boxes","nonMaxSuppression"),g=Se(t,"scores","nonMaxSuppression"),A=Qg(f,g,i,o,l,null),v=A.maxOutputSize,C=A.iouThreshold,S=A.scoreThreshold,M={boxes:f,scores:g},_={maxOutputSize:v,iouThreshold:C,scoreThreshold:S,padToMaxOutputSize:u},B=ze.runKernel(uA,M,_);return{selectedIndices:B[0],validOutputs:B[1]}}const d5=Qe({nonMaxSuppressionPadded_:h5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/async function f5(s,t,i,o=.5,l=Number.NEGATIVE_INFINITY,u=!1){const f=Se(s,"boxes","nonMaxSuppressionAsync"),g=Se(t,"scores","nonMaxSuppressionAsync"),A=Qg(f,g,i,o,l,null),v=A.maxOutputSize,C=A.iouThreshold,S=A.scoreThreshold,[M,_]=await Promise.all([f.data(),g.data()]),{selectedIndices:B,validOutputs:F}=ZS(M,_,v,C,S,u);return f!==s&&f.dispose(),g!==t&&g.dispose(),{selectedIndices:T(B,"int32"),validOutputs:Ni(F,"int32")}}const p5=f5;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function m5(s,t,i=!1,o=!1){const l=Se(s,"images","resizeBilinear");E(l.rank===3||l.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${l.rank}.`),E(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),E(o===!1||i===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let u=l,f=!1;l.rank===3&&(f=!0,u=He(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const g={images:u},A={alignCorners:i,halfPixelCenters:o,size:t},v=ze.runKernel(Um,g,A);return f?He(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const pB=Qe({resizeBilinear_:m5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function g5(s,t,i=!1,o=!1){const l=Se(s,"images","resizeNearestNeighbor");E(l.rank===3||l.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${l.rank}.`),E(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),E(l.dtype==="float32"||l.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),E(o===!1||i===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let u=l,f=!1;l.rank===3&&(f=!0,u=He(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const g={images:u},A={alignCorners:i,halfPixelCenters:o,size:t},v=ze.runKernel(Gm,g,A);return f?He(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const mB=Qe({resizeNearestNeighbor_:g5});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function A5(s,t="binary",i=!1,o=.5){const l=Se(s,"image","threshold"),u=.2989,f=.587,g=.114,A=l.shape[0]*l.shape[1];let v=Oe(T([o]),255),C,S,M,_;if(E(l.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`),E(l.shape[2]===3||l.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`),E(l.dtype==="int32"||l.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`),E(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),l.shape[2]===3){[C,S,M]=zr(l,[1,1,1],-1);const F=Oe(C,u),P=Oe(S,f),U=Oe(M,g);_=Ut(Ut(F,P),U)}else _=s;if(t==="otsu"){const F=ub(hn(Ug(_),"int32"),Ur([]),256);v=b5(F,A)}const B=i?qr(_,v):Va(_,v);return hn(Oe(B,255),"int32")}function b5(s,t){let i=T([-1]),o=T([0]),l=T([0]),u,f,g,A,v,C;for(let S=0;S<s.size-1;S++){u=Vi(s,0,S+1),f=Vi(s,S+1),v=En(wn(u),t),C=En(wn(f),t);const M=wn(Oe(u,Cp(0,u.size)));g=En(M,wn(u));const _=op(f.shape,u.size),B=Ut(Cp(0,f.size),_),F=Oe(f,B);A=En(wn(F),wn(f));const P=Wn(g,A),U=Wn(g,A),V=Oe(v,C);l=Oe(Oe(V,P),U);const $=Va(l,o);o=Ii($,l,o),i=Ii($,T([S]),i)}return i}const y5=Qe({threshold_:A5});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function v5(s,t,i="nearest",o="constant",l=0,u){const f=Se(s,"image","transform","float32"),g=Se(t,"transforms","transform","float32");E(f.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${f.rank}.`),E(g.rank===2&&(g.shape[0]===f.shape[0]||g.shape[0]===1)&&g.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),E(u==null||u.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${u}.`);const A={image:f,transforms:g},v={interpolation:i,fillMode:o,fillValue:l,outputShape:u};return ze.runKernel(Mf,A,v)}const x5=Qe({transform_:v5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function w5(s,t,i){E(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),E(i%1===0,()=>`bandPart(): numUpper must be an integer, got ${i}.`);const o=Se(s,"a","bandPart");E(o.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${o.rank}.`);const l=o.shape,[u,f]=o.shape.slice(-2);if(!(t<=u))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${u}).`);if(!(i<=f))throw new Error(`bandPart(): numUpper (${i}) must not be greater than the number of columns (${f}).`);t<0&&(t=u),i<0&&(i=f);const g=He(Cp(0,u,1,"int32"),[-1,1]),A=Cp(0,f,1,"int32"),v=Wn(g,A),C=Vo(qr(v,Ni(+t,"int32")),$c(v,Ni(-i,"int32"))),S=Zs([u,f],o.dtype);return He(Xo(Fn(He(o,[-1,u,f])).map(M=>Ii(C,M,S))),l)}const C5=Qe({bandPart_:w5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function E5(s){let t;if(Array.isArray(s)){t=!1,E(s!=null&&s.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const l=s[0].shape[0];for(let u=1;u<s.length;++u)E(s[u].shape[0]===l,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${s[u].shape[0]} vs. ${l})`)}else t=!0,s=zr(s,s.shape[0],0).map(l=>Jl(l,[0]));E(s.length<=s[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${s.length}) exceeds number of dimensions (${s[0].shape[0]}).`);const i=[],o=s;for(let l=0;l<s.length;++l)i.push(ze.tidy(()=>{let u=o[l];if(l>0)for(let f=0;f<l;++f){const g=Oe(wn(Oe(i[f],u)),i[f]);u=Wn(u,g)}return En(u,dp(u,"euclidean"))}));return t?Xo(i,0):i}const S5=Qe({gramSchmidt_:E5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function I5(s,t=!1){if(E(s.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${s.rank}`),s.rank===2)return gB(s,t);{const i=s.shape.slice(0,s.shape.length-2).reduce((A,v)=>A*v),o=Fn(He(s,[i,s.shape[s.shape.length-2],s.shape[s.shape.length-1]]),0),l=[],u=[];o.forEach(A=>{const[v,C]=gB(A,t);l.push(v),u.push(C)});const f=He(Xo(l,0),s.shape),g=He(Xo(u,0),s.shape);return[f,g]}}function gB(s,t=!1){return ze.tidy(()=>{E(s.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${s.shape.length}D Tensor.`);const i=s.shape[0],o=s.shape[1];let l=xb(i),u=Ul(s);const f=L([[1]],[1,1]);let g=Ul(f);const A=i>=o?o:i;for(let v=0;v<A;++v){const C=u,S=g,M=l;[g,u,l]=ze.tidy(()=>{const _=Vi(u,[v,v],[i-v,1]),B=dp(_),F=Vi(u,[v,v],[1,1]),P=Ii(Va(F,0),L([[-1]]),L([[1]])),U=Wn(F,Oe(P,B)),V=En(_,U);V.shape[0]===1?g=Ul(f):g=yi([f,Vi(V,[1,0],[V.shape[0]-1,V.shape[1]])],0);const $=Us(En(Li(P,U),B)),q=Vi(u,[v,0],[i-v,o]),ne=Oe($,g),he=bi(g);if(v===0)u=Wn(q,Li(ne,Li(he,q)));else{const ye=Wn(q,Li(ne,Li(he,q)));u=yi([Vi(u,[0,0],[v,o]),ye],0)}const me=bi(ne),pe=Vi(l,[0,v],[i,l.shape[1]-v]);if(v===0)l=Wn(pe,Li(Li(pe,g),me));else{const ye=Wn(pe,Li(Li(pe,g),me));l=yi([Vi(l,[0,0],[i,v]),ye],1)}return[g,u,l]}),ci([C,S,M])}return!t&&i>o&&(l=Vi(l,[0,0],[i,o]),u=Vi(u,[0,0],[o,o])),[l,u]})}const T5=Qe({qr_:I5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const G1={flipLeftRight:QW,grayscaleToRGB:ZW,resizeNearestNeighbor:mB,resizeBilinear:pB,rotateWithOffset:YW,cropAndResize:HW,nonMaxSuppression:qW,nonMaxSuppressionAsync:a5,nonMaxSuppressionWithScore:l5,nonMaxSuppressionWithScoreAsync:u5,nonMaxSuppressionPadded:d5,nonMaxSuppressionPaddedAsync:p5,threshold:y5,transform:x5},M5={bandPart:C5,gramSchmidt:S5,qr:T5};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Cd extends dl{minimize(t,i=!1,o){const{value:l,grads:u}=this.computeGradients(t,o);if(o!=null){const f=o.map(g=>({name:g.name,tensor:u[g.name]}));this.applyGradients(f)}else this.applyGradients(u);return ci(u),i?l:(l.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,i){return bS(t,i)}dispose(){this.iterations_!=null&&ci(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ni(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Cd,Symbol.hasInstance,{value:s=>s.minimize!=null&&s.computeGradients!=null&&s.applyGradients!=null});/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class jS extends Cd{constructor(t,i,o=null){super(),this.learningRate=t,this.rho=i,this.epsilon=o,this.accumulatedGrads=[],this.accumulatedUpdates=[],o==null&&(this.epsilon=ze.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,o)=>{const l=ze.registeredVariables[i],u=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${i}/accum_grad`,variable:$e(()=>oi(l).variable(u))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${i}/accum_var`,variable:$e(()=>oi(l).variable(u))});const f=Array.isArray(t)?t[o].tensor:t[i];if(f==null)return;const g=this.accumulatedGrads[o].variable,A=this.accumulatedUpdates[o].variable;$e(()=>{const v=Ut(Oe(g,this.rho),Oe(qi(f),1-this.rho)),C=Oe(En(Pr(Ut(A,this.epsilon)),Pr(Ut(g,this.epsilon))),f),S=Ut(Oe(A,this.rho),Oe(qi(C),1-this.rho));g.assign(v),A.assign(S);const M=Ut(Oe(C,-this.learningRate),l);l.assign(M)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(ci(this.accumulatedGrads.map(t=>t.variable)),ci(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(i=>({name:i.originalName,tensor:i.variable})))}async setWeights(t){t=await this.extractIterations(t);const i=t.length/2,o=!1;this.accumulatedGrads=t.slice(0,i).map(l=>({originalName:l.name,variable:l.tensor.variable(o)})),this.accumulatedUpdates=t.slice(i,i*2).map(l=>({originalName:l.name,variable:l.tensor.variable(o)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,i){return new t(i.learningRate,i.rho,i.epsilon)}}jS.className="Adadelta",Lt(jS);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class qS extends Cd{constructor(t,i=.1){super(),this.learningRate=t,this.initialAccumulatorValue=i,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,o)=>{const l=ze.registeredVariables[i];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${i}/accumulator`,variable:$e(()=>op(l.shape,this.initialAccumulatorValue).variable(!1))});const u=Array.isArray(t)?t[o].tensor:t[i];if(u==null)return;const f=this.accumulatedGrads[o].variable;$e(()=>{const g=Ut(f,qi(u));f.assign(g);const A=Ut(Oe(En(u,Pr(Ut(g,ze.backend.epsilon()))),-this.learningRate),l);l.assign(A)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&ci(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const i=!1;this.accumulatedGrads=t.map(o=>({originalName:o.name,variable:o.tensor.variable(i)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,i){return new t(i.learningRate,i.initialAccumulatorValue)}}qS.className="Adagrad",Lt(qS);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class JS extends Cd{constructor(t,i,o,l=null){super(),this.learningRate=t,this.beta1=i,this.beta2=o,this.epsilon=l,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],$e(()=>{this.accBeta1=Ni(i).variable(),this.accBeta2=Ni(o).variable()}),l==null&&(this.epsilon=ze.backend.epsilon())}applyGradients(t){const i=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);$e(()=>{const o=Wn(1,this.accBeta1),l=Wn(1,this.accBeta2);i.forEach((u,f)=>{const g=ze.registeredVariables[u],A=!1;this.accumulatedFirstMoment[f]==null&&(this.accumulatedFirstMoment[f]={originalName:`${u}/m`,variable:$e(()=>oi(g).variable(A))}),this.accumulatedSecondMoment[f]==null&&(this.accumulatedSecondMoment[f]={originalName:`${u}/v`,variable:$e(()=>oi(g).variable(A))});const v=Array.isArray(t)?t[f].tensor:t[u];if(v==null)return;const C=this.accumulatedFirstMoment[f].variable,S=this.accumulatedSecondMoment[f].variable,M=Ut(Oe(C,this.beta1),Oe(v,1-this.beta1)),_=Ut(Oe(S,this.beta2),Oe(qi(v),1-this.beta2)),B=En(M,o),F=En(_,l);C.assign(M),S.assign(_);const P=Ut(Oe(En(B,Ut(Pr(F),this.epsilon)),-this.learningRate),g);g.assign(P)}),this.accBeta1.assign(Oe(this.accBeta1,this.beta1)),this.accBeta2.assign(Oe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&ci(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&ci(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(i=>({name:i.originalName,tensor:i.variable})))}async setWeights(t){t=await this.extractIterations(t),$e(()=>{this.accBeta1.assign(gr(this.beta1,this.iterations_+1)),this.accBeta2.assign(gr(this.beta2,this.iterations_+1))});const i=t.length/2,o=!1;this.accumulatedFirstMoment=t.slice(0,i).map(l=>({originalName:l.name,variable:l.tensor.variable(o)})),this.accumulatedSecondMoment=t.slice(i,i*2).map(l=>({originalName:l.name,variable:l.tensor.variable(o)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,i){return new t(i.learningRate,i.beta1,i.beta2,i.epsilon)}}JS.className="Adam",Lt(JS);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class eI extends Cd{constructor(t,i,o,l=null,u=0){super(),this.learningRate=t,this.beta1=i,this.beta2=o,this.epsilon=l,this.decay=u,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],$e(()=>{this.iteration=Ni(0).variable(),this.accBeta1=Ni(i).variable()}),l==null&&(this.epsilon=ze.backend.epsilon())}applyGradients(t){const i=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);$e(()=>{const o=Wn(1,this.accBeta1),l=En(-this.learningRate,Ut(Oe(this.iteration,this.decay),1));i.forEach((u,f)=>{const g=ze.registeredVariables[u],A=!1;this.accumulatedFirstMoment[f]==null&&(this.accumulatedFirstMoment[f]={originalName:`${u}/m`,variable:oi(g).variable(A)}),this.accumulatedWeightedInfNorm[f]==null&&(this.accumulatedWeightedInfNorm[f]={originalName:`${u}/v`,variable:oi(g).variable(A)});const v=Array.isArray(t)?t[f].tensor:t[u];if(v==null)return;const C=this.accumulatedFirstMoment[f].variable,S=this.accumulatedWeightedInfNorm[f].variable,M=Ut(Oe(C,this.beta1),Oe(v,1-this.beta1)),_=Oe(S,this.beta2),B=Ri(v),F=Yl(_,B);C.assign(M),S.assign(F);const P=Ut(Oe(En(l,o),En(M,Ut(F,this.epsilon))),g);g.assign(P)}),this.iteration.assign(Ut(this.iteration,1)),this.accBeta1.assign(Oe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&ci(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&ci(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,i){return new t(i.learningRate,i.beta1,i.beta2,i.epsilon,i.decay)}}eI.className="Adamax",Lt(eI);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class U1 extends Cd{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,o)=>{const l=Array.isArray(t)?t[o].tensor:t[i];if(l==null)return;const u=ze.registeredVariables[i];$e(()=>{const f=Ut(Oe(this.c,l),u);u.assign(f)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=ca(Ni(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,i){return new t(i.learningRate)}}U1.className="SGD",Lt(U1);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class tI extends U1{constructor(t,i,o=!1){super(t),this.learningRate=t,this.momentum=i,this.useNesterov=o,this.accumulations=[],this.m=Ni(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,o)=>{const l=ze.registeredVariables[i];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${i}/momentum`,variable:$e(()=>oi(l).variable(!1))});const u=this.accumulations[o].variable,f=Array.isArray(t)?t[o].tensor:t[i];f!=null&&$e(()=>{let g;const A=Ut(Oe(this.m,u),f);this.useNesterov?g=Ut(Oe(this.c,Ut(f,Oe(A,this.m))),l):g=Ut(Oe(this.c,A),l),u.assign(A),l.assign(g)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&ci(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const i=!1;this.accumulations=t.map(o=>({originalName:o.name,variable:o.tensor.variable(i)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,i){return new t(i.learningRate,i.momentum,i.useNesterov)}}tI.className="Momentum",Lt(tI);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class nI extends Cd{constructor(t,i=.9,o=0,l=null,u=!1){if(super(),this.learningRate=t,this.decay=i,this.momentum=o,this.epsilon=l,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=u,l==null&&(this.epsilon=ze.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,o)=>{const l=ze.registeredVariables[i],u=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${i}/rms`,variable:$e(()=>oi(l).variable(u))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${i}/momentum`,variable:$e(()=>oi(l).variable(u))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${i}/mg`,variable:$e(()=>oi(l).variable(u))});const f=Array.isArray(t)?t[o].tensor:t[i];if(f==null)return;const g=this.accumulatedMeanSquares[o].variable,A=this.accumulatedMoments[o].variable;$e(()=>{const v=Ut(Oe(g,this.decay),Oe(qi(f),1-this.decay));if(this.centered){const C=this.accumulatedMeanGrads[o].variable,S=Ut(Oe(C,this.decay),Oe(f,1-this.decay)),M=En(Oe(f,this.learningRate),Pr(Wn(v,Ut(qi(S),this.epsilon)))),_=Ut(Oe(A,this.momentum),M);g.assign(v),C.assign(S),A.assign(_);const B=Wn(l,_);l.assign(B)}else{const C=Ut(Oe(g,this.decay),Oe(qi(f),1-this.decay)),S=Ut(Oe(A,this.momentum),En(Oe(f,this.learningRate),Pr(Ut(C,this.epsilon))));g.assign(C),A.assign(S);const M=Wn(l,S);l.assign(M)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&ci(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&ci(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&ci(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(i=>({name:i.originalName,tensor:i.variable})))}async setWeights(t){t=await this.extractIterations(t);const i=this.centered?t.length/3:t.length/2,o=!1;this.accumulatedMeanSquares=t.slice(0,i).map(l=>({originalName:l.name,variable:l.tensor.variable(o)})),this.accumulatedMoments=t.slice(i,i*2).map(l=>({originalName:l.name,variable:l.tensor.variable(o)})),this.centered&&(this.accumulatedMeanGrads=t.slice(i*2,i*3).map(l=>({originalName:l.name,variable:l.tensor.variable(o)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,i){return new t(i.learningRate,i.decay,i.momentum,i.epsilon,i.centered)}}nI.className="RMSProp",Lt(nI);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Rp{static sgd(t){return new U1(t)}static momentum(t,i,o=!1){return new tI(t,i,o)}static rmsprop(t,i=.9,o=0,l=null,u=!1){return new nI(t,i,o,l,u)}static adam(t=.001,i=.9,o=.999,l=null){return new JS(t,i,o,l)}static adadelta(t=.001,i=.95,o=null){return new jS(t,i,o)}static adamax(t=.002,i=.9,o=.999,l=null,u=0){return new eI(t,i,o,l,u)}static adagrad(t,i=.1){return new qS(t,i)}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Kg={sgd:Rp.sgd,momentum:Rp.momentum,adadelta:Rp.adadelta,adagrad:Rp.adagrad,rmsprop:Rp.rmsprop,adamax:Rp.adamax,adam:Rp.adam};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _5=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:s=>s();function P1(){return new Promise(s=>_5(()=>s()))}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iI(s,t){const i=s[0].length;s.forEach((l,u)=>{E(l.length===i,()=>`Error in concat${i}D: rank of tensors[${u}] must be the same as the rank of the rest (${i})`)}),E(t>=0&&t<i,()=>`Error in concat${i}D: axis must be between 0 and ${i-1}.`);const o=s[0];s.forEach((l,u)=>{for(let f=0;f<i;f++)E(f===t||l[f]===o[f],()=>`Error in concat${i}D: Shape of tensors[${u}] (${l}) does not match the shape of the rest (${o}) along the non-concatenated axis ${u}.`)})}function iu(s,t){const i=s[0].slice();for(let o=1;o<s.length;o++)i[t]+=s[o][t];return i}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var bl;(function(s){s[s.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",s[s.VALUE_ROWIDS=1]="VALUE_ROWIDS",s[s.ROW_LENGTHS=2]="ROW_LENGTHS",s[s.ROW_SPLITS=3]="ROW_SPLITS",s[s.ROW_LIMITS=4]="ROW_LIMITS",s[s.ROW_STARTS=5]="ROW_STARTS"})(bl||(bl={}));function sI(s,t,i){let o=new Array;if(i==null&&t==null)return o;if(t==null)for(;o.length<s+i.length;)o.push(-1);else o=t.slice();if(i==null)return o;if(s+i.length!==o.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${s+i.length}, but shape.rank = ${o.length}`);for(let l=1;l<i.length;++l){const u=i[l],f=o[o.length-i.length+l],g=o[f];if(u>=0)if(g>=0){if(g!==u)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${l+s}] = ${u} but shape[${l+s}] = ${g}`)}else o[f]=u}return o}function rI(s){const t={FIRST_DIM_SIZE:bl.FIRST_DIM_SIZE,VALUE_ROWIDS:bl.VALUE_ROWIDS,ROW_LENGTHS:bl.ROW_LENGTHS,ROW_SPLITS:bl.ROW_SPLITS,ROW_LIMITS:bl.ROW_LIMITS,ROW_STARTS:bl.ROW_STARTS},i=[];for(const o of s)if(o in t)i.push(t[o]);else break;return i}function aI(s){return s.length===0?0:s[0]===bl.FIRST_DIM_SIZE?s.length-1:s.length}function oI(s,t){if(s==null||t==null)return;const i=s.length,o=t.length;if(i>=o)throw new Error(`defaultValue.shape=${s} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${i} must be less than ragged tensor input flatValues.rank = ${o})`);for(let l=0;l<Math.min(i,o-1);++l){const u=s[l],f=t[l+1];if(u>=0&&f>=0&&u!==1&&u!==f)throw new Error(`defaultValue.shape=${s}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${l-s.length}] = ${u} but ragged tensor input.flatValues.shape[${l-s.length}] = ${f}`)}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lI=30;function z1(s){return s<=lI?s:Ve(s,Math.floor(Math.sqrt(s)))}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cI(s,t,i){const o=i*(typeof s=="number"?s:s[0]),l=t*(typeof s=="number"?s:s[1]);return[o,l]}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zb(s,t,i,o=!0){let l=[];if(o)l=l.concat(t.slice(0)),l.push(s[0]/i),l=l.concat(s.slice(1));else{l=l.concat(s[0]);const u=t.length;for(let f=0;f<u;++f)l=l.concat([s[f+1]/t[f],t[f]]);l=l.concat(s.slice(u+1))}return l}function Vb(s,t,i=!0){const o=[];if(i){o.push(t);for(let l=t+1;l<s;++l)l<=2*t?(o.push(l),o.push(l-(t+1))):o.push(l)}else{const l=[],u=[];for(let f=1;f<s;++f)f>=t*2+1||f%2===1?u.push(f):l.push(f);o.push(...l),o.push(0),o.push(...u)}return o}function Wb(s,t,i,o=!0){const l=[];o?l.push(s[0]/i):l.push(s[0]*i);for(let u=1;u<s.length;++u)u<=t.length?o?l.push(t[u-1]*s[u]):l.push(s[u]/t[u-1]):l.push(s[u]);return l}function uI(s,t){const i=[0];for(let o=0;o<t;++o)i.push(s[o][0]);return i}function hI(s,t,i){const o=s.slice(0,1);for(let l=0;l<i;++l)o.push(s[l+1]-t[l][0]-t[l][1]);return o}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const V1=1.7580993408473768,W1=1.0507009873554805;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dI=.3275911,fI=.254829592,pI=-.284496736,mI=1.421413741,gI=-1.453152027,AI=1.061405429;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function th(s,t){if(s.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${s.length}, imag: ${t.length}.`);const i=new Float32Array(s.length*2);for(let o=0;o<i.length;o+=2)i[o]=s[o/2],i[o+1]=t[o/2];return i}function AB(s){const t=new Float32Array(s.length/2),i=new Float32Array(s.length/2);for(let o=0;o<s.length;o+=2)t[o/2]=s[o],i[o/2]=s[o+1];return{real:t,imag:i}}function bB(s){const t=Math.ceil(s.length/4),i=new Float32Array(t),o=new Float32Array(t);for(let l=0;l<s.length;l+=4)i[Math.floor(l/4)]=s[l],o[Math.floor(l/4)]=s[l+1];return{real:i,imag:o}}function yB(s){const t=Math.floor(s.length/4),i=new Float32Array(t),o=new Float32Array(t);for(let l=2;l<s.length;l+=4)i[Math.floor(l/4)]=s[l],o[Math.floor(l/4)]=s[l+1];return{real:i,imag:o}}function bI(s,t){const i=s[t*2],o=s[t*2+1];return{real:i,imag:o}}function vB(s,t,i,o){s[o*2]=t,s[o*2+1]=i}function xB(s,t){const i=new Float32Array(s/2),o=new Float32Array(s/2);for(let l=0;l<Math.ceil(s/2);l++){const u=(t?2:-2)*Math.PI*(l/s);i[l]=Math.cos(u),o[l]=Math.sin(u)}return{real:i,imag:o}}function wB(s,t,i){const o=(i?2:-2)*Math.PI*(s/t),l=Math.cos(o),u=Math.sin(o);return{real:l,imag:u}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yI="->",R5=/->/g,CB=",",EB="...";function vI(s,t){s=s.replace(/\s/g,"");const i=(s.length-s.replace(R5,"").length)/yI.length;if(i<1)throw new Error("Equations without an arrow are not supported.");if(i>1)throw new Error(`Equation must contain exactly one arrow ("${yI}").`);const[o,l]=s.split(yI);E(o.indexOf(EB)===-1,()=>`The ellipsis notation ("${EB}") is not supported yet.`);const u=o.split(CB),f=u.length;if(t!==f)throw new Error(`Expected ${f} input tensors, received ${t}`);if(f>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const g=[];for(let M=0;M<l.length;++M){const _=l[M];if(!u.some(B=>B.indexOf(_)!==-1))throw new Error(`Output subscripts contain the label ${_} not present in the input subscripts.`);g.indexOf(_)===-1&&g.push(_)}for(let M=0;M<o.length;++M){const _=o[M];g.indexOf(_)===-1&&_!==CB&&g.push(_)}const A=new Array(u.length);for(let M=0;M<f;++M){if(new Set(u[M].split("")).size!==u[M].length)throw new Error(`Found duplicate axes in input component ${u[M]}. Support for duplicate axes in input is not implemented yet.`);A[M]=[];for(let _=0;_<u[M].length;++_)A[M].push(g.indexOf(u[M][_]))}const v=g.length,C=l.length,S=[];for(let M=C;M<v;++M)S.push(M);return{allDims:g,summedDims:S,idDims:A}}function xI(s,t){let i=new Array(s);i.fill(-1);for(let l=0;l<t.length;++l)i[t[l]]=l;const o=[];for(let l=0;l<s;++l)i[l]===-1&&o.push(l);return i=i.filter(l=>l!==-1),{permutationIndices:i,expandDims:o}}function wI(s,t,i){const o=new Array(s);for(let l=0;l<i.length;++l){const u=i[l].shape;for(let f=0;f<t[l].length;++f)o[t[l][f]]===void 0?o[t[l][f]]=u[f]:E(o[t[l][f]]===u[f],()=>`Expected dimension ${o[t[l][f]]} at axis ${f} of input shaped ${JSON.stringify(u)}, but got dimension ${u[f]}`)}}function CI(s,t){const i=s,o=[];let l=0;s.length===0&&i.push(-1),l=s.length+1;for(let f=0;f<l;++f)o.push([]);const u=[];for(let f=0;f<i.length;++f){const g=i[f],A=k5(t,g);for(const v of A)u.indexOf(v)===-1&&(o[f].push(v),u.push(v))}return{path:i,steps:o}}function EI(s){return s.every((t,i)=>t===i)}function k5(s,t){const i=[];for(let o=0;o<s.length;++o)(s[o].length===0||s[o].indexOf(t)!==-1||t===-1)&&i.push(o);return i}function SI(s,t,i=0){let o=[];if(typeof t=="number")E(s.shape[i]%t===0,()=>"Number of splits must evenly divide the axis."),o=new Array(t).fill(s.shape[i]/t);else{const l=t.reduce((f,g)=>(g===-1&&(f+=1),f),0);E(l<=1,()=>"There should be only one negative value in split array.");const u=t.indexOf(-1);if(u!==-1){const f=t.reduce((g,A)=>A>0?g+A:g);t[u]=s.shape[i]-f}E(s.shape[i]===t.reduce((f,g)=>f+g),()=>"The sum of sizes must match the size of the axis dimension."),o=t}return o}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function II(s){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${s}`}function TI(s,t){return`indices(${s}, 0) is invalid: ${t} < 0`}function MI(s,t,i){return`indices(${s}, 0) is invalid: ${t} >= ${i}`}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _I(s,t){return`only one output dimension may be -1, not both ${s} and ${t}`}function RI(s,t){return`size ${s} must be non-negative, not ${t}`}function kI(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function BI(s,t){const i=N(s),o=N(t);return`Input to reshape is a SparseTensor with ${i}
  dense values, but the requested shape requires a multiple of ${o}. inputShape=${s} outputShape= ${t}`}function LI(s,t){const i=N(s),o=N(t);return`Input to reshape is a tensor with ${i} dense values, but the requested shape has ${o}. inputShape=${s} outputShape=${t}`}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Hb(){return"segment ids must be >= 0"}function NI(){return"segment ids are not increasing"}function DI(s,t){return`Segment id ${s} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function FI(s,t,i){return`Bad: indices[${s}] == ${t} out of range [0, ${i})`}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function SB(s,t){let i=!1,o;for(s<=lI?(o=s,i=!0):o=Ve(s,Math.floor(Math.sqrt(s)));!i;)o>t||o===s?i=!0:o=Ve(s,o+1);return o}function IB(s,t,i){const o=[],l=s.length;for(let u=0;u<l;u++)u!==t?o.push(s[u]):o.push(i);return o}function OI(s,t,i,o){const l=t.shape.length,u=s.shape.length;if(o!==0&&(o<-l||o>l))throw new Error(`Expect batchDims in the range of [-${l}, ${l}], but got ${o}`);if(o<0&&(o+=l),o>u)throw new Error(`batchDims (${o}) must be less than rank(x) (
    ${u}).`);if(i<o)throw new Error(`batchDims (${o}) must be less than or equal to axis (${i}).`);for(let S=0;S<o;++S)if(s.shape[S]!==t.shape[S])throw new Error(`x.shape[${S}]: ${s.shape[S]} should be equal to indices.shape[${S}]: ${t.shape[S]}.`);const f=s.shape[i],g=[];let A=1,v=1,C=1;for(let S=0;S<o;++S)g.push(s.shape[S]),A*=s.shape[S];for(let S=o;S<i;S++)g.push(s.shape[S]),v*=s.shape[S];for(let S=o;S<l;S++)g.push(t.shape[S]);for(let S=i+1;S<u;S++)g.push(s.shape[S]),C*=s.shape[S];return{batchSize:A,sliceSize:C,outerSize:v,dimSize:f,outputShape:g}}const B5=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:OI,computeOutShape:IB,segOpComputeOptimalWindowSize:SB},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nh(s){try{return s.map(t=>oa(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function GI(s){return s.map(t=>ri(t))}const L5=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:fI,ERF_A2:pI,ERF_A3:mI,ERF_A4:gI,ERF_A5:AI,ERF_P:dI,PARALLELIZE_THRESHOLD:lI,get RowPartitionType(){return bl},SELU_SCALE:W1,SELU_SCALEALPHA:V1,applyActivation:Gn,assertAndGetBroadcastShape:$n,assertAxesAreInnerMostDims:Rs,assertParamsConsistent:iI,assignToTypedArray:vB,axesAreInnerMostDims:dd,calculateShapes:Jf,checkEinsumDimSizes:wI,checkPadOnDimRoundingMode:Ms,combineLocations:Zl,combineRaggedTensorToTensorShapes:sI,complexWithEvenIndex:bB,complexWithOddIndex:yB,computeConv2DInfo:qs,computeConv3DInfo:Wl,computeDefaultPad:sp,computeDilation2DInfo:nd,computeOptimalWindowSize:z1,computeOutAndReduceShapes:Ei,computeOutShape:iu,computePool2DInfo:Oa,computePool3DInfo:go,convertConv2DDataFormat:pl,decodeEinsumEquation:vI,eitherStridesOrDilationsAreOne:or,expandShapeToKeepDim:ts,exponent:wB,exponents:xB,fromStringArrayToUint8:GI,fromUint8ToStringArray:nh,getAxesPermutation:ji,getBroadcastDims:Pl,getComplexWithIndex:bI,getEinsumComputePath:CI,getEinsumPermutation:xI,getFusedBiasGradient:Sn,getFusedDyActivation:ui,getImageCenter:cI,getInnerMostAxes:Ss,getPermuted:Vb,getRaggedRank:aI,getReductionAxes:Qs,getReshaped:zb,getReshapedPermuted:Wb,getRowPartitionTypesHelper:rI,getSliceBeginCoords:uI,getSliceSize:hI,getSparseFillEmptyRowsIndicesDenseShapeMismatch:II,getSparseFillEmptyRowsNegativeIndexErrorMessage:TI,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:MI,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:kI,getSparseReshapeInputOutputMismatchErrorMessage:LI,getSparseReshapeInputOutputMultipleErrorMessage:BI,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:_I,getSparseReshapeNegativeOutputDimErrorMessage:RI,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:FI,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Hb,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:NI,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:DI,getUndoAxesPermutation:gl,isIdentityPermutation:EI,log:qv,mergeRealAndImagArrays:th,prepareAndValidate:qf,prepareSplitSize:SI,segment_util:B5,shouldFuse:Js,slice_util:mg,splitRealAndImagArrays:AB,tupleValuesAreOne:Pc,upcastType:ar,validateDefaultValueShape:oI,validateInput:yx,validateUpdateShape:jA,warn:sa},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const TB={kernelName:At,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(s,_p(hn(i,"float32"),-1))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const N5={kernelName:dn,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>{const o=qi(hn(i,"float32")),l=Pr(Wn(Ni(1),o));return Us(En(s,l))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const D5={kernelName:ge,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>{const o=Pr(Wn(qi(hn(i,"float32")),1));return En(s,o)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const F5={kernelName:se,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t,l=$n(i.shape,o.shape);return{a:()=>{let u=s;const f=Qs(i.shape,l);return f.length>0&&(u=wn(u,f)),He(u,i.shape)},b:()=>{let u=s;const f=Qs(o.shape,l);return f.length>0&&(u=wn(u,f)),He(u,o.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const O5={kernelName:Ge,saveAllInputs:!0,gradFunc:(s,t)=>{const i={};return t.forEach((o,l)=>{i[l]=()=>s.clone()}),i}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const G5={kernelName:xt,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>oi(i)}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const U5={kernelName:fn,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>oi(i)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const P5={kernelName:Gt,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>En(s,Pr(Wn(Ni(1),qi(hn(i,"float32")))))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const z5={kernelName:Jt,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>{const o=Pr(Ut(Ni(1),qi(hn(i,"float32"))));return En(s,o)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const V5={kernelName:bn,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t,l=$n(i.shape,o.shape);return{a:()=>{const u=Ut(qi(i),qi(o));let f=Oe(s,En(o,u));const g=Qs(i.shape,l);return g.length>0&&(f=wn(f,g)),He(f,i.shape)},b:()=>{const u=Ut(qi(i),qi(o));let f=Us(Oe(s,En(i,u)));const g=Qs(o.shape,l);return g.length>0&&(f=wn(f,g)),He(f,o.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const W5={kernelName:Ln,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>En(s,Ut(qi(hn(i,"float32")),1))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const H5={kernelName:Zt,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>En(s,Wn(Ni(1),qi(hn(i,"float32"))))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function X5(s,t,i,o,l,u){const f=Se(s,"dy","avgPool3dGrad"),g=Se(t,"input","avgPool3dGrad");let A=f,v=g,C=!1;g.rank===4&&(C=!0,A=He(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]]),v=He(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]])),E(A.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${A.rank}.`),E(v.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${v.rank}.`),Ms("avgPool3dGrad",l,u);const S={dy:A,input:v},M={filterSize:i,strides:o,pad:l,dimRoundingMode:u},_=ze.runKernel(Wt,S,M);return C?He(_,[_.shape[1],_.shape[2],_.shape[3],_.shape[4]]):_}const Q5=Qe({avgPool3dGrad_:X5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const K5={kernelName:wt,inputsToSave:["x"],gradFunc:(s,t,i)=>{const[o]=t,{filterSize:l,strides:u,pad:f,dimRoundingMode:g}=i;return{x:()=>Q5(s,o,l,u,f,g)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Z5(s,t,i,o,l){const u=Se(s,"dy","avgPoolGrad"),f=Se(t,"input","avgPoolGrad");E(f.rank===u.rank,()=>`Rank of input (${f.rank}) does not match rank of dy (${u.rank})`);let g=f,A=u,v=!1;f.rank===3&&(v=!0,g=He(f,[1,f.shape[0],f.shape[1],f.shape[2]]),A=He(u,[1,u.shape[0],u.shape[1],u.shape[2]])),E(A.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${A.rank}.`),E(g.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${g.rank}.`);const C={dy:A,input:g},S={filterSize:i,strides:o,pad:l},M=ze.runKernel(ke,C,S);return v?He(M,[M.shape[1],M.shape[2],M.shape[3]]):M}const $5=Qe({avgPoolGrad_:Z5});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Y5={kernelName:Jn,inputsToSave:["x"],gradFunc:(s,t,i)=>{const[o]=t,{filterSize:l,strides:u,pad:f}=i;return{x:()=>$5(s,o,l,u,f)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const j5={kernelName:jt,inputsToSave:["a","b"],gradFunc:(s,t,i)=>{const[o,l]=t,{transposeA:u,transposeB:f}=i;return!u&&!f?{a:()=>Li(s,l,!1,!0),b:()=>Li(o,s,!0,!1)}:!u&&f?{a:()=>Li(s,l,!1,!1),b:()=>Li(s,o,!0,!1)}:u&&!f?{a:()=>Li(l,s,!1,!0),b:()=>Li(o,s,!1,!1)}:{a:()=>Li(l,s,!0,!0),b:()=>Li(s,o,!0,!0)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const q5={kernelName:tn,gradFunc:(s,t,i)=>{const{blockShape:o,crops:l}=i;return{x:()=>Dg(s,o,l)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const J5={kernelName:Vn,gradFunc:(s,t,i)=>{const o=i,l=o.inputShape,u=o.shape,f=Array.from(u);for(let A=l.length-1;A>=0;A--)if(l[A]===u[A])f[A]=1;else if(l[A]!==1)throw new Error(`broadcastTo(): [${l}] cannot be broadcast to [${u}].`);const g=[];for(let A=0;A<f.length;A++)f[A]>1&&g.push(A);return{x:()=>wn(s,g,!0)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eH={kernelName:qt,gradFunc:s=>({x:()=>s.clone()})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tH={kernelName:mn,gradFunc:s=>({x:()=>oi(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const nH={kernelName:fi,inputsToSave:["x"],gradFunc:(s,t,i)=>{const[o]=t,{clipValueMin:l,clipValueMax:u}=i;return{x:()=>Ii(Vo($c(o,l),qr(o,u)),s,oi(s))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const iH={kernelName:Ts,inputsToSave:["x"],gradFunc:TB.gradFunc};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sH={kernelName:ir,saveAllInputs:!0,gradFunc:(s,t,i)=>{const o=t.map(g=>g.shape),{axis:l}=i,u=J(l,t[0].shape)[0],f=o.map(g=>g[u]);return zr(s,f,u).map(g=>()=>g)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rH={kernelName:ro,inputsToSave:["x","filter"],gradFunc:(s,t,i)=>{const[o,l]=t,{dilations:u,strides:f,pad:g,dataFormat:A}=i;return E(Pc(u),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${u}'`),{x:()=>lp(o.shape,s,l,f,g,A),filter:()=>gn(o,s,l.shape,f,g,A)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aH={kernelName:ao,inputsToSave:["dy","filter"],gradFunc:(s,t,i)=>{const[o,l]=t,{strides:u,pad:f,dataFormat:g,dimRoundingMode:A}=i;return{dy:()=>Vc(s,l,u,f,g,1,A),filter:()=>gn(s,o,l.shape,u,f,g,A)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oH(s,t,i,o,l){let u=s;s.rank===4&&(u=He(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));let f=t;f.rank===4&&(f=He(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),E(u.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${u.shape}.`),E(f.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${f.shape}.`),E(i.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${i}.`),E(u.shape[4]===i[3],()=>`Error in conv3dDerFilter: depth of input ${u.shape[4]}) must match input depth in filter (${i[3]}.`),E(f.shape[4]===i[4],()=>`Error in conv3dDerFilter: depth of dy (${f.shape[4]}) must match output depth for filter (${i[4]}).`);const g={x:u,dy:f},A={strides:o,pad:l,filterShape:i};return ze.runKernel(Cc,g,A)}const lH=Qe({conv3DBackpropFilter_:oH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cH={kernelName:wc,inputsToSave:["x","filter"],gradFunc:(s,t,i)=>{const{dilations:o,strides:l,pad:u}=i;E(Pc(o),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const[f,g]=t;return{x:()=>od(f.shape,s,g,l,u),filter:()=>lH(f,s,g.shape,l,u)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const uH={kernelName:oo,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(Us(Ep(hn(i,"float32"))),s)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hH={kernelName:Ea,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(B1(hn(i,"float32")),s)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dH={kernelName:ko,inputsToSave:["x"],gradFunc:(s,t,i)=>{const[o]=t,{axis:l,exclusive:u,reverse:f}=i;return{x:()=>{const g=ji([l],o.rank);let A=Zi(s,l,u,!f);return g!=null&&(A=bi(A,g)),A}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fH={kernelName:Cu,inputsToSave:["x","filter"],gradFunc:(s,t,i)=>{const{dilations:o,strides:l,pad:u,dimRoundingMode:f}=i,g=o??[1,1];E(Pc(g),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${g}'`);const[A,v]=t;return E(A.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${A.rank}.`),E(v.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${v.rank}.`),E(A.shape[3]===v.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${A.shape[3]}) must match the inChannels dimension in filter ${v.shape[2]}.`),E(or(l,g),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${l} and dilations '${g}'.`),Ms("depthwiseConv2d",u,f),{x:()=>zW(A.shape,s,v,l,u,g,f),filter:()=>UW(A,s,v.shape,l,u,g,f)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pH={kernelName:ce,inputsToSave:["x","filter"],gradFunc:(s,t,i)=>{const[o,l]=t,u={x:o,filter:l,dy:s},f={x:o,filter:l,dy:s};return{x:()=>ze.runKernel(We,u,i),filter:()=>ze.runKernel(st,f,i)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mH={kernelName:Nt,outputsToSave:[!0],gradFunc:(s,t)=>{const[i]=t,o={dy:s,y:i};return{x:()=>ze.runKernel(sn,o)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gH={kernelName:un,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t,o=Oe($l(Us(qi(i))),2/Math.sqrt(Math.PI));return{x:()=>Oe(s,o)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const AH={kernelName:Dn,outputsToSave:[!0],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(s,i)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bH={kernelName:Un,inputsToSave:["input"],gradFunc:(s,t)=>{const[i]=t;return{input:()=>He(s,i.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yH={kernelName:Mn,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(s,$l(i))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vH={kernelName:ss,gradFunc:s=>({x:()=>oi(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xH={kernelName:ei,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t,l=$n(i.shape,o.shape);return{a:()=>{const u=En(s,hn(o,"float32")),f=Qs(i.shape,l);return f.length>0?He(wn(u,f),i.shape):u},b:()=>{let u=Oe(s,hn(i,"float32"));const f=Qs(o.shape,l);f.length>0&&(u=He(wn(u,f),o.shape));const g=qi(o);return Us(En(u,hn(g,"float32")))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wH={kernelName:Fs,inputsToSave:["x","mean","variance","scale"],gradFunc:(s,t,i)=>{const{varianceEpsilon:o}=i,[l,u,f,g]=t,A=g??Ni(1),v=Qs(u.shape,l.shape),C=[];if(u.rank===1){for(let F=0;F<l.shape.length-1;++F)C.push(l.shape[F]);C.push(1)}const S=Wn(l,u),M=Oe(s,A),_=wd(Ut(f,Ni(o))),B=Oe(Oe(Oe(_,_),_),Ni(-.5));return{x:()=>u.rank===1?He(Oe(Oe(s,yo(He(_,[1,1,1,u.shape[0]]),C)),A),l.shape):He(Oe(Oe(s,_),A),l.shape),mean:()=>{let F=Oe(Oe(_,Ni(-1)),M);return u.rank===1&&(F=wn(F,v)),He(F,u.shape)},variance:()=>{let F=Oe(Oe(B,S),M);return u.rank===1&&(F=wn(F,v)),He(F,u.shape)},scale:()=>{const F=Oe(S,_);let P=Oe(s,F);return u.rank===1&&(P=wn(P,v)),He(P,u.shape)},offset:()=>{let F=s;return u.rank===1&&(F=wn(F,v)),He(F,u.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const CH={kernelName:xn,inputsToSave:["x","indices"],gradFunc:(s,t,i)=>{const[o,l]=t,{axis:u}=i,f=J(u,o.shape)[0];return{x:()=>{const g=o.shape,A=l.size,v=g.slice(0,f),C=v.length,S=g.slice(u,g.length).slice(1),M=S.length,_=MB(0,C),B=MB(C+1,C+1+M),F=_B([v,[A],S]),P=He(s,F),U=He(l,[A]),V=_B([[C],_,B]),$=bi(P,V);let q=at($,U,o.shape[f]);const ne=gl(V);return q=bi(q,ne),q},indices:()=>l}}};function MB(s,t){const i=[];for(let o=s;o<t;++o)i.push(o);return i}function _B(s){const t=[];for(let i=0;i<s.length;++i)for(let o=0;o<s[i].length;++o)t.push(s[i][o]);return t}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const EH={kernelName:Ws,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t;return{a:()=>oi(i),b:()=>oi(o)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SH={kernelName:Sr,gradFunc:s=>({x:()=>hn(s,"float32")})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const IH={kernelName:Si,gradFunc:s=>({x:()=>oi(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const TH={kernelName:Cs,gradFunc:s=>({x:()=>oi(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const MH={kernelName:sr,gradFunc:s=>({x:()=>oi(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _H={kernelName:vs,inputsToSave:["x"],gradFunc:(s,t,i)=>{const[o]=t,{alpha:l}=i,u=Va(o,0);return{x:()=>Ii(u,s,Oe(s,l))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const RH={kernelName:lf,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>En(s,Ut(i,1))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kH={kernelName:of,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>En(s,hn(i,"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const BH={kernelName:Dh,inputsToSave:[],outputsToSave:[!0],gradFunc:(s,t,i)=>{const[o]=t,{axis:l}=i;return{logits:()=>{const u=$l(o);return Wn(s,Oe(wn(s,l,!0),u))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LH(s,t,i,o=5,l=1,u=1,f=.5){const g={x:s,y:t,dy:i},A={depthRadius:o,bias:l,alpha:u,beta:f};return ze.runKernel(Nm,g,A)}const NH=Qe({localResponseNormalizationBackprop_:LH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const DH={kernelName:Ll,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,t,i)=>{const[o,l]=t,{depthRadius:u,bias:f,alpha:g,beta:A}=i;return{x:()=>NH(o,l,s,u,f,g,A)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function RB(s,t,i,o){return t.rank<i.rank&&(t=He(t,ts(t.shape,o))),s.rank<i.rank&&(s=He(s,ts(s.shape,o))),{x:()=>Oe(s,hn(Ao(i,t),s.dtype))}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kB={kernelName:Fh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,t,i)=>{const o=i,{reductionIndices:l}=o,u=t[0],f=t[1],g=J(l,u.shape),A=RB(s,f,u,g);return{x:()=>A.x()}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const FH={kernelName:Oh,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t;return{a:()=>Oe(s,hn($c(i,o),"float32")),b:()=>Oe(s,hn(Mg(i,o),"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OH(s,t,i,o,l,u,f){const g=Se(s,"dy","maxPool3dGrad"),A=Se(t,"input","maxPool3dGrad"),v=Se(i,"output","maxPool3dGrad");let C=g,S=A,M=v,_=!1;A.rank===4&&(_=!0,C=He(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]]),S=He(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]]),M=He(v,[1,v.shape[0],v.shape[1],v.shape[2],v.shape[3]])),E(C.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${C.rank}.`),E(S.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${S.rank}.`),E(M.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${M.rank}.`),Ms("maxPool3dGrad",u,f);const B={dy:C,input:S,output:M},F={filterSize:o,strides:l,pad:u,dimRoundingMode:f},P=ze.runKernel(Iu,B,F);return _?He(P,[P.shape[1],P.shape[2],P.shape[3],P.shape[4]]):P}const GH=Qe({maxPool3dGrad_:OH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const UH={kernelName:Gh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,t,i)=>{const[o,l]=t,{filterSize:u,strides:f,pad:g,dimRoundingMode:A}=i;return{x:()=>GH(s,o,l,u,f,g,A)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function PH(s,t,i,o,l,u,f){const g=Se(s,"dy","maxPoolGrad"),A=Se(t,"input","maxPoolGrad"),v=Se(i,"output","maxPoolGrad");E(A.rank===g.rank,()=>`Rank of input (${A.rank}) does not match rank of dy (${g.rank})`),E(g.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${g.rank}.`),E(A.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${A.rank}.`),Ms("maxPoolGrad",u,f);const C={dy:g,input:A,output:v},S={filterSize:o,strides:l,pad:u,dimRoundingMode:f};return ze.runKernel(No,C,S)}const zH=Qe({maxPoolGrad_:PH});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const VH={kernelName:Sc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,t,i)=>{const[o,l]=t,{filterSize:u,strides:f,pad:g}=i;return{x:()=>zH(s,o,l,u,f,g)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const WH={kernelName:Uh,inputsToSave:["x"],gradFunc:(s,t,i)=>{const[o]=t,{axis:l}=i,u=J(l,o.shape),f=Ei(o.shape,u)[1],g=N(f);return{x:()=>{const A=o.shape.slice();u.forEach(C=>{A[C]=1});const v=He(s,A);return En(Oe(v,ks(o.shape,"float32")),g)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const HH={kernelName:Tu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,t,i)=>{const o=i,{axis:l}=o,[u,f]=t,g=J(l,u.shape),A=RB(s,f,u,g);return{x:()=>A.x()}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const XH={kernelName:Ph,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t;return{a:()=>Oe(s,hn(qr(i,o),"float32")),b:()=>Oe(s,hn(Va(i,o),"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const QH={kernelName:Mu,inputsToSave:["x"],gradFunc:(s,t,i)=>{const o=t[0],{paddings:l}=i,u=l.map(f=>f[0]);return{x:()=>Vi(s,u,o.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const KH={kernelName:Ic,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t,l=$n(i.shape,o.shape);return{a:()=>{const u=Qs(i.shape,l);return u.length>0?He(wn(s,u),i.shape):s},b:()=>{const u=Oe(s,Us(fp(En(i,o)))),f=Qs(o.shape,l);return f.length>0?He(wn(u,f),o.shape):u}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ZH={kernelName:dr,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t,l=$n(i.shape,o.shape);return{a:()=>{const u=Oe(s,hn(o,"float32")),f=Qs(i.shape,l);return f.length>0?He(wn(u,f),i.shape):u},b:()=>{const u=Oe(s,hn(i,"float32")),f=Qs(o.shape,l);return f.length>0?He(wn(u,f),o.shape):u}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $H={kernelName:sl,gradFunc:s=>({x:()=>Us(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const YH={kernelName:Tc,inputsToSave:["indices"],gradFunc:(s,t)=>{const i=t[0];return{indices:()=>Zs(i.shape,"float32")}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jH={kernelName:zh,gradFunc:s=>({x:()=>oi(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qH={kernelName:ku,saveAllInputs:!0,gradFunc:(s,t,i)=>{const{axis:o}=i;return Fn(s,o).map(l=>()=>l)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const BB={kernelName:uf,inputsToSave:["x"],gradFunc:(s,t,i)=>{const o=t[0],{paddings:l}=i,u=l.map(f=>f[0]);return{x:()=>Vi(s,u,o.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const JH={kernelName:hf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(s,t)=>{const[i,o,l]=t,u=i,f=o,g=$n(u.shape,f.shape);return{a:()=>{const A=hn(f,"float32");let v=Oe(s,Oe(A,gr(u,Wn(A,Ni(1)))));const C=Qs(u.shape,g);return C.length>0&&(v=wn(v,C)),He(v,u.shape)},b:()=>{const A=Va(u,0),v=Ii(A,zo(u),oi(u));let C=Oe(s,Oe(l,v));const S=Qs(f.shape,g);return S.length>0&&(C=wn(C,S)),He(C,f.shape)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eX={kernelName:Dm,inputsToSave:["x","alpha"],gradFunc:(s,t)=>{const[i,o]=t,l=Va(i,0);return{x:()=>Ii(l,s,Oe(s,o)),alpha:()=>{let u=Ii(l,oi(s),Oe(s,i));const f=Qs(o.shape,s.shape);return f.length>0&&(u=wn(u,f)),He(u,o.shape)}}}};/**
* @license
* Copyright 2022 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tX(s,t,i){const o=s.shape.slice();o[i]=1;const l=He(t,o),u=fb(s,i,!0,!1),f=fb(s,i,!0,!0),g=Oe(u,f);return Oe(l,g)}function nX(s,t,i){const o=s.shape.length,l=o-i.length,u=ji(i,o);let f=s;u!=null&&(f=bi(s,u));const g=f.shape.slice(),A=g.splice(o-i.length,i.length).reduce((S,M)=>S*M,1);g.push(A);const v=f.reshape(g);let C=tX(v,t,l);if(C=C.reshape(f.shape),u!=null){const S=gl(u);C=bi(C,S)}return C}const iX={kernelName:Fm,inputsToSave:["x"],gradFunc:(s,t,i)=>{const[o]=t,{axis:l}=i;let u=[];return l==null?u=o.shape.map((f,g)=>g):typeof l=="number"?u=[l]:u=l,{x:()=>nX(o,s,u)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sX={kernelName:ot,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t,l=$n(i.shape,o.shape);return{a:()=>{const u=En(s,hn(o,"float32")),f=Qs(i.shape,l);return f.length>0?He(wn(u,f),i.shape):u},b:()=>{let u=Oe(s,hn(i,"float32"));const f=Qs(o.shape,l);f.length>0&&(u=He(wn(u,f),o.shape));const g=qi(o);return Us(En(u,hn(g,"float32")))}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rX={kernelName:df,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>En(s,Us(qi(i)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aX={kernelName:Bu,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t,o=Oe(qr(i,6),_p(i));return{x:()=>Oe(s,hn(o,"float32"))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const oX={kernelName:ff,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(s,hn(_p(i),"float32"))}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lX={kernelName:pf,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>He(s,i.shape)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cX={kernelName:Um,inputsToSave:["images"],gradFunc:(s,t,i)=>{const[o]=t,l={dy:s,images:o};return{images:()=>ze.runKernel(pA,l,i)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const uX={kernelName:Gm,inputsToSave:["images"],gradFunc:(s,t,i)=>{const[o]=t,l={dy:s,images:o};return{images:()=>ze.runKernel(fA,l,i)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const hX={kernelName:Pm,gradFunc:(s,t,i)=>{const{dims:o}=i,l=J(o,s.shape);return{x:()=>Al(s,l)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dX={kernelName:mf,gradFunc:s=>({x:()=>oi(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fX={kernelName:gf,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Us(En(s,Oe(gr(i,1.5),2)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pX={kernelName:zm,inputsToSave:["condition"],gradFunc:(s,t)=>{const[i]=t;return{condition:()=>hn(oi(i),"float32"),t:()=>Oe(s,hn(i,s.dtype)),e:()=>Oe(s,hn(gp(i),s.dtype))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mX={kernelName:Af,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>{const o=Va(i,Ni(0)),l=Ni(V1),u=Ni(W1),f=Oe(s,u),g=Oe(Oe(s,l),$l(hn(i,"float32")));return Ii(o,f,g)}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gX={kernelName:xf,outputsToSave:[!0],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(s,Oe(i,Wn(Ni(1),i)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const AX={kernelName:vf,gradFunc:s=>({x:()=>oi(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bX={kernelName:bf,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(Yu(hn(i,"float32")),s)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yX={kernelName:yf,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(up(hn(i,"float32")),s)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vX={kernelName:Vm,inputsToSave:["x"],gradFunc:(s,t,i)=>{const[o]=t,{begin:l,size:u}=i,f=o.shape,[g,A]=ip(o,l,u),v=[];for(let C=0;C<s.rank;C++)v.push([g[C],f[C]-g[C]-A[C]]);return{x:()=>Tb(s,v)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xX={kernelName:Ef,outputsToSave:[!0],gradFunc:(s,t,i)=>{const[o]=t,{dim:l}=i,u=!0,f=Oe(s,o);return{logits:()=>Wn(f,Oe(wn(f,[l],u),o))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wX={kernelName:wf,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(s,sd(i))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const LB={kernelName:Wm,gradFunc:(s,t,i)=>{const{blockShape:o,paddings:l}=i;return{x:()=>$u(s,o,l)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const NB={kernelName:Cf,gradFunc:(s,t,i)=>{const{axis:o}=i;return{x:()=>yi(s,o)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const CX={kernelName:Lu,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>En(s,Oe(Pr(hn(i,"float32")),2))}}};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const EX={kernelName:yA,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(s,Oe(hn(i,"float32"),2))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SX={kernelName:Sf,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t,l=Ni(2);return{a:()=>Oe(s,Oe(l,Wn(i,o))),b:()=>Oe(s,Oe(l,Wn(o,i)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const IX={kernelName:Rf,gradFunc:s=>({x:()=>oi(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const TX={kernelName:If,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[i,o]=t,l=$n(i.shape,o.shape);return{a:()=>{let u=s;const f=Qs(i.shape,l);return f.length>0&&(u=wn(u,f)),He(u,i.shape)},b:()=>{let u=s;const f=Qs(o.shape,l);return f.length>0&&(u=wn(u,f)),He(Us(u),o.shape)}}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const MX={kernelName:Mc,inputsToSave:["x"],gradFunc:(s,t,i)=>{const[o]=t,l=o.shape.slice(),{axis:u}=i;J(u,o.shape).forEach(A=>{l[A]=1});const f=He(s,l),g=Oe(f,ks(o.shape,"float32"));return{x:()=>g}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _X={kernelName:_c,inputsToSave:["x"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>En(s,qi(Yu(i)))}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const RX={kernelName:Hh,outputsToSave:[!0],gradFunc:(s,t)=>{const[i]=t;return{x:()=>Oe(Wn(Ni(1),qi(i)),s)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kX={kernelName:Xh,inputsToSave:["x"],gradFunc:(s,t,i)=>{const[o]=t,{reps:l}=i;return{x:()=>{let u=oi(o);if(o.rank===1)for(let f=0;f<l[0];++f)u=Ut(u,Vi(s,[f*o.shape[0]],[o.shape[0]]));else if(o.rank===2)for(let f=0;f<l[0];++f)for(let g=0;g<l[1];++g)u=Ut(u,Vi(s,[f*o.shape[0],g*o.shape[1]],[o.shape[0],o.shape[1]]));else if(o.rank===3)for(let f=0;f<l[0];++f)for(let g=0;g<l[1];++g)for(let A=0;A<l[2];++A)u=Ut(u,Vi(s,[f*o.shape[0],g*o.shape[1],A*o.shape[2]],[o.shape[0],o.shape[1],o.shape[2]]));else if(o.rank===4)for(let f=0;f<l[0];++f)for(let g=0;g<l[1];++g)for(let A=0;A<l[2];++A)for(let v=0;v<l[3];++v)u=Ut(u,Vi(s,[f*o.shape[0],g*o.shape[1],A*o.shape[2],v*o.shape[3]],[o.shape[0],o.shape[1],o.shape[2],o.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${o.rank} tensors yet.`);return u}}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const BX={kernelName:Du,gradFunc:(s,t,i)=>{const o=i,{perm:l}=o,u=gl(l);return{x:()=>bi(s,u)}}};/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const LX={kernelName:_f,gradFunc:(s,t,i)=>{const o=i,{axis:l}=o;return{value:()=>Xo(s,l)}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const NX={kernelName:Qm,inputsToSave:["segmentIds"],gradFunc:(s,t)=>{const[i]=t;return{x:()=>DX(s,i)}}};function DX(s,t){const i=Yl(t,oi(t)),o=pd(s,i);let l=$c(t,Ni(0,"int32"));const u=o.rank-l.rank;for(let g=0;g<u;++g)l=za(l,g+1);l=Vo(l,ks(o.shape,"bool"));const f=oi(o);return Ii(l,o,f)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const FX={kernelName:Km,gradFunc:s=>({x:()=>oi(s)})};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const OX=[TB,N5,D5,F5,O5,G5,U5,P5,z5,V5,W5,H5,K5,Y5,j5,q5,J5,eH,tH,nH,iH,sH,aH,rH,cH,uH,hH,dH,fH,pH,sX,mH,gH,AH,bH,yH,xH,vH,wH,CH,EH,SH,IH,TH,MH,_H,RH,kH,BH,DH,kB,kB,FH,UH,VH,WH,HH,XH,QH,KH,ZH,$H,YH,jH,qH,BB,BB,JH,eX,iX,rX,aX,oX,lX,cX,uX,hX,dX,fX,pX,mX,gX,AX,bX,yX,vX,xX,wX,LB,LB,NB,NB,CX,SX,EX,IX,TX,MX,_X,RX,kX,BX,LX,NX,FX];for(const s of OX)SA(s);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.abs=function(){return this.throwIfDisposed(),Ri(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.acos=function(){return this.throwIfDisposed(),ib(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.acosh=function(){return this.throwIfDisposed(),Tx(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.add=function(s){return this.throwIfDisposed(),Ut(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.all=function(s,t){return this.throwIfDisposed(),Uc(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.any=function(s,t){return this.throwIfDisposed(),bg(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.argMax=function(s){return this.throwIfDisposed(),td(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.argMin=function(s){return this.throwIfDisposed(),Rx(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.asScalar=function(){return this.throwIfDisposed(),E(this.size===1,()=>"The array must have only 1 element."),He(this,[])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.asType=function(s){return this.throwIfDisposed(),hn(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.as1D=function(){return this.throwIfDisposed(),He(this,[this.size])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.as2D=function(s,t){return this.throwIfDisposed(),He(this,[s,t])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.as3D=function(s,t,i){return this.throwIfDisposed(),He(this,[s,t,i])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.as4D=function(s,t,i,o){return this.throwIfDisposed(),He(this,[s,t,i,o])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.as5D=function(s,t,i,o,l){return this.throwIfDisposed(),He(this,[s,t,i,o,l])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.asin=function(){return this.throwIfDisposed(),kx(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.asinh=function(){return this.throwIfDisposed(),aS(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.atan=function(){return this.throwIfDisposed(),mr(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.atan2=function(s){return this.throwIfDisposed(),Nx(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.atanh=function(){return this.throwIfDisposed(),Fx(this)},dt().prototype.avgPool=function(s,t,i,o){return this.throwIfDisposed(),Go(this,s,t,i,o)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.batchToSpaceND=function(s,t){return this.throwIfDisposed(),$u(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.batchNorm=function(s,t,i,o,l){return this.throwIfDisposed(),rd(this,s,t,i,o,l)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.broadcastTo=function(s){return this.throwIfDisposed(),_s(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.cast=function(s){return this.throwIfDisposed(),hn(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.ceil=function(){return this.throwIfDisposed(),Kx(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.clipByValue=function(s,t){return this.throwIfDisposed(),fs(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.concat=function(s,t){return this.throwIfDisposed(),s instanceof Ci&&(s=[s]),yi([this,...s],t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.conv1d=function(s,t,i,o,l,u){return this.throwIfDisposed(),Hc(this,s,t,i,o,l,u)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.conv2dTranspose=function(s,t,i,o,l){return this.throwIfDisposed(),Po(this,s,t,i,o,l)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.conv2d=function(s,t,i,o,l,u){return this.throwIfDisposed(),Vc(this,s,t,i,o,l,u)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.cos=function(){return this.throwIfDisposed(),Yu(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.cosh=function(){return this.throwIfDisposed(),up(this)};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.cumprod=function(s,t,i){return this.throwIfDisposed(),fb(this,s,t,i)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.cumsum=function(s,t,i){return this.throwIfDisposed(),Zi(this,s,t,i)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.depthToSpace=function(s,t){return this.throwIfDisposed(),vi(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.depthwiseConv2d=function(s,t,i,o,l,u){return this.throwIfDisposed(),Wi(this,s,t,i,o,l,u)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.dilation2d=function(s,t,i,o,l){return this.throwIfDisposed(),Qc(this,s,t,i,o,l)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.divNoNan=function(s){return this.throwIfDisposed(),bo(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.div=function(s){return this.throwIfDisposed(),En(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.dot=function(s){return this.throwIfDisposed(),hp(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.elu=function(){return this.throwIfDisposed(),hd(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.equal=function(s){return this.throwIfDisposed(),Ao(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.erf=function(){return this.throwIfDisposed(),Eg(this)};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.euclideanNorm=function(s,t){return this.throwIfDisposed(),vb(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.exp=function(){return this.throwIfDisposed(),$l(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.expandDims=function(s){return this.throwIfDisposed(),za(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.expm1=function(){return this.throwIfDisposed(),fd(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.fft=function(){return this.throwIfDisposed(),ql(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.flatten=function(){return this.throwIfDisposed(),He(this,[this.size])};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.floor=function(){return this.throwIfDisposed(),fp(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.floorDiv=function(s){return this.throwIfDisposed(),Fa(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.gather=function(s,t){return this.throwIfDisposed(),pd(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.greaterEqual=function(s){return this.throwIfDisposed(),$c(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.greater=function(s){return this.throwIfDisposed(),Va(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.ifft=function(){return this.throwIfDisposed(),Vg(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.irfft=function(){return this.throwIfDisposed(),HS(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.isFinite=function(){return this.throwIfDisposed(),h1(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.isInf=function(){return this.throwIfDisposed(),mS(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.isNaN=function(){return this.throwIfDisposed(),Ig(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.leakyRelu=function(s){return this.throwIfDisposed(),pp(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.lessEqual=function(s){return this.throwIfDisposed(),qr(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.less=function(s){return this.throwIfDisposed(),Mg(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.localResponseNormalization=function(s,t,i,o){return this.throwIfDisposed(),AS(this,s,t,i,o)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.logSigmoid=function(){return this.throwIfDisposed(),Cb(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.logSoftmax=function(s){return this.throwIfDisposed(),Ad(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.logSumExp=function(s,t){return this.throwIfDisposed(),m1(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.log=function(){return this.throwIfDisposed(),zo(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.log1p=function(){return this.throwIfDisposed(),wb(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.logicalAnd=function(s){return this.throwIfDisposed(),Vo(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.logicalNot=function(){return this.throwIfDisposed(),gp(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.logicalOr=function(s){return this.throwIfDisposed(),Rg(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.logicalXor=function(s){return this.throwIfDisposed(),kg(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.matMul=function(s,t,i){return this.throwIfDisposed(),Li(this,s,t,i)},dt().prototype.maxPool=function(s,t,i,o){return this.throwIfDisposed(),Bg(this,s,t,i,o)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.max=function(s,t){return this.throwIfDisposed(),ha(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.maximum=function(s){return this.throwIfDisposed(),Yl(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.mean=function(s,t){return this.throwIfDisposed(),Hn(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.min=function(s,t){return this.throwIfDisposed(),jr(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.minimum=function(s){return this.throwIfDisposed(),bp(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.mirrorPad=function(s,t){return this.throwIfDisposed(),Ng(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.mod=function(s){return this.throwIfDisposed(),y1(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.mul=function(s){return this.throwIfDisposed(),Oe(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.neg=function(){return this.throwIfDisposed(),Us(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.norm=function(s,t,i){return this.throwIfDisposed(),dp(this,s,t,i)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.notEqual=function(s){return this.throwIfDisposed(),vp(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.oneHot=function(s,t=1,i=0){return this.throwIfDisposed(),$A(this,s,t,i)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.onesLike=function(){return this.throwIfDisposed(),Wa(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.pad=function(s,t){return this.throwIfDisposed(),Tb(this,s,t)},dt().prototype.pool=function(s,t,i,o,l,u){return this.throwIfDisposed(),_b(this,s,t,i,o,l,u)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.pow=function(s){return this.throwIfDisposed(),gr(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.prelu=function(s){return this.throwIfDisposed(),Ha(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.prod=function(s,t){return this.throwIfDisposed(),v1(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.reciprocal=function(){return this.throwIfDisposed(),OS(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.relu=function(){return this.throwIfDisposed(),Wo(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.relu6=function(){return this.throwIfDisposed(),M1(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.reshapeAs=function(s){return this.throwIfDisposed(),He(this,s.shape)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.reshape=function(s){return this.throwIfDisposed(),He(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.resizeBilinear=function(s,t,i){return this.throwIfDisposed(),pB(this,s,t,i)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.resizeNearestNeighbor=function(s,t,i){return this.throwIfDisposed(),mB(this,s,t,i)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.reverse=function(s){return this.throwIfDisposed(),Al(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.rfft=function(){return this.throwIfDisposed(),XS(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.round=function(){return this.throwIfDisposed(),Ug(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.rsqrt=function(){return this.throwIfDisposed(),wd(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.selu=function(){return this.throwIfDisposed(),Fb(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.separableConv2d=function(s,t,i,o,l,u){return this.throwIfDisposed(),Ob(this,s,t,i,o,l,u)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.sigmoid=function(){return this.throwIfDisposed(),sd(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.sign=function(){return this.throwIfDisposed(),Gb(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.sin=function(){return this.throwIfDisposed(),Ep(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.sinh=function(){return this.throwIfDisposed(),B1(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.slice=function(s,t){return this.throwIfDisposed(),Vi(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.softmax=function(s){return this.throwIfDisposed(),eh(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.softplus=function(){return this.throwIfDisposed(),gd(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.spaceToBatchND=function(s,t){return this.throwIfDisposed(),Dg(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.split=function(s,t){return this.throwIfDisposed(),zr(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.sqrt=function(){return this.throwIfDisposed(),Pr(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.square=function(){return this.throwIfDisposed(),qi(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.squaredDifference=function(s){return this.throwIfDisposed(),Hg(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.squeeze=function(s){return this.throwIfDisposed(),Jl(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.stack=function(s,t){this.throwIfDisposed();const i=s instanceof Ci?[this,s]:[this,...s];return Xo(i,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.step=function(s){return this.throwIfDisposed(),_p(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.stridedSlice=function(s,t,i,o,l,u,f,g){return this.throwIfDisposed(),d(this,s,t,i,o,l,u,f,g)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.sub=function(s){return this.throwIfDisposed(),Wn(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.sum=function(s,t){return this.throwIfDisposed(),wn(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.tan=function(){return this.throwIfDisposed(),x(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.tanh=function(){return this.throwIfDisposed(),wg(this)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.tile=function(s){return this.throwIfDisposed(),yo(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.toBool=function(){return this.throwIfDisposed(),hn(this,"bool")};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.toFloat=function(){return this.throwIfDisposed(),hn(this,"float32")};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.toInt=function(){return this.throwIfDisposed(),hn(this,"int32")};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.topk=function(s,t){return this.throwIfDisposed(),te(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.transpose=function(s){return this.throwIfDisposed(),bi(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.unique=function(s){return this.throwIfDisposed(),Ct(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.unsortedSegmentSum=function(s,t){return this.throwIfDisposed(),at(this,s,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.unstack=function(s){return this.throwIfDisposed(),Fn(this,s)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.where=function(s,t){return this.throwIfDisposed(),Ii(s,this,t)};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/dt().prototype.zerosLike=function(){return this.throwIfDisposed(),oi(this)};/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class su extends Error{constructor(t){super(t),Object.setPrototypeOf(this,su.prototype)}}class yl extends Error{constructor(t){super(t),Object.setPrototypeOf(this,yl.prototype)}}class Ue extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ue.prototype)}}class hi extends Error{constructor(t){super(t),Object.setPrototypeOf(this,hi.prototype)}}class UI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,UI.prototype)}}/**
* @license
* Copyright 2022 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class DB{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let i;return this.cache.has(t)&&(i=this.cache.get(t),this.cache.delete(t),this.cache.set(t,i)),i}put(t,i){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const o=this.cache.keys().next().value;this.cache.delete(o)}this.cache.set(t,i)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let i=0;i<this.maxEntries-t;i++){const o=this.cache.keys().next().value;this.cache.delete(o)}this.maxEntries=t}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function kp(s,t){if(Array.isArray(s)){let i=[];for(let o=0;o<t;o++)i=i.concat(s);return i}else{const i=new Array(t);return i.fill(s),i}}function ru(s,t){if(!s)throw new UI(t)}function FB(s,t){let i=0;for(const o of s)o===t&&i++;return i}function Xa(s){return s.length===1?s[0]:s}function Is(s){return Array.isArray(s)?s:[s]}function ih(s){const t=s.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Bp(s){return s.length<=1||s.indexOf("_")===-1?s:s.replace(/[_]+(\w|$)/g,(t,i)=>i.toUpperCase())}let vl={};function PI(s){if(s==null)return null;const t={};return t.className=s.getClassName(),t.config=s.getConfig(),t}function zI(s){if(!(s==null||typeof s!="object"))if(Array.isArray(s))s.forEach(t=>zI(t));else{const t=Object.keys(s);for(const i of t){const o=s[i];o!=null&&typeof o=="object"&&(!Array.isArray(o)&&o.type==="ndarray"&&typeof o.value=="number"?s[i]=o.value:zI(o))}}}function Xb(s,t={},i={},o="object",l=!1){if(typeof s=="string"){const u=s;let f;if(u in i)f=i[u];else if(u in vl)f=vl[u];else if(f=t[u],f==null)throw new Ue(`Unknown ${o}: ${s}. This may be due to one of the following reasons:
1. The ${o} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${o} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return f}else{const u=s;if(u.className==null||u.config==null)throw new Ue(`${o}: Improper config format: ${JSON.stringify(u)}.
'className' and 'config' must set.`);const f=u.className;let g,A;if(f in i?[g,A]=i[f]:f in vl?[g,A]=vl.className:f in t&&([g,A]=t[f]),g==null)throw new Ue(`Unknown ${o}: ${f}. This may be due to one of the following reasons:
1. The ${o} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${o} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(A!=null){const v={};for(const _ of Object.keys(vl))v[_]=vl[_];for(const _ of Object.keys(i))v[_]=i[_];const C=u.config;C.customObjects=v;const S=Object.assign({},vl);for(const _ of Object.keys(i))vl[_]=i[_];zI(u.config);const M=A(g,u.config,i,l);return vl=Object.assign({},S),M}else{const v=Object.assign({},vl);for(const S of Object.keys(i))vl[S]=i[S];const C=new g(u.config);return vl=Object.assign({},v),C}}}function GX(s,t){return s<t?-1:s>t?1:0}function H1(s,t){return-1*GX(s,t)}function Ed(s){if(s==null)return s;const t=[];for(const i of s)t.indexOf(i)===-1&&t.push(i);return t}function UX(s){if(s==null)throw new Ue(`Invalid value in obj: ${JSON.stringify(s)}`);for(const t in s)if(s.hasOwnProperty(t))return!1;return!0}function Lp(s,t,i){if(i!=null&&s.indexOf(i)<0)throw new Ue(`${i} is not a valid ${t}.  Valid values are ${s} or null/undefined.`)}function VI(s,t,i=0,o=1/0){return ru(i>=0),ru(o>=i),Array.isArray(s)&&s.length>=i&&s.length<=o&&s.every(l=>typeof l===t)}function _r(s,t){Array.isArray(s)?(E(s.length>0,()=>`${t} is unexpectedly an empty array.`),s.forEach((i,o)=>_r(i,`element ${o+1} of ${t}`))):E(Number.isInteger(s)&&s>0,()=>`Expected ${t} to be a positive integer, but got ${OB(s)}.`)}function OB(s){return s===null?"null":Array.isArray(s)?"["+s.map(t=>OB(t)).join(",")+"]":typeof s=="string"?`"${s}"`:`${s}`}function PX(s,t,i){let o=i!=null?i():wi(),l;return(...u)=>{const f=i!=null?i():wi();return f-o<t||(o=f,l=s(...u)),l}}function GB(s){return s==="relu"?"relu":s==="linear"?"linear":s==="elu"?"elu":null}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/let zX=0;function UB(){return zX++}const X1={};function Q1(s=""){return s in X1||(X1[s]=0),X1[s]+=1,s+X1[s].toString()}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const VX=["channelsFirst","channelsLast"],WX=["nearest","bilinear"],HX=["valid","same","causal"],XX=["max","avg"],QX=["sum","mul","concat","ave"];/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const Zg=new Map;function er(s){Lp(VX,"DataFormat",s)}function KX(s){Lp(WX,"InterpolationFormat",s)}function Qo(s){Lp(HX,"PaddingMode",s)}function PB(s){Lp(XX,"PoolMode",s)}const Qb=[],zB="/";function Np(s,t){Qb.push(s);try{const i=t();return Qb.pop(),i}catch(i){throw Qb.pop(),i}}function ZX(){return Qb.length===0?"":Qb.join(zB)+zB}function VB(s){if(!HB(s))throw new Error("Not a valid tensor name: '"+s+"'");return ZX()+s}function WB(s){if(!HB(s))throw new Error("Not a valid tensor name: '"+s+"'");Zg.has(s)||Zg.set(s,0);const t=Zg.get(s);if(Zg.set(s,Zg.get(s)+1),t>0){const i=`${s}_${t}`;return Zg.set(i,1),i}else return s}const $X=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function HB(s){return!!s.match($X)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function YX(s){return s===parseInt(s.toString(),10)}function Sd(s,t,i){t==null&&(t=0),i==null&&(i=s.length);let o=1;for(let l=t;l<i;++l)o*=s[l];return o}function $g(s){if(s.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let i=0;i<s.length;i++){const o=s[i];o<t&&(t=o)}return t}function Id(s){if(s.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let i=0;i<s.length;i++){const o=s[i];o>t&&(t=o)}return t}function ec(s,t){if(t<s)throw new Ue(`end (${t}) < begin (${s}) is forbidden.`);const i=[];for(let o=s;o<t;++o)i.push(o);return i}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/let WI;function Ar(){return WI==null&&(WI=Fc().epsilon()),WI}function tc(){return"channelsLast"}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function Kb(s,t){return hn(s,t)}function Zb(s,t=-1){const i=s.shape.slice();return t<0&&(t=i.length+t+1),i.splice(t,0,1),He(s,i)}function jX(s,t){return $e(()=>{if(s.shape.length!==2)throw new Ue(`repeat() expects a rank-2 tensor, but received a rank-${s.shape.length} tensor.`);const i=Zb(s,1);return QI(i,[1,t,1])})}function qX(s){const t=[Sd(s.shape)];return He(s,t)}function JX(s){if(s.rank<=1)throw new Ue(`batchFlatten requires a minimum rank of 2. Got rank: ${s.rank}.`);const t=[s.shape[0],Sd(s.shape,1)];return He(s,t)}function Dp(s,t,i){return $e(()=>{switch(s.rank){case 1:return Sp(s,t,i);case 2:return zg(s,[t,0],[i,s.shape[1]]);case 3:return Ip(s,[t,0,0],[i,s.shape[1],s.shape[2]]);case 4:return Ho(s,[t,0,0,0],[i,s.shape[1],s.shape[2],s.shape[3]]);case 5:return Vi(s,[t,0,0,0,0],[i,s.shape[1],s.shape[2],s.shape[3],s.shape[4]]);case 6:return Vi(s,[t,0,0,0,0,0],[i,s.shape[1],s.shape[2],s.shape[3],s.shape[4],s.shape[5]]);default:throw new Ue(`sliceAlongFirstAxis() received an unsupported tensor rank: ${s.rank}`)}})}function HI(s,t,i){return $e(()=>{switch(s.rank){case 1:return Sp(s,t,i);case 2:return zg(s,[0,t],[s.shape[0],i]);case 3:return Ip(s,[0,0,t],[s.shape[0],s.shape[1],i]);case 4:return Ho(s,[0,0,0,t],[s.shape[0],s.shape[1],s.shape[2],i]);default:throw new Ue(`sliceAlongLastAxis() received an unsupported tensor rank: ${s.rank}`)}})}function K1(s,t,i,o){return $e(()=>{switch(s.rank){case 1:return Sp(s,t,i);case 2:switch(o){case 1:return Dp(s,t,i);case 2:return HI(s,t,i);default:throw new Ue(`The axis is not within the rank of the tensor ${o}`)}case 3:switch(o){case 1:return Dp(s,t,i);case 2:return Ip(s,[0,t,0],[s.shape[0],i,s.shape[2]]);case 3:return HI(s,t,i);default:throw new Ue(`The axis is not within the rank of the tensor ${o}`)}case 4:switch(o){case 1:return Dp(s,t,i);case 2:return Ho(s,[0,t,0,0],[s.shape[0],i,s.shape[2],s.shape[3]]);case 3:return Ho(s,[0,0,t,0],[s.shape[0],s.shape[1],i,s.shape[3]]);case 4:return HI(s,t,i);default:throw new Ue(`The axis is not within the rank of the tensor ${o}`)}default:throw new Ue(`sliceAlongLastAxis() received an unsupported tensor rank: ${s.rank}`)}})}function XI(s,t=-1){let i;return t<0&&(i=s[0].rank,i!==0?t=i:t=0),t===s[0].rank&&(t=-1),yi(s,t)}function XB(s,t){switch(s.rank){case 1:return Zx([s,t]);case 2:return cS([s,t],0);case 3:return Ga([s,t],0);case 4:return Yx([s,t],0);default:throw new Ue(`concatAlongFirstAxis() received an unsupported tensor rank: ${s.rank}`)}}function QI(s,t){if(Array.isArray(t)||(t=[t]),s.rank!==t.length)throw new Ue(`The length of input n (${t.length}) does not match the number of dimensions in input x (${s.rank})`);return yo(s,t)}function Z1(s,t=0,i=1,o,l){return Nb(s,t,i,o,l)}function au(s,t,i,o){if(s.rank<2||t.rank<2)throw new hi(`dot requires both inputs to be rank >= 2 but got x shape = ${s.shape} and y shape = ${t.shape}`);if(t.rank>=3){const l=s.shape.slice(-1)[0],u=t.shape.slice(-2)[0];if(l!==u)throw new hi(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${s.shape} and  y shape = ${t.shape}`)}if(s.rank===2&&t.rank===2)return dB({a:s,b:t,transposeA:!1,transposeB:!1,bias:o?KI(s.rank,o,tc()):null,activation:i});{const l=s.shape.slice(),u=l.pop();s=He(s,[-1,u]);const f=t.shape.slice(),g=f.pop(),A=f.pop(),v=[...f,g],C=Array.from({length:t.rank},(M,_)=>_===0?t.rank-2:_<=t.rank-2?_-1:_);t=He(bi(t,C),[A,-1]);const S=[...l,...v];return He(dB({a:s,b:t,transposeA:!1,transposeB:!1,bias:o?KI(s.rank,o,tc()):null,activation:i}),S)}}function QB(s,t,i){return $e(()=>(Array.isArray(t)?t=T(t,"int32"):t=hn(t,"int32"),pd(s,t,i)))}function $b(s){return Oe(s,s)}function KI(s,t,i){const o=t.shape;if(t.rank!==1&&t.rank!==s)throw new Ue(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${s}`);if(s===5){if(i==="channelsFirst")return o.length===1?He(t,[1,o[0],1,1,1]):He(t,[1,o[3],o[0],o[1],o[2]]);if(i==="channelsLast")return o.length===1?He(t,[1,1,1,1,o[0]]):He(t,[1].concat(o))}else if(s===4){if(i==="channelsFirst")return o.length===1?He(t,[1,o[0],1,1]):He(t,[1,o[2],o[0],o[1]]);if(i==="channelsLast")return o.length===1?He(t,[1,1,1,o[0]]):He(t,[1].concat(o))}else if(s===3){if(i==="channelsFirst")return o.length===1?He(t,[1,o[0],1]):He(t,[1,o[1],o[0]]);if(i==="channelsLast")return o.length===1?He(t,[1,1,o[0]]):He(t,[1].concat(o))}else if(s<3)return t;throw new Ue(`Unsupported input rank by biasAdd: ${t.rank}`)}function nc(s,t,i){return $e(()=>(i==null&&(i=tc()),er(i),Ut(s,KI(s.rank,t,i))))}function e9(s,t=1){if(t!==1)throw new hi(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return hd(s)}function t9(s){return $e(()=>En(s,Ut(Ri(s),1)))}function KB(s,t,i,o){return $e(()=>qe(s,t,i,o))}function n9(s){return $e(()=>{const t=Ut(.5,Oe(.2,s));return fs(t,0,1)})}function Yb(s,t,i=!1){return i?s():t()}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const i9=["fanIn","fanOut","fanAvg"],s9=["normal","uniform","truncatedNormal"];/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function r9(s){Lp(i9,"FanMode",s)}function a9(s){Lp(s9,"Distribution",s)}class xl extends dl{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class ZB extends xl{apply(t,i){return Zs(t,i)}}ZB.className="Zeros",Lt(ZB);class ZI extends xl{apply(t,i){return ks(t,i)}}ZI.className="Ones",Lt(ZI);class $B extends xl{constructor(t){if(super(),typeof t!="object")throw new Ue(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new Ue(`config must have value set but got ${t}`);this.value=t.value}apply(t,i){return $e(()=>Oe(Ni(this.value),ks(t,i)))}getConfig(){return{value:this.value}}}$B.className="Constant",Lt($B);class YB extends xl{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,i){return Ju(t,this.minval,this.maxval,i)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}YB.className="RandomUniform",Lt(YB);class jB extends xl{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,i){if(i=i||"float32",i!=="float32"&&i!=="int32")throw new hi(`randomNormal does not support dType ${i}.`);return Z1(t,this.mean,this.stddev,i,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}jB.className="RandomNormal",Lt(jB);class qB extends xl{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,i){if(i=i||"float32",i!=="float32"&&i!=="int32")throw new hi(`truncatedNormal does not support dType ${i}.`);return Ce(t,this.mean,this.stddev,i,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}qB.className="TruncatedNormal",Lt(qB);class JB extends xl{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,i){return $e(()=>{if(t.length!==2||t[0]!==t[1])throw new Ue("Identity matrix initializer can only be used for 2D square matrices.");return Oe(this.gain,xb(t[0]))})}getConfig(){return{gain:this.gain}}}JB.className="Identity",Lt(JB);function o9(s,t="channelsLast"){let i,o;if(er(t),s.length===2)i=s[0],o=s[1];else if([3,4,5].indexOf(s.length)!==-1){if(t==="channelsFirst"){const l=Sd(s,2);i=s[1]*l,o=s[0]*l}else if(t==="channelsLast"){const l=Sd(s,0,s.length-2);i=s[s.length-2]*l,o=s[s.length-1]*l}}else{const l=Sd(s);i=Math.sqrt(l),o=Math.sqrt(l)}return[i,o]}class vo extends xl{constructor(t){if(super(),t.scale<0)throw new Ue(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,r9(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,a9(this.distribution),this.seed=t.seed}apply(t,i){const o=o9(t),l=o[0],u=o[1];let f=this.scale;if(this.mode==="fanIn"?f/=Math.max(1,l):this.mode==="fanOut"?f/=Math.max(1,u):f/=Math.max(1,(l+u)/2),this.distribution==="normal"){const g=Math.sqrt(f);if(i=i||"float32",i!=="float32"&&i!=="int32")throw new hi(`${this.getClassName()} does not support dType ${i}.`);return Ce(t,0,g,i,this.seed)}else{const g=Math.sqrt(3*f);return Ju(t,-g,g,i)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}vo.className="VarianceScaling",Lt(vo);class $I extends vo{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return vo.className}}$I.className="GlorotUniform",Lt($I);class YI extends vo{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return vo.className}}YI.className="GlorotNormal",Lt(YI);class jI extends vo{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return vo.className}}jI.className="HeNormal",Lt(jI);class qI extends vo{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return vo.className}}qI.className="HeUniform",Lt(qI);class JI extends vo{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return vo.className}}JI.className="LeCunNormal",Lt(JI);class eT extends vo{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return vo.className}}eT.className="LeCunNormal",Lt(eT);class eL extends xl{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new hi("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,i){return $e(()=>{if(t.length<2)throw new hi("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const o=t[0]>t[1]?[t[1],t[0]]:t,l=Z1(o,0,1,"float32");let u=M5.gramSchmidt(l);return t[0]>t[1]&&(u=bi(u)),Oe(this.gain,u)})}getConfig(){return{gain:this.gain,seed:this.seed}}}eL.className="Orthogonal",Lt(eL);const tL={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function nL(s,t={}){return Xb(s,Yr.getMap().classNameMap,t,"initializer")}function Ps(s){return PI(s)}function Bs(s){if(typeof s=="string"){const t=s in tL?tL[s]:s;if(t==="GlorotNormal")return new YI;if(t==="GlorotUniform")return new $I;if(t==="HeNormal")return new jI;if(t==="HeUniform")return new qI;if(t==="LeCunNormal")return new JI;if(t==="LeCunUniform")return new eT;{const i={};return i.className=t,i.config={},nL(i)}}else return s instanceof xl?s:nL(s)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function tT(s){return Array.isArray(s)&&Array.isArray(s[0])}function $1(s){return s.length===0?[]:Array.isArray(s[0])?s:[s]}function ti(s){let t;if(Array.isArray(s)){if(s.length!==1)throw new Ue(`Expected Tensor length to be 1; got ${s.length}`);t=s[0]}else t=s;return t}function ns(s){if(Array.isArray(s)&&Array.isArray(s[0])){if(s.length===1)return s=s,s[0];throw new Ue(`Expected exactly 1 Shape; got ${s.length}`)}else return s}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function Y1(s){let t=0;for(const i of s)i.shape.length===0?t+=1:t+=i.shape.reduce((o,l)=>o*l);return t}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const iL="Variable";class l9{constructor(t,i="float32",o=iL,l=!0,u=null){this.dtype=i??"float32",this.shape=t.shape,this.id=UB(),o=o??iL,this.originalName=VB(o),this.name=WB(this.originalName),this.trainable_=l,this.constraint=u,this.val=Pn(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),c9(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function c9(s,t){if(s.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(s.shape)+" vs. "+JSON.stringify(t.shape))}function nT(s){return s.map(t=>t.read())}function iT(s){s.forEach(t=>{t[0].write(t[1])})}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class br{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class ou{constructor(t,i,o,l,u,f,g){this.dtype=t,this.shape=i,this.sourceLayer=o,this.inputs=l,this.callArgs=u,this.outputTensorIndex=g,this.id=UB(),f!=null&&(this.originalName=VB(f),this.name=WB(this.originalName)),this.rank=i.length}}let u9=0;class j1{constructor(t,i){this.callArgs=i,this.id=u9++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const o of t.inboundLayers)o?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const i of this.inboundLayers)i!=null?t.push(i.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let h9=0;class Bi extends dl{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=h9++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let i=t.name;if(!i){const o=this.getClassName();i=ih(o)+"_"+Q1(o)}if(this.name=i,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let o;if(t.batchInputShape!=null)o=t.batchInputShape;else if(t.inputShape!=null){let u=null;t.batchSize!=null&&(u=t.batchSize),o=[u].concat(t.inputShape)}this.batchInputShape=o;let l=t.dtype;l==null&&(l=t.inputDType),l==null&&(l="float32"),this.dtype=l}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,i){return t.name+"_ib-"+i.toString()}getNodeAtIndex(t,i){if(this.inboundNodes.length===0)throw new yl(`The layer has never been called and thus has no defined ${i}.`);if(this.inboundNodes.length<=t)throw new Ue(`Asked to get ${i} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Xa(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Xa(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new su(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new su(`Layer ${this.name} is not connected, no input to return.`);return Xa(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new su(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new su(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Xa(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(i=>i.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Is(t),this.inputSpec==null||this.inputSpec.length===0)return;const i=Is(this.inputSpec);if(t.length!==i.length)throw new Ue(`Layer ${this.name} expects ${i.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let o=0;o<t.length;o++){const l=t[o],u=i[o];if(u==null)continue;const f=l.rank;if(u.ndim!=null&&f!==u.ndim)throw new Ue(`Input ${o} is incompatible with layer ${this.name}: expected ndim=${u.ndim}, found ndim=${f}`);if(u.maxNDim!=null&&f>u.maxNDim)throw new Ue(`Input ${o} is incompatible with layer ${this.name}: expected max_ndim=${u.maxNDim}, found ndim=${f}`);if(u.minNDim!=null&&f<u.minNDim)throw new Ue(`Input ${o} is incompatible with layer ${this.name}: expected min_ndim=${u.minNDim}, found ndim=${f}.`);if(u.dtype!=null&&l.dtype!==u.dtype)throw new Ue(`Input ${o} is incompatible with layer ${this.name} : expected dtype=${u.dtype}, found dtype=${l.dtype}.`);if(u.axes){const g=l.shape;for(const A in u.axes){const v=Number(A),C=u.axes[A],S=v>=0?g[v]:g[g.length+v];if(C!=null&&[C,null].indexOf(S)===-1)throw new Ue(`Input ${o} is incompatible with layer ${this.name}: expected axis ${v} of input shape to have value ${C} but got shape ${g}.`)}}if(u.shape!=null)for(let g=0;g<u.shape.length;++g){const A=u.shape[g],v=l.shape[g];if(A!=null&&v!=null&&A!==v)throw new Ue(`Input ${o} is incompatible with layer ${this.name}: expected shape=${u.shape}, found shape=${l.shape}.`)}}}call(t,i){return t}invokeCallHook(t,i){this._callHook!=null&&this._callHook(t,i)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,i){i=i||{},this.assertNotDisposed();const o=Is(t);let l=!0;for(const f of o)if(!(f instanceof ou)){l=!1;break}let u=!0;for(const f of o)if(f instanceof ou){u=!1;break}if(l===u)throw new Ue("Arguments to apply() must be all SymbolicTensors or all Tensors");return Np(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const f=[];for(const g of Is(t))f.push(g.shape);this.build(Xa(f)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&u&&(this._refCount=1)}if(this.assertInputCompatibility(t),u){let f=this.call(t,i);const g=Is(f),A=[];for(let v of g)o.indexOf(v)!==-1&&(v=v.clone()),A.push(v);if(f=Xa(A),this.activityRegularizer!=null)throw new hi("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return f}else{const f=d9(t),g=this.computeOutputShape(f);let A;const v=f9(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?f[0]:f),g!=null&&g.length>0&&Array.isArray(g[0])?A=g.map((C,S)=>new ou(v,C,this,Is(t),i,this.name,S)):A=new ou(v,g,this,Is(t),i,this.name),this.addInboundNode(t,A,null,null,f,g,i),this._refCount++,this.activityRegularizer!=null)throw new hi("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return A}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let i=!1;this.batchInputShape.forEach((o,l)=>{o!=null&&t[l]!=null&&t[l]!==o&&(i=!0)}),i&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new su(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const i of this.inboundNodes){const o=JSON.stringify(i.outputShapes);t.indexOf(o)===-1&&t.push(o)}if(t.length===1){const i=this.inboundNodes[0].outputShapes;return Array.isArray(i)&&Array.isArray(i[0])&&i.length===1?i[0]:i}else throw new su(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new yl(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Y1(this.weights)}build(t){this.built=!0}getWeights(t=!1){return nT(t?this.trainableWeights:this.weights)}setWeights(t){$e(()=>{const i=this.weights;if(i.length!==t.length)throw new Ue(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${i.length} weights. Provided weights: ${t}...`);if(i.length===0)return;const o=[],l=nT(i);for(let u=0;u<l.length;++u){const f=l[u],g=i[u],A=t[u];if(!O(f.shape,A.shape))throw new Ue(`Layer weight shape ${f.shape} not compatible with provided weight shape ${A.shape}`);o.push([g,A])}iT(o)})}addWeight(t,i,o,l,u,f,g,A){if(this._addedWeightNames.indexOf(t)!==-1)throw new Ue(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),o==null&&(o="float32"),this.fastWeightInitDuringBuild&&(l=A!=null?A():Bs("zeros"));const v=l.apply(i,o),C=new l9(v,o,t,f,g);return v.dispose(),u!=null&&this.addLoss(()=>u.apply(C.read())),f==null&&(f=!0),f?this._trainableWeights.push(C):this._nonTrainableWeights.push(C),C}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Is(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,i){if(!this.supportsMasking){if(i!=null)if(Array.isArray(i))i.forEach(o=>{if(o!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return i}addInboundNode(t,i,o,l,u,f,g=null){const A=Is(t);i=Is(i),o=Is(o),l=Is(l),u=$1(u),f=$1(f);const v=[],C=[],S=[];for(const M of A)v.push(M.sourceLayer),C.push(M.nodeIndex),S.push(M.tensorIndex);new j1({outboundLayer:this,inboundLayers:v,nodeIndices:C,tensorIndices:S,inputTensors:A,outputTensors:i,inputMasks:o,outputMasks:l,inputShapes:u,outputShapes:f},g);for(let M=0;M<i.length;M++)i[M].sourceLayer=this,i[M].nodeIndex=this.inboundNodes.length-1,i[M].tensorIndex=M}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function d9(s){s=Is(s);const t=[];for(const i of s)t.push(i.shape);return Xa(t)}function f9(s){return"float32"}function sL(s,t,i){if((t==null||i!=null&&i>0)&&(t=s.sourceLayer,i=s.nodeIndex),t.inboundNodes.length===0)return[s];{const o=t.inboundNodes[i];if(o.inboundLayers.length===0)return o.inputTensors;{const l=[];for(let u=0;u<o.inboundLayers.length;u++){const f=o.inputTensors[u],g=o.inboundLayers[u],A=o.nodeIndices[u],v=sL(f,g,A);for(const C of v)l.indexOf(C)===-1&&l.push(C)}return l}}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class jb extends Bi{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:Q1("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new Ue("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let i=t.batchInputShape;if(i==null){if(t.inputShape==null)throw new Ue("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");i=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new Ue("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const o=t.dtype||"float32";this.batchInputShape=i,this.dtype=o,this.inputSpec=[{shape:i}];const l=new ou(this.dtype,this.batchInputShape,this,[],{},this.name);l.nodeIndex=0,l.tensorIndex=0,new j1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[l],outputTensors:[l],inputMasks:[null],outputMasks:[null],inputShapes:[i],outputShapes:[i]})}apply(t,i){throw new Ue(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}jb.className="InputLayer",Lt(jb);function p9(s){if(s.batchShape==null&&s.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(s.batchShape!=null&&s.shape!=null)throw new Ue("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=s.batchShape;s.shape!=null&&t==null&&(t=[null].concat(s.shape));let i=s.dtype;return i==null&&(i="float32"),new jb({batchInputShape:t,name:s.name,dtype:i,sparse:s.sparse}).inboundNodes[0].outputTensors[0]}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function m9(s,t){if(s.dtype==null||s.dtype===t.dtype)return t;try{return hn(t,s.dtype)}catch{throw new Ue(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${s.name}' (${s.dtype}).`)}}class Td{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Td)for(const i in t.id2Value)this.id2Value[i]=t.id2Value[i],i in t.id2Mask&&(this.id2Mask[i]=t.id2Mask[i]);else{if(t==null)return;for(const i of t)this.add(i.key,i.value)}}add(t,i,o){if(this.id2Value[t.id]==null)this.id2Value[t.id]=m9(t,i),this.name2Id[t.name]=t.id,o!=null&&(this.id2Mask[t.id]=o);else throw new Ue(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof ou){if(this.id2Value[t.id]==null)throw new Ue(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const i=this.name2Id[t];if(i==null)throw new Ue(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[i]}}getMask(t){if(t instanceof ou){if(this.id2Value[t.id]==null)throw new Ue(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const i=this.name2Id[t];if(i==null)throw new Ue(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[i]}}disposeMasks(){this.id2Mask!=null&&ci(this.id2Mask)}}const q1=new DB,J1=new DB;function g9(s){q1?.setMaxEntries(s),J1?.setMaxEntries(s)}function qb(s,t,i,o){const l=i==null?!1:i.training,u=Array.isArray(s),f=u?s:[s],g=f.map(B=>B.name),A=[],v=t.names();for(const B of g)v.indexOf(B)!==-1?A.push(t.getValue(B)):A.push(null);const C=g.join(",")+"|"+t.names().sort().join(",");let S=q1.get(C),M;if(S==null){const B=A9(f,t);S=B.sorted,M=B.recipientCounts,q1.put(C,S),J1.put(C,M)}M={},l||Object.assign(M,J1.get(C));const _=new Td(t);for(let B=0;B<S.length;++B){const F=S[B],P=F.sourceLayer;if(P instanceof jb)continue;const U=[],V=[],$=[];let q=!1;for(const ye of F.inputs){const Te=_.getValue(ye),Ye=_.getMask(ye);U.push(Te),V.push(Ye),Ye!=null&&(q=!0),l||(M[ye.name]--,M[ye.name]===0&&!t.hasKey(ye)&&g.indexOf(ye.name)===-1&&!Te.isDisposed&&ye.sourceLayer.stateful!==!0&&$.push(Te))}q&&(i=i||{},i.mask=V[0]);const ne=Is(P.apply(U,i));let he=null;P.supportsMasking&&(he=P.computeMask(U,V));const me=y9(F),pe=Array.isArray(me)?me:[me];for(let ye=0;ye<pe.length;++ye){_.hasKey(pe[ye])||_.add(pe[ye],ne[ye],Array.isArray(he)?he[0]:he);const Te=g.indexOf(pe[ye].name);Te!==-1&&(A[Te]=ne[ye])}l||ci($)}return _.disposeMasks(),u?A:A[0]}function A9(s,t){E(s!=null&&s.length>0,()=>"Expected at least one fetch, got none");let i=[],o={};if(s.length===1){const l=rL(s[0],t);i=l.sorted,o=l.recipientMap}else{const l=new Set;for(const u of s){const{sorted:f,recipientMap:g}=rL(u,t);for(const A of f)l.has(A.name)||(i.push(A),l.add(A.name));for(const A in g)o[A]==null&&(o[A]=new Set),g[A].forEach(v=>o[A].add(v))}}return{sorted:i,recipientCounts:b9(o)}}function b9(s){const t={};for(const i in s)t[i]=s[i].size;return t}function rL(s,t){const i=new Set,o=[],l={};for(const g of t.names())i.add(g);const u=[],f=[];for(u.push(s);u.length>0;){const g=u[u.length-1];if(i.has(g.name)){u.pop();continue}const A=f[f.length-1]===u.length-1;if(g.inputs.length===0||A)u.pop(),o.push(g),i.add(g.name),A&&f.pop();else{f.push(u.length-1);for(const v of g.inputs)l[v.name]==null&&(l[v.name]=new Set),l[v.name].add(g.name),!i.has(v.name)&&u.push(v)}}return{sorted:o,recipientMap:l}}function y9(s){let t;if(s.sourceLayer.inboundNodes.length===1)t=s.sourceLayer.output;else{let i=null;for(let o=0;o<s.sourceLayer.inboundNodes.length;++o)for(const l of s.sourceLayer.inboundNodes[o].outputTensors)if(l.id===s.id){i=o;break}t=s.sourceLayer.getOutputAt(i)}return t}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Ee().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,g9);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function sT(s,t){return $e(()=>Pr(wn(Oe(s,s),t,!0)))}class Jb extends dl{getConfig(){return{}}}class aL extends Jb{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return $e(()=>{const i=sT(t,this.axis),o=fs(i,0,this.maxValue);return Oe(t,En(o,Ut(Ar(),i)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}aL.className="MaxNorm",Lt(aL);class oL extends Jb{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return $e(()=>En(t,Ut(Ar(),sT(t,this.axis))))}getConfig(){return{axis:this.axis}}}oL.className="UnitNorm",Lt(oL);class lL extends Jb{apply(t){return Wo(t)}}lL.className="NonNeg",Lt(lL);class cL extends Jb{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return $e(()=>{const i=sT(t,this.axis),o=Ut(Oe(this.rate,fs(i,this.minValue,this.maxValue)),Oe(1-this.rate,i));return Oe(t,En(o,Ut(Ar(),i)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}cL.className="MinMaxNorm",Lt(cL);const uL={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function yr(s){return PI(s)}function hL(s,t={}){return Xb(s,Yr.getMap().classNameMap,t,"constraint")}function vr(s){if(s==null)return null;if(typeof s=="string"){const t={className:s in uL?uL[s]:s,config:{}};return hL(t)}else return s instanceof Jb?s:hL(s)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/async function Fp(s){if(s==null)return;const t=[],i=[],o=[];for(const l in s){const u=s[l];if(typeof u!="number"){const f=u;t.push(f.data()),i.push(l),o.push(f)}}if(t.length>0){const l=await Promise.all(t);for(let u=0;u<l.length;++u)s[i[u]]=l[u][0];ci(o)}}function dL(s){if(s!=null)for(const t in s){const i=s[t];typeof i!="number"&&i.dispose()}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/var fL;(function(s){s[s.SILENT=0]="SILENT",s[s.VERBOSE=1]="VERBOSE"})(fL||(fL={}));const v9=125;class ey{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,i){}async onEpochEnd(t,i){}async onBatchBegin(t,i){}async onBatchEnd(t,i){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class x9{constructor(t,i=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=i}append(t){this.callbacks.push(t)}setParams(t){for(const i of this.callbacks)i.setParams(t)}setModel(t){for(const i of this.callbacks)i.setModel(t)}async onEpochBegin(t,i){i==null&&(i={});for(const o of this.callbacks)await o.onEpochBegin(t,i)}async onEpochEnd(t,i){i==null&&(i={});for(const o of this.callbacks)await o.onEpochEnd(t,i)}async onBatchBegin(t,i){i==null&&(i={});for(const o of this.callbacks)await o.onBatchBegin(t,i)}async onBatchEnd(t,i){i==null&&(i={});for(const o of this.callbacks)await o.onBatchEnd(t,i)}async onTrainBegin(t){t==null&&(t={});for(const i of this.callbacks)await i.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const i of this.callbacks)await i.onTrainEnd(t)}}class w9 extends ey{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,i){i==null&&(i={});const o=i.size==null?0:i.size;this.seen+=o;for(const l in i){const u=i[l];if(typeof u=="number")this.totals.hasOwnProperty(l)||(this.totals[l]=0),this.totals[l]=this.totals[l]+u*o;else{let f;l in this.totals?f=this.totals[l]:this.totals[l]=0;const g=$e(()=>Ut(this.totals[l],Oe(u,o)));this.totals[l]=g,f?.dispose()}}}async onEpochEnd(t,i){if(i!=null)for(const o of this.params.metrics)this.totals[o]!=null&&(typeof this.totals[o]=="number"?i[o]=this.totals[o]/this.seen:$e(()=>{const l=Oe(En(1,this.seen),this.totals[o]);i[o]=l,this.totals[o].dispose(),ca(i[o])}))}}class C9 extends ey{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,i){i==null&&(i={}),this.epoch.push(t);for(const o in i)this.history[o]==null&&(this.history[o]=[]),this.history[o].push(i[o])}async syncData(){const t=[],i=[],o=[];for(const u in this.history){const f=this.history[u];for(let g=0;g<f.length;++g)if(typeof f[g]!="number"){const A=f[g];t.push(A.data()),i.push(u),o.push(g)}}const l=await Promise.all(t);for(let u=0;u<l.length;++u)this.history[i[u]][o[u]].dispose(),this.history[i[u]][o[u]]=l[u][0]}}class E9 extends ey{constructor(t,i){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||P1,this.yieldEvery=i||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=v9),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Le(this.yieldEvery)&&(this.maybeWait=PX(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,i,o){const l=[];this.yield!=null&&(await Fp(o),l.push(this.yield(t,i,o))),l.push(this.nextFrameFunc()),await Promise.all(l)}async onEpochBegin(t,i){this.currentEpoch=t,this.epochBegin!=null&&(await Fp(i),await this.epochBegin(t,i))}async onEpochEnd(t,i){const o=[];this.epochEnd!=null&&(await Fp(i),o.push(this.epochEnd(t,i))),this.yieldEvery==="epoch"&&o.push(this.nextFrameFunc()),await Promise.all(o)}async onBatchBegin(t,i){this.batchBegin!=null&&(await Fp(i),await this.batchBegin(t,i))}async onBatchEnd(t,i){const o=[];this.batchEnd!=null&&(await Fp(i),o.push(this.batchEnd(t,i))),this.yieldEvery==="batch"?o.push(this.nextFrameFunc()):Le(this.yieldEvery)&&o.push(this.maybeWait(this.currentEpoch,t,i)),await Promise.all(o)}async onTrainBegin(t){this.trainBegin!=null&&(await Fp(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Fp(t),await this.trainEnd(t))}}function pL(s,t){return s==null&&(s={}),s instanceof ey?[s]:Array.isArray(s)&&s[0]instanceof ey?s:Is(s).map(i=>new E9(i,t))}class wl{constructor(){}static registerCallbackConstructor(t,i){E(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),wl.checkForDuplicate(i),wl.constructors[t]==null&&(wl.constructors[t]=[]),wl.constructors[t].push(i)}static checkForDuplicate(t){for(const i in wl.constructors)wl.constructors[+i].forEach(o=>{if(o===t)throw new Ue("Duplicate callback constructor.")})}static clear(){wl.constructors={}}static createCallbacks(t){const i=[];for(const o in wl.constructors){const l=+o;t>=l&&i.push(...wl.constructors[l])}return i.map(o=>new o)}}wl.constructors={};function mL(s,t,i,o,l,u,f,g,A){const v=new C9,C=[new w9,...wl.createCallbacks(t)];s!=null&&C.push(...s),C.push(v);const S=new x9(C);return S.setParams({epochs:i,initialEpoch:o,samples:l,steps:u,batchSize:f,verbose:t,doValidation:g,metrics:A}),{callbackList:S,history:v}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function sh(s,t={},i=!1){return Xb(s,Yr.getMap().classNameMap,t,"layer",i)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function ew(s,t){return $e(()=>{s.dtype!=="float32"&&(s=hn(s,"float32"));const i=wn($b(s),t,!0),o=op(i.shape,Ar()),l=Pr(Yl(i,o));return En(s,l)})}function tw(s,t){return $e(()=>Hn($b(Wn(t,s)),-1))}function rT(s,t){return $e(()=>Hn(Ri(Wn(t,s)),-1))}function aT(s,t){return $e(()=>{const i=Wn(s,t),o=fs(Ri(s),Ar(),Number.MAX_VALUE),l=Ri(En(i,o));return Oe(100,Hn(l,-1))})}function S9(s,t){return $e(()=>{const i=fs(t,Ar(),Number.MAX_VALUE),o=zo(Ut(1,i)),l=fs(s,Ar(),Number.MAX_VALUE),u=zo(Ut(1,l));return Hn($b(Wn(o,u)),-1)})}function I9(s,t){return $e(()=>{const i=Yl(0,Wn(1,Oe(s,t)));return Hn($b(i),-1)})}function T9(s,t){return $e(()=>{const i=Yl(0,Wn(1,Oe(s,t)));return Hn(i,-1)})}function M9(s,t){return $e(()=>{const i=wn(Oe(s,t),-1),o=ha(Oe(Wn(1,s),t),-1);return Yl(0,Ut(1,Wn(o,i)))})}function _9(s,t){return $e(()=>{const i=Math.log(2),o=Wn(t,s),l=Wn(Ut(o,gd(Oe(-2,o))),i);return Hn(l,-1)})}function ty(s,t,i=!1){return $e(()=>{if(i)t=eh(t);else{const o=wn(t,t.shape.length-1,!0);t=En(t,o)}return t=fs(t,Ar(),1-Ar()),Us(wn(Oe(hn(s,"float32"),zo(t)),t.shape.length-1))})}function nw(s,t,i=!1){return $e(()=>{const o=hn(fp(qX(s)),"int32");t=fs(t,Ar(),1-Ar());const l=t.shape,u=He($A(o,l[l.length-1]),l);return ty(u,t,i)})}function R9(s,t){if(!O(s.shape,t.shape))throw new Ue(`logits and labels must have the same shape, but got shapes ${JSON.stringify(s.shape)} and ${JSON.stringify(t.shape)}`);return $e(()=>{const i=Wo(t),o=Us(Ri(t));return Ut(Wn(i,Oe(t,s)),wb($l(o)))})}function iw(s,t){return $e(()=>{let i;return i=fs(t,Ar(),1-Ar()),i=zo(En(i,Wn(1,i))),Hn(R9(s,i),-1)})}function k9(s,t){return $e(()=>{const i=fs(s,Ar(),1),o=fs(t,Ar(),1);return wn(Oe(s,zo(En(i,o))),-1)})}function B9(s,t){return $e(()=>{const i=zo(Ut(Ar(),t));return Hn(Wn(t,Oe(s,i)),-1)})}function gL(s,t){return $e(()=>{const i=ew(s,-1),o=ew(t,-1),l=Oe(i,o);return Us(wn(l,-1))})}const sw={meanSquaredError:tw,meanAbsoluteError:rT,meanAbsolutePercentageError:aT,meanSquaredLogarithmicError:S9,squaredHinge:I9,hinge:T9,categoricalHinge:M9,logcosh:_9,categoricalCrossentropy:ty,sparseCategoricalCrossentropy:nw,binaryCrossentropy:iw,kullbackLeiblerDivergence:k9,poisson:B9,cosineProximity:gL};function oT(s){if(typeof s=="string"){if(s in sw)return sw[s];let t=`Unknown loss ${s}`;throw s.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${s}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Ue(t)}else return s}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function AL(s,t){return $e(()=>{const i=Oe(.5,Wa(t)),o=Kb(Va(t,i),s.dtype);return Hn(Ao(s,o),-1)})}function bL(s,t){return $e(()=>Kb(Ao(td(s,-1),td(t,-1)),"float32"))}function L9(s,t){return $e(()=>hn(wn(Vo(Ao(s,1),Ao(t,1))),"float32"))}function N9(s,t){return $e(()=>hn(wn(Vo(Ao(s,0),Ao(t,1))),"float32"))}function D9(s,t){return $e(()=>{const i=L9(s,t),o=N9(s,t),l=Ut(i,o);return hn(Ii(Va(l,0),En(i,l),0),"float32")})}function F9(s,t){return iw(s,t)}function O9(s,t){return s.rank===t.rank&&(s=Jl(s,[s.rank-1])),t=td(t,-1),t.dtype!==s.dtype&&(t=hn(t,s.dtype)),hn(Ao(s,t),"float32")}const G9=tw,U9=tw,P9=rT,z9=rT,V9=aT,W9=aT,yL=ty,H9=gL,vL=nw,rw={binaryAccuracy:AL,categoricalAccuracy:bL,precision:D9,categoricalCrossentropy:yL,sparseCategoricalCrossentropy:vL,mse:G9,MSE:U9,mae:P9,MAE:z9,mape:V9,MAPE:W9,cosine:H9};function X9(s){if(typeof s=="string"&&s in rw)return rw[s];if(typeof s!="string"&&s!=null)return s;throw new Ue(`Unknown metric ${s}`)}function aw(s){if(ru(s!==null,`Unknown LossOrMetricFn ${s}`),typeof s=="string")return s;{let t;for(const i of Object.keys(sw))if(sw[i]===s){t=i;break}if(t!==void 0)return t;for(const i of Object.keys(rw))if(rw[i]===s){t=i;break}return t!==void 0?t:s.name}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function Q9(s){const t={Adagrad:()=>Kg.adagrad(.01),Adadelta:()=>Kg.adadelta(1,.95,Ar()),Adam:()=>Kg.adam(.001,.9,.999,Ar()),Adamax:()=>Kg.adamax(.002,.9,.999,Ar(),0),RMSProp:()=>Kg.rmsprop(.001,.9,0,Ar()),SGD:()=>Kg.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,s in t)return t[s]();throw new Ue(`Unknown Optimizer ${s}`)}/**
* @license
* Copyright 2019 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const xL=1*1024*1024;function wL(s,t,i=!1){if(s==null||typeof s!="object"||Object.getPrototypeOf(s)!==Object.prototype||!lT(s))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(i){const o=JSON.stringify(s);o.length>xL&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${o.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${xL}.`)}}function lT(s){if(s===null)return!0;if(typeof s=="object")if(Object.getPrototypeOf(s)===Object.prototype){const t=Object.keys(s);for(const i of t)if(typeof i!="string"||!lT(s[i]))return!1;return!0}else if(Array.isArray(s)){for(const t of s)if(!lT(t))return!1;return!0}else return!1;else{const t=typeof s;return t==="string"||t==="number"||t==="boolean"}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function K9(s,t,i,o=console.log){const l=$9(s),u=["Layer (type)","Input Shape","Output shape","Param #"];l?(t=t||90,i=i||[.32,.61,.89,1]):(t=t||115,i=i||[.24,.48,.7,.8,1]),i[i.length-1]<=1&&(i=i.map(C=>Math.floor(t*C)));let f;if(!l){u.push("Receives inputs"),f=[];for(const C in s.nodesByDepth)f.push(...s.nodesByDepth[C])}o("_".repeat(t)),ow(u,i,o),o("=".repeat(t));const g=s.layers;for(let C=0;C<g.length;++C)l?Y9(g[C],i,o):j9(g[C],i,f,o),o((C===g.length-1?"=":"_").repeat(t));s.checkTrainableWeightsConsistency();const A=Z9(s),v=Y1(s.nonTrainableWeights);o(`Total params: ${A+v}`),o(`Trainable params: ${A}`),o(`Non-trainable params: ${v}`),o("_".repeat(t))}function Z9(s){let t;return s.collectedTrainableWeights!=null?t=Y1(s.collectedTrainableWeights):t=Y1(s.trainableWeights),t}function $9(s){let t=!0;const i=[],o=[];for(const l in s.nodesByDepth)i.push(s.nodesByDepth[l]);for(const l of i){if(l.length>1||l.length===1&&l[0].inboundLayers.length>1){t=!1;break}o.push(...l)}if(t)for(const l of s.layers){let u=!1;for(const f of l.inboundNodes)if(o.indexOf(f)!==-1)if(u){t=!1;break}else u=!0;if(!t)break}return t}function ow(s,t,i=console.log){let o="";for(let l=0;l<s.length;++l)l>0&&(o=o.slice(0,o.length-1)+" "),o+=s[l],o=o.slice(0,t[l]),o+=" ".repeat(t[l]-o.length);i(o)}function Y9(s,t,i){let o,l;try{l=s.inboundNodes.map(A=>JSON.stringify(A.inputShapes)).join(",")}catch{l="multiple"}try{o=JSON.stringify(s.outputShape)}catch{o="multiple"}const u=s.name,f=s.getClassName(),g=[`${u} (${f})`,l,o,s.countParams().toString()];ow(g,t,i)}function j9(s,t,i,o){let l,u;try{u=s.inboundNodes.map(S=>JSON.stringify(S.inputShapes)).join(",")}catch{u="multiple"}try{l=JSON.stringify(s.outputShape)}catch{l="multiple"}const f=[];for(const S of s.inboundNodes)if(!(i!=null&&i.length>0&&i.indexOf(S)===-1))for(let M=0;M<S.inboundLayers.length;++M){const _=S.inboundLayers[M].name,B=S.nodeIndices[M],F=S.tensorIndices[M];f.push(`${_}[${B}][${F}]`)}const g=s.name,A=s.getClassName(),v=f.length===0?"":f[0],C=[`${g} (${A})`,u,l,s.countParams().toString(),v];ow(C,t,o);for(let S=1;S<f.length;++S)ow(["","","","",f[S]],t,o)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function CL(s,t,i){return(s==="inboundNodes"||s==="outputLayers"||s==="inputLayers")&&t===0&&typeof i=="string"}function cT(s,t){if(s===null)return null;if(typeof s=="string")return Bp(s);if(typeof s=="number"||typeof s=="boolean")return s;if(s instanceof Array){const i=[],o=s.length;for(let l=0;l<o;++l){const u=s[l];CL(t,l,u)?i.push(u):i.push(cT(u,t))}return i}else{const i={};for(const o of Object.keys(s)){const l=s[o];if(o==="name"&&typeof l=="string")i[o]=l;else{const u=Bp(o);i[u]=cT(l,u)}}return i}}function uT(s,t){if(s==null)return null;if(typeof s=="string")return ih(s);if(typeof s=="number"||typeof s=="boolean")return s;if(s instanceof Array){const i=[],o=s.length;for(let l=0;l<o;++l){const u=s[l];CL(t,l,u)?i.push(u):i.push(uT(u,t))}return i}else{const i={};for(const o of Object.keys(s)){const l=s[o],u=ih(o);(o==="name"||o==="className")&&typeof l=="string"?i[u]=l:i[u]=uT(l,o)}return i}}/** @license See the LICENSE file. */const EL="3.21.0";/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class ic extends Bi{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const V=this.getClassName().toLowerCase();this.name=Q1(V)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Ed(this.inputs).length!==this.inputs.length)throw new Ue(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(V=>V.name)}`);Ed(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(V=>V.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const V of this.outputs){const $=V.sourceLayer,q=V.nodeIndex,ne=V.tensorIndex;this.outputLayers.push($),this.outputLayersNodeIndices.push(q),this.outputLayersTensorIndices.push(ne)}for(const V of this.inputs){const $=V.sourceLayer,q=V.nodeIndex,ne=V.tensorIndex;ru(q===0,"input layer has >1 nodes"),ru(ne===0,"input layer has >1 tensors"),this.inputLayers.push($),this.inputLayersNodeIndices.push(q),this.inputLayersTensorIndices.push(ne)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let V=0;V<this.inputLayers.length;V++){const $=this.inputLayers[V];if(!($ instanceof jb))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${V} (0-based) originates from layer type ${$.getClassName()}.`);this.inputNames.push($.name),this.feedInputShapes.push($.batchInputShape),this.feedInputNames.push($.name)}for(const V of this.outputLayers)this.outputNames.push(V.name);this.internalInputShapes=this.inputs.map(V=>V.shape),this.internalOutputShapes=this.outputs.map(V=>V.shape);const i={},o={},l={},u={},f={},g=[],A=(V,$,q,ne,he,me)=>{(ne==null||he==null||me==null)&&(ne=V.sourceLayer,he=V.nodeIndex,me=V.tensorIndex);const pe=ne.inboundNodes[he];if(q.indexOf(pe)!==-1)throw new yl(`The tensor ${V.name} at layer "${ne.name}" is part of a cycle.`);if($.indexOf(pe)!==-1)return;this.containerNodes.add(ic.nodeKey(ne,he)),ne.id in f||(f[ne.id]=Object.keys(f).length),q.indexOf(pe)===-1&&q.push(pe);const ye=pe.inboundLayers.length;for(let Te=0;Te<ye;Te++){const Ye=pe.inputTensors[Te],et=pe.inboundLayers[Te],nt=pe.nodeIndices[Te],ht=pe.tensorIndices[Te];A(Ye,$,q,et,nt,ht)}for($.push(pe);q.indexOf(pe)>=0;)q.splice(q.indexOf(pe),1);g.push(pe)},v=[],C=[];for(const V of this.outputs)A(V,v,C);const S=g.slice().reverse();for(const V of S){o[V.id]=V,V.id in i||(i[V.id]=0);let $=i[V.id];const q=l[V.outboundLayer.id]==null?0:l[V.outboundLayer.id];$=Math.max($,q),l[V.outboundLayer.id]=$,u[V.outboundLayer.id]=V.outboundLayer,i[V.id]=$;for(let ne=0;ne<V.inboundLayers.length;ne++){const he=V.inboundLayers[ne],me=V.nodeIndices[ne],pe=he.inboundNodes[me],ye=i[pe.id]==null?0:i[pe.id];i[pe.id]=Math.max($+1,ye),o[pe.id]=pe}}const M={};for(const V in i){const $=i[V];$ in M||(M[$]=[]),M[$].push(o[V])}const _={};for(const V in l){const $=l[V];$ in _||(_[$]=[]),_[$].push(u[V])}let B=Object.keys(_).map(V=>parseInt(V,10)).sort(H1);this.layers=[];for(const V of B){const $=_[V];$.sort((q,ne)=>{const he=f[q.id],me=f[ne.id];return he<me?-1:he>me?1:0});for(const q of $)q instanceof ic&&this.internalContainerRefs.push(q),this.layers.push(q)}this.layersByDepth=_,B=Object.keys(M).map(V=>parseInt(V,10)).sort(H1);const F=this.inputs.slice(),P=[];for(const V of B)for(const $ of M[V]){const q=$.outboundLayer;if(q!=null){for(const ne of $.inputTensors)if(F.indexOf(ne)===-1)throw new yl(`Graph disconnected: cannot obtain value for tensor ${ne} at layer "${q.name}". The following previous layers were accessed without issue: ${P}`);for(const ne of $.outputTensors)F.push(ne);P.push(q.name)}}this.nodesByDepth=M;const U=this.layers.map(V=>V.name);for(const V of U){const $=U.filter(q=>q===V).length;if($!==1)throw new yl(`The name "${V}" is used ${$} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(U))}this.outboundNodes=[],this.inboundNodes=[],new j1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(V=>null),outputMasks:this.outputs.map(V=>null),inputShapes:this.inputs.map(V=>V.shape),outputShapes:this.outputs.map(V=>V.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const i of this.layers)t.numDisposedVariables+=i.dispose().numDisposedVariables;for(const i of this.internalContainerRefs)t.numDisposedVariables+=i.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(i=>{i._trainableWeights.forEach(o=>o.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new Ue("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const i of this.layers)t=t.concat(i.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const i of this.layers)t.push(...i.nonTrainableWeights);if(!this.trainable){const i=[];for(const o of this.layers)i.push(...o.trainableWeights);return i.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,i=!0){const o={};let l=0;for(const f of this.layers)for(const g of f.weights){if(o[g.originalName]!=null)throw new Ue(`Duplicate weight name: ${g.originalName}`);o[g.originalName]=g,l++}const u=[];for(const f in t){let g=f;if(o[f]==null){const A=f.split("/");g=A.slice(0,-2).concat([A[A.length-1]]).join("/")}if(o[g]!=null)u.push([o[g],t[f]]);else if(i)throw new Ue(`Provided weight data has no target variable: ${f}`);delete o[g]}if(i){const f=[];for(const g in o)f.push(g);if(f.length>0)throw new Ue(`${f.length} of ${l} weights are not set: ${f}`)}iT(u)}updatedConfig(){const t=this.getConfig(),i={};return i.className=this.getClassName(),i.config=t,i.kerasVersion=`tfjs-layers ${EL}`,i.backend="TensorFlow.js",i}toJSON(t,i=!0){const o=uT(this.updatedConfig());return i?JSON.stringify(o):o}call(t,i){return $e(()=>{t=Is(t);const o=new Td;for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],t[l]);return qb(this.outputs,o,i)})}computeMask(t,i){return $e(()=>{t=Is(t);let o;return i==null?o=kp(null,t.length):o=Is(i),this.runInternalGraph(t,o)[1]})}computeOutputShape(t){const i=$1(t);if(i.length!==this.inputLayers.length)throw new Ue(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const o={};for(let g=0;g<i.length;g++){const A=this.inputLayers[g],v=i[g],C=A.name+"_0_0";o[C]=v}const l=Object.keys(this.nodesByDepth).map(g=>parseInt(g,10)).sort(H1);if(l.length>1)for(const g of l){const A=this.nodesByDepth[g];for(const v of A){const C=v.outboundLayer;if(this.inputLayers.map(F=>F.id).indexOf(C.id)!==-1)continue;const S=[];for(let F=0;F<v.inboundLayers.length;F++){const P=v.inboundLayers[F],U=v.nodeIndices[F],V=v.tensorIndices[F],$=`${P.name}_${U}_${V}`,q=o[$];S.push(q)}const M=C.computeOutputShape(Xa(S)),_=$1(M),B=C.inboundNodes.indexOf(v);for(let F=0;F<_.length;F++){const P=`${C.name}_${B}_${F}`;o[P]=_[F]}}}const u=[],f=[];for(let g=0;g<this.outputLayers.length;g++){const A=this.outputLayers[g],v=this.outputLayersNodeIndices[g],C=this.outputLayersTensorIndices[g],S=`${A.name}_${v}_${C}`;f.push(S)}for(let g=0;g<f.length;g++){const A=f[g];ru(A in o),u.push(o[A])}return Xa(u)}runInternalGraph(t,i){i==null&&(i=kp(null,t.length));const o={};for(let A=0;A<this.inputs.length;++A){const v=this.inputs[A],C=t[A],S=i[A];o[v.id]=[C,S]}const l=Object.keys(this.nodesByDepth).map(A=>parseInt(A,10)).sort(H1);for(const A of l){const v=this.nodesByDepth[A];for(const C of v){const S=C.outboundLayer,M=C.inputTensors,_=C.outputTensors,B=new Array;for(const F of M)F.id in o&&B.push(o[F.id]);if(B.length===M.length){let F={},P,U,V,$;if(C.callArgs!=null&&(F=C.callArgs),B.length===1){const[q,ne]=B[0];F.mask==null&&(F.mask=ne),V=Is(S.call(q,F)),$=Is(S.computeMask(q,ne)),P=[q],U=[ne]}else P=B.map(q=>q[0]),U=B.map(q=>q[1]),F.mask==null&&(F.mask=U),V=Is(S.call(P,F)),$=Is(S.computeMask(P,U));if(S.activityRegularizer)throw new hi("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let q=0;q<_.length;++q){const ne=_[q],he=V[q],me=$[q];o[ne.id]=[he,me]}}}}const u=[],f=[],g=[];for(const A of this.outputs){ru(A.id in o,`Could not compute output ${A.name} : ${A.id}`);const[v,C]=o[A.id];g.push(v.shape),u.push(v),f.push(C)}return[u,f,g]}buildNodeConversionMap(t){const i={};let o;for(const l of this.layers){o=l instanceof ic?1:0;for(let u=0;u<l.inboundNodes.length;u++){const f=ic.nodeKey(l,u);this.containerNodes.has(f)&&(i[f]=o,o+=1)}}return i}getLayer(t,i){if(i!=null){if(this.layers.length<=i)throw new Ue(`Was asked to retrieve layer at index ${i}, but model only has ${this.layers.length} layer(s).`);return this.layers[i]}else if(t==null)throw new Ue("Provide either a layer name or layer index");for(const o of this.layers)if(o.name===t)return o;throw new Ue(`No such layer: ${t}`)}calculateLosses(){return $e(()=>{const t=[];for(const i of this.layers)for(let o=0;o<i.inboundNodes.length;++o){const l=ic.nodeKey(i,o);this.containerNodes.has(l)&&t.push(...i.calculateLosses())}return t})}getConfig(){const t={name:this.name},i=this.buildNodeConversionMap(this.layers),o=[];for(const f of this.layers){const g=f.getClassName(),A=f.getConfig(),v=[];for(let S=0;S<f.inboundNodes.length;S++){const M=f.inboundNodes[S],_=ic.nodeKey(f,S);let B={};if(this.containerNodes.has(_)){if(M.callArgs)try{JSON.stringify(M.callArgs),B=M.callArgs}catch{console.warn(`Layer ${f.name} was passed non-serializable keyword arguments: ${M.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),B={}}if(M.inboundLayers.length>0){const F=[];for(let P=0;P<M.inboundLayers.length;P++){const U=M.inboundLayers[P],V=M.nodeIndices[P],$=M.tensorIndices[P],q=ic.nodeKey(U,V);let ne=i[q];ne==null&&(ne=0),F.push([U.name,ne,$,B])}v.push(F)}}}const C={};C.name=f.name,C.className=g,C.config=A,C.inboundNodes=v,o.push(C)}t.layers=o;const l=[];for(let f=0;f<this.inputLayers.length;f++){const g=this.inputLayers[f],A=this.inputLayersNodeIndices[f],v=ic.nodeKey(g,A);if(!this.containerNodes.has(v))continue;let C=i[v];C==null&&(C=0);const S=this.inputLayersTensorIndices[f];l.push([g.name,C,S])}t.inputLayers=l;const u=[];for(let f=0;f<this.outputLayers.length;f++){const g=this.outputLayers[f],A=this.outputLayersNodeIndices[f],v=ic.nodeKey(g,A);if(!this.containerNodes.has(v))continue;let C=i[v];C==null&&(C=0);const S=this.outputLayersTensorIndices[f];u.push([g.name,C,S])}return t.outputLayers=u,t}static fromConfig(t,i,o={},l=!1){const u={},f={};function g(P,U){P.name in f?f[P.name].push(U):f[P.name]=[U]}function A(P,U){const V=[];let $;for(const q of U){const ne=q[0],he=q[1],me=q[2];if($=q[3]==null?{}:q[3],!(ne in u)){g(P,U);return}const pe=u[ne];if(pe.inboundNodes.length<=he){g(P,U);return}const ye=pe.inboundNodes[he];V.push(ye.outputTensors[me])}V.length>0&&P.apply(Xa(V),$)}function v(P){const U=P.name,V=sh(P,i.customObjects!=null?i.customObjects:{});V.setFastWeightInitDuringBuild(l),u[U]=V,P.inboundNodes.forEach($=>{if(!($ instanceof Array))throw new Ue(`Corrupted configuration, expected array for nodeData: ${$}`);g(V,$)})}const C=i.name,S=i.layers;for(const P of S)v(P);for(;!UX(f);)for(const P of S){const U=u[P.name];if(U.name in f){const V=f[U.name];delete f[U.name];for(const $ of V)A(U,$)}}const M=[],_=[],B=i.inputLayers;for(const P of B){const U=P[0],V=P[1],$=P[2];ru(U in u);const q=u[U].inboundNodes[V].outputTensors;M.push(q[$])}const F=i.outputLayers;for(const P of F){const U=P[0],V=P[1],$=P[2];ru(U in u);const q=u[U].inboundNodes[V].outputTensors;_.push(q[$])}return new t({inputs:M,outputs:_,name:C})}get stateful(){if(this._stateful)throw new Ue("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){$e(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function q9(s,t,i){const o=t.length;if(s==null||Array.isArray(s)&&s.length===0)return t.map(l=>null);if(o===1)return Array.isArray(s)&&s.length===1?s:typeof s=="object"&&t[0]in s?[s[t[0]]]:[s];if(Array.isArray(s)){if(s.length!==o)throw new Error(`Provided ${i} is an array of ${s.length} element(s), but the model has ${o} outputs. Make sure a set of weights is provided for each model output.`);return s}else if(typeof s=="object"&&Object.keys(s).length>0&&typeof s[Object.keys(s)[0]]=="object"){const l=[];return t.forEach(u=>{u in s?l.push(s[u]):l.push(null)}),l}else throw new Error(`The model has multiple (${o}) outputs, so ${i} must be either an array with ${o} elements or an object with ${t} keys. Provided ${i} not understood: ${JSON.stringify(s)}`)}function SL(s,t){return q9(s,t,"classWeight")}async function IL(s,t,i,o){if(i!=null){const l=$e(()=>{if(s.shape.length===1)return Ul(s);if(s.shape.length===2){if(s.shape[1]>1)return td(s,1);if(s.shape[1]===1)return He(s,[s.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${s.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${s.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),u=Array.from(await l.data());ci(l);const f=[];return u.forEach(g=>{if(i[g]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${g} exists in the data but not in classWeight`);f.push(i[g])}),T(f,"float32")}else return null}function J9(s,t){return Oe(s,t)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/const e4=32;function TL(s,t){let i,o;const l=t;i=l.xs,o=l.ys,E(i!=null&&o!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const u=ML("input",s.inputNames,i),f=ML("output",s.outputNames,o),g=u[0].shape[0];E(u.length===s.inputs.length,()=>`LayersModel has ${s.inputs.length} inputs, but the dataset provides ${u.length} inputs.  (Expected input keys: ${JSON.stringify(s.inputNames)})`),E(f.length===s.outputs.length,()=>`LayersModel has ${s.outputs.length} outputs, but the dataset provides ${f.length} outputs.  (Expected output keys: ${JSON.stringify(s.outputNames)})`);for(let A=0;A<u.length;A++)E(u[A].shape[0]===g,()=>`Batch size mismatch: input ${s.inputNames[A]} has ${u[A].shape[0]}; expected  ${g} based on input ${s.inputNames[0]}.`);for(let A=0;A<f.length;A++)E(f[A].shape[0]===g,()=>`Batch size mismatch: output ${s.outputNames[A]} has ${f[A].shape[0]}; expected  ${g} based on input ${s.inputNames[0]}.`);return{xs:u,ys:f}}function ML(s,t,i){if(i instanceof Ci)return[i];if(Array.isArray(i))return E(i.length===t.length,()=>`Received an array of ${i.length} Tensors, but expected ${t.length} to match the ${s} keys ${t}.`),i;{const o=[];for(const l of t){if(i[l]==null)throw new Ue(`The feature data generated by the dataset lacks the required ${s} key '${l}'.`);o.push(i[l])}return o}}function t4(s){if(s.length===3)throw new hi("Validation with sample weights is not implemented yet.");return{xs:s[0],ys:s[1]}}async function n4(s,t,i){const o=i.batchesPerEpoch!=null;if(E(s.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),E(i!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),E(i.epochs!=null&&i.epochs>0&&Number.isInteger(i.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${i.epochs}`),E(!o||i.batchesPerEpoch>0&&Number.isInteger(i.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${i.batchesPerEpoch}`),E(i.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),s.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");s.isTraining=!0;try{const l=i.validationData!=null;let u,f;if(l)if(_L(i.validationData))E(i.validationBatches==null||i.validationBatches>0&&Number.isInteger(i.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${i.validationBatches}`);else{const P=t4(i.validationData);u=P.xs,f=P.ys}const g=s.makeTrainFunction(),A=s.getDedupedMetricsNames();let v;l?v=A.slice().concat(A.map(P=>"val_"+P)):v=A.slice();const C=pL(i.callbacks,i.yieldEvery),S=i.verbose==null?1:i.verbose,{callbackList:M,history:_}=mL(C,S,i.epochs,null,null,i4(t,i),null,l,v);M.setModel(s),s.history=_,await M.onTrainBegin(),s.stopTraining_=!1;let B=i.initialEpoch==null?0:i.initialEpoch,F=await t.iterator();for(;B<i.epochs;){const P={};await M.onEpochBegin(B);let U=0,V=0;for(o||(F=await t.iterator());!o||U<i.batchesPerEpoch;){const $=await F.next();if(o&&$.done){console.warn(`You provided \`batchesPerEpoch\` as ${i.batchesPerEpoch}, but your dataset iterator ran out of data after ${U} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${i.batchesPerEpoch*i.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if($.value!=null){const{xs:q,ys:ne}=TL(s,$.value),he={};he.batch=V,he.size=q[0].shape[0],await M.onBatchBegin(V,he);const me=[];if(i.classWeight!=null){const Te=SL(i.classWeight,s.outputNames);for(let Ye=0;Ye<Te.length;++Ye)me.push(await IL(ne[Ye],null,Te[Ye]))}const pe=q.concat(ne).concat(me),ye=g(pe);ci(pe);for(let Te=0;Te<A.length;++Te){const Ye=A[Te],et=ye[Te];he[Ye]=et,ca(et)}await M.onBatchEnd(V,he),dL(he),V++,U++}if(o?U>=i.batchesPerEpoch:$.done){if(l){let q;_L(i.validationData)?q=Is(await s.evaluateDataset(i.validationData,{batches:i.validationBatches})):q=Is(s.evaluate(u,f,{batchSize:i.validationBatchSize==null?e4:i.validationBatchSize,verbose:0}));for(let ne=0;ne<s.metricsNames.length;++ne)P[`val_${s.metricsNames[ne]}`]=q[ne]}break}if(s.stopTraining_)break}if(await M.onEpochEnd(B,P),B++,s.stopTraining_)break}return await M.onTrainEnd(),await s.history.syncData(),s.history}finally{s.isTraining=!1}}function i4(s,t){let i=null;return t.batchesPerEpoch!=null?i=t.batchesPerEpoch:Number.isFinite(s.size)&&(i=s.size),i}function _L(s){return typeof s.iterator=="function"}function s4(s){return typeof s.next=="function"}async function r4(s,t,i){i=i||{};const o=i.batches!=null,l=s.testFunction;let u=[];if(i.verbose>0)throw new hi("Verbose mode is not implemented yet.");E(!o||i.batches>0&&Number.isInteger(i.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(i.batches)}`);const f=s4(t)?t:await t.iterator();let g=0,A=0;for(;!o||A<i.batches;){const v=await f.next();if(u=$e(()=>{if(v.value){const{xs:C,ys:S}=TL(s,v.value),M=C.concat(S),_=$e(()=>l(M));if(ci(M),A===0)for(let F=0;F<_.length;++F)u.push(Ni(0));const B=M[0].shape[0];for(let F=0;F<_.length;++F){const P=_[F],U=u[F];u[F]=$e(()=>Ut(u[F],Oe(B,P))),A>0&&ci(U)}ci(_),g+=B,++A}return u}),v.done){o&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${i.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let v=0;v<u.length;++v){const C=u[v];u[v]=En(u[v],g),ci(C)}return Xa(u)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function hT(s){E(s>0&&Number.isInteger(s),()=>`batchSize is required to be a positive integer, but got ${s}`)}function ny(s,t,i){return s==null?[null]:Array.isArray(s)?s.map(o=>Dp(o,t,i-t)):Dp(s,t,i-t)}function dT(s,t){return $e(()=>s==null?null:Array.isArray(s)?s.map(i=>dT(i,t)):QB(s,t.dtype==="int32"?t:hn(t,"int32")))}function fT(s,t){const i=[];let o=0,l=null;for(;o<s;)l=o+t,l>=s&&(l=s),i.push([o,l]),o=l;return i}async function a4(s,t,i,o,l,u,f,g,A,v,C,S,M,_,B){l==null&&(l=32),u==null&&(u=1),C==null&&(C=!0),M==null&&(M=0);let F=!1;A!=null&&v!=null&&(F=!0),B!=null;const P=s.checkNumSamples(i,l,_,"steps_per_epoch");let U;P!=null&&(U=ec(0,P)),f==null&&(f=1);const{callbackList:V,history:$}=mL(g,f,u,M,P,_,l,F,S);V.setModel(s),s.history=$,await V.onTrainBegin(),s.stopTraining_=!1;for(let q=M;q<u;++q){await V.onEpochBegin(q);const ne={};{if(C==="batch")throw new hi("batch shuffling is not implemneted yet");C&&p(U);const he=T(U),me=fT(P,l);for(let pe=0;pe<me.length;++pe){const ye={};if(await V.onBatchBegin(pe,ye),$e(()=>{const Te=me[pe][0],Ye=me[pe][1],et=Dp(he,Te,Ye-Te);ye.batch=pe,ye.size=Ye-Te;const nt=dT(i,et),ht=t(nt);for(let ct=0;ct<o.length;++ct){const pt=o[ct],Et=ht[ct];ye[pt]=Et,ca(Et)}if(pe===me.length-1&&F){const ct=s.testLoop(A,v,l);for(let pt=0;pt<o.length;++pt){const Et=o[pt],yt=ct[pt];ca(yt),ne["val_"+Et]=yt}}}),await V.onBatchEnd(pe,ye),dL(ye),s.stopTraining_)break}he.dispose()}if(await V.onEpochEnd(q,ne),s.stopTraining_)break}return await V.onTrainEnd(),await s.history.syncData(),s.history}async function o4(s,t,i,o={}){if(s.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");s.isTraining=!0;let l,u,f,g,A,v,C,S,M;try{const _=o.batchSize==null?32:o.batchSize;hT(_);const B=!1,F=await s.standardizeUserData(t,i,o.sampleWeight,o.classWeight,B,_);l=F[0],u=F[1],M=F[2];let P=!1,U;if(o.validationData!=null&&o.validationData.length>0){if(P=!0,o.validationData.length===2)A=o.validationData[0],v=o.validationData[1];else throw o.validationData.length===3?new hi("validationData including sample weights is not supported yet."):new Ue(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${o.validationData} is invalid.`);const pe=!0,ye=await s.standardizeUserData(A,v,null,null,pe,_);C=ye[0],S=ye[1],U=C.concat(S)}else if(o.validationSplit!=null&&o.validationSplit>0&&o.validationSplit<1){P=!0;const pe=Math.floor(l[0].shape[0]*(1-o.validationSplit)),ye=l[0].shape[0];C=ny(l,pe,ye),f=l,l=ny(l,0,pe),S=ny(u,pe,ye),g=u,u=ny(u,0,pe),U=C.concat(S)}else o.validationSteps!=null&&(P=!0);const V=l.concat(u).concat(M);s.checkTrainableWeightsConsistency();const $=s.makeTrainFunction(),q=s.getDedupedMetricsNames();let ne,he;P?(s.makeTestFunction(),ne=s.testFunction,he=q.slice().concat(q.map(pe=>"val_"+pe))):(ne=null,U=[],he=q.slice());const me=pL(o.callbacks,o.yieldEvery);return await a4(s,$,V,q,_,o.epochs,o.verbose,me,ne,U,o.shuffle,he,o.initialEpoch,null,null)}finally{s.isTraining=!1,sc(l,t),sc(u,i),sc(f,t),sc(g,i),sc(C,A),sc(S,v),M!=null&&ci(M)}}function RL(s){const t=[];s instanceof Ci&&(s=[s]);for(let i=0;i<s.length;++i){const o=s[i];if(o.rank===1)t.push(Zb(o,1));else{if(o.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(o)}}return t}function sc(s,t){if(s==null)return;const i=[];if(t instanceof Ci)i.push(t.id);else if(Array.isArray(t))t.forEach(l=>i.push(l.id));else if(t!=null)for(const l in t){const u=t[l];i.push(u.id)}const o=[];if(s instanceof Ci)i.indexOf(s.id)===-1&&o.push(s);else if(Array.isArray(s))s.forEach(l=>{i.indexOf(l.id)===-1&&o.push(l)});else if(s!=null)for(const l in s){const u=s[l];i.indexOf(u.id)===-1&&o.push(u)}o.forEach(l=>{l.isDisposed||l.dispose()})}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function l4(s){return s instanceof Ci}function pT(s){return Array.isArray(s)}function kL(s){return!l4(s)&&!pT(s)}function BL(s,t,i,o=!0,l=""){if(t==null||t.length===0){if(s!=null){let f=!1;if(pT(s)&&s.length>0)f=!0;else if(kL(s)){for(const g in s)if(s.hasOwnProperty(g)){f=!0;break}}else f=!0;if(f)throw new Ue(`Error when checking model ${l} expected no data, but got ${s}`)}return[]}if(s==null)return t.map(f=>null);let u;if(kL(s)){s=s,u=[];for(const f of t){if(s[f]==null)throw new Ue(`No data provided for "${f}". Need data for each key in: ${t}`);u.push(s[f])}}else if(pT(s)){if(s=s,s.length!==t.length)throw new Ue(`Error when checking model ${l}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${s}`);u=s}else{if(s=s,t.length>1)throw new Ue(`The model ${l} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${s.shape}`);u=[s]}if(u=RL(u),i!=null)for(let f=0;f<t.length;++f){if(i[f]==null)continue;const g=u[f];if(g.shape.length!==i[f].length)throw new Ue(`Error when checking ${l}: expected ${t[f]} to have ${i[f].length} dimension(s). but got array with shape ${g.shape}`);for(let A=0;A<i[f].length;++A){if(A===0&&!o)continue;const v=g.shape[A],C=i[f][A];if(C!=null&&C>=0&&v!==C)throw new Ue(`${l} expected a batch of elements where each example has shape [${i[f].slice(1,i[f].length)}] (i.e.,tensor shape [*,${i[f].slice(1,i[f].length)}]) but the ${l} received an input with ${g.shape[0]} examples, each with shape [${g.shape.slice(1,g.shape.length)}] (tensor shape [${g.shape}])`)}}return u}function c4(s,t,i){const o=Ed(s.map(u=>u.shape[0]));o.sort();const l=Ed(t.map(u=>u.shape[0]));if(l.sort(),o.length>1)throw new Ue(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(s.map(u=>u.shape))}`);if(l.length>1)throw new Ue(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(u=>u.shape))}`);if(o.length>0&&l.length>0&&!O(o,l))throw new Ue(`Input Tensors should have the same number of samples as target Tensors. Found ${o[0]} input sample(s) and ${l[0]} target sample(s).`)}function u4(s,t,i){const o=[tw,iw,ty];for(let l=0;l<s.length;++l){const u=s[l],f=t[l],g=i[l];if(f!=null){if(f===ty&&u.shape[u.shape.length-1]===1)throw new Ue(`You are passing a target array of shape ${u.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(o.indexOf(f)!==-1){const A=u.shape.slice(1),v=g.slice(1);for(let C=0;C<A.length;++C){const S=A[C],M=v[C];if(M!=null&&S!==M)throw new Ue(`A target Tensor with shape ${u.shape} was passed for an output of shape ${g}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function LL(s,t,i,o=!0,l=""){let u;if(Array.isArray(s)){if(s.length!==t.length)throw new Ue(`Error when checking model ${l}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${s.length} Tensors(s).`);u=s}else{if(t.length>1)throw new Ue(`The model expects ${t.length} ${l} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(s.shape)}.`);u=[s]}if(i!=null)for(let f=0;f<t.length;++f){if(i[f]==null)continue;const g=u[f];if(g.shape.length!==i[f].length)throw new Ue(`Error when checking ${l}: expected ${t[f]} to have ${i[f].length} dimension(s), but got array with shape ${JSON.stringify(g.shape)}`);for(let A=0;A<i[f].length;++A){if(A===0&&!o)continue;const v=g.shape[A],C=i[f][A];if(C!=null&&C!==v)throw new Ue(`Error when checking ${l}: expected ${t[f]} to have shape ${JSON.stringify(i[f])} but got array with shape ${JSON.stringify(g.shape)}.`)}}}function h4(s,t){if(s==null||Array.isArray(s)&&s.length===0)return t.map(o=>[]);let i;if(typeof s=="string"||typeof s=="function")i=[s];else if(Array.isArray(s)||typeof s=="object")i=s;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${s}`);if(Array.isArray(i))return t.map(o=>i);{const o=[];for(const l of t){let u=i.hasOwnProperty(l)?i[l]:[];Array.isArray(u)||(u=[u]),o.push(u)}return o}}const d4="layers-model";class Yg extends ic{constructor(t){super(t),this.isTraining=!1}summary(t,i,o=console.log){if(!this.built)throw new Ue("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");K9(this,t,i,o)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=Q9(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Cd))throw new Ue("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let i=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const f in t.loss)if(this.outputNames.indexOf(f)===-1)throw new Ue(`Unknown entry in loss dictionary: "${f}". Only expected the following keys: ${this.outputNames}`);for(const f of this.outputNames)t.loss[f]==null&&console.warn(`Output "${f}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${f} during training`),i.push(oT(t.loss[f]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new Ue(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);i=t.loss.map(f=>oT(f))}else{const f=oT(t.loss);this.outputs.forEach(g=>{i.push(f)})}this.lossFunctions=i,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let f=0;f<this.outputs.length;++f){const g=this.internalOutputShapes[f],A=this.outputNames[f];this.feedOutputNames.push(A),this.feedOutputShapes.push(g),this.feedLossFns.push(this.lossFunctions[f])}const o=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Np("loss",()=>{for(let f=0;f<this.outputs.length;++f){if(o.indexOf(f)!==-1)continue;const g=this.lossFunctions[f];this.outputs.length>1&&(this.metricsTensors.push([g,f]),this.metricsNames.push(this.outputNames[f]+"_loss"))}});const l=h4(t.metrics,this.outputNames),u=(f,g,A)=>{this.outputNames.length>1&&(g=this.outputNames[f]+"_"+g),this.metricsNames.push(g),this.metricsTensors.push([A,f])};Np("metric",()=>{for(let f=0;f<this.outputs.length;++f){if(o.indexOf(f)!==-1)continue;const g=l[f];(A=>{let C,S,M;for(const _ of A){if(typeof _=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(_)!==-1){const F=this.internalOutputShapes[f];F[F.length-1]===1||this.lossFunctions[f]===iw?["accuracy","acc"].indexOf(_)!==-1?S=AL:["crossentropy","ce"].indexOf(_)!==-1&&(S=F9):this.lossFunctions[f]===nw?["accuracy","acc"].indexOf(_)!==-1?S=O9:["crossentropy","ce"].indexOf(_)!==-1&&(S=vL):["accuracy","acc"].indexOf(_)!==-1?S=bL:["crossentropy","ce"].indexOf(_)!==-1&&(S=yL);let P;["accuracy","acc"].indexOf(_)!==-1?P="acc":["crossentropy","ce"].indexOf(_)!==-1&&(P="ce"),M=S,C=""+P}else M=X9(_),C=""+aw(_);let B;Np(C,()=>{B=M}),u(f,C,B)}})(g)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,i,o={}){const l=o.batchSize==null?32:o.batchSize;hT(l);const u=!0,f=this.standardizeUserDataXY(t,i,u,l);try{const g=f[0].concat(f[1]);this.makeTestFunction();const A=this.testFunction,v=this.testLoop(A,g,l,o.verbose,o.steps);return Xa(v)}finally{sc(f[0],t),sc(f[1],i)}}async evaluateDataset(t,i){return this.makeTestFunction(),r4(this,t,i)}checkNumSamples(t,i,o,l="steps"){let u;if(o!=null){if(u=null,i!=null)throw new Ue(`If ${l} is set, batchSize must be null or undefined.Got batchSize = ${i}`)}else if(t!=null)Array.isArray(t)?u=t[0].shape[0]:u=t.shape[0];else throw new Ue(`Either the input data should have a defined shape, or ${l} shoud be specified.`);return u}execute(t,i){if(Array.isArray(i)&&i.length===0)throw new Ue("`outputs` is an empty Array, which is not allowed.");const o=Array.isArray(i),l=o?i:[i],u=this.retrieveSymbolicTensors(l),f=new Td;if(t instanceof Ci&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new Ue(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let A=0;A<this.inputs.length;++A)f.add(this.inputs[A],t[A])}else for(const A of this.inputs){const v=t[A.name];if(v==null)throw new Ue(`No value is provided for the model's input ${A.name}`);f.add(A,v)}const g=qb(u,f);return o?g:g[0]}retrieveSymbolicTensors(t){const i=kp(null,t.length);let o=t.length;for(const l of this.layers){const u=Array.isArray(l.output)?l.output:[l.output],f=u.map(g=>g.name);for(let g=0;g<t.length;++g){const A=f.indexOf(t[g]);if(A!==-1&&(i[g]=u[A],o--),o===0)break}if(o===0)break}if(o>0){const l=[];throw i.forEach((u,f)=>{u==null&&l.push(t[f])}),new Ue(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(l)}`)}return i}predictLoop(t,i=32,o=!1){return $e(()=>{const l=this.checkNumSamples(t);if(o)throw new hi("Verbose predictLoop() is not implemented yet.");const u=fT(l,i),f=this.outputs.map(g=>[]);for(let g=0;g<u.length;++g)$e(()=>{const A=u[g][0],v=u[g][1],C=ny(t,A,v),S=[];if(Array.isArray(C))for(let _=0;_<C.length;++_)S.push({key:this.inputs[_],value:C[_]});else S.push({key:this.inputs[0],value:C});const M=new Td(S);return qb(this.outputs,M)}).forEach((A,v)=>f[v].push(A));return Xa(f.map(g=>yi(g,0)))})}predict(t,i={}){const o=RL(t);LL(o,this.inputNames,this.feedInputShapes,!1);try{const l=i.batchSize==null?32:i.batchSize;return hT(l),this.predictLoop(o,l)}finally{sc(o,t)}}predictOnBatch(t){LL(t,this.inputNames,this.feedInputShapes,!0);const i=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,i)}standardizeUserDataXY(t,i,o=!0,l){if(this.optimizer_==null)throw new yl("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const u=[];for(let f=0;f<this.feedOutputShapes.length;++f){const g=this.feedOutputShapes[f];this.feedLossFns[f]===nw?u.push(g.slice(0,g.length-1).concat([1])):u.push(g)}if(t=BL(t,this.feedInputNames,this.feedInputShapes,!1,"input"),i=BL(i,this.feedOutputNames,u,!1,"target"),c4(t,i),u4(i,this.feedLossFns,this.feedOutputShapes),this.stateful&&l!=null&&l>0&&t[0].shape[0]%l!==0)throw new Ue(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${l}. Found: ${t[0].shape[0]} sample(s).`);return[t,i]}async standardizeUserData(t,i,o,l,u=!0,f){const[g,A]=this.standardizeUserDataXY(t,i,u,f);if(o!=null)throw new Error("sample weight is not supported yet.");let v=null;if(l!=null){const C=SL(l,this.outputNames);v=[];for(let S=0;S<C.length;++S)v.push(await IL(A[S],null,C[S]))}return[g,A,v]}testLoop(t,i,o,l=0,u){return $e(()=>{const f=this.checkNumSamples(i,o,u,"steps"),g=[];if(l>0)throw new hi("Verbose mode is not implemented yet.");if(u!=null)throw new hi("steps mode in testLoop() is not implemented yet");{const A=fT(f,o),v=T(ec(0,f));for(let C=0;C<A.length;++C){const S=A[C][0],M=A[C][1],_=Dp(v,S,M-S),B=dT(i,_),F=t(B);if(C===0)for(let P=0;P<F.length;++P)g.push(Ni(0));for(let P=0;P<F.length;++P){const U=F[P];g[P]=Ut(g[P],Oe(M-S,U))}}for(let C=0;C<g.length;++C)g[C]=En(g[C],f)}return g})}getDedupedMetricsNames(){const t=this.metricsNames,i=[];for(let o=0;o<t.length;++o){const l=t[o];let u=l;if(FB(t,l)>1){const f=FB(t.slice(0,o),l);u+=`_${f}`}i.push(u)}return i}makeTrainFunction(){return t=>{const i=[],o=t.slice(0,this.inputs.length),l=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),u=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),f=[],g=()=>{const C=[];for(let B=0;B<this.inputs.length;++B)C.push({key:this.inputs[B],value:o[B]});const S=new Td(C),M=qb(this.outputs,S,{training:!0});let _;for(let B=0;B<this.lossFunctions.length;++B){const F=this.lossFunctions[B];let P=F(l[B],M[B]);u[B]!=null&&(P=J9(P,u[B]));const U=Hn(P);i.push(U),B===0?_=P:_=Ut(_,P)}for(let B=0;B<this.metricsTensors.length;++B){let F;if(this.outputs.length>1&&B<this.outputs.length)F=i[B];else{const P=this.metricsTensors[B][0],U=this.metricsTensors[B][1];F=Hn(P(l[U],M[U]))}ca(F),f.push(F)}return _=Hn(_),this.calculateLosses().forEach(B=>{_=Ut(_,B)}),_},A=this.collectedTrainableWeights.map(C=>C.read());return[this.optimizer_.minimize(g,!0,A)].concat(f)}}makeTestFunction(){this.testFunction=t=>$e(()=>{const i=[];let o;const l=t.slice(0,this.inputs.length),u=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),f=[];for(let v=0;v<this.inputs.length;++v)f.push({key:this.inputs[v],value:l[v]});const g=new Td(f),A=qb(this.outputs,g);for(let v=0;v<this.lossFunctions.length;++v){const C=this.lossFunctions[v],S=Hn(C(u[v],A[v]));v===0?o=S:o=Ut(o,S),i.push(o)}for(let v=0;v<this.metricsTensors.length;++v){const C=this.metricsTensors[v][0],S=this.metricsTensors[v][1],M=Hn(C(u[S],A[S]));i.push(M)}return i})}async fit(t,i,o={}){return o4(this,t,i,o)}async fitDataset(t,i){return n4(this,t,i)}async trainOnBatch(t,i){const o=await this.standardizeUserData(t,i),l=o[0],u=o[1],f=this.makeTrainFunction()(l.concat(u)),g=[];for(const A of f){const v=await A.data();g.push(v[0])}return ci(f),sc(o[0],t),sc(o[1],i),Xa(g)}getNamedWeights(t){const i=[],o=t!=null&&t.trainableOnly,l=o?this.trainableWeights:this.weights,u=this.getWeights(o);for(let f=0;f<l.length;++f)o&&!l[f].trainable||i.push({name:l[f].originalName,tensor:u[f]});return i}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const i=cg().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=i-cg().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=ih(this.loss);else if(Array.isArray(this.loss)){for(const i of this.loss)if(typeof i!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(i=>ih(i))}else{const i=Object.keys(this.loss);t={};const o=this.loss;for(const l of i)if(typeof o[l]=="string")t[l]=ih(o[l]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ih(aw(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>ih(aw(t)));{const t={};for(const i in this.metrics)t[i]=ih(aw(this.metrics[i]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const i=cT(t.optimizer_config),o=sh(i);let l;if(typeof t.loss=="string")l=Bp(t.loss);else if(Array.isArray(t.loss))l=t.loss.map(f=>Bp(f));else if(t.loss!=null){l={};for(const f in t.loss)l[f]=Bp(t.loss[f])}let u;if(Array.isArray(t.metrics))u=t.metrics.map(f=>Bp(f));else if(t.metrics!=null){u={};for(const f in t.metrics)u[f]=Bp(t.metrics[f])}this.compile({loss:l,metrics:u,optimizer:o})}async save(t,i){if(typeof t=="string"){const g=HA(t);if(g.length===0)throw new Ue(`Cannot find any save handlers for URL '${t}'`);if(g.length>1)throw new Ue(`Found more than one (${g.length}) save handlers for URL '${t}'`);t=g[0]}if(t.save==null)throw new Ue("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const o=await ng(this.getNamedWeights(i)),l=!1,u=null,f={modelTopology:this.toJSON(u,l),format:d4,generatedBy:`TensorFlow.js tfjs-layers v${EL}`,convertedBy:null};if(i!=null&&i.includeOptimizer&&this.optimizer!=null){f.trainingConfig=this.getTrainingConfig();const g="optimizer",{data:A,specs:v}=await ng(await this.optimizer.getWeights(),g);o.specs.push(...v),o.data=ig([o.data,A])}return this.userDefinedMetadata!=null&&(wL(this.userDefinedMetadata,this.name,!0),f.userDefinedMetadata=this.userDefinedMetadata),f.weightData=o.data,f.weightSpecs=o.specs,t.save(f)}setUserDefinedMetadata(t){wL(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Yg.className="Model",Lt(Yg);class NL extends Yg{}NL.className="Functional",Lt(NL);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class iy extends Yg{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:Q1("sequential_"),t.layers!=null)for(const i of t.layers)this.add(i)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(i=>i<0))throw new Ue(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const i=t instanceof iy||t instanceof Yg;let o;if(i){if(o=t,o.outputs.length!==1)throw new Ue("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(o.inputs.length!==1)throw new Ue("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new Ue("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const l=p9({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(l)}if(i)this.outputs=o.outputs,this.inputs=o.inputs;else{if(t.inboundNodes.length!==1)throw new Ue(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new Ue("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=sL(this.outputs[0])}this.inboundNodes=[],new j1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:kp(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(l=>l.shape),outputShapes:this.outputs[0].shape})}else{const l=t.apply(this.outputs[0]);if(Array.isArray(l))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[l],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,i){return this.model==null&&this.build(),this.model.call(t,i)}build(t){if(ns(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Yg({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,i,o=console.log){this.built||this.build(),super.summary(t,i,o)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,i,o={}){if(!this.built)throw new yl("The model needs to be compiled before being used.");return this.model.evaluate(t,i,o)}async evaluateDataset(t,i){if(!this.built)throw new yl("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,i)}predict(t,i={}){return this.model==null&&this.build(),this.model.predict(t,i)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,i,o={}){if(!this.built)throw new yl("The model needs to be compiled before being used.");return this.model.fit(t,i,o)}async fitDataset(t,i){if(!this.built)throw new yl("The model needs to be compiled before being used.");return this.model.fitDataset(t,i)}async trainOnBatch(t,i){return this.model.trainOnBatch(t,i)}static fromConfig(t,i,o={},l=!1){let u,f={};if(i instanceof Array){if(i[0].className==null||i[0].className==="Merge")throw new Ue("Legacy serialization format not supported yet.");u=i}else E(i.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),u=i.layers,delete i.layers,f=i;const g=new t(f);if(!(g instanceof iy))throw new hi(`Sequential.fromConfig called on non-Sequential input: ${g}`);for(const A of u){const v=sh(A,void 0,l);l&&v.setFastWeightInitDuringBuild(!0),g.add(v)}return g}set stopTraining(t){if(this.model==null)throw new Ue("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new Ue("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const i of this.layers){const o={};o.className=i.getClassName(),o.config=i.getConfig(),t.push(o)}return{name:this.name,layers:t}}}iy.className="Sequential",Lt(iy);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/let Qa=class extends dl{getConfig(){return{}}};class DL extends Qa{apply(t,i=1){return e9(t,i)}}DL.className="elu",Lt(DL);class FL extends Qa{apply(t){return Fb(t)}}FL.className="selu",Lt(FL);class OL extends Qa{apply(t){return Wo(t)}}OL.className="relu",Lt(OL);class GL extends Qa{apply(t){return $e(()=>bp(6,Wo(t)))}}GL.className="relu6",Lt(GL);class UL extends Qa{apply(t){return t}}UL.className="linear",Lt(UL);class PL extends Qa{apply(t){return sd(t)}}PL.className="sigmoid",Lt(PL);class zL extends Qa{apply(t){return n9(t)}}zL.className="hardSigmoid",Lt(zL);class VL extends Qa{apply(t){return gd(t)}}VL.className="softplus",Lt(VL);class WL extends Qa{apply(t){return t9(t)}}WL.className="softsign",Lt(WL);class HL extends Qa{apply(t){return wg(t)}}HL.className="tanh",Lt(HL);let mT=class extends Qa{apply(s,t=-1){return eh(s,t)}};mT.className="softmax",Lt(mT);class XL extends Qa{apply(t,i=-1){return Ad(t,i)}}XL.className="logSoftmax",Lt(XL);class QL extends Qa{apply(t,i=1){return $e(()=>Oe(sd(Oe(t,i)),t))}}QL.className="swish",Lt(QL);class KL extends Qa{apply(t){return $e(()=>Oe(t,wg(gd(t))))}}KL.className="mish",Lt(KL);function Md(s){return s.getClassName()}function gT(s,t={}){return Xb(s,Yr.getMap().classNameMap,t,"activation")}function _d(s){if(s==null){const t={};return t.className="linear",t.config={},gT(t)}if(typeof s=="string"){const t={};return t.className=s,t.config={},gT(t)}else return s instanceof Qa?s:gT(s)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function f4(s){if(s!=null&&typeof s!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${s}`)}class ZL extends dl{}class $L extends ZL{constructor(t){super(),f4(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return $e(()=>{let i=Zs([1]);return this.hasL1&&(i=Ut(i,wn(Oe(this.l1,Ri(t))))),this.hasL2&&(i=Ut(i,wn(Oe(this.l2,$b(t))))),He(i,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,i){return new t({l1:i.l1,l2:i.l2})}}$L.className="L1L2",Lt($L);const YL={l1l2:"L1L2"};function ms(s){return PI(s)}function jL(s,t={}){return Xb(s,Yr.getMap().classNameMap,t,"regularizer")}function Ls(s){if(s==null)return null;if(typeof s=="string"){const t={className:s in YL?YL[s]:s,config:{}};return jL(t)}else return s instanceof ZL?s:jL(s)}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class qL extends Bi{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,i){t=ti(t);let o=Wo(t);return this.maxValue!=null&&(o=fs(o,0,this.maxValue)),o}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},i=super.getConfig();return Object.assign(t,i),t}}qL.className="ReLU",Lt(qL);class JL extends Bi{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,i){const o=ti(t);return pp(o,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},i=super.getConfig();return Object.assign(t,i),t}}JL.className="LeakyReLU",Lt(JL);class eN extends Bi{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Bs(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ls(t.alphaRegularizer),this.alphaConstraint=vr(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new Ue(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=ns(t);const i=t.slice(1);if(this.sharedAxes!=null)for(const l of this.sharedAxes)i[l-1]=1;this.alpha=this.addWeight("alpha",i,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const o={};if(this.sharedAxes!=null)for(let l=1;l<t.length;++l)o[l]=t[l];this.inputSpec=[new br({ndim:t.length,axes:o})],this.built=!0}call(t,i){return t=ti(t),Ha(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Ps(this.alphaInitializer),alphaRegularizer:ms(this.alphaRegularizer),alphaConstraint:yr(this.alphaConstraint),sharedAxes:this.sharedAxes},i=super.getConfig();return Object.assign(t,i),t}}eN.className="PReLU",Lt(eN);let tN=class extends Bi{constructor(s){if(super(s??{}),this.DEFAULT_ALPHA=1,s==null&&(s={}),s.alpha!=null&&s.alpha!==this.DEFAULT_ALPHA)throw new hi(`Non-default alpha value (${s.alpha}) is not supported by the ELU layer yet.`);this.alpha=s.alpha==null?this.DEFAULT_ALPHA:s.alpha}call(s,t){const i=ti(s);return hd(i)}computeOutputShape(s){return s}getConfig(){const s={alpha:this.alpha},t=super.getConfig();return Object.assign(s,t),s}};tN.className="ELU",Lt(tN);class nN extends Bi{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,i){const o=ti(t);return Oe(o,hn(Va(o,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},i=super.getConfig();return Object.assign(t,i),t}}nN.className="ThresholdedReLU",Lt(nN);class iN extends Bi{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new mT().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,i){const o=ti(t);return this.softmax(o,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},i=super.getConfig();return Object.assign(t,i),t}}iN.className="Softmax",Lt(iN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function jg(s,t,i){if(typeof s=="number")return kp(s,t);if(s.length!==t)throw new Ue(`The ${i} argument must be an integer or tuple of ${t} integers. Received: ${s.length} elements.`);for(let o=0;o<t;++o){const l=s[o];if(!YX(l))throw new Ue(`The ${i} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(s)} including a non-integer number ${l}`)}return s}function rc(s,t,i,o,l=1){if(s==null)return s;const u=t+(t-1)*(l-1);let f;return i==="same"?f=s:f=s-u+1,Math.floor((f+o-1)/o)}function lu(s,t,i,o){if(s==null)return null;if(o==="valid")s=s*t+Id([i-t,0]);else if(o==="same")s=s*t;else throw new Ue(`Unsupport padding mode: ${o}.`);return s}/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function AT(s,t){return $e(()=>(er(t),t==="channelsFirst"?bi(s,[0,2,3,1]):s))}function sN(s,t){return $e(()=>(er(t),t==="channelsFirst"?bi(s,[0,2,3,4,1]):s))}function p4(s,t,i,o=1,l="valid",u,f=1){return $e(()=>{if(u==null&&(u=tc()),er(u),s.shape.length!==3)throw new Ue(`The input of a conv1dWithBias operation should be 3, but is ${s.shape.length} instead.`);if(t.shape.length!==3)throw new Ue(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(i!=null&&i.shape.length!==1)throw new Ue(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(u==="channelsFirst"&&(s=bi(s,[0,2,1])),l==="causal")throw new hi("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let g=Hc(s,t,o,l==="same"?"same":"valid","NWC",f);return i!=null&&(g=nc(g,i)),g})}function rN(s,t,i,o=[1,1],l="valid",u,f,g=null){return $e(()=>{if(u==null&&(u=tc()),er(u),s.rank!==3&&s.rank!==4)throw new Ue(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${s.rank}.`);if(t.rank!==3&&t.rank!==4)throw new Ue(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${s.rank}.`);let A=AT(s,u);if(l==="causal")throw new hi("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return A=nu({x:A,filter:t,strides:o,pad:l==="same"?"same":"valid",dilations:f,dataFormat:"NHWC",bias:i,activation:g}),u==="channelsFirst"&&(A=bi(A,[0,3,1,2])),A})}function m4(s,t,i,o=[1,1,1],l="valid",u,f){return $e(()=>{if(u==null&&(u=tc()),er(u),s.rank!==4&&s.rank!==5)throw new Ue(`conv3dWithBias expects input to be of rank 4 or 5, but received ${s.rank}.`);if(t.rank!==4&&t.rank!==5)throw new Ue(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${s.rank}.`);let g=sN(s,u);if(l==="causal")throw new hi("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return g=ad(g,t,o,l==="same"?"same":"valid","NDHWC",f),i!=null&&(g=nc(g,i)),u==="channelsFirst"&&(g=bi(g,[0,4,1,2,3])),g})}class lw extends Bi{constructor(t,i){if(super(i),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",lw.verifyArgs(i),this.rank=t,_r(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new hi(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=jg(i.kernelSize,t,"kernelSize"),this.strides=jg(i.strides==null?1:i.strides,t,"strides"),this.padding=i.padding==null?"valid":i.padding,Qo(this.padding),this.dataFormat=i.dataFormat==null?"channelsLast":i.dataFormat,er(this.dataFormat),this.activation=_d(i.activation),this.useBias=i.useBias==null?!0:i.useBias,this.biasInitializer=Bs(i.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=vr(i.biasConstraint),this.biasRegularizer=Ls(i.biasRegularizer),this.activityRegularizer=Ls(i.activityRegularizer),this.dilationRate=jg(i.dilationRate==null?1:i.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Ue(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Ue(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Ue(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(ru("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!VI(t.kernelSize,"number",1,3))throw new Ue(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Md(this.activation),useBias:this.useBias,biasInitializer:Ps(this.biasInitializer),biasRegularizer:ms(this.biasRegularizer),activityRegularizer:ms(this.activityRegularizer),biasConstraint:yr(this.biasConstraint)},i=super.getConfig();return Object.assign(t,i),t}}class qg extends lw{constructor(t,i){super(t,i),this.kernel=null,qg.verifyArgs(i),this.filters=i.filters,_r(this.filters,"filters"),this.kernelInitializer=Bs(i.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=vr(i.kernelConstraint),this.kernelRegularizer=Ls(i.kernelRegularizer)}build(t){t=ns(t);const i=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[i]==null)throw new Ue(`The channel dimension of the input should be defined. Found ${t[i]}`);const o=t[i],l=this.kernelSize.concat([o,this.filters]);this.kernel=this.addWeight("kernel",l,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[i]:o}}],this.built=!0}call(t,i){return $e(()=>{t=ti(t);let o;const l=this.bias==null?null:this.bias.read(),u=GB(this.activation.getClassName());if(u!=null&&this.rank===2)o=rN(t,this.kernel.read(),l,this.strides,this.padding,this.dataFormat,this.dilationRate,u);else{if(this.rank===1)o=p4(t,this.kernel.read(),l,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)o=rN(t,this.kernel.read(),l,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)o=m4(t,this.kernel.read(),l,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new hi("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(o=this.activation.apply(o))}return o})}computeOutputShape(t){t=ns(t);const i=[],o=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let u=0;u<o.length;++u){const f=rc(o[u],this.kernelSize[u],this.padding,this.strides[u],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[u]);i.push(f)}let l=[t[0]];return this.dataFormat==="channelsLast"?(l=l.concat(i),l.push(this.filters)):(l.push(this.filters),l=l.concat(i)),l}getConfig(){const t={filters:this.filters,kernelInitializer:Ps(this.kernelInitializer),kernelRegularizer:ms(this.kernelRegularizer),kernelConstraint:yr(this.kernelConstraint)},i=super.getConfig();return Object.assign(t,i),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new Ue(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class sy extends qg{constructor(t){super(2,t),sy.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!VI(t.kernelSize,"number",1,2))throw new Ue(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}sy.className="Conv2D",Lt(sy);class ry extends qg{constructor(t){super(3,t),ry.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new Ue(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}ry.className="Conv3D",Lt(ry);class aN extends sy{constructor(t){if(super(t),this.inputSpec=[new br({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Ue(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=ns(t),t.length!==4)throw new Ue("Input should have rank 4; Received input shape: "+JSON.stringify(t));const i=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[i]==null)throw new Ue("The channel dimension of the inputs should be defined. Found `None`.");const o=t[i],l=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",l,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new br({ndim:4,axes:{[i]:o}})],this.built=!0}call(t,i){return $e(()=>{let o=ti(t);if(o.shape.length!==4)throw new Ue(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);const l=o.shape,u=l[0];let f,g;this.dataFormat==="channelsFirst"?(f=2,g=3):(f=1,g=2);const A=l[f],v=l[g],C=this.kernelSize[0],S=this.kernelSize[1],M=this.strides[0],_=this.strides[1],B=lu(A,M,C,this.padding),F=lu(v,_,S,this.padding),P=[u,B,F,this.filters];this.dataFormat!=="channelsLast"&&(o=bi(o,[0,2,3,1]));let U=Po(o,this.kernel.read(),P,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(U=bi(U,[0,3,1,2])),this.bias!=null&&(U=nc(U,this.bias.read(),this.dataFormat)),this.activation!=null&&(U=this.activation.apply(U)),U})}computeOutputShape(t){t=ns(t);const i=t.slice();let o,l,u;this.dataFormat==="channelsFirst"?(o=1,l=2,u=3):(o=3,l=1,u=2);const f=this.kernelSize[0],g=this.kernelSize[1],A=this.strides[0],v=this.strides[1];return i[o]=this.filters,i[l]=lu(i[l],A,f,this.padding),i[u]=lu(i[u],v,g,this.padding),i}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}aN.className="Conv2DTranspose",Lt(aN);class oN extends ry{constructor(t){if(super(t),this.inputSpec=[new br({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Ue(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=ns(t),t.length!==5)throw new Ue("Input should have rank 5; Received input shape: "+JSON.stringify(t));const i=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[i]==null)throw new Ue("The channel dimension of the inputs should be defined. Found `None`.");const o=t[i],l=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",l,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new br({ndim:5,axes:{[i]:o}})],this.built=!0}call(t,i){return $e(()=>{let o=ti(t);if(o.shape.length!==5)throw new Ue(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);const l=o.shape,u=l[0];let f,g,A;this.dataFormat==="channelsFirst"?(A=2,f=3,g=4):(A=1,f=2,g=3);const v=l[A],C=l[f],S=l[g],M=this.kernelSize[0],_=this.kernelSize[1],B=this.kernelSize[2],F=this.strides[0],P=this.strides[1],U=this.strides[2],V=lu(v,F,M,this.padding),$=lu(C,P,_,this.padding),q=lu(S,U,B,this.padding),ne=[u,V,$,q,this.filters];this.dataFormat!=="channelsLast"&&(o=bi(o,[0,2,3,4,1]));let he=qx(o,this.kernel.read(),ne,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(he=bi(he,[0,4,1,2,3])),this.bias!==null&&(he=nc(he,this.bias.read(),this.dataFormat)),this.activation!==null&&(he=this.activation.apply(he)),he})}computeOutputShape(t){t=ns(t);const i=t.slice();let o,l,u,f;this.dataFormat==="channelsFirst"?(o=1,l=2,u=3,f=4):(o=4,l=1,u=2,f=3);const g=this.kernelSize[0],A=this.kernelSize[1],v=this.kernelSize[2],C=this.strides[0],S=this.strides[1],M=this.strides[2];return i[o]=this.filters,i[l]=lu(i[l],C,g,this.padding),i[u]=lu(i[u],S,A,this.padding),i[f]=lu(i[f],M,v,this.padding),i}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}oN.className="Conv3DTranspose",Lt(oN);class lN extends qg{constructor(t,i){if(super(t,i),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,i.filters==null)throw new Ue("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(i.kernelInitializer!=null||i.kernelRegularizer!=null||i.kernelConstraint!=null)throw new Ue("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(i.padding!=null&&i.padding!=="same"&&i.padding!=="valid")throw new Ue(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(i.padding)}`);this.depthMultiplier=i.depthMultiplier==null?1:i.depthMultiplier,this.depthwiseInitializer=Bs(i.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ls(i.depthwiseRegularizer),this.depthwiseConstraint=vr(i.depthwiseConstraint),this.pointwiseInitializer=Bs(i.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ls(i.pointwiseRegularizer),this.pointwiseConstraint=vr(i.pointwiseConstraint)}build(t){if(t=ns(t),t.length<this.rank+2)throw new Ue(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const i=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[i]==null||t[i]<0)throw new Ue(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[i])}`);const o=t[i],l=this.kernelSize.concat([o,this.depthMultiplier]),u=[];for(let g=0;g<this.rank;++g)u.push(1);u.push(o*this.depthMultiplier,this.filters);const f=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",l,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,f,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",u,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,f,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,f,this.biasConstraint):this.bias=null,this.inputSpec=[new br({ndim:this.rank+2,axes:{[i]:o}})],this.built=!0}call(t,i){return $e(()=>{t=ti(t);let o;if(this.rank===1)throw new hi("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=bi(t,[0,2,3,1])),o=Ob(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(o=nc(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),this.dataFormat==="channelsFirst"&&(o=bi(o,[0,3,1,2])),o})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Ps(this.depthwiseInitializer),t.pointwiseInitializer=Ps(this.pointwiseInitializer),t.depthwiseRegularizer=ms(this.depthwiseRegularizer),t.pointwiseRegularizer=ms(this.pointwiseRegularizer),t.depthwiseConstraint=yr(this.depthwiseConstraint),t.pointwiseConstraint=yr(this.pointwiseConstraint),t}}lN.className="SeparableConv";class cN extends lN{constructor(t){super(2,t)}}cN.className="SeparableConv2D",Lt(cN);class cw extends qg{constructor(t){super(1,t),cw.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!VI(t.kernelSize,"number",1,1))throw new Ue(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}cw.className="Conv1D",Lt(cw);class uN extends Bi{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,i){return $e(()=>{if(t=ti(t),this.dataFormat==="channelsLast"){const o=K1(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return K1(o,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const o=K1(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return K1(o,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(t,i),t}}uN.className="Cropping2D",Lt(uN);class hN extends Bi{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,er(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,KX(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const i=t[2]==null?null:this.size[0]*t[2],o=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],i,o]}else{const i=t[1]==null?null:this.size[0]*t[1],o=t[2]==null?null:this.size[1]*t[2];return[t[0],i,o,t[3]]}}call(t,i){return $e(()=>{let o=ti(t);const l=o.shape;if(this.dataFormat==="channelsFirst"){o=bi(o,[0,2,3,1]);const u=this.size[0]*l[2],f=this.size[1]*l[3],g=this.interpolation==="nearest"?G1.resizeNearestNeighbor(o,[u,f]):G1.resizeBilinear(o,[u,f]);return bi(g,[0,3,1,2])}else{const u=this.size[0]*l[1],f=this.size[1]*l[2];return this.interpolation==="nearest"?G1.resizeNearestNeighbor(o,[u,f]):G1.resizeBilinear(o,[u,f])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},i=super.getConfig();return Object.assign(t,i),t}}hN.className="UpSampling2D",Lt(hN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function g4(s,t,i=[1,1],o="valid",l,u){return $e(()=>{l==null&&(l=tc()),er(l);let f=AT(s,l);if(s.rank!==4)throw new Ue(`Input for depthwiseConv2d is required to be 4-D, but is instead ${s.rank}-D`);if(t.rank!==4)throw new Ue(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return f=Wi(f,t,i,o==="same"?"same":"valid","NHWC",u),l==="channelsFirst"&&(f=bi(f,[0,3,1,2])),f})}class dN extends lw{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Bs(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=vr(t.depthwiseConstraint),this.depthwiseRegularizer=Ls(t.depthwiseRegularizer)}build(t){if(t=ns(t),t.length<4)throw new Ue(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const i=this.dataFormat==="channelsFirst"?1:3;if(t[i]==null||t[i]<0)throw new Ue(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[i]}).`);const o=t[i],l=[this.kernelSize[0],this.kernelSize[1],o,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",l,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[o*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,i){return $e(()=>{t=ti(t);let o=g4(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(o=nc(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),o})}computeOutputShape(t){t=ns(t);const i=this.dataFormat==="channelsFirst"?t[2]:t[1],o=this.dataFormat==="channelsFirst"?t[3]:t[2],l=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,u=rc(i,this.kernelSize[0],this.padding,this.strides[0]),f=rc(o,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],l,u,f]:[t[0],u,f,l]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Ps(this.depthwiseInitializer),t.depthwiseRegularizer=ms(this.depthwiseRegularizer),t.depthwiseConstraint=yr(this.depthwiseRegularizer),t}}dN.className="DepthwiseConv2D",Lt(dN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function fN(s,t,i,o){if(Array.isArray(s)){if(t!=null||i!=null)throw new Ue("When inputs is an array, neither initialState or constants should be provided");o!=null&&(i=s.slice(s.length-o,s.length),s=s.slice(0,s.length-o)),s.length>1&&(t=s.slice(1,s.length)),s=s[0]}function l(u){return u==null||Array.isArray(u)?u:[u]}return t=l(t),i=l(i),{inputs:s,initialState:t,constants:i}}function pN(s,t,i,o=!1,l,u,f=!1,g=!1){return $e(()=>{const A=t.shape.length;if(A<3)throw new Ue(`Input should be at least 3D, but is ${A}D.`);const v=[1,0].concat(ec(2,A));t=bi(t,v),u!=null,f&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),l!=null&&(l=hn(hn(l,"bool"),"float32"),l.rank===A-1&&(l=za(l,-1)),l=bi(l,v)),o&&(t=Al(t,0),l!=null&&(l=Al(l,0)));const C=[];let S,M=i;const _=t.shape[0],B=Fn(t);let F;l!=null&&(F=Fn(l));for(let U=0;U<_;++U){const V=B[U],$=$e(()=>s(V,M));if(l==null)S=$[0],M=$[1];else{const q=$e(()=>{const ne=F[U],he=Wn(Wa(ne),ne),me=Ut(Oe($[0],ne),Oe(M[0],he)),pe=M.map((ye,Te)=>Ut(Oe($[1][Te],ne),Oe(ye,he)));return{output:me,newStates:pe}});S=q.output,M=q.newStates}g&&C.push(S)}let P;return g&&(P=Xo(C,1)),[S,P,M]})}class Rd extends Bi{constructor(t){super(t);let i;if(t.cell==null)throw new Ue("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?i=new vT({cells:t.cell}):i=t.cell,i.stateSize==null)throw new Ue("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=i,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new br({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return ec(0,t).map(i=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){tT(t)&&(t=t[0]),t=t;let i=this.cell.stateSize;Array.isArray(i)||(i=[i]);const o=i[0];let l;if(this.returnSequences?l=[t[0],t[1],o]:l=[t[0],o],this.returnState){const u=[];for(const f of i)u.push([t[0],f]);return[l].concat(u)}else return l}computeMask(t,i){return $e(()=>{Array.isArray(i)&&(i=i[0]);const o=this.returnSequences?i:null;if(this.returnState){const l=this.states.map(u=>null);return[o].concat(l)}else return o})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,i=[];for(let o=0;o<t;++o)i.push(null);return i}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new hi("Constants support is not implemented in RNN yet.");tT(t)&&(t=t[0]),t=t;const i=this.stateful?t[0]:null,o=t.slice(2);this.inputSpec[0]=new br({shape:[i,null,...o]});const l=[t[0]].concat(t.slice(2));this.cell.build(l);let u;if(Array.isArray(this.cell.stateSize)?u=this.cell.stateSize:u=[this.cell.stateSize],this.stateSpec!=null){if(!O(this.stateSpec.map(f=>f.shape[f.shape.length-1]),u))throw new Ue(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=u.map(f=>new br({shape:[null,f]}));this.stateful&&this.resetStates()}resetStates(t,i=!1){$e(()=>{if(!this.stateful)throw new su("Cannot call resetStates() on an RNN Layer that is not stateful.");const o=this.inputSpec[0].shape[0];if(o==null)throw new Ue("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(l=>Zs([o,l])):this.states_=[Zs([o,this.cell.stateSize])];else if(t==null)ci(this.states_),this.keptStates!=null&&(ci(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(l=>Zs([o,l])):this.states_[0]=Zs([o,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new Ue(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);i===!0?this.keptStates.push(this.states_.slice()):ci(this.states_);for(let l=0;l<this.states_.length;++l){const u=t[l],f=Array.isArray(this.cell.stateSize)?this.cell.stateSize[l]:this.cell.stateSize,g=[o,f];if(!O(u.shape,g))throw new Ue(`State ${l} is incompatible with layer ${this.name}: expected shape=${g}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>ca(l.clone()))})}apply(t,i){let o=i==null?null:i.initialState,l=i==null?null:i.constants;i==null&&(i={});const u=fN(t,o,l,this.numConstants);t=u.inputs,o=u.initialState,l=u.constants;let f=[],g=[];if(o!=null){i.initialState=o,f=f.concat(o),this.stateSpec=[];for(const A of o)this.stateSpec.push(new br({shape:A.shape}));g=g.concat(this.stateSpec)}if(l!=null&&(i.constants=l,f=f.concat(l),this.numConstants=l.length),f[0]instanceof ou){const A=[t].concat(f),v=this.inputSpec.concat(g),C=this.inputSpec;this.inputSpec=v;const S=super.apply(A,i);return this.inputSpec=C,S}else return super.apply(t,i)}call(t,i){return $e(()=>{const o=i==null?null:i.mask,l=i==null?null:i.training;let u=i==null?null:i.initialState;t=ti(t),u==null&&(this.stateful?u=this.states_:u=this.getInitialState(t));const f=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(u.length!==f)throw new Ue(`RNN Layer has ${f} state(s) but was passed ${u.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const g={training:l},A=pN((_,B)=>{const F=this.cell.call([_].concat(B),g);return[F[0],F.slice(1)]},t,u,this.goBackwards,o,null,this.unroll,this.returnSequences),v=A[0],C=A[1],S=A[2];this.stateful&&this.resetStates(S,l);const M=this.returnSequences?C:v;return this.returnState?[M].concat(S):M})}getInitialState(t){return $e(()=>{let i=Zs(t.shape);return i=wn(i,[1,2]),i=Zb(i),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>o>1?QI(i,[1,o]):i):this.cell.stateSize>1?[QI(i,[1,this.cell.stateSize])]:[i]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),i={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(i.numConstants=this.numConstants);const o=this.cell.getConfig();return this.getClassName()===Rd.className&&(i.cell={className:this.cell.getClassName(),config:o}),Object.assign({},o,t,i)}static fromConfig(t,i,o={}){const l=i.cell,u=sh(l,o);return new t(Object.assign(i,{cell:u}))}}Rd.className="RNN",Lt(Rd);class uw extends Bi{}class bT extends uw{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,_r(this.units,"units"),this.activation=_d(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Bs(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Bs(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Bs(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ls(t.kernelRegularizer),this.recurrentRegularizer=Ls(t.recurrentRegularizer),this.biasRegularizer=Ls(t.biasRegularizer),this.kernelConstraint=vr(t.kernelConstraint),this.recurrentConstraint=vr(t.recurrentConstraint),this.biasConstraint=vr(t.biasConstraint),this.dropout=$g([1,Id([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=$g([1,Id([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ns(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,i){return $e(()=>{if(t=t,t.length!==2)throw new Ue(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let o=t[1];t=t[0];const l=i.training==null?!1:i.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=kd({ones:()=>Wa(t),rate:this.dropout,training:l,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=kd({ones:()=>Wa(o),rate:this.recurrentDropout,training:l,dropoutFunc:this.dropoutFunc}));let u;const f=this.dropoutMask,g=this.recurrentDropoutMask;f!=null?u=au(Oe(t,f),this.kernel.read()):u=au(t,this.kernel.read()),this.bias!=null&&(u=nc(u,this.bias.read())),g!=null&&(o=Oe(o,g));let A=Ut(u,au(o,this.recurrentKernel.read()));return this.activation!=null&&(A=this.activation.apply(A)),[A,A]})}getConfig(){const t=super.getConfig(),i={units:this.units,activation:Md(this.activation),useBias:this.useBias,kernelInitializer:Ps(this.kernelInitializer),recurrentInitializer:Ps(this.recurrentInitializer),biasInitializer:Ps(this.biasInitializer),kernelRegularizer:ms(this.kernelRegularizer),recurrentRegularizer:ms(this.recurrentRegularizer),biasRegularizer:ms(this.biasRegularizer),activityRegularizer:ms(this.activityRegularizer),kernelConstraint:yr(this.kernelConstraint),recurrentConstraint:yr(this.recurrentConstraint),biasConstraint:yr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,i)}}bT.className="SimpleRNNCell",Lt(bT);class mN extends Rd{constructor(t){t.cell=new bT(t),super(t)}call(t,i){return $e(()=>{this.cell.dropoutMask!=null&&(ci(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ci(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const o=i==null?null:i.mask,l=i==null?null:i.training,u=i==null?null:i.initialState;return super.call(t,{mask:o,training:l,initialState:u})})}static fromConfig(t,i){return new t(i)}}mN.className="SimpleRNN",Lt(mN);class yT extends uw{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new Ue("GRUCell does not support reset_after parameter set to true.");this.units=t.units,_r(this.units,"units"),this.activation=_d(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=_d(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Bs(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Bs(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Bs(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ls(t.kernelRegularizer),this.recurrentRegularizer=Ls(t.recurrentRegularizer),this.biasRegularizer=Ls(t.biasRegularizer),this.kernelConstraint=vr(t.kernelConstraint),this.recurrentConstraint=vr(t.recurrentConstraint),this.biasConstraint=vr(t.biasConstraint),this.dropout=$g([1,Id([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=$g([1,Id([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ns(t);const i=t[t.length-1];this.kernel=this.addWeight("kernel",[i,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,i){return $e(()=>{if(t=t,t.length!==2)throw new Ue(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const o=i.training==null?!1:i.training;let l=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=kd({ones:()=>Wa(t),rate:this.dropout,training:o,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=kd({ones:()=>Wa(l),rate:this.recurrentDropout,training:o,count:3,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,f=this.recurrentDropoutMask;let g,A,v;0<this.dropout&&this.dropout<1&&(t=Oe(t,u[0]));let C=au(t,this.kernel.read());this.useBias&&(C=nc(C,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(l=Oe(l,f[0]));const S=this.recurrentKernel.read(),[M,_]=zr(S,[2*this.units,this.units],S.rank-1),B=au(l,M),[F,P,U]=zr(C,3,C.rank-1),[V,$]=zr(B,2,B.rank-1);g=this.recurrentActivation.apply(Ut(F,V)),A=this.recurrentActivation.apply(Ut(P,$));const q=au(Oe(A,l),_);v=this.activation.apply(Ut(U,q));const ne=Ut(Oe(g,l),Oe(Ut(1,Us(g)),v));return[ne,ne]})}getConfig(){const t=super.getConfig(),i={units:this.units,activation:Md(this.activation),recurrentActivation:Md(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ps(this.kernelInitializer),recurrentInitializer:Ps(this.recurrentInitializer),biasInitializer:Ps(this.biasInitializer),kernelRegularizer:ms(this.kernelRegularizer),recurrentRegularizer:ms(this.recurrentRegularizer),biasRegularizer:ms(this.biasRegularizer),activityRegularizer:ms(this.activityRegularizer),kernelConstraint:yr(this.kernelConstraint),recurrentConstraint:yr(this.recurrentConstraint),biasConstraint:yr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,i)}}yT.className="GRUCell",Lt(yT);class gN extends Rd{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new yT(t),super(t)}call(t,i){return $e(()=>{this.cell.dropoutMask!=null&&(ci(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ci(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const o=i==null?null:i.mask,l=i==null?null:i.training,u=i==null?null:i.initialState;return super.call(t,{mask:o,training:l,initialState:u})})}static fromConfig(t,i){return i.implmentation===0&&(i.implementation=1),new t(i)}}gN.className="GRU",Lt(gN);class hw extends uw{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,_r(this.units,"units"),this.activation=_d(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=_d(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Bs(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Bs(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Bs(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ls(t.kernelRegularizer),this.recurrentRegularizer=Ls(t.recurrentRegularizer),this.biasRegularizer=Ls(t.biasRegularizer),this.kernelConstraint=vr(t.kernelConstraint),this.recurrentConstraint=vr(t.recurrentConstraint),this.biasConstraint=vr(t.biasConstraint),this.dropout=$g([1,Id([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=$g([1,Id([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var i;t=ns(t);const o=t[t.length-1];this.kernel=this.addWeight("kernel",[o,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let l;if(this.useBias){if(this.unitForgetBias){const u=this.biasInitializer,f=this.units;l=new(i=class extends xl{apply(g,A){const v=u.apply([f]),C=new ZI().apply([f]),S=u.apply([f*2]);return XB(XB(v,C),S)}},i.className="CustomInit",i)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,l,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,i){return $e(()=>{const o=i.training==null?!1:i.training;if(t=t,t.length!==3)throw new Ue(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let l=t[1];const u=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=kd({ones:()=>Wa(t),rate:this.dropout,training:o,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=kd({ones:()=>Wa(l),rate:this.recurrentDropout,training:o,count:4,dropoutFunc:this.dropoutFunc}));const f=this.dropoutMask,g=this.recurrentDropoutMask;let A,v,C,S;0<this.dropout&&this.dropout<1&&(t=Oe(t,f[0]));let M=au(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(l=Oe(l,g[0])),M=Ut(M,au(l,this.recurrentKernel.read())),this.useBias&&(M=nc(M,this.bias.read()));const[_,B,F,P]=zr(M,4,M.rank-1);A=this.recurrentActivation.apply(_),v=this.recurrentActivation.apply(B),C=Ut(Oe(v,u),Oe(A,this.activation.apply(F))),S=this.recurrentActivation.apply(P);const U=Oe(S,this.activation.apply(C));return[U,U,C]})}getConfig(){const t=super.getConfig(),i={units:this.units,activation:Md(this.activation),recurrentActivation:Md(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ps(this.kernelInitializer),recurrentInitializer:Ps(this.recurrentInitializer),biasInitializer:Ps(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ms(this.kernelRegularizer),recurrentRegularizer:ms(this.recurrentRegularizer),biasRegularizer:ms(this.biasRegularizer),activityRegularizer:ms(this.activityRegularizer),kernelConstraint:yr(this.kernelConstraint),recurrentConstraint:yr(this.recurrentConstraint),biasConstraint:yr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,i)}}hw.className="LSTMCell",Lt(hw);class AN extends Rd{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new hw(t),super(t)}call(t,i){return $e(()=>{this.cell.dropoutMask!=null&&(ci(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ci(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const o=i==null?null:i.mask,l=i==null?null:i.training,u=i==null?null:i.initialState;return super.call(t,{mask:o,training:l,initialState:u})})}static fromConfig(t,i){return i.implmentation===0&&(i.implementation=1),new t(i)}}AN.className="LSTM",Lt(AN);class vT extends uw{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const i of this.cells.slice().reverse())Array.isArray(i.stateSize)?t.push(...i.stateSize):t.push(i.stateSize);return t}call(t,i){return $e(()=>{t=t;let o=t.slice(1);const l=[];for(const g of this.cells.slice().reverse())Array.isArray(g.stateSize)?l.push(o.splice(0,g.stateSize.length)):l.push(o.splice(0,1));l.reverse();const u=[];let f;for(let g=0;g<this.cells.length;++g){const A=this.cells[g];o=l[g],g===0?f=[t[0]].concat(o):f=[f[0]].concat(o),f=A.call(f,i),u.push(f.slice(1))}o=[];for(const g of u.slice().reverse())o.push(...g);return[f[0]].concat(o)})}build(t){tT(t)&&(t=t[0]),t=t;let i;this.cells.forEach((o,l)=>{Np(`RNNCell_${l}`,()=>{o.build(t),Array.isArray(o.stateSize)?i=o.stateSize[0]:i=o.stateSize,t=[t[0],i]})}),this.built=!0}getConfig(){const t=super.getConfig(),i=l=>({className:l.getClassName(),config:l.getConfig()}),o={cells:this.cells.map(i)};return Object.assign({},t,o)}static fromConfig(t,i,o={}){const l=[];for(const u of i.cells)l.push(sh(u,o));return new t({cells:l})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const i of this.cells)t.push(...i.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const i of this.cells)t.push(...i.nonTrainableWeights);if(!this.trainable){const i=[];for(const o of this.cells)i.push(...o.trainableWeights);return i.concat(t)}return t}getWeights(){const t=[];for(const i of this.cells)t.push(...i.weights);return nT(t)}setWeights(t){const i=[];for(const o of this.cells){const l=o.weights.length,u=t.splice(l);for(let f=0;f<o.weights.length;++f)i.push([o.weights[f],u[f]])}iT(i)}}vT.className="StackedRNNCells",Lt(vT);function kd(s){const{ones:t,rate:i,training:o=!1,count:l=1,dropoutFunc:u}=s,f=()=>u!=null?u(t(),i):KB(t(),i),g=()=>Yb(f,t,o);return!l||l<=1?ca(g().clone()):Array(l).fill(void 0).map(g).map(A=>ca(A.clone()))}/**
* @license
* Copyright 2020 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/var A4=globalThis&&globalThis.__rest||function(s,t){var i={};for(var o in s)Object.prototype.hasOwnProperty.call(s,o)&&t.indexOf(o)<0&&(i[o]=s[o]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var l=0,o=Object.getOwnPropertySymbols(s);l<o.length;l++)t.indexOf(o[l])<0&&Object.prototype.propertyIsEnumerable.call(s,o[l])&&(i[o[l]]=s[o[l]]);return i};class bN extends Rd{constructor(t){if(t.unroll)throw new hi("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new hi("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new br({ndim:5})]}call(t,i){return $e(()=>{if(this.cell.dropoutMask!=null&&(ci(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ci(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),i&&i.constants)throw new Ue("ConvRNN2D cell does not support constants");const o=i==null?null:i.mask,l=i==null?null:i.training,u=i==null?null:i.initialState;return super.call(t,{mask:o,training:l,initialState:u})})}computeOutputShape(t){let i=this.computeSingleOutputShape(t);return this.returnSequences||(i=[i[0],...i.slice(2)]),this.returnState&&(i=[i,...Array(2).fill([t[0],...i.slice(-3)])]),i}getInitialState(t){return $e(()=>{const{stateSize:i}=this.cell,o=t.shape,l=this.computeSingleOutputShape(o),u=[l[0],...l.slice(2)],f=Zs(u);return Array.isArray(i)?Array(i.length).fill(f):[f]})}resetStates(t,i=!1){$e(()=>{if(!this.stateful)throw new su("Cannot call resetStates() on an RNN Layer that is not stateful.");const o=this.inputSpec[0].shape,l=this.computeSingleOutputShape(o),u=[l[0],...l.slice(2)];if(o[0]==null)throw new Ue("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Zs(u)):this.states_=[Zs(u)];else if(t==null)ci(this.states_),this.keptStates!=null&&(ci(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Zs(u)):this.states_[0]=Zs(u);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new Ue(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);i?this.keptStates.push(this.states_.slice()):ci(this.states_);for(let f=0;f<this.states_.length;++f){const g=t[f],A=u;if(!O(g.shape,A))throw new Ue(`State ${f} is incompatible with layer ${this.name}: expected shape=${A}, received shape=${g.shape}`);this.states_[f]=g}}this.states_=this.states_.map(f=>ca(f.clone()))})}computeSingleOutputShape(t){const{dataFormat:i,filters:o,kernelSize:l,padding:u,strides:f,dilationRate:g}=this.cell,A=i==="channelsFirst",v=t[A?3:2],C=t[A?4:3],S=rc(v,l[0],u,f[0],g[0]),M=rc(C,l[1],u,f[1],g[1]);return[...t.slice(0,2),...A?[o,S,M]:[S,M,o]]}}bN.className="ConvRNN2D";class xT extends hw{constructor(t){const{filters:i,kernelSize:o,strides:l,padding:u,dataFormat:f,dilationRate:g}=t;super(Object.assign({},t,{units:i})),this.filters=i,_r(this.filters,"filters"),this.kernelSize=jg(o,2,"kernelSize"),this.kernelSize.forEach(A=>_r(A,"kernelSize")),this.strides=jg(l||1,2,"strides"),this.strides.forEach(A=>_r(A,"strides")),this.padding=u||"valid",Qo(this.padding),this.dataFormat=f||"channelsLast",er(this.dataFormat),this.dilationRate=jg(g||1,2,"dilationRate"),this.dilationRate.forEach(A=>_r(A,"dilationRate"))}build(t){var i;t=ns(t);const o=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[o]==null)throw new Ue(`The channel dimension of the input should be defined. Found ${t[o]}`);const l=t[o],u=4,f=this.kernelSize.concat([l,this.filters*u]);this.kernel=this.addWeight("kernel",f,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const g=this.kernelSize.concat([this.filters,this.filters*u]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",g,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let A;if(this.unitForgetBias){const v=this.biasInitializer,C=this.filters;A=new(i=class extends xl{apply(S,M){const _=v.apply([C]),B=ks([C]),F=v.apply([C*2]);return XI([_,B,F])}},i.className="CustomInit",i)}else A=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*u],null,A,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,i){return $e(()=>{if(t.length!==3)throw new Ue(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const o=i.training||!1,l=t[0],u=t[1],f=t[2],g=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=kd({ones:()=>Wa(l),rate:this.dropout,training:o,count:g,dropoutFunc:this.dropoutFunc}));const A=this.dropoutMask,v=(Pt,Ft,Xt)=>!Ft||!Ft[Xt]?Pt:Oe(Ft[Xt],Pt);let C=v(l,A,0),S=v(l,A,1),M=v(l,A,2),_=v(l,A,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=kd({ones:()=>Wa(u),rate:this.recurrentDropout,training:o,count:g,dropoutFunc:this.dropoutFunc}));const B=this.recurrentDropoutMask;let F=v(u,B,0),P=v(u,B,1),U=v(u,B,2),V=v(u,B,3);const $=3,[q,ne,he,me]=zr(this.kernel.read(),g,$),[pe,ye,Te,Ye]=this.useBias?zr(this.bias.read(),g):[null,null,null,null];C=this.inputConv(C,q,pe,this.padding),S=this.inputConv(S,ne,ye,this.padding),M=this.inputConv(M,he,Te,this.padding),_=this.inputConv(_,me,Ye,this.padding);const[et,nt,ht,ct]=zr(this.recurrentKernel.read(),g,$);F=this.recurrentConv(F,et),P=this.recurrentConv(P,nt),U=this.recurrentConv(U,ht),V=this.recurrentConv(V,ct);const pt=this.recurrentActivation.apply(Ut(C,F)),Et=this.recurrentActivation.apply(Ut(S,P)),yt=Ut(Oe(Et,f),Oe(pt,this.activation.apply(Ut(M,U)))),It=Oe(this.recurrentActivation.apply(Ut(_,V)),this.activation.apply(yt));return[It,It,yt]})}getConfig(){const t=super.getConfig(),i=A4(t,["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},i,o)}inputConv(t,i,o,l){const u=Vc(t,i,this.strides,l||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return o?nc(u,o,this.dataFormat):u}recurrentConv(t,i){return Vc(t,i,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}xT.className="ConvLSTM2DCell",Lt(xT);class yN extends bN{constructor(t){const i=new xT(t);super(Object.assign({},t,{cell:i}))}static fromConfig(t,i){return new t(i)}}yN.className="ConvLSTM2D",Lt(yN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class wT extends Bi{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const i=t.shape,o=[];for(let l=0;l<this.noiseShape.length;++l)o.push(this.noiseShape[l]==null?i[l]:this.noiseShape[l]);return o}call(t,i){return $e(()=>{this.invokeCallHook(t,i);const o=ti(t);if(0<this.rate&&this.rate<1){const l=i.training==null?!1:i.training,u=this.getNoiseShape(o);return Yb(()=>KB(o,this.rate,u,this.seed),()=>o,l)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},i=super.getConfig();return Object.assign(t,i),t}dispose(){return super.dispose()}}wT.className="Dropout",Lt(wT);class vN extends wT{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const i=t.shape;return[i[0],1,i[2]]}}vN.className="SpatialDropout1D",Lt(vN);class xN extends Bi{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let i=null;t.batchSize!=null&&(i=t.batchSize),this.batchInputShape=[i,t.inputDim]}this.units=t.units,_r(this.units,"units"),this.activation=_d(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Bs(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Bs(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=vr(t.kernelConstraint),this.biasConstraint=vr(t.biasConstraint),this.kernelRegularizer=Ls(t.kernelRegularizer),this.biasRegularizer=Ls(t.biasRegularizer),this.activityRegularizer=Ls(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=ns(t);const i=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[i,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:i}}],this.built=!0}computeOutputShape(t){t=ns(t);const i=t.slice();return i[i.length-1]=this.units,i}call(t,i){return $e(()=>{this.invokeCallHook(t,i);const o=ti(t),l=GB(this.activation.getClassName());let u;return l!=null?u=au(o,this.kernel.read(),l,this.bias?this.bias.read():null):(u=au(o,this.kernel.read()),this.bias!=null&&(u=nc(u,this.bias.read())),this.activation!=null&&(u=this.activation.apply(u))),u})}getConfig(){const t={units:this.units,activation:Md(this.activation),useBias:this.useBias,kernelInitializer:Ps(this.kernelInitializer),biasInitializer:Ps(this.biasInitializer),kernelRegularizer:ms(this.kernelRegularizer),biasRegularizer:ms(this.biasRegularizer),activityRegularizer:ms(this.activityRegularizer),kernelConstraint:yr(this.kernelConstraint),biasConstraint:yr(this.biasConstraint)},i=super.getConfig();return Object.assign(t,i),t}}xN.className="Dense",Lt(xN);class wN extends Bi{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=ns(t);for(const i of t.slice(1))if(i==null)throw new Ue(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Sd(t,1)]}call(t,i){return $e(()=>{this.invokeCallHook(t,i);let o=ti(t);if(this.dataFormat==="channelsFirst"&&o.rank>1){const l=[0];for(let u=2;u<o.rank;++u)l.push(u);l.push(1),o=bi(o,l)}return JX(o)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const i=super.getConfig();return Object.assign(t,i),t}}wN.className="Flatten",Lt(wN);class CN extends Bi{constructor(t){super(t),this.supportsMasking=!0,this.activation=_d(t.activation)}call(t,i){return $e(()=>{this.invokeCallHook(t,i);const o=ti(t);return this.activation.apply(o)})}getConfig(){const t={activation:Md(this.activation)},i=super.getConfig();return Object.assign(t,i),t}}CN.className="Activation",Lt(CN);class EN extends Bi{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,i){return $e(()=>(t=ti(t),jX(t,this.n)))}getConfig(){const t={n:this.n},i=super.getConfig();return Object.assign(t,i),t}}EN.className="RepeatVector",Lt(EN);class SN extends Bi{constructor(t){super(t),this.targetShape=t.targetShape;for(let i=0;i<this.targetShape.length;++i)this.isUnknown(this.targetShape[i])&&(this.targetShape[i]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,i){const o="Total size of new array must be unchanged.",l=i.slice();let u=1,f=null;for(let A=0;A<l.length;++A){const v=l[A];if(this.isUnknown(v))if(f===null)f=A;else throw new Ue("Can only specifiy one unknown dimension.");else u*=v}const g=Sd(t);if(f!==null){if(u===0||g%u!==0)throw new Ue(o);l[f]=g/u}else if(g!==u)throw new Ue(o);return l}computeOutputShape(t){let i=!1;for(let o=0;o<t.length;++o)if(this.isUnknown(t[o])){i=!0;break}return i?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,i){return $e(()=>{this.invokeCallHook(t,i);const o=ti(t),l=o.shape,u=l.slice(0,1).concat(this.fixUnknownDimension(l.slice(1),this.targetShape));return He(o,u)})}getConfig(){const t={targetShape:this.targetShape},i=super.getConfig();return Object.assign(t,i),t}}SN.className="Reshape",Lt(SN);class IN extends Bi{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const i=ec(1,t.dims.length+1);if(!O(t.dims.slice().sort(),i))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new br({ndim:this.dims.length+1})]}computeOutputShape(t){t=ns(t);const i=t.slice();return this.dims.forEach((o,l)=>{i[l+1]=t[o]}),i}call(t,i){return bi(ti(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},i=super.getConfig();return Object.assign(t,i),t}}IN.className="Permute",Lt(IN);class TN extends Bi{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),i={maskValue:this.maskValue};return Object.assign(i,t),i}computeMask(t,i){const o=ti(t);return bg(vp(o,this.maskValue),-1)}call(t,i){return $e(()=>{this.invokeCallHook(t,i);const o=ti(t),l=-1,u=!0,f=bg(vp(o,this.maskValue),l,u);return Oe(o,hn(f,o.dtype))})}}TN.className="Masking",Lt(TN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class MN extends Bi{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let i=null;t.batchSize!=null&&(i=t.batchSize),t.inputLength==null?this.batchInputShape=[i,null]:this.batchInputShape=[i].concat(Is(t.inputLength))}this.inputDim=t.inputDim,_r(this.inputDim,"inputDim"),this.outputDim=t.outputDim,_r(this.outputDim,"outputDim"),this.embeddingsInitializer=Bs(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ls(t.embeddingsRegularizer),this.activityRegularizer=Ls(t.activityRegularizer),this.embeddingsConstraint=vr(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,i){return $e(()=>this.maskZero?(t=ti(t),vp(t,oi(t))):null)}computeOutputShape(t){if(t=ns(t),this.inputLength==null)return[...t,this.outputDim];const i=Is(this.inputLength);if(i.length!==t.length-1)throw new Ue(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let o=0;for(let l=0;l<i.length;++l){const u=i[l],f=t[l+1];if(u!=null&&f!=null&&u!==f)throw new Ue(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);u==null&&(i[o]=f),o++}}return[t[0],...i,this.outputDim]}call(t,i){return $e(()=>{this.invokeCallHook(t,i);let o=ti(t);o.dtype!=="int32"&&(o=Kb(o,"int32"));const l=QB(this.embeddings.read(),He(o,[o.size]));return He(l,ns(this.computeOutputShape(o.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ps(this.embeddingsInitializer),embeddingsRegularizer:ms(this.embeddingsRegularizer),activityRegularizer:ms(this.activityRegularizer),embeddingsConstraint:yr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},i=super.getConfig();return Object.assign(t,i),t}}MN.className="Embedding",Lt(MN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class Op extends Bi{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new hi}computeElementwiseOpOutputShape(t,i){if(t==null||i==null)return null;if(t.length<i.length)return this.computeElementwiseOpOutputShape(i,t);if(i.length===0)return t;const o=t.slice(0,t.length-i.length);for(let l=0;l<i.length;++l){const u=t[t.length-i.length+l],f=i[l];if(u==null||f==null||u<0||f<0)o.push(null);else if(u===1)o.push(f);else if(f===1)o.push(u);else{if(u!==f)throw new Ue("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(i));o.push(u)}}return o}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[ns(t)]),t=t,t.length<2)throw new Ue(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let i=[];for(const u of t)u!=null&&u[0]!==null&&i.push(u[0]);if(i=Ed(i),i.length>1)throw new Ue(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let o=t[0]==null?null:t[0].slice(1);for(let u=1;u<t.length;++u){const f=t[u]==null?null:t[u].slice(1);o=this.computeElementwiseOpOutputShape(o,f)}const l=t.map(u=>u.length);t.indexOf(null)===-1&&Ed(l).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,i){return $e(()=>{if(t=t,this.reshapeRequired){const o=[],l=t.map(u=>u.rank);if(l.indexOf(null)===-1){const u=Id(l);for(let f of t){const g=f.rank;for(let A=0;A<u-g;++A)f=Zb(f,1);o.push(f)}return this.mergeFunction(o)}else{let u=!1;for(const A of t){const v=A.rank;if(v==null){const C=A.shape,S=C[0],M=C.slice(1).concat([S]);let _=He(A,[S].concat(Sd(C.slice(1))));_=bi(_,[1,0]),_=He(_,M),o.push(_),u=!0}else if(v>1){const C=ec(1,v).concat([0]);o.push(bi(A,C)),u=!0}else o.push(A)}let f=this.mergeFunction(o);const g=f.rank;if(u){if(g==null){const A=f.shape,v=A.length,C=A[v-1],S=[C].concat(A.slice(0,A.length-1));f=He(bi(He(f,[-1,C]),[1,0]),S)}else if(g>1){const A=[g-1].concat(ec(0,g-1));f=bi(f,A)}}return f}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let i;t[0]==null?i=null:i=t[0].slice(1);for(let l=1;l<t.length;++l){const u=t[l]==null?null:t[l].slice(1);i=this.computeElementwiseOpOutputShape(i,u)}let o=[];for(const l of t)l!=null&&l[0]!==null&&o.push(l[0]);return o=Ed(o),o.length===1?i=o.concat(i):i=[null].concat(i),i}computeMask(t,i){return $e(()=>{if(i==null)return null;if(!Array.isArray(i))throw new Ue("`mask` should be an Array");if(!Array.isArray(t))throw new Ue("`inputs` should be an Array");if(i.length!==t.length)throw new Ue(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${i.length})`);if(i.every(l=>l==null))return null;i=i.map(l=>l==null?l:za(l,0));let o=i[0];for(let l=1;l<i.length-1;++l)o=Vo(o,i[l]);return o})}}class _N extends Op{constructor(t){super(t)}mergeFunction(t){return $e(()=>{let i=t[0].clone();for(let o=1;o<t.length;++o)i=Ut(i,t[o]);return i})}}_N.className="Add",Lt(_N);class RN extends Op{constructor(t){super(t)}mergeFunction(t){return $e(()=>{let i=t[0].clone();for(let o=1;o<t.length;++o)i=Oe(i,t[o]);return i})}}RN.className="Multiply",Lt(RN);class kN extends Op{constructor(t){super(t)}mergeFunction(t){return $e(()=>{let i=t[0].clone();for(let o=1;o<t.length;++o)i=Ut(i,t[o]);return Oe(1/t.length,i)})}}kN.className="Average",Lt(kN);class BN extends Op{constructor(t){super(t)}mergeFunction(t){return $e(()=>{let i=t[0];for(let o=1;o<t.length;++o)i=Yl(i,t[o]);return i})}}BN.className="Maximum",Lt(BN);class LN extends Op{constructor(t){super(t)}mergeFunction(t){return $e(()=>{let i=t[0];for(let o=1;o<t.length;++o)i=bp(i,t[o]);return i})}}LN.className="Minimum",Lt(LN);class NN extends Op{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new Ue("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let i=!0;for(const l of t)if(l!=null){i=!1;break}if(i)return;const o=[];for(let l=0;l<t.length;++l){const u=t[l].slice();u.splice(this.axis,1);let f=!1;for(const g of o)if(O(g,u)){f=!0;break}f||o.push(u)}if(o.length>1)throw new Ue("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return $e(()=>XI(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new Ue("A `Concatenate` layer should be called on a list of inputs.");const i=t,o=i[0].slice(),l=this.axis<0?o.length+this.axis:this.axis;for(const u of i.slice(1)){if(o[l]==null||u[l]==null){o[l]=null;break}o[l]+=u[l]}return o}computeMask(t,i){if(i==null)return null;if(!Array.isArray(i))throw new Ue("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new Ue("`inputs` should be an array for Concatenate");if(i.length!==t.length)throw new Ue(`Mismatch in the length of mask (${i.length}) and the legnth of inputs (${t.length})`);return $e(()=>{let o=!0;if(i.forEach(f=>{if(f!=null){o=!1;return}}),o)return null;const l=[];for(let f=0;f<t.length;++f)i[f]==null?l.push(hn(Wa(t[f]),"bool")):i[f].rank<t[f].rank?l.push(za(i[f],-1)):l.push(i[f]);const u=yi(l,this.axis);return Uc(u,-1,!1)})}getConfig(){const t={axis:this.axis},i=super.getConfig();return Object.assign(t,i),t}}NN.className="Concatenate",Lt(NN);function ay(s,t){for(;s<0;)s+=t;return s}function b4(s,t,i){if(s.shape.length>3||t.shape.length>3)throw new hi("batchDot is not implemented for tensors of 4D or higher rank yet");if(E(s.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${s.shape.length}`),E(s.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof i=="number"&&(i=[i,i]),s.dtype==="complex64"||t.dtype==="complex64")throw new hi("batchDot is not implemented for complex64-type Tensors yet.");const o=s.shape.length,l=t.shape.length;i==null&&(i=[o-1,l-2]);const u=i;return $e(()=>{let f;if(o>l){f=o-l;const A=[];for(let v=0;v<f;++v)A.push(1);t=He(t,t.shape.concat(A))}else if(l>o){f=l-o;const A=[];for(let v=0;v<f;++v)A.push(1);s=He(s,s.shape.concat(A))}else f=0;let g;if(s.shape.length===2&&t.shape.length===2)u[0]===u[1]?g=wn(Oe(s,t),u[0]):g=wn(Oe(bi(s,[1,0]),t),u[1]);else{const A=u[0]!==s.shape.length-1,v=u[1]===t.shape.length-1;g=Li(s,t,A,v)}if(f>0){let A;o>l?A=o+l-3:A=o-1;const v=[];for(let C=A;C<A+f;++C)v.push(C);g=Jl(g,v)}return g.shape.length===1&&(g=za(g,1)),g})}class DN extends Op{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){E(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const i=t[0],o=t[1];if(i.length>3||o.length>3)throw new hi("Dot layer does not support tensors of 4D or higher rank yet.");const l=this.interpretAxes(i,o);if(i[l[0]]!==o[l[1]])throw new Ue(`Dimension incompatibility: ${i[l[0]]} !== ${o[l[1]]}`)}mergeFunction(t){if(t.length!==2)throw new Ue(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let i=t[0],o=t[1],l;return Array.isArray(this.axes)?l=this.axes.map((u,f)=>ay(u,t[f].shape.length)):l=[ay(this.axes,i.shape.length),ay(this.axes,o.shape.length)],this.normalize&&(i=ew(i,l[0]),o=ew(o,l[1])),b4(i,o,l)}interpretAxes(t,i){let o;return Array.isArray(this.axes)?o=this.axes:o=[ay(this.axes,t.length),ay(this.axes,i.length)],o}computeOutputShape(t){E(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const i=t[0].slice(),o=t[1].slice();if(i.length>3||o.length>3)throw new hi("Dot layer does not support tensors of 4D or higher rank yet.");const l=this.interpretAxes(i,o);i.splice(l[0],1),o.splice(l[1],1),o.splice(0,1);const u=i.concat(o);return u.length===1&&u.push(1),u}computeMask(t,i){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},i=super.getConfig();return Object.assign(t,i),t}}DN.className="Dot",Lt(DN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class FN extends Bi{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),i={stddev:this.stddev};return Object.assign(i,t),i}call(t,i){return $e(()=>{this.invokeCallHook(t,i);const o=ti(t);return Yb(()=>Ut(Z1(o.shape,0,this.stddev),o),()=>o,i.training||!1)})}}FN.className="GaussianNoise",Lt(FN);class ON extends Bi{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),i={rate:this.rate};return Object.assign(i,t),i}call(t,i){return $e(()=>{this.invokeCallHook(t,i);const o=ti(t);return this.rate>0&&this.rate<1?Yb(()=>{const l=Math.sqrt(this.rate/(1-this.rate));return Oe(o,Z1(o.shape,1,l))},()=>o,i.training||!1):o})}}ON.className="GaussianDropout",Lt(ON);class GN extends Bi{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||ti(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),i={rate:this.rate};return Object.assign(i,t),i}call(t,i){return $e(()=>{if(this.rate<1&&this.rate>0){const o=this._getNoiseShape(t);return Yb(()=>{const l=ti(t),u=1.0507009873554805,f=-1.6732632423543772*u;let g=$c(Ju(o),this.rate);g=Kb(g,"float32");const A=((1-this.rate)*(1+this.rate*f**2))**-.5,v=-A*f*this.rate,C=Ut(Oe(l,g),Oe(Ut(g,-1),f));return Ut(Oe(C,A),v)},()=>ti(t),i.training||!1)}return t})}}GN.className="AlphaDropout",Lt(GN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function oy(s,t,i,o,l,u=.001){let f;if(s.rank===2)f=lb(s,t,i,o,l,u);else if(s.rank===3)f=Cg(s,t,i,o,l,u);else if(s.rank===4)f=Xl(s,t,i,o,l,u);else throw new hi(`batchNormalization is not implemented for array of rank ${s.rank} yet`);return f}function y4(s,t,i,o,l=.001){return $e(()=>{const u=yp(s,o),f=u.mean,g=u.variance;return[oy(s,f,g,i,t,l),f,g]})}function v4(s,t,i,o,l=.001){return $e(()=>{const u=yp(s,o),f=u.mean,g=u.variance,A=[];for(const _ of ec(0,s.rank))o.indexOf(_)!==-1?A.push(1):A.push(s.shape[_]);const v=He(f,A),C=He(g,A),S=t==null?null:He(t,A),M=i==null?null:He(i,A);return[oy(s,v,C,M,S,l),f,g]})}function x4(s,t,i,o,l=.001){return O(o.slice().sort(),ec(0,s.rank-1))?y4(s,t,i,o,l):v4(s,t,i,o,l)}class UN extends Bi{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Bs(t.betaInitializer||"zeros"),this.gammaInitializer=Bs(t.gammaInitializer||"ones"),this.movingMeanInitializer=Bs(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Bs(t.movingVarianceInitializer||"ones"),this.betaConstraint=vr(t.betaConstraint),this.gammaConstraint=vr(t.gammaConstraint),this.betaRegularizer=Ls(t.betaRegularizer),this.gammaRegularizer=Ls(t.gammaRegularizer)}build(t){t=ns(t);const i=this.axis>=0?this.axis:this.axis+t.length,o=t[i];if(o==null)throw new Ue(`Axis ${i} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new br({ndim:t.length,axes:{[i]:o}})];const l=[o];this.scale&&(this.gamma=this.addWeight("gamma",l,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",l,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",l,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",l,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,i){return $e(()=>{const o=i.training==null?!1:i.training,l=ti(t),u=l.shape,f=u.length,g=ec(0,f),A=this.axis>=0?this.axis:this.axis+f;g.splice(A,1);const v=kp(1,f);v[A]=u[A];const C=g.slice();C.sort();const S=!O(C,ec(0,f).slice(0,f-1)),M=()=>{if(S){const U=He(this.movingMean.read(),v),V=He(this.movingVariance.read(),v),$=this.center?He(this.beta.read(),v):null,q=this.scale?He(this.gamma.read(),v):null;return oy(l,U,V,$,q,this.epsilon)}else return oy(l,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!o)return M();const[_,B,F]=x4(l,this.gamma.read(),this.beta.read(),g,this.epsilon),P=(U,V,$)=>{$e(()=>{const q=1-$,ne=U.read(),he=Oe(Wn(ne,V),q);U.write(Wn(ne,he))})};return P(this.movingMean,B,this.momentum),P(this.movingVariance,F,this.momentum),_})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ps(this.betaInitializer),gammaInitializer:Ps(this.gammaInitializer),movingMeanInitializer:Ps(this.movingMeanInitializer),movingVarianceInitializer:Ps(this.movingVarianceInitializer),betaRegularizer:ms(this.betaRegularizer),gammaRegularizer:ms(this.gammaRegularizer),betaConstraint:yr(this.betaConstraint),gammaConstraint:yr(this.gammaConstraint)},i=super.getConfig();return Object.assign(t,i),t}}UN.className="BatchNormalization",Lt(UN);class PN extends Bi{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const i of this.axis)if(!Number.isInteger(i))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Bs(t.betaInitializer||"zeros"),this.gammaInitializer=Bs(t.gammaInitializer||"ones"),this.betaRegularizer=Ls(t.betaRegularizer),this.gammaRegularizer=Ls(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=ns(t);const i=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let u=0;u<this.axis.length;++u)this.axis[u]<0&&(this.axis[u]+=i);for(const u of this.axis)if(u<0||u>=i)throw new Error(`Invalid axis: ${u}`);if(this.axis.length!==Ed(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const o=this.axis.map(u=>t[u]),l=!0;this.scale?this.gamma=this.addWeight("gamma",o,"float32",this.gammaInitializer,this.gammaRegularizer,l):this.gamma=null,this.center?this.beta=this.addWeight("beta",o,"float32",this.betaInitializer,this.betaRegularizer,l):this.beta=null,this.built=!0}call(t,i){const o=ti(t),l=o.shape,u=l.length;return $e(()=>{let{mean:f,variance:g}=yp(o,this.axis,!0);const A=kp(1,u);for(const B of this.axis)A[B]=l[B];const v=B=>B!=null&&B.shape.length!==u?He(B,A):B;let C=this.scale?v(this.gamma.read()):null,S=this.center?v(this.beta.read()):null;const M=[],_=[];for(let B=0;B<u;++B)this.axis.indexOf(B)!==-1?(M.push(l[B]),_.push(1)):(M.push(1),_.push(l[B]));return f=yo(f,M),g=yo(g,M),C!=null&&(C=yo(C,_)),S!=null&&(S=yo(S,_)),oy(o,f,g,S,C,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ps(this.betaInitializer),gammaInitializer:Ps(this.gammaInitializer),betaRegularizer:ms(this.betaRegularizer),gammaRegularizer:ms(this.gammaRegularizer)},i=super.getConfig();return Object.assign(t,i),t}}PN.className="LayerNormalization",Lt(PN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function w4(s,t,i){return $e(()=>{if(s.rank!==4)throw new Ue(`temporalPadding expects input tensor to be 4-D, but received a ${s.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new Ue("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(i==null&&(i=tc()),i!=="channelsLast"&&i!=="channelsFirst")throw new Ue(`Unknown data format: ${i}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let o;return i==="channelsFirst"?o=[[0,0],[0,0],t[0],t[1]]:o=[[0,0],t[0],t[1],[0,0]],Tb(s,o)})}class zN extends Bi{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?tc():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new Ue(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let i,o;if(typeof t.padding[0]=="number")i=[t.padding[0],t.padding[0]],o=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new Ue(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(i=t.padding[0],t.padding[1].length!==2)throw new Ue(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);o=t.padding[1]}this.padding=[i,o]}this.inputSpec=[new br({ndim:4})]}computeOutputShape(t){t=ns(t);let i,o;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?i=t[2]+this.padding[0][0]+this.padding[0][1]:i=null,t[3]!=null&&t[3]>=0?o=t[3]+this.padding[1][0]+this.padding[1][1]:o=null,[t[0],t[1],i,o]):(t[1]!=null&&t[1]>=0?i=t[1]+this.padding[0][0]+this.padding[0][1]:i=null,t[2]!=null&&t[2]>=0?o=t[2]+this.padding[1][0]+this.padding[1][1]:o=null,[t[0],i,o,t[3]])}call(t,i){return $e(()=>w4(ti(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(t,i),t}}zN.className="ZeroPadding2D",Lt(zN);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/function dw(s,t,i,o,l,u){return $e(()=>{er(l),PB(u),Qo(o),i==null&&(i=[1,1]),o==null&&(o="valid"),l==null&&(l=tc()),u==null&&(u="max"),s=AT(s,l);let f;const g=o==="same"?"same":"valid";return u==="max"?f=Bg(s,t,i,g):f=Go(s,t,i,g),l==="channelsFirst"&&(f=bi(f,[0,3,1,2])),f})}function VN(s,t,i,o,l,u){return $e(()=>{er(l),PB(u),Qo(o),i==null&&(i=[1,1,1]),o==null&&(o="valid"),l==null&&(l=tc()),u==null&&(u="max"),s=sN(s,l);let f;const g=o==="same"?"same":"valid";return u==="max"?f=CS(s,t,i,g):f=xg(s,t,i,g),l==="channelsFirst"&&(f=bi(f,[0,4,1,2,3])),f})}class WN extends Bi{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new Ue(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(_r(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new Ue(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);_r(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Qo(this.padding),this.inputSpec=[new br({ndim:3})]}computeOutputShape(t){t=ns(t);const i=rc(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],i,t[2]]}call(t,i){return $e(()=>{this.invokeCallHook(t,i),t=Zb(ti(t),2);const o=this.poolingFunction(ti(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Jl(o,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},i=super.getConfig();return Object.assign(t,i),t}}class HN extends WN{constructor(t){super(t)}poolingFunction(t,i,o,l,u){return er(u),Qo(l),dw(t,i,o,l,u,"max")}}HN.className="MaxPooling1D",Lt(HN);class XN extends WN{constructor(t){super(t)}poolingFunction(t,i,o,l,u){return er(u),Qo(l),dw(t,i,o,l,u,"avg")}}XN.className="AveragePooling1D",Lt(XN);class QN extends Bi{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new Ue(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];_r(this.poolSize,"poolSize"),_r(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,er(this.dataFormat),Qo(this.padding),this.inputSpec=[new br({ndim:4})]}computeOutputShape(t){t=ns(t);let i=this.dataFormat==="channelsFirst"?t[2]:t[1],o=this.dataFormat==="channelsFirst"?t[3]:t[2];return i=rc(i,this.poolSize[0],this.padding,this.strides[0]),o=rc(o,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],i,o]:[t[0],i,o,t[3]]}call(t,i){return $e(()=>(this.invokeCallHook(t,i),this.poolingFunction(ti(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(t,i),t}}class KN extends QN{constructor(t){super(t)}poolingFunction(t,i,o,l,u){return er(u),Qo(l),dw(t,i,o,l,u,"max")}}KN.className="MaxPooling2D",Lt(KN);class ZN extends QN{constructor(t){super(t)}poolingFunction(t,i,o,l,u){return er(u),Qo(l),dw(t,i,o,l,u,"avg")}}ZN.className="AveragePooling2D",Lt(ZN);class $N extends Bi{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new Ue(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];_r(this.poolSize,"poolSize"),_r(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,er(this.dataFormat),Qo(this.padding),this.inputSpec=[new br({ndim:5})]}computeOutputShape(t){t=ns(t);let i=this.dataFormat==="channelsFirst"?t[2]:t[1],o=this.dataFormat==="channelsFirst"?t[3]:t[2],l=this.dataFormat==="channelsFirst"?t[4]:t[3];return i=rc(i,this.poolSize[0],this.padding,this.strides[0]),o=rc(o,this.poolSize[1],this.padding,this.strides[1]),l=rc(l,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],i,o,l]:[t[0],i,o,l,t[4]]}call(t,i){return $e(()=>(this.invokeCallHook(t,i),this.poolingFunction(ti(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(t,i),t}}class YN extends $N{constructor(t){super(t)}poolingFunction(t,i,o,l,u){return er(u),Qo(l),VN(t,i,o,l,u,"max")}}YN.className="MaxPooling3D",Lt(YN);class jN extends $N{constructor(t){super(t)}poolingFunction(t,i,o,l,u){return er(u),Qo(l),VN(t,i,o,l,u,"avg")}}jN.className="AveragePooling3D",Lt(jN);class qN extends Bi{constructor(t){super(t),this.inputSpec=[new br({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,i){throw new hi}}class JN extends qN{constructor(t){super(t||{})}call(t,i){return $e(()=>{const o=ti(t);return Hn(o,1)})}}JN.className="GlobalAveragePooling1D",Lt(JN);class e3 extends qN{constructor(t){super(t||{})}call(t,i){return $e(()=>{const o=ti(t);return ha(o,1)})}}e3.className="GlobalMaxPooling1D",Lt(e3);class t3 extends Bi{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,er(this.dataFormat),this.inputSpec=[new br({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,i){throw new hi}getConfig(){const t={dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(t,i),t}}class n3 extends t3{call(t,i){return $e(()=>{const o=ti(t);return this.dataFormat==="channelsLast"?Hn(o,[1,2]):Hn(o,[2,3])})}}n3.className="GlobalAveragePooling2D",Lt(n3);class i3 extends t3{call(t,i){return $e(()=>{const o=ti(t);return this.dataFormat==="channelsLast"?ha(o,[1,2]):ha(o,[2,3])})}}i3.className="GlobalMaxPooling2D",Lt(i3);/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class s3 extends Bi{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},i=super.getConfig();return Object.assign(t,i),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,i,o={}){const l=i.layer,u=sh(l,o);delete i.layer;const f={layer:u};return Object.assign(f,i),new t(f)}}class r3 extends s3{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=ns(t),t.length<3)throw new Ue(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const i=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(i),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=ns(t);const i=[t[0]].concat(t.slice(2)),o=this.layer.computeOutputShape(i),l=t[1];return[o[0],l].concat(o.slice(1))}call(t,i){return $e(()=>(t=ti(t),pN((o,l)=>[ti(this.layer.call(o,i)),[]],t,[],!1,null,null,!1,!0)[1]))}}r3.className="TimeDistributed",Lt(r3);function C4(s){Lp(QX,"BidirectionalMergeMode",s)}const E4="concat";class a3 extends s3{constructor(t){super(t);const i=t.layer.getConfig(),o={};o.className=t.layer.getClassName(),o.config=i,this.forwardLayer=sh(o),i.goBackwards=i.goBackwards!==!0;const l={};if(l.className=t.layer.getClassName(),l.config=i,this.backwardLayer=sh(l),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?E4:t.mergeMode,C4(this.mergeMode),t.weights)throw new hi("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const i=t.length,o=Math.floor(i/2);this.forwardLayer.setWeights(t.slice(0,o)),this.backwardLayer.setWeights(t.slice(o))}computeOutputShape(t){let i=this.forwardLayer.computeOutputShape(t);Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i;let o,l,u;return this.returnState&&(u=i.slice(1)),o=i[0],o=o,this.mergeMode==="concat"?(o[o.length-1]*=2,l=[o]):this.mergeMode==null?l=[o,o.slice()]:l=[o],this.returnState?this.mergeMode==null?l.concat(u).concat(u.slice()):[o].concat(u).concat(u.slice()):Xa(l)}apply(t,i){let o=i==null?null:i.initialState,l=i==null?null:i.constants;i==null&&(i={});const u=fN(t,o,l,this.numConstants);if(t=u.inputs,o=u.initialState,l=u.constants,Array.isArray(t)&&(o=t.slice(1),t=t[0]),(o==null||o.length===0)&&l==null)return super.apply(t,i);const f=[],g=[];if(o!=null){const v=o.length;if(v%2>0)throw new Ue("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");i.initialState=o,f.push(...o);const C=o.map(S=>new br({shape:S.shape}));this.forwardLayer.stateSpec=C.slice(0,v/2),this.backwardLayer.stateSpec=C.slice(v/2),g.push(...C)}if(l!=null)throw new hi("Support for constants in Bidirectional layers is not implemented yet.");const A=f[0]instanceof ou;for(const v of f)if(v instanceof ou!==A)throw new Ue("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(A){const v=[t].concat(f),C=this.inputSpec.concat(g),S=this.inputSpec;this.inputSpec=C;const M=super.apply(v,i);return this.inputSpec=S,M}else return super.apply(t,i)}call(t,i){return $e(()=>{const o=i.initialState;let l,u;if(o==null)l=this.forwardLayer.call(t,i),u=this.backwardLayer.call(t,i);else{const A=o.slice(0,o.length/2),v=o.slice(o.length/2);l=this.forwardLayer.call(t,Object.assign(i,{initialState:A})),u=this.backwardLayer.call(t,Object.assign(i,{initialState:v}))}let f;this.returnState&&(Array.isArray(l)&&(f=l.slice(1).concat(u.slice(1))),l=l[0],u=u[0]),this.returnSequences&&(u=Al(u,1));let g;return this.mergeMode==="concat"?g=XI([l,u]):this.mergeMode==="sum"?g=Ut(l,u):this.mergeMode==="ave"?g=Oe(.5,Ut(l,u)):this.mergeMode==="mul"?g=Oe(l,u):this.mergeMode==null&&(g=[l,u]),this.returnState?this.mergeMode==null?g.concat(f):[g].concat(f):g})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Np(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Np(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,i){Array.isArray(i)&&(i=i[0]);let o;if(this.returnSequences?this.mergeMode==null?o=[i,i]:o=i:this.mergeMode==null?o=[null,null]:o=null,this.returnState){const l=this.forwardLayer.states.map(u=>null);return Array.isArray(o)?o.concat(l).concat(l):[o].concat(l).concat(l)}else return o}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},i=super.getConfig();return Object.assign(t,i),t}static fromConfig(t,i){const o=sh(i.layer);if(delete i.layer,i.numConstants!=null)throw new hi("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const l=i;return l.layer=o,new t(l)}}a3.className="Bidirectional",Lt(a3);/**
* @license
* Copyright 2022 CodeSmith LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/class o3 extends Bi{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},i=super.getConfig();return Object.assign(t,i),t}call(t,i){return $e(()=>(t=ti(t),t.dtype!=="float32"&&(t=Kb(t,"float32")),Ut(Oe(t,this.scale),this.offset)))}}o3.className="Rescaling",Lt(o3);/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/Ee().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,s=>{s&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/var l3;(function(s){s[s.DT_INVALID=0]="DT_INVALID",s[s.DT_FLOAT=1]="DT_FLOAT",s[s.DT_DOUBLE=2]="DT_DOUBLE",s[s.DT_INT32=3]="DT_INT32",s[s.DT_UINT8=4]="DT_UINT8",s[s.DT_INT16=5]="DT_INT16",s[s.DT_INT8=6]="DT_INT8",s[s.DT_STRING=7]="DT_STRING",s[s.DT_COMPLEX64=8]="DT_COMPLEX64",s[s.DT_INT64=9]="DT_INT64",s[s.DT_BOOL=10]="DT_BOOL",s[s.DT_QINT8=11]="DT_QINT8",s[s.DT_QUINT8=12]="DT_QUINT8",s[s.DT_QINT32=13]="DT_QINT32",s[s.DT_BFLOAT16=14]="DT_BFLOAT16",s[s.DT_QINT16=15]="DT_QINT16",s[s.DT_QUINT16=16]="DT_QUINT16",s[s.DT_UINT16=17]="DT_UINT16",s[s.DT_COMPLEX128=18]="DT_COMPLEX128",s[s.DT_HALF=19]="DT_HALF",s[s.DT_RESOURCE=20]="DT_RESOURCE",s[s.DT_VARIANT=21]="DT_VARIANT",s[s.DT_UINT32=22]="DT_UINT32",s[s.DT_UINT64=23]="DT_UINT64",s[s.DT_FLOAT_REF=101]="DT_FLOAT_REF",s[s.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",s[s.DT_INT32_REF=103]="DT_INT32_REF",s[s.DT_UINT8_REF=104]="DT_UINT8_REF",s[s.DT_INT16_REF=105]="DT_INT16_REF",s[s.DT_INT8_REF=106]="DT_INT8_REF",s[s.DT_STRING_REF=107]="DT_STRING_REF",s[s.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",s[s.DT_INT64_REF=109]="DT_INT64_REF",s[s.DT_BOOL_REF=110]="DT_BOOL_REF",s[s.DT_QINT8_REF=111]="DT_QINT8_REF",s[s.DT_QUINT8_REF=112]="DT_QUINT8_REF",s[s.DT_QINT32_REF=113]="DT_QINT32_REF",s[s.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",s[s.DT_QINT16_REF=115]="DT_QINT16_REF",s[s.DT_QUINT16_REF=116]="DT_QUINT16_REF",s[s.DT_UINT16_REF=117]="DT_UINT16_REF",s[s.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",s[s.DT_HALF_REF=119]="DT_HALF_REF",s[s.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",s[s.DT_VARIANT_REF=121]="DT_VARIANT_REF",s[s.DT_UINT32_REF=122]="DT_UINT32_REF",s[s.DT_UINT64_REF=123]="DT_UINT64_REF"})(l3||(l3={}));var c3;(function(s){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(s.CheckpointFormatVersion||(s.CheckpointFormatVersion={}))})(c3||(c3={}));/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/var u3;(function(s){s[s.FAIL=0]="FAIL",s[s.SHORTEST=1]="SHORTEST",s[s.LONGEST=2]="LONGEST"})(u3||(u3={}));/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yn(s,t){Array.isArray(s)||(s=[s]),s.forEach(i=>{i!=null&&E(i.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const S4=Ji;class fw extends c{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new a(this,os())}nextDataId(){return fw.nextDataId++}write(t,i,o){this.firstUse&&(this.firstUse=!1,Ee().get("IS_NODE")&&sa(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const l={id:this.nextDataId()};return this.data.set(l,{values:t,dtype:o,refCount:1}),l}makeTensorInfo(t,i,o){let l;if(i==="string"&&o!=null&&o.length>0&&de(o[0])){const u=o.map(f=>ri(f));l=this.write(u,t,i)}else l=this.write(o,t,i);return{dataId:l,shape:t,dtype:i}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const i=this.data.get(t);i.refCount++}decRef(t){if(this.data.has(t)){const i=this.data.get(t);i.refCount--}}move(t,i,o,l,u){this.data.set(t,{values:i,dtype:l,refCount:u})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:i,complexTensorInfos:o}=this.data.get(t);if(i==="complex64"){const l=this.readSync(o.real.dataId),u=this.readSync(o.imag.dataId);return th(l,u)}return this.data.get(t).values}bufferSync(t){const i=this.readSync(t.dataId);if(t.dtype==="string")try{const o=i.map(l=>oa(l));return On(t.shape,t.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return On(t.shape,t.dtype,i)}makeOutput(t,i,o){return os().makeTensorFromTensorInfo(this.makeTensorInfo(i,o,t),this)}disposeData(t,i=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!i&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:o}=this.data.get(t);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const i=wi();return t(),{kernelMs:wi()-i}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){yn([t],"where");const i=this.readSync(t.dataId);return S4(t.shape,i)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}fw.nextDataId=0;/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function I4(s){const t=new Float32Array(s.length);for(let i=0;i<s.length;++i)t[i]=Math.abs(s[i]);return t}const T4={kernelName:At,backendName:"cpu",kernelFunc:s=>{const{x:t}=s.inputs,i=s.backend;yn(t,"abs");let o=new Float32Array(N(t.shape));const l=i.data.get(t.dataId).values;return o=I4(l),i.makeOutput(o,t.shape,t.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lr(s){return(t,i,o,l,u)=>{const f=$n(t,i),g=f.length,A=Ne(f),v=N(f),C=re(u,v),S=t.length,M=i.length,_=Ne(t),B=Ne(i),F=Pl(t,f),P=Pl(i,f);if(F.length+P.length===0)for(let U=0;U<C.length;++U)C[U]=s(o[U%o.length],l[U%l.length]);else for(let U=0;U<C.length;++U){const V=Ot(U,g,A),$=V.slice(-S);F.forEach(me=>$[me]=0);const q=_t($,S,_),ne=V.slice(-M);P.forEach(me=>ne[me]=0);const he=_t(ne,M,B);C[U]=s(o[q],l[he])}return[C,f]}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xo(s){const{inputs:t,backend:i}=s,{real:o,imag:l}=t,u=i.data.get(o.dataId).values,f=i.data.get(l.dataId).values,g=i.makeTensorInfo(o.shape,"complex64"),A=i.data.get(g.dataId);return A.complexTensorInfos={real:i.makeTensorInfo(o.shape,"float32",u),imag:i.makeTensorInfo(l.shape,"float32",f)},g}const M4={kernelName:Ki,backendName:"cpu",kernelFunc:xo};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pw(s,t,i="float32"){if(i==="complex64"){const l=pw(s,t,"float32"),u=pw(s,t,"float32");return xo({inputs:{real:l,imag:u},backend:s})}const o=Tt(N(t),i);return s.makeTensorInfo(t,i,o)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cu(s){const{inputs:t,backend:i}=s,{x:o}=t;return i.incRef(o.dataId),{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}const _4={kernelName:Sr,backendName:"cpu",kernelFunc:cu};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gp(s){const{inputs:t,backend:i}=s,{input:o}=t,l=i.data.get(o.dataId).complexTensorInfos.real,u=i.data.get(l.dataId).values;return i.makeTensorInfo(l.shape,l.dtype,u)}const R4={kernelName:dA,backendName:"cpu",kernelFunc:Gp};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function k4(s,t,i,o){if(o==="int32"){const l=Int32Array.from(s);return[t,"int32",l]}if(o==="bool"){const l=Gs([0],i),[u,f]=lr((g,A)=>g!==A?1:0)(t,[],s,l,"bool");return[f,"bool",u]}throw new Error(`Error in Cast: failed to cast ${i} to ${o}`)}function Bd(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{dtype:u}=o;if(u==="complex64"){if(l.dtype==="complex64")return cu({inputs:{x:l},backend:i});const C=pw(i,l.shape,l.dtype),S=Bd({inputs:{x:l},backend:i,attrs:{dtype:"float32"}}),M=xo({inputs:{real:S,imag:C},backend:i});return i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(S),M}if(l.dtype==="complex64"){const C=Gp({inputs:{input:l},backend:i}),S=Bd({inputs:{x:C},backend:i,attrs:{dtype:u}});return i.disposeIntermediateTensorInfo(C),S}if(!Re(l.dtype,u)){const C=cu({inputs:{x:l},backend:i});return{dataId:C.dataId,shape:C.shape,dtype:u}}const f=i.data.get(l.dataId).values,[g,A,v]=k4(f,l.shape,l.dtype,u);return i.makeTensorInfo(g,A,v)}const B4={kernelName:qt,backendName:"cpu",kernelFunc:Bd};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rr(s,t,i,o){return i==null?({inputs:l,backend:u})=>{const{a:f,b:g}=l,A=u;yn([f,g],s);const v=A.data.get(f.dataId).values,C=A.data.get(g.dataId).values,S=f.dtype==="string"?nh(v):v,M=f.dtype==="string"?nh(C):C,_=o||f.dtype,[B,F]=t(f.shape,g.shape,S,M,_);return A.makeTensorInfo(F,_,B)}:({inputs:l,backend:u})=>{const{a:f,b:g}=l,A=u;if(f.dtype==="complex64"||g.dtype==="complex64"){const v=Bd({inputs:{x:f},backend:A,attrs:{dtype:"complex64"}}),C=A.data.get(v.dataId),S=C.complexTensorInfos.real,M=C.complexTensorInfos.imag,_=A.data.get(S.dataId).values,B=A.data.get(M.dataId).values,F=Bd({inputs:{x:g},backend:A,attrs:{dtype:"complex64"}}),P=A.data.get(F.dataId),U=P.complexTensorInfos.real,V=P.complexTensorInfos.imag,$=A.data.get(U.dataId).values,q=A.data.get(V.dataId).values,[ne,he,me]=i(f.shape,g.shape,_,B,$,q),pe=A.makeTensorInfo(me,"float32",ne),ye=A.makeTensorInfo(me,"float32",he),Te=xo({inputs:{real:pe,imag:ye},backend:A});return A.disposeIntermediateTensorInfo(v),A.disposeIntermediateTensorInfo(F),A.disposeIntermediateTensorInfo(pe),A.disposeIntermediateTensorInfo(ye),Te}else{const v=A.data.get(f.dataId).values,C=A.data.get(g.dataId).values,S=o||f.dtype,[M,_]=t(f.shape,g.shape,v,C,S);return A.makeTensorInfo(_,S,M)}}}function CT(s){return(t,i,o,l,u,f)=>{const g=$n(t,i),A=N(g),v=g.length,C=Ne(g),S=re("float32",A),M=re("float32",A),_=Pl(t,g),B=Pl(i,g),F=th(o,l),P=th(u,f),U=t.length,V=Ne(t),$=i.length,q=Ne(i);if(_.length+B.length===0)for(let ne=0;ne<S.length;ne++){const he=ne%F.length,me=ne%P.length,pe=s(F[he*2],F[he*2+1],P[me*2],P[me*2+1]);S[ne]=pe.real,M[ne]=pe.imag}else for(let ne=0;ne<S.length;ne++){const he=Ot(ne,v,C),me=he.slice(-U);_.forEach(et=>me[et]=0);const pe=_t(me,U,V),ye=he.slice(-$);B.forEach(et=>ye[et]=0);const Te=_t(ye,$,q),Ye=s(F[pe*2],F[pe*2+1],P[Te*2],P[Te*2+1]);S[ne]=Ye.real,M[ne]=Ye.imag}return[S,M,g]}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const L4=lr((s,t)=>s+t),N4=CT((s,t,i,o)=>({real:s+i,imag:t+o})),Jg=Rr(se,L4,N4),D4={kernelName:se,backendName:"cpu",kernelFunc:Jg};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function h3(s,t,i,o,l){const u=N(o),f=Tt(l,i);for(let g=0;g<s.length;g++){const A=s[g];if(A<0)throw new Error("Input x must be non-negative!");A>=l||(u>0?f[A]+=t[g]:f[A]+=1)}return f}function F4(s,t,i,o=!1){const l=s.shape[0],u=s.shape[1],f=On([l,i],t.dtype);for(let g=0;g<l;g++)for(let A=0;A<u;A++){const v=s.get(g,A);if(v<0)throw new Error("Input x must be non-negative!");v>=i||(o?f.set(1,g,v):t.size>0?f.set(f.get(g,v)+t.get(g,A),g,v):f.set(f.get(g,v)+1,g,v))}return f}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function e0(s){return(t,i,o)=>{const l=re(i,t.length);for(let u=0;u<t.length;++u)l[u]=s(t[u],o);return l}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function is(s,t,i){return({inputs:o,attrs:l,backend:u})=>{const{x:f}=o;if(yn(f,s),f.dtype==="string"||i==="string")throw new Error("unaryKernelFunc does not support string input/output");const g=u,A=g.data.get(f.dataId).values,v=N(f.shape),C=i||f.dtype,S=Y(C,v);for(let M=0;M<v;++M)S[M]=t(A[M],l);return g.makeTensorInfo(f.shape,C,S)}}function t0(s,t,i){return({inputs:o,attrs:l,backend:u})=>{const{x:f}=o;if(yn(f,s),f.dtype==="string"||i==="string")throw new Error("unaryKernelFunc does not support string input/output");const g=u,A=g.data.get(f.dataId).values,v=i||f.dtype,C=t(A,v,l);return g.makeTensorInfo(f.shape,v,C)}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const O4=e0(s=>Math.ceil(s)),G4=t0(mn,O4),U4={kernelName:mn,backendName:"cpu",kernelFunc:G4};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function P4(s,t,i,o){const l=Y(i,N(t));if(o&&i!=="string"){let u=0;s.forEach(f=>{const g=N(f.shape);l.set(f.vals,u),u+=g})}else{let u=0;s.forEach(f=>{const g=i==="string"?nh(f.vals):f.vals;let A=0;for(let v=0;v<f.shape[0];++v){const C=v*t[1]+u;for(let S=0;S<f.shape[1];++S)l[C+S]=g[A++]}u+=f.shape[1]})}return l}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const z4=lr((s,t)=>s===t?1:0),d3=Rr(ln,z4,null,"bool"),V4={kernelName:ln,backendName:"cpu",kernelFunc:d3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const W4=e0(s=>Math.exp(s)),f3=t0(Dn,W4,"float32"),H4={kernelName:Dn,backendName:"cpu",kernelFunc:f3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const X4=e0(s=>Math.expm1(s)),Q4=t0(Mn,X4),K4={kernelName:Mn,backendName:"cpu",kernelFunc:Q4};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Z4=e0(s=>Math.floor(s)),$4=t0(ss,Z4),Y4={kernelName:ss,backendName:"cpu",kernelFunc:$4};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function j4(s,t,i,o,l,u,f,g,A){const v=On([o,u],i);for(let C=0;C<o;C++){const S=[];let M=0;for(let _=0;_<l;_++){const B=s[C*l+_];M+=B*f[_],S.push(B)}if(M<0||M>=A/u)throw new Error(`Invalid indices: ${S} does not index into ${g}`);for(let _=0;_<u;_++)v.values[C*u+_]=t.get(...t.indexToLoc(M*u+_))}return v}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function q4(s,t,i){const o=On(i,s.dtype);for(let l=0;l<o.size;++l){const u=o.indexToLoc(l).slice(),f=u[0],g=u[2],A=t.locToIndex([f,g]);u[2]=t.values[A];const v=s.locToIndex(u);0<=v&&v<s.values.length&&(o.values[l]=s.values[v])}return o}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const J4=lr((s,t)=>s>t?1:0),eQ=Rr(Qn,J4,null,"bool"),tQ={kernelName:Qn,backendName:"cpu",kernelFunc:eQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const nQ=lr((s,t)=>s>=t?1:0),iQ=Rr(Ws,nQ,null,"bool"),sQ={kernelName:Ws,backendName:"cpu",kernelFunc:iQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rQ=lr((s,t)=>s<t?1:0),aQ=Rr(lo,rQ,null,"bool"),oQ={kernelName:lo,backendName:"cpu",kernelFunc:aQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lQ=lr((s,t)=>s<=t?1:0),cQ=Rr(co,lQ,null,"bool"),uQ={kernelName:co,backendName:"cpu",kernelFunc:cQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hQ(s,t,i){const o=(t-s)/(i-1),l=Tt(i,"float32");l[0]=s;for(let u=1;u<l.length;u++)l[u]=l[u-1]+o;return l}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dQ=e0(s=>Math.log(s)),fQ=t0(of,dQ),pQ={kernelName:of,backendName:"cpu",kernelFunc:fQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mQ(s,t,i,o){const l=re(o,N(i));for(let u=0;u<l.length;++u){const f=u*t;let g=s[f];for(let A=0;A<t;++A){const v=s[f+A];(Number.isNaN(v)||v>g)&&(g=v)}l[u]=g}return l}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gQ=lr((s,t)=>Math.max(s,t)),AQ=Rr(Oh,gQ),bQ={kernelName:Oh,backendName:"cpu",kernelFunc:AQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yQ=lr((s,t)=>Math.min(s,t)),vQ=Rr(Ph,yQ),xQ={kernelName:Ph,backendName:"cpu",kernelFunc:vQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const p3=lr((s,t)=>s*t),wQ=CT((s,t,i,o)=>({real:s*i-t*o,imag:s*o+t*i})),mw=Rr(dr,p3,wQ),CQ={kernelName:dr,backendName:"cpu",kernelFunc:mw};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function EQ(s,t,i){const o=Do(-1,i);return p3([],t,o,s,i)}function SQ(s){const{inputs:t,backend:i}=s,{x:o}=t;yn(o,"neg");const l=i.data.get(o.dataId).values,[u,f]=EQ(l,o.shape,o.dtype);return i.makeTensorInfo(f,o.dtype,u)}const IQ={kernelName:sl,backendName:"cpu",kernelFunc:SQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const TQ=lr((s,t)=>s!==t?1:0),MQ=Rr(_u,TQ,null,"bool"),_Q={kernelName:_u,backendName:"cpu",kernelFunc:MQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function m3(s,t,i,o,l){const u=t.length,f=N(t),g=Ne(t),A=Ne(l),v=re(i,N(l));for(let C=0;C<f;++C){const S=Ot(C,u,g),M=new Array(S.length);for(let B=0;B<M.length;B++)M[B]=S[o[B]];const _=_t(M,u,A);v[_]=s[C]}return v}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ka(s){const{inputs:t,attrs:i,backend:o}=s,{x:l}=t,{perm:u}=i;yn(l,"transpose");const f=l.shape.length,g=new Array(f);for(let C=0;C<g.length;C++)g[C]=l.shape[u[C]];const A=o.data.get(l.dataId).values,v=m3(A,l.shape,l.dtype,u,g);return{dataId:o.write(v,g,l.dtype),shape:g,dtype:l.dtype}}const RQ={kernelName:Du,backendName:"cpu",kernelFunc:Ka};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kQ(s,t,i,o){const[l,u]=Ei(s,o),f=ar(t,"int32"),g=Tt(N(l),f),A=N(u);for(let v=0;v<g.length;++v){const C=v*A;let S=1;for(let M=0;M<A;++M)S*=i[C+M];g[v]=S}return{outVals:g,outShape:l,outDtype:f}}function BQ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o;yn(l,"prod");const g=l.shape.length,A=J(u,l.shape),v=ji(A,g);let C=A,S=l;const M=[];v!=null&&(S=Ka({inputs:{x:l},backend:i,attrs:{perm:v}}),M.push(S),C=Ss(C.length,g));const _=i.data.get(S.dataId).values,{outVals:B,outShape:F,outDtype:P}=kQ(S.shape,S.dtype,_,C);let U=F;return f&&(U=ts(F,A)),M.forEach(V=>i.disposeIntermediateTensorInfo(V)),i.makeTensorInfo(U,P,B)}const LQ={kernelName:Fm,backendName:"cpu",kernelFunc:BQ};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function NQ(s,t,i){s.forEach((o,l)=>{if(o<0||o>=i){const u=Ot(l,t.length,Ne(t)).join(",");throw new Error(`indices[${u}] = ${o} is not in [0, ${i})`)}})}function DQ(s,t){for(let i=0;i<s.length;++i){const o=s[i],l=i===s.length-1?t:s[i+1].length;if(o.length===0)throw new Error("Ragged splits may not be empty");if(o[0]<0)throw new Error("Ragged splits must be non-negative");if(o[o.length-1]>l)throw new Error("Ragged splits must not point past values");for(let u=1;u<o.length;++u)if(o[u-1]>o[u])throw new Error("Ragged splits must be sorted in ascending order")}}function FQ(s,t,i,o){const l=[];let u=0;const f=t.length-1+i.length,g=new Array(f).fill(null).map(()=>[0]);DQ(i,o);let A=1;for(let v=0;v<t.length-1;++v){A*=t[v];const C=t[v+1];for(let S=1;S<A+1;++S)g[v].push(S*C)}for(let v=0;v<s.length;++v){let C=s[v],S=s[v]+1;for(let M=0;M<i.length;++M){const _=i[M],B=M+t.length-1;if(B>=0){const F=g[B],P=F[F.length-1]-_[C];for(let U=C;U<S;++U)g[B].push(_[U+1]+P)}C=_[C],S=_[S]}S!==C&&(l.push([C,S]),u+=S-C)}return{outSplits:g,valueSlices:l,numValues:u}}function OQ(s){const t=[];for(let i=0;i<s.length;++i){const o=s[i].length,l=Y("int32",o);t.push(l),s[i].forEach((u,f)=>l[f]=u)}return t}function g3(s,t){const i=s.slice(0,t);for(;i.length<t;)i.push(1);for(let o=t;o<s.length;o++)i[t-1]*=s[o];return i}function GQ(s,t,i,o,l,u){const f=g3(t,2)[1],g=g3(u,2)[1];let A=0;for(const v of i)for(let C=v[0];C<v[1];++C){for(let S=0;S<o;++S)l[A*g+S]=s[C*f+S];++A}}function UQ(s,t,i,o,l){const u=t.slice();u[0]=l;const f=Y(i,N(u)),g=s.length,A=g===0?0:g/t[0];return GQ(s,t,o,A,f,u),[f,u]}function PQ(s,t,i,o,l,u,f,g){if(s.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const A=t[0][0]-1;if(NQ(u,f,A),o.length===0)throw new Error("params.rank must be nonzero");const v=o[0],{outSplits:C,valueSlices:S,numValues:M}=FQ(u,f,s,v),_=OQ(C),B=UQ(i,o,l,S,M);return[_,B[0],B[1]]}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var Cl=bl;let zQ=class QR{constructor(t,i,o,l,u,f,g,A,v,C){this.shape=t,this.shapeShape=i,this.values=o,this.valuesShape=l,this.valuesDType=u,this.defaultValue=f,this.defaultValueShape=g,this.rowPartitionValues=A,this.rowPartitionValuesShapes=v,this.rowPartitionTypes=rI(C),this.raggedRank=aI(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Cl.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Cl.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const i=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Cl.VALUE_ROWIDS:return QR.getMaxWidthValueRowID(i);case Cl.ROW_SPLITS:return QR.getMaxWidthRowSplit(i);default:throw new Error(`Cannot handle partition type ${Cl[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const i=t.length;if(i===0||i===1)return 0;let o=0;for(let l=0;l<i-1;++l){const u=t[l+1]-t[l];u>o&&(o=u)}return o}static getMaxWidthValueRowID(t){const i=t.length;if(i===0)return 0;let o=0,l=t[0],u=0;for(let f=1;f<i;++f){const g=t[f];g!==l&&(l=g,u=Math.max(f-o,u),o=f)}return Math.max(i-o,u)}tensorShapeFromTensor(t,i,o=!0){if(i.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return b3(t,o)}calculateOutputSize(t){const i=this.valuesShape,o=this.defaultValueShape;oI(o,i);const l=this.tensorShapeFromTensor(this.shape,this.shapeShape),u=sI(this.raggedRank,l,i);u[0]<0&&(u[0]=t);for(let f=1;f<=this.raggedRank;++f)u[f]<0&&(u[f]=this.getMaxWidth(f));return u}calculateFirstParentOutputIndex(t,i,o){const l=Math.min(t,o),u=[];let f=0;for(let g=0;g<l;++g,f+=i)u.push(f);for(let g=l;g<t;++g)u.push(-1);return E(u.length===t,()=>"Final length of result must be equal to firstDimension."),u}calculateOutputIndexRowSplit(t,i,o,l){const u=t.length,f=[];for(let g=0;g<u-1;++g){const A=t[g+1]-t[g];let v=Math.min(l,A),C=i[g];C===-1&&(v=0);for(let S=0;S<v;++S)f.push(C),C+=o;for(let S=0;S<A-v;++S)f.push(-1)}if(u>0&&f.length!==t[u-1])throw new Error("Invalid row split size.");return f}calculateOutputIndexValueRowID(t,i,o,l){const u=t.length,f=[];if(u===0)return[];let g=0,A=t[0];if(A>=i.length)throw new Error(`Got currentValueRowId=${A}, which is not less than ${i.length}`);let v=i[A];f.push(v);for(let C=1;C<u;++C){const S=t[C];if(S===A)v>=0&&(++g,g<l?v+=o:v=-1);else{if(g=0,A=S,S>=i.length)throw new Error(`Got nextValueRowId=${S} which is not less than ${i.length}`);v=i[S]}f.push(v)}if(f.length!==t.length)throw new Error("Invalid row ids.");return f}calculateOutputIndex(t,i,o,l){const u=this.getRowPartitionTensor(t),f=this.getRowPartitionTypeByDimension(t);switch(f){case Cl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(u,i,o,l);case Cl.ROW_SPLITS:if(u.length-1>i.length)throw new Error(`Row partition size is greater than output size: ${u.length-1} > ${i.length}`);return this.calculateOutputIndexRowSplit(u,i,o,l);default:throw new Error(`Unsupported partition type: ${Cl[f]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const i=this.rowPartitionTypes[0];switch(i){case Cl.FIRST_DIM_SIZE:return t[0];case Cl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Cl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Cl[i]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),i=this.calculateOutputSize(t),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let f=o.length-2;f>=0;--f)o[f]=o[f+1]*i[f+1];const l=b3(i,!1),u=Y(this.valuesDType,N(l));if(o[0]*i[0]>0){let f=this.calculateFirstParentOutputIndex(t,o[0],i[0]);for(let g=1;g<=this.raggedRank;++g)f=this.calculateOutputIndex(g-1,f,o[g],i[g]);this.setOutput(this.raggedRank,f,u,l)}return[l,u]}setOutput(t,i,o,l){if(o.length===0)return;const u=this.values,f=o;let g=l.slice();g=g.slice(t+1);const A=N(g),v=i.length;let C=this.defaultValue;if(C.length!==A&&C.length!==1){const B=this.defaultValueShape;$e(()=>{const F=He(C,B);C=_s(F,g).dataSync()})}let S=0,M=0,_=0;for(let B=0;B<=v;++B){let F=B<v?i[B]:-1;if(F===_){++_;continue}if(M<_){const P=u.subarray(S*A),U=f.subarray(M*A),V=(_-M)*A;A3(U,P,V)}if(B>=v){const P=o.length;F=Math.floor(P/A)}if(F>_)if(this.defaultValue.length===1)f.subarray(_*A,F*A).fill(this.defaultValue[0]),_=F;else for(;F>_;){const P=f.slice(_*A);A3(P,C,A),++_}F<0?(S=B+1,M=_):(S=B,M=_,_=M+1)}}};function A3(s,t,i){for(let o=0;o<i;o++)s[o]=t[o]}function b3(s,t){const i=[];for(let o of s){if(o<0){if(!t)throw new Error(`Dimension ${o} must be >= 0`);if(o<-1)throw new Error(`Dimension ${o} must be >= -1`);o=-1}i.push(o)}return i}function VQ(s,t,i,o,l,u,f,g,A,v){return new zQ(s,t,i,o,l,u,f,g,A,v).compute()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function WQ(s,t,i,o){const l=s===t,u=s<t&&i<0,f=t<s&&i>1;if(l||u||f)return Tt(0,o);const g=Math.abs(Math.ceil((t-s)/i)),A=Tt(g,o);t<s&&i===1&&(i=-1),A[0]=s;for(let v=1;v<A.length;v++)A[v]=A[v-1]+i;return A}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const HQ=e0(s=>1/Math.sqrt(s)),XQ=t0(gf,HQ),QQ={kernelName:gf,backendName:"cpu",kernelFunc:XQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ly(s,t,i,o,l,u,f,g,A,v){const C=[o/l,l],S=s.values,M=t.values;if(o===0)return On(i,t.dtype);const _=On(C,t.dtype);typeof A=="string"||typeof A=="number"?_.values.fill(A):typeof A=="boolean"&&_.values.fill(+A);for(let B=0;B<u;B++){const F=[];let P=0;for(let U=0;U<f;U++){const V=S[B*f+U];F.push(V),P+=V*g[U]}if(P<0||P>=o/l)throw new Error(`Invalid indices: ${F} does not index into ${i}`);for(let U=0;U<l;U++)v?_.values[P*l+U]+=M[B*l+U]:_.values[P*l+U]=t.rank===0?M[0]:M[B*l+U]}return _}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const y3=is(xf,s=>1/(1+Math.exp(-s))),KQ={kernelName:xf,backendName:"cpu",kernelFunc:y3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ZQ(s,t,i,o,l){const u=Ku(o,t,i),f=N(i),g=Ne(o);if(u){const S=np(t,g);return l==="string"?s.slice(S,S+f):s.subarray(S,S+f)}const A=l==="string"?nh(s):s,v=On(o,l,A),C=On(i,l);for(let S=0;S<C.size;++S){const M=C.indexToLoc(S),_=M.map((B,F)=>B+t[F]);C.set(v.get(..._),...M)}return l==="string"?GI(C.values):C.values}function Up(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{begin:u,size:f}=o;yn(l,"slice");const[g,A]=ip(l,u,f);dg(l,g,A);const v=i.data.get(l.dataId).values,C=ZQ(v,g,A,l.shape,l.dtype);return i.makeTensorInfo(A,l.dtype,C)}const $Q={kernelName:Vm,backendName:"cpu",kernelFunc:Up};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function YQ(s,t,i,o,l,u,f){const g=t[0],A=u[0],v=new Array(A),C=new Array(g),S=t[1];if(A===0){if(g!==0)throw new Error(II(g));const P=Y(i,0),U=Y(l,0);return[P,[0,S],U,v,C]}let M=!0,_=0;const B=new Array(A).fill(0);for(let P=0;P<g;++P){const U=s[P*S];if(U<0)throw new Error(TI(P,U));if(U>=A)throw new Error(MI(P,U,A));++B[U],M=M&&U>=_,_=U}let F=!0;for(let P=0;P<A;++P){const U=B[P]===0;v[P]=U,F=F&&!U,B[P]=Math.max(B[P],1),P>0&&(B[P]+=B[P-1])}if(F&&M){const P=s,U=o;for(let V=0;V<g;++V)C[V]=V;return[P,[g,S],U,v,C]}else{const P=B[A-1],U=Y(i,P*S),V=Y(l,P),$=new Array(A).fill(0);for(let q=0;q<g;++q){const ne=s[q*S],he=$[ne],me=(ne===0?0:B[ne-1])+he;$[ne]++;for(let pe=0;pe<S;++pe)U[me*S+pe]=s[q*S+pe];V[me]=o[q],C[q]=me}for(let q=0;q<A;++q)if($[q]===0){const ne=q===0?0:B[q-1];U[ne*S+0]=q;for(let he=1;he<S;++he)U[ne*S+he]=0;V[ne]=f}return[U,[P,S],V,v,C]}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jQ(s,t,i,o,l){const u=N(o),f=t[0],g=l.length,A=[];let v=1,C=-1;for(let F=0;F<g;++F){const P=l[F];if(P===-1){if(C!==-1)throw new Error(_I(C,F));C=F,A.push(1)}else{if(P<0)throw new Error(RI(F,P));v*=P,A.push(P)}}if(C!==-1){if(v<=0)throw new Error(kI());const F=Math.trunc(u/v);if(v*F!==u)throw new Error(BI(o,A));A[C]=F}if(N(A)!==u)throw new Error(LI(o,A));const S=o.length,M=[];if(S>0){M[S-1]=1;for(let F=S-2;F>=0;--F)M[F]=M[F+1]*o[F+1]}const _=[];if(g>0){_[g-1]=1;for(let F=g-2;F>=0;--F)_[F]=_[F+1]*A[F+1]}const B=Y(i,f*g);for(let F=0;F<f;++F){let P=0;for(let U=0;U<S;++U)P+=s[F*S+U]*M[U];for(let U=0;U<g;++U)B[F*g+U]=Math.trunc(P/_[U]),P%=_[U]}return[B,[f,g],A]}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function v3(s,t,i,o,l,u=!1,f=0){const g=o.length,A=[t[0],s.length/t[0]],v=A[1],C=g>0?l[g-1]+1:0;if(C<0)throw new Error(Hb());const S=t.slice();S[0]=C;const M=S.reduce((V,$)=>V*$,1),_=Y(i,M);if(g===0)return C>0&&_.fill(f),[_,S];if(C<=0)throw new Error(Hb());let B=0,F=1,P=0,U=l[B];for(;;){let V=0;if(F<g){if(V=l[F],U===V){++F;continue}if(U>=V)throw new Error(NI())}if(U<0||U>=C)throw new Error(DI(U,C));U>P&&_.fill(f,P*v,U*v);for(let $=B;$<F;++$){const q=o[$];if(q<0||q>=A[0])throw new Error(FI($,o[$],A[0]));for(let ne=0;ne<v;ne++)_[U*v+ne]+=s[q*v+ne]}if(u)for(let $=0;$<v;$++)_[U*v+$]/=F-B;if(B=F,++F,P=U+1,U=V,F>g)break}return P<C&&_.fill(f,P*v,C*v),[_,S]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qQ=is(Lu,s=>Math.sqrt(s)),JQ={kernelName:Lu,backendName:"cpu",kernelFunc:qQ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const eK=lr((s,t)=>{const i=s-t;return i*i}),tK=Rr(Sf,eK),nK={kernelName:Sf,backendName:"cpu",kernelFunc:tK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iK(s,t,i,o){const l=On(s,t.dtype);for(let u=0;u<l.size;u++){const f=l.indexToLoc(u),g=new Array(f.length);for(let A=0;A<g.length;A++)g[A]=f[A]*i[A]+o[A];l.set(t.get(...g),...f)}return l}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/let sK=class{constructor(s,t,i,o,l,u){this.separator=ri(s),this.nGramWidths=t,this.leftPad=ri(i),this.rightPad=ri(o),this.padWidth=l,this.preserveShort=u}getPadWidth(s){return Math.min(this.padWidth<0?s-1:this.padWidth,s-1)}getNumNGrams(s,t){const i=this.getPadWidth(t);return Math.max(0,s+2*i-t+1)}createNGrams(s,t,i,o,l,u){for(let f=0;f<l;++f){const g=this.getPadWidth(u),A=Math.max(0,g-f),v=Math.max(0,g-(l-(f+1))),C=u-(A+v),S=t+(A>0?0:f-g);let M=0;M+=A*this.leftPad.length;for(let U=0;U<C;++U)M+=s[S+U].length;M+=v*this.rightPad.length;const _=A+v+C-1;M+=_*this.separator.length,i[o+f]=new Uint8Array(M);const B=i[o+f];let F=0;const P=U=>U.forEach(V=>B[F++]=V);for(let U=0;U<A;++U)P(this.leftPad),P(this.separator);for(let U=0;U<C-1;++U)P(s[S+U]),P(this.separator);if(C>0){P(s[S+C-1]);for(let U=0;U<v;++U)P(this.separator),P(this.rightPad)}else{for(let U=0;U<v-1;++U)P(this.rightPad),P(this.separator);P(this.rightPad)}}}compute(s,t){const i=s.length,o=t.length;if(o>0){let g=t[0];if(g!==0)throw new Error(`First split value must be 0, got ${g}`);for(let A=1;A<o;++A){let v=t[A]>=g;if(v=v&&t[A]<=i,!v)throw new Error(`Invalid split value ${t[A]}, must be in [${g}, ${i}]`);g=t[A]}if(g!==i)throw new Error(`Last split value must be data size. Expected ${i}, got ${g}`)}const l=o-1,u=Y("int32",o);if(i===0||o===0){const g=new Array(i);for(let A=0;A<=l;++A)u[A]=0;return[g,u]}u[0]=0;for(let g=1;g<=l;++g){const A=t[g]-t[g-1];let v=0;this.nGramWidths.forEach(C=>{v+=this.getNumNGrams(A,C)}),this.preserveShort&&A>0&&v===0&&(v=1),u[g]=u[g-1]+v}const f=new Array(u[l]);for(let g=0;g<l;++g){const A=t[g];let v=u[g];if(this.nGramWidths.forEach(C=>{const S=t[g+1]-t[g],M=this.getNumNGrams(S,C);this.createNGrams(s,A,f,v,M,C),v+=M}),this.preserveShort&&v===u[g]){const C=t[g+1]-t[g];if(C===0)continue;const S=C+2*this.padWidth;this.createNGrams(s,A,f,v,1,S)}}return[f,u]}};function rK(s,t,i,o,l,u,f,g){return new sK(i,o,l,u,f,g).compute(s,t)}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aK(s,t,i,o){if(!s.length)return;if(t.length===0){for(let u=0;u<s.length;++u)o.push(s.subarray(u,u+1));return}if(t.length===1){const u=t[0];let f=s.indexOf(u);for(;f!==-1;){const g=s.subarray(0,f);(!i||g.length!==0)&&o.push(g),s=s.subarray(f+1),f=s.indexOf(u)}(!i||s.length!==0)&&o.push(s);return}let l=0;for(let u=0;u<s.length+1;u++)if(u===s.length||t.indexOf(s[u])!==-1){const f=s.subarray(l,u);(!i||f.length!==0)&&o.push(f),l=u+1}}function oK(s,t,i){const o=s.length,l=[];let u=0,f=0;const g=new Array(o);for(let M=0;M<o;++M){const _=l.length;aK(s[M],t,i,l);const B=l.length-_;g[M]=B,u+=B,f=Math.max(f,B)}const A=Y("int32",u*2),v=new Array(u),C=[o,f];let S=0;for(let M=0;M<o;++M)for(let _=0;_<g[M];++_)A[S*2]=M,A[S*2+1]=_,v[S]=l[S],++S;return[A,v,C]}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function lK(s,t){const i=Y("int32",s.length);for(let o=0;o<s.length;++o)i[o]=RA(s[o]).modulo(t).getLowBitsUnsigned();return i}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cK=lr((s,t)=>s-t),uK=CT((s,t,i,o)=>({real:s-i,imag:t-o})),ET=Rr(If,cK,uK),hK={kernelName:If,backendName:"cpu",kernelFunc:ET};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function dK(s,t){const i=new Array(s.rank);for(let l=0;l<i.length;l++)i[l]=s.shape[l]*t[l];const o=On(i,s.dtype);for(let l=0;l<o.values.length;++l){const u=o.indexToLoc(l),f=new Array(s.rank);for(let A=0;A<f.length;A++)f[A]=u[A]%s.shape[A];const g=s.locToIndex(f);o.values[l]=s.values[g]}return o}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cy=(s,t)=>{const i=t.value-s.value;return i===0?s.index-t.index:i};function x3(s,t,i=0,o=s.length-1){for(;o>i;){if(o-i>600){const g=o-i+1,A=t-i+1,v=Math.log(g),C=.5*Math.exp(2*v/3),S=.5*Math.sqrt(v*C*(g-C)/g)*Math.sign(A-g/2),M=Math.max(i,Math.floor(t-A*C/g+S)),_=Math.min(o,Math.floor(t+(g-A)*C/g+S));x3(s,t,M,_)}const l=s[t];let u=i,f=o;for(w(s,i,t),cy(s[o],l)>0&&w(s,i,o);u<f;){for(w(s,u,f),u++,f--;cy(s[u],l)<0;)u=u+1;for(;cy(s[f],l)>0;)f=f-1}cy(s[i],l)===0?w(s,i,f):(f=f+1,w(s,f,o)),f<=t&&(i=f+1),t<=f&&(o=f-1)}}function fK(s,t,i,o,l){const u=t[t.length-1],[f,g]=[s.length/u,u],A=re(i,f*o),v=re("int32",f*o);for(let S=0;S<f;S++){const M=S*g,_=s.subarray(M,M+g);let B=new Array(_.length);_.forEach((V,$)=>B[$]={value:V,index:$}),o<B.length&&(x3(B,o),B=B.slice(0,o)),l&&B.sort(cy);const F=S*o,P=A.subarray(F,F+o),U=v.subarray(F,F+o);for(let V=0;V<o;V++)P[V]=B[V].value,U[V]=B[V].index}const C=t.slice();return C[C.length-1]=o,[On(C,i,A),On(C,"int32",v)]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pK(s,t,i,o){const l=J(t,i)[0],u=[1,i[0],1];for(let B=0;B<l;B++)u[0]*=i[B];u[1]=i[l];for(let B=l+1;B<i.length;B++)u[2]*=i[B];const f={},g=new Int32Array(i[l]),A=new Hs(u,o,s),v=[],C=u[0]===1&&u[2]===1;for(let B=0;B<i[l];B++){let F;if(C)F=s[B].toString();else{const P=[];for(let U=0;U<u[0];U++)for(let V=0;V<u[2];V++)P.push(A.get(U,B,V));F=P.join(",")}if(f[F]!==void 0)g[B]=f[F];else{const P=Object.keys(f).length;f[F]=P,g[B]=P,v.push(B)}}const S=u.slice();S[1]=Object.keys(f).length;const M=new Hs(S,o);v.forEach((B,F)=>{for(let P=0;P<u[0];P++)for(let U=0;U<u[2];U++)M.set(A.get(P,B,U),P,F,U)});const _=i.slice();return _[l]=S[1],{outputValues:M.values,outputShape:_,indices:g}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/YA("cpu",()=>new fw,1);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const w3=is(Nt,s=>s>=0?s:Math.exp(s)-1),mK={kernelName:Nt,backendName:"cpu",kernelFunc:w3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function C3(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{alpha:u}=o;yn([l],"leakyRelu");const f=N(l.shape),g=i.data.get(l.dataId).values,A=re("float32",f);for(let v=0;v<g.length;v++)A[v]=g[v]<0?u*g[v]:g[v];return i.makeTensorInfo(l.shape,"float32",A)}const gK={kernelName:vs,backendName:"cpu",kernelFunc:C3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const AK=lr((s,t)=>s<0?t*s:s);function E3(s){const{inputs:t,backend:i}=s,{x:o,alpha:l}=t;yn([o,l],"prelu");const u=i.data.get(o.dataId).values,f=i.data.get(l.dataId).values,[g,A]=AK(o.shape,l.shape,u,f,"float32");return i.makeTensorInfo(A,"float32",g)}const bK={kernelName:Dm,backendName:"cpu",kernelFunc:E3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const S3=is(ff,s=>Math.max(0,s)),yK={kernelName:ff,backendName:"cpu",kernelFunc:S3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const I3=is(Bu,s=>Math.min(Math.max(0,s),6)),vK={kernelName:Bu,backendName:"cpu",kernelFunc:I3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gw(s,t,i,o,l){if(i==="linear")return cu({inputs:{x:t},backend:s});if(i==="relu")return S3({inputs:{x:t},backend:s});if(i==="elu")return w3({inputs:{x:t},backend:s});if(i==="relu6")return I3({inputs:{x:t},backend:s});if(i==="prelu")return E3({inputs:{x:t,alpha:o},backend:s});if(i==="leakyrelu")return C3({inputs:{x:t},backend:s,attrs:{alpha:l}});if(i==="sigmoid")return y3({inputs:{x:t},backend:s});throw new Error(`Activation ${i} has not been implemented for the CPU backend.`)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xs(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{shape:u}=o,f=N(l.shape),g=j(u,f),A=N(g);E(f===A,()=>`The new shape (${g}) has ${A} elements and the old shape (${l.shape}) has ${f} elements. The new shape and old shape must have the same number of elements.`),i.incRef(l.dataId);const v=i.data.get(l.dataId);if(v.complexTensorInfos!=null){const C=v.complexTensorInfos.real,S=v.complexTensorInfos.imag;C.shape=g,S.shape=g}return{dataId:l.dataId,shape:g,dtype:l.dtype}}const xK={kernelName:pf,backendName:"cpu",kernelFunc:xs};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function T3(s){const{inputs:t,backend:i,attrs:o}=s,{a:l,b:u}=t,{transposeA:f,transposeB:g}=o;yn([l,u],"matMul");const A=l.shape.length,v=u.shape.length,C=f?l.shape[A-2]:l.shape[A-1],S=g?u.shape[v-1]:u.shape[v-2],M=f?l.shape[A-1]:l.shape[A-2],_=g?u.shape[v-2]:u.shape[v-1],B=l.shape.slice(0,-2),F=u.shape.slice(0,-2),P=N(B),U=N(F),V=$n(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([M,_]);E(C===S,()=>`Error in matMul: inner shapes (${C}) and (${S}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${f} and transposeB=${g} must match.`);const $=f?[P,C,M]:[P,M,C],q=g?[U,_,S]:[U,S,_],ne=xs({inputs:{x:l},backend:i,attrs:{shape:$}}),he=xs({inputs:{x:u},backend:i,attrs:{shape:q}}),me=f?ne.shape[1]:ne.shape[2],pe=f?ne.shape[2]:ne.shape[1],ye=g?he.shape[1]:he.shape[2],Te=Math.max(P,U),Ye=i.data.get(ne.dataId).values,et=i.data.get(he.dataId).values,nt=Ne(ne.shape),ht=Ne(he.shape),[ct,pt,Et]=f?[nt[0],1,nt[1]]:[nt[0],nt[1],1],[yt,It,Pt]=g?[1,ht[1],ht[0]]:[ht[1],1,ht[0]],Ft=pe*ye,Xt=On([Te,pe,ye],ne.dtype),$t=Xt.values,Yt=i.blockSize;for(let en=0;en<Te;en++)for(let _n=0;_n<pe;_n+=Yt)for(let An=0;An<ye;An+=Yt)for(let Rn=0;Rn<me;Rn+=Yt){const Kn=Math.min(_n+Yt,pe),ni=Math.min(An+Yt,ye),jn=Math.min(Rn+Yt,me);for(let Fi=_n;Fi<Kn;Fi++)for(let cs=An;cs<ni;cs++){let gs=0;for(let us=Rn;us<jn;us++){const As=Math.min(en,P-1)*ct,Ns=Math.min(en,U-1)*Pt,zs=Ye[As+Fi*pt+us*Et],oc=et[us*yt+cs*It+Ns];gs+=zs*oc}$t[en*Ft+(Fi*ye+cs)]+=gs}}return i.disposeIntermediateTensorInfo(ne),i.disposeIntermediateTensorInfo(he),i.makeTensorInfo(V,Xt.dtype,Xt.values)}const wK={kernelName:jt,backendName:"cpu",kernelFunc:T3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CK(s){const{inputs:t,backend:i,attrs:o}=s,{a:l,b:u,bias:f,preluActivationWeights:g}=t,{transposeA:A,transposeB:v,activation:C,leakyreluAlpha:S}=o;let M,_,B;const F=[];M=T3({inputs:{a:l,b:u},attrs:{transposeA:A,transposeB:v},backend:i}),f&&(_=Jg({inputs:{a:M,b:f},backend:i}),F.push(M),M=_),C&&(B=gw(i,M,C,g,S),F.push(M),M=B);for(const P of F)i.disposeIntermediateTensorInfo(P);return M}const EK={kernelName:Gr,backendName:"cpu",kernelFunc:CK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SK=is(dn,s=>Math.acos(s)),IK={kernelName:dn,backendName:"cpu",kernelFunc:SK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const TK=is(ge,s=>Math.acosh(s)),MK={kernelName:ge,backendName:"cpu",kernelFunc:TK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _K(s){const{inputs:t,backend:i}=s,o=t;yn(t,"addN");const l=o.map(g=>i.data.get(g.dataId).values),u=On(o[0].shape,o[0].dtype),f=u.values;for(let g=0;g<o.length;g++){const A=l[g];for(let v=0;v<f.length;v++)f[v]+=A[v]}return i.makeTensorInfo(u.shape,u.dtype,u.values)}const RK={kernelName:Ge,backendName:"cpu",kernelFunc:_K};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kK(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o;yn(l,"all");const g=J(u,l.shape);let A=g;const v=ji(A,l.shape.length);let C=l;v!=null&&(C=Ka({inputs:{x:l},backend:i,attrs:{perm:v}}),A=Ss(A.length,l.shape.length)),Rs("all",A,C.shape.length);const[S,M]=Ei(C.shape,A),_=N(M),B=Tt(N(S),C.dtype),F=i.data.get(C.dataId).values;for(let U=0;U<B.length;++U){const V=U*_;let $=F[V];for(let q=0;q<_;++q){const ne=F[V+q];$=$&&ne}B[U]=$}v!=null&&i.disposeIntermediateTensorInfo(C);const P=i.makeTensorInfo(S,C.dtype,B);if(f){const U=ts(S,g),V=xs({inputs:{x:P},backend:i,attrs:{shape:U}});return i.disposeIntermediateTensorInfo(P),V}return P}const BK={kernelName:ut,backendName:"cpu",kernelFunc:kK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LK(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o;yn(l,"any");const g=J(u,l.shape);let A=g;const v=ji(A,l.shape.length);let C=l;v!=null&&(C=Ka({inputs:{x:l},backend:i,attrs:{perm:v}}),A=Ss(A.length,l.shape.length)),Rs("any",A,C.shape.length);const[S,M]=Ei(C.shape,A),_=N(M),B=Tt(N(S),C.dtype),F=i.data.get(C.dataId).values;for(let U=0;U<B.length;++U){const V=U*_;let $=F[V];for(let q=0;q<_;++q){const ne=F[V+q];$=$||ne}B[U]=$}v!=null&&i.disposeIntermediateTensorInfo(C);const P=i.makeTensorInfo(S,C.dtype,B);if(f){const U=ts(S,g),V=xs({inputs:{x:P},backend:i,attrs:{shape:U}});return i.disposeIntermediateTensorInfo(P),V}return P}const NK={kernelName:kt,backendName:"cpu",kernelFunc:LK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DK(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u}=o;yn(l,"argMax");let f=J(u,l.shape);const g=ji(f,l.shape.length);let A=l;const v=[];g!=null&&(A=Ka({inputs:{x:l},backend:i,attrs:{perm:g}}),v.push(A),f=Ss(f.length,A.shape.length)),f=[f[0]],Rs("argMax",f,A.shape.length);const[C,S]=Ei(A.shape,f),M=N(C),_=Tt(M,"int32"),B=N(S),F=i.data.get(A.dataId).values;for(let P=0;P<_.length;++P){const U=P*B;let V=F[U],$=0;for(let q=0;q<B;++q){const ne=F[U+q];ne>V&&(V=ne,$=q)}_[P]=$}return v.forEach(P=>i.disposeIntermediateTensorInfo(P)),i.makeTensorInfo(C,"int32",_)}const FK={kernelName:xt,backendName:"cpu",kernelFunc:DK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OK(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u}=o;yn(l,"argMin");let f=J(u,l.shape);const g=ji(f,l.shape.length);let A=l;const v=[];g!=null&&(A=Ka({inputs:{x:l},backend:i,attrs:{perm:g}}),v.push(A),f=Ss(f.length,A.shape.length)),f=[f[0]],Rs("argMin",f,A.shape.length);const[C,S]=Ei(A.shape,f),M=N(C),_=Tt(M,"int32"),B=N(S),F=i.data.get(A.dataId).values;for(let P=0;P<_.length;++P){const U=P*B;let V=F[U],$=0;for(let q=0;q<B;++q){const ne=F[U+q];ne<V&&(V=ne,$=q)}_[P]=$}return v.forEach(P=>i.disposeIntermediateTensorInfo(P)),i.makeTensorInfo(C,"int32",_)}const GK={kernelName:fn,backendName:"cpu",kernelFunc:OK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const UK=is(Gt,s=>Math.asin(s)),PK={kernelName:Gt,backendName:"cpu",kernelFunc:UK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zK=is(Jt,s=>Math.asinh(s)),VK={kernelName:Jt,backendName:"cpu",kernelFunc:zK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const WK=is(Ln,s=>Math.atan(s)),HK={kernelName:Ln,backendName:"cpu",kernelFunc:WK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const XK=lr((s,t)=>Math.atan2(s,t)),QK=Rr(bn,XK),KK={kernelName:bn,backendName:"cpu",kernelFunc:QK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ZK=is(Zt,s=>Math.atanh(s)),$K={kernelName:Zt,backendName:"cpu",kernelFunc:ZK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ST(s,t,i,o,l,u){const f=l.strideHeight,g=l.strideWidth,A=l.dilationHeight,v=l.dilationWidth,C=l.effectiveFilterHeight,S=l.effectiveFilterWidth,M=l.padInfo.top,_=l.padInfo.left,B=u==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,F=On(l.outShape,i),P=F.values,U=l.outShape[1]*l.outShape[2]*l.outShape[3],V=l.outShape[2]*l.outShape[3],$=l.outShape[3];for(let q=0;q<l.batchSize;++q){const ne=q*U,he=q*o[0];for(let me=0;me<l.inChannels;++me)for(let pe=0;pe<l.outHeight;++pe){const ye=pe*f-M,Te=Math.max(0,ye),Ye=Math.min(l.inHeight,C+ye),et=ne+pe*V;for(let nt=0;nt<l.outWidth;++nt){const ht=nt*g-_,ct=Math.max(0,ht),pt=Math.min(l.inWidth,S+ht);let Et=B,yt=0,It=0;for(let Ft=Te;Ft<Ye;Ft+=A){const Xt=he+Ft*o[1];for(let $t=ct;$t<pt;$t+=v){const Yt=Xt+$t*o[2],en=s[Yt+me];u==="max"&&en>Et?Et=en:u==="avg"&&(yt+=en,It++)}if(isNaN(Et))break}const Pt=et+nt*$+me;P[Pt]=u==="avg"?yt/It:Et}}}return F}function M3(s,t,i,o,l=!1,u=!1){const f=On(o.outShape,"int32"),g=o.strideHeight,A=o.strideWidth,v=o.dilationHeight,C=o.dilationWidth,S=o.effectiveFilterHeight,M=o.effectiveFilterWidth,_=o.padInfo.top,B=o.padInfo.left,F=On(t,i,s);for(let P=0;P<o.batchSize;++P)for(let U=0;U<o.inChannels;++U)for(let V=0;V<o.outHeight;++V){const $=V*g-_;let q=$;for(;q<0;)q+=v;const ne=Math.min(o.inHeight,S+$);for(let he=0;he<o.outWidth;++he){const me=he*A-B;let pe=me;for(;pe<0;)pe+=C;const ye=Math.min(o.inWidth,M+me);let Te=Number.NEGATIVE_INFINITY,Ye=-1;for(let et=q;et<ne;et+=v){const nt=et-$;for(let ht=pe;ht<ye;ht+=C){const ct=ht-me,pt=F.get(P,et,ht,U);pt>Te&&(Te=pt,l?Ye=u?((P*o.inHeight+et)*o.inWidth+ht)*o.inChannels+U:(et*o.inWidth+ht)*o.inChannels+U:Ye=nt*M+ct)}}f.set(Ye,P,V,he,U)}}return f}function _3(s,t,i,o,l,u){const f=l.strideDepth,g=l.strideHeight,A=l.strideWidth,v=l.dilationDepth,C=l.dilationHeight,S=l.dilationWidth,M=l.effectiveFilterDepth,_=l.effectiveFilterHeight,B=l.effectiveFilterWidth,F=l.padInfo.front,P=l.padInfo.top,U=l.padInfo.left,V=u==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,$=On(l.outShape,i),q=$.values,ne=l.outShape[1]*l.outShape[2]*l.outShape[3]*l.outShape[4],he=l.outShape[2]*l.outShape[3]*l.outShape[4],me=l.outShape[3]*l.outShape[4],pe=l.outShape[4];for(let ye=0;ye<l.batchSize;++ye){const Te=ye*ne,Ye=ye*o[0];for(let et=0;et<l.inChannels;++et)for(let nt=0;nt<l.outDepth;++nt){const ht=nt*f-F;let ct=ht;for(;ct<0;)ct+=v;const pt=Math.min(l.inDepth,M+ht),Et=Te+nt*he;for(let yt=0;yt<l.outHeight;++yt){const It=yt*g-P;let Pt=It;for(;Pt<0;)Pt+=C;const Ft=Math.min(l.inHeight,_+It),Xt=Et+yt*me;for(let $t=0;$t<l.outWidth;++$t){const Yt=$t*A-U;let en=Yt;for(;en<0;)en+=S;const _n=Math.min(l.inWidth,B+Yt),An=Xt+$t*pe;let Rn=V,Kn=0,ni=0;for(let Fi=ct;Fi<pt;Fi+=v){const cs=Ye+Fi*o[1];for(let gs=Pt;gs<Ft;gs+=C){const us=cs+gs*o[2];for(let As=en;As<_n;As+=S){const Ns=us+As*o[3],zs=s[Ns+et];if(u==="max"&&zs>Rn?Rn=zs:u==="avg"&&(Kn+=zs,ni++),isNaN(Rn))break}if(isNaN(Rn))break}if(isNaN(Rn))break}const jn=An+et;q[jn]=u==="avg"?Kn/ni:Rn}}}}return $}function YK(s,t){const i=On(t.outShape,"int32"),o=t.strideDepth,l=t.strideHeight,u=t.strideWidth,f=t.dilationDepth,g=t.dilationHeight,A=t.dilationWidth,v=t.effectiveFilterDepth,C=t.effectiveFilterHeight,S=t.effectiveFilterWidth,M=t.padInfo.front,_=t.padInfo.top,B=t.padInfo.left;for(let F=0;F<t.batchSize;++F)for(let P=0;P<t.inChannels;++P)for(let U=0;U<t.outDepth;++U){const V=U*o-M;let $=V;for(;$<0;)$+=f;const q=Math.min(t.inDepth,v+V);for(let ne=0;ne<t.outHeight;++ne){const he=ne*l-_;let me=he;for(;me<0;)me+=g;const pe=Math.min(t.inHeight,C+he);for(let ye=0;ye<t.outWidth;++ye){const Te=ye*u-B;let Ye=Te;for(;Ye<0;)Ye+=A;const et=Math.min(t.inWidth,S+Te);let nt=Number.NEGATIVE_INFINITY,ht=-1;for(let ct=$;ct<q;ct+=f){const pt=ct-V;for(let Et=me;Et<pe;Et+=g){const yt=Et-he;for(let It=Ye;It<et;It+=A){const Pt=It-Te,Ft=s.get(F,ct,Et,It,P);Ft>=nt&&(nt=Ft,ht=pt*C*S+yt*C+Pt)}}}i.set(ht,F,U,ne,ye,P)}}}return i}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function jK(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t;yn(l,"avgPool");const{filterSize:u,strides:f,pad:g,dimRoundingMode:A}=o,v=1;E(or(f,v),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${f} and dilations '${v}'`);const C=Oa(l.shape,u,f,v,g,A);let S;if(C.filterWidth===1&&C.filterHeight===1&&O(C.inShape,C.outShape))S=cu({inputs:{x:l},backend:i});else{const M=i.data.get(l.dataId).values,_=Ne(l.shape),B=ST(M,l.shape,l.dtype,_,C,"avg");S=i.makeTensorInfo(C.outShape,l.dtype,B.values)}return S}const qK={kernelName:Jn,backendName:"cpu",kernelFunc:jK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JK(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{filterSize:u,strides:f,pad:g,dimRoundingMode:A,dataFormat:v}=o;yn(l,"avgPool3d");const C=go(l.shape,u,f,1,g,A,v),S=i.data.get(l.dataId).values,M=_3(S,l.shape,l.dtype,Ne(l.shape),C,"avg");return i.makeTensorInfo(M.shape,"float32",M.values)}const eZ={kernelName:wt,backendName:"cpu",kernelFunc:JK};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tZ(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,input:u}=t,{filterSize:f,strides:g,pad:A,dimRoundingMode:v}=o;yn([l,u],"avgPool3DGrad");const C=go(u.shape,f,g,1,A,v),S=C.strideDepth,M=C.strideHeight,_=C.strideWidth,B=C.filterDepth,F=C.filterHeight,P=C.filterWidth,U=C.dilationDepth,V=C.dilationHeight,$=C.dilationWidth,q=C.effectiveFilterDepth,ne=C.effectiveFilterHeight,he=C.effectiveFilterWidth,me=q-1-C.padInfo.front,pe=he-1-C.padInfo.left,ye=ne-1-C.padInfo.top,Te=On(u.shape,"float32"),Ye=1/(B*F*P),et=i.bufferSync(l);for(let nt=0;nt<C.batchSize;++nt)for(let ht=0;ht<C.inChannels;++ht)for(let ct=0;ct<C.inDepth;++ct)for(let pt=0;pt<C.inHeight;++pt)for(let Et=0;Et<C.inWidth;++Et){const yt=ct-me,It=pt-ye,Pt=Et-pe;let Ft=0;for(let Xt=0;Xt<q;Xt+=U){const $t=(yt+Xt)/S;if(!($t<0||$t>=C.outDepth||Math.floor($t)!==$t))for(let Yt=0;Yt<ne;Yt+=V){const en=(It+Yt)/M;if(!(en<0||en>=C.outHeight||Math.floor(en)!==en))for(let _n=0;_n<he;_n+=$){const An=(Pt+_n)/_;if(An<0||An>=C.outWidth||Math.floor(An)!==An)continue;const Rn=et.get(nt,$t,en,An,ht);Ft+=Rn}}}Te.set(Ft*Ye,nt,ct,pt,Et,ht)}return i.makeTensorInfo(Te.shape,Te.dtype,Te.values)}const nZ={kernelName:Wt,backendName:"cpu",kernelFunc:tZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iZ(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,input:u}=t,f=u;yn([l,u],"avgPoolGrad");const{filterSize:g,strides:A,pad:v}=o,C=Oa(f.shape,g,A,1,v),S=C.strideHeight,M=C.strideWidth,_=C.filterHeight,B=C.filterWidth,F=C.dilationHeight,P=C.dilationWidth,U=C.effectiveFilterHeight,V=C.effectiveFilterWidth,$=V-1-C.padInfo.left,q=U-1-C.padInfo.top,ne=On(f.shape,"float32"),he=1/(_*B),me=i.data.get(l.dataId).values,pe=On(l.shape,"float32",me);for(let ye=0;ye<C.batchSize;++ye)for(let Te=0;Te<C.inChannels;++Te)for(let Ye=0;Ye<C.inHeight;++Ye)for(let et=0;et<C.inWidth;++et){const nt=Ye-q,ht=et-$;let ct=0;for(let pt=0;pt<U;pt+=F){const Et=(nt+pt)/S;if(!(Et<0||Et>=C.outHeight||Math.floor(Et)!==Et))for(let yt=0;yt<V;yt+=P){const It=(ht+yt)/M;if(It<0||It>=C.outWidth||Math.floor(It)!==It)continue;const Pt=pe.get(ye,Et,It,Te);ct+=Pt}}ne.set(ct*he,ye,Ye,et,Te)}return i.makeTensorInfo(ne.shape,ne.dtype,ne.values)}const sZ={kernelName:ke,backendName:"cpu",kernelFunc:iZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,scale:u,offset:f,mean:g,variance:A}=t;E(g.shape.length===A.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E(f==null||g.shape.length===f.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E(u==null||g.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),yn([l,g,A,u,f],"batchNorm");let{varianceEpsilon:v}=o;v==null&&(v=.001);const C=i.data.get(l.dataId).values,S=i.data.get(g.dataId).values,M=i.data.get(A.dataId).values,_=u?i.data.get(u.dataId).values:new Float32Array([1]),B=f?i.data.get(f.dataId).values:new Float32Array([0]),F=new Float32Array(C.length),P=B.length,U=_.length,V=M.length,$=S.length;let q=0,ne=0,he=0,me=0;for(let pe=0;pe<C.length;++pe)F[pe]=B[q++]+(C[pe]-S[ne++])*_[he++]/Math.sqrt(M[me++]+v),q>=P&&(q=0),ne>=$&&(ne=0),he>=U&&(he=0),me>=V&&(me=0);return i.makeTensorInfo(l.shape,l.dtype,F)}const aZ={kernelName:Fs,backendName:"cpu",kernelFunc:rZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{blockShape:u,crops:f}=o;yn([l],"batchToSpaceND");const g=u.reduce((U,V)=>U*V),A=zb(l.shape,u,g),v=Vb(A.length,u.length),C=Wb(l.shape,u,g),S=uI(f,u.length),M=hI(C,f,u.length),_=xs({inputs:{x:l},backend:i,attrs:{shape:A}}),B=Ka({inputs:{x:_},backend:i,attrs:{perm:v}}),F=xs({inputs:{x:B},backend:i,attrs:{shape:C}}),P=Up({inputs:{x:F},backend:i,attrs:{begin:S,size:M}});return i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(F),P}const lZ={kernelName:tn,backendName:"cpu",kernelFunc:oZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,weights:u}=t,{size:f}=o,g=i.data.get(l.dataId).values,A=i.data.get(u.dataId).values,v=h3(g,A,u.dtype,u.shape,f);return i.makeTensorInfo([f],u.dtype,v)}const uZ={kernelName:cn,backendName:"cpu",kernelFunc:cZ};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hZ(s){const{inputs:t,backend:i}=s,{s0:o,s1:l}=t,u=i.data.get(o.dataId).values,f=i.data.get(l.dataId).values,g=$n(Array.from(u),Array.from(f));return i.makeTensorInfo([g.length],"int32",Int32Array.from(g))}const dZ={kernelName:nn,backendName:"cpu",kernelFunc:hZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const fZ=is(fi,(s,t)=>{const i=t;return s>i.clipValueMax?i.clipValueMax:s<i.clipValueMin?i.clipValueMin:s}),pZ={kernelName:fi,backendName:"cpu",kernelFunc:fZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mZ={kernelName:Ts,backendName:"cpu",kernelFunc:s=>{const{x:t}=s.inputs,i=s.backend,o=new Float32Array(N(t.shape)),l=i.data.get(t.dataId),u=l.complexTensorInfos.real,f=l.complexTensorInfos.imag,g=i.data.get(u.dataId).values,A=i.data.get(f.dataId).values;for(let v=0;v<g.length;v++){const C=g[v],S=A[v];o[v]=Math.hypot(C,S)}return i.makeOutput(o,t.shape,"float32")}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n0(s){const{inputs:t,backend:i}=s,{input:o}=t,l=i.data.get(o.dataId).complexTensorInfos.imag,u=i.data.get(l.dataId).values;return i.makeTensorInfo(l.shape,l.dtype,u)}const gZ={kernelName:Xr,backendName:"cpu",kernelFunc:n0};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function i0(s){const{inputs:t,backend:i,attrs:o}=s,{axis:l}=o,u=J(l,t[0].shape)[0],f=t.map(F=>F.shape);iI(f,u);let g=iu(t.map(F=>F.shape),u);if(N(g)===0)return i.makeTensorInfo(g,t[0].dtype,[]);const A=t.filter(F=>N(F.shape)>0);if(A.length===1)return cu({inputs:{x:A[0]},backend:i});if(A[0].dtype==="complex64"){const F=A.map(q=>Gp({inputs:{input:q},backend:i})),P=A.map(q=>n0({inputs:{input:q},backend:i})),U=i0({inputs:F,backend:i,attrs:{axis:u}}),V=i0({inputs:P,backend:i,attrs:{axis:u}}),$=xo({inputs:{real:U,imag:V},backend:i});return F.forEach(q=>i.disposeIntermediateTensorInfo(q)),P.forEach(q=>i.disposeIntermediateTensorInfo(q)),i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo(V),$}const v=A.map(F=>{const P=[-1,N(F.shape.slice(u))];return xs({inputs:{x:F},backend:i,attrs:{shape:P}})}),C=v.map(F=>({vals:i.data.get(F.dataId).values,shape:F.shape}));g=iu(v.map(F=>F.shape),1);const S=v[0].shape[0]===1,M=P4(C,g,t[0].dtype,S),_=iu(A.map(F=>F.shape),u),B=i.makeTensorInfo(_,t[0].dtype,M);return v.forEach(F=>i.disposeIntermediateTensorInfo(F)),B}const AZ={kernelName:ir,backendName:"cpu",kernelFunc:i0};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function R3(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u}=t,{strides:f,pad:g,dataFormat:A,dilations:v,dimRoundingMode:C}=o;yn([l,u],"conv2d");const S=pl(A),M=qs(l.shape,u.shape,f,v,g,C,!1,S),_=M.filterHeight,B=M.filterWidth,F=M.dilationHeight,P=M.dilationWidth,U=M.padInfo.left,V=M.padInfo.top,$=M.dataFormat==="channelsLast",q=new Hs(M.outShape,l.dtype),ne=Ne(l.shape),he=Ne(u.shape),me=ne[0],pe=$?ne[1]:ne[2],ye=$?ne[2]:1,Te=$?1:ne[1],Ye=q.strides[0],et=$?q.strides[1]:q.strides[2],nt=$?q.strides[2]:1,ht=$?1:q.strides[1],ct=i.data.get(l.dataId).values,pt=i.data.get(u.dataId).values,Et=q.values;for(let yt=0;yt<M.batchSize;++yt){const It=yt*me,Pt=yt*Ye;for(let Ft=0;Ft<M.outHeight;++Ft){const Xt=Pt+Ft*et,$t=Ft*M.strideHeight-V;for(let Yt=0;Yt<_;++Yt){const en=$t+Yt*F;if(en<0||en>=M.inHeight)continue;const _n=Yt*he[0],An=It+en*pe;for(let Rn=0;Rn<M.outWidth;++Rn){const Kn=Xt+Rn*nt,ni=Rn*M.strideWidth-U;for(let jn=0;jn<B;++jn){const Fi=ni+jn*P;if(Fi<0||Fi>=M.inWidth)continue;const cs=_n+jn*he[1],gs=An+Fi*ye;let us=cs;for(let As=0;As<M.inChannels;++As){const Ns=ct[gs+As*Te];for(let zs=0;zs<M.outChannels;++zs)Et[Kn+zs*ht]+=Ns*pt[us+zs];us+=M.outChannels}}}}}}return i.makeTensorInfo(q.shape,q.dtype,Et)}const bZ={kernelName:ro,backendName:"cpu",kernelFunc:R3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,dy:u}=t,{strides:f,pad:g,dataFormat:A,dimRoundingMode:v,filterShape:C}=o;yn([l,u],"conv2dBackpropFilter");const S=pl(A),M=qs(l.shape,C,f,1,g,v,!1,S),{strideHeight:_,strideWidth:B,filterHeight:F,filterWidth:P}=M,U=M.dataFormat==="channelsLast",V=new Hs(M.filterShape,"float32"),$=M.padInfo.left,q=M.padInfo.top,ne=i.data.get(l.dataId).values,he=i.data.get(u.dataId).values,me=new Hs(l.shape,l.dtype,ne),pe=new Hs(u.shape,u.dtype,he);for(let ye=0;ye<F;++ye){const Te=Math.max(0,Math.ceil((q-ye)/_)),Ye=Math.min(M.outHeight,(M.inHeight+q-ye)/_);for(let et=0;et<P;++et){const nt=Math.max(0,Math.ceil(($-et)/B)),ht=Math.min(M.outWidth,(M.inWidth+$-et)/B);for(let ct=0;ct<M.inChannels;++ct)for(let pt=0;pt<M.outChannels;++pt){let Et=0;for(let yt=0;yt<M.batchSize;++yt)for(let It=Te;It<Ye;++It){const Pt=ye+It*_-q;for(let Ft=nt;Ft<ht;++Ft){const Xt=et+Ft*B-$;U?Et+=me.get(yt,Pt,Xt,ct)*pe.get(yt,It,Ft,pt):Et+=me.get(yt,ct,Pt,Xt)*pe.get(yt,pt,It,Ft)}}V.set(Et,ye,et,ct,pt)}}}return i.makeTensorInfo(V.shape,V.dtype,V.values)}const vZ={kernelName:xc,backendName:"cpu",kernelFunc:yZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xZ(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,filter:u}=t,{inputShape:f,strides:g,pad:A,dataFormat:v,dimRoundingMode:C}=o;yn([l,u],"conv2dBackpropInput");const S=Ne(u.shape),M=Ne(l.shape);let _=pl(v);const B=qs(f,u.shape,g,1,A,C,!1,_),F=new Hs(B.inShape,"float32"),P=F.values,U=i.data.get(l.dataId).values,V=i.data.get(u.dataId).values,[$,q,ne]=S,{batchSize:he,filterHeight:me,filterWidth:pe,inChannels:ye,inHeight:Te,inWidth:Ye,outChannels:et,outHeight:nt,outWidth:ht,strideHeight:ct,strideWidth:pt}=B;_=B.dataFormat;const Et=me-1-B.padInfo.top,yt=pe-1-B.padInfo.left,It=_==="channelsLast",Pt=F.strides[0],Ft=It?F.strides[1]:F.strides[2],Xt=It?F.strides[2]:1,$t=It?1:F.strides[1],Yt=M[0],en=It?M[1]:M[2],_n=It?M[2]:1,An=It?1:M[1];for(let Rn=0;Rn<he;++Rn)for(let Kn=0;Kn<ye;++Kn)for(let ni=0;ni<Te;++ni){const jn=ni-Et,Fi=Math.max(0,Math.ceil(jn/ct)),cs=Math.min(nt,(me+jn)/ct);for(let gs=0;gs<Ye;++gs){const us=gs-yt,As=Math.max(0,Math.ceil(us/pt)),Ns=Math.min(ht,(pe+us)/pt);let zs=0;for(let De=Fi;De<cs;++De){const oe=De*ct-jn;for(let xe=As;xe<Ns;++xe){const Be=xe*pt-us,Me=Yt*Rn+en*De+_n*xe,mt=$*(me-1-oe)+q*(pe-1-Be)+ne*Kn;for(let tt=0;tt<et;++tt){const Qt=U[Me+An*tt],Cn=V[mt+tt];zs+=Qt*Cn}}}const oc=Pt*Rn+Ft*ni+Xt*gs+$t*Kn;P[oc]=zs}}return i.makeTensorInfo(F.shape,F.dtype,F.values)}const wZ={kernelName:ao,backendName:"cpu",kernelFunc:xZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function CZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u}=t,{strides:f,pad:g,dilations:A}=o;yn([l,u],"conv3d");const v=Wl(l.shape,u.shape,f,A,g),{filterDepth:C,filterHeight:S,filterWidth:M,dilationDepth:_,dilationHeight:B,dilationWidth:F,padInfo:P}=v,U=P.front,V=P.left,$=P.top,q=new Hs(v.outShape,l.dtype),ne=i.data.get(l.dataId).values,he=i.data.get(u.dataId).values,me=q.values,pe=Ne(l.shape),ye=Ne(u.shape);for(let Te=0;Te<v.batchSize;++Te){const Ye=Te*pe[0],et=Te*q.strides[0];for(let nt=0;nt<v.outDepth;++nt){const ht=et+nt*q.strides[1],ct=nt*v.strideDepth-U;for(let pt=0;pt<C;++pt){const Et=ct+pt*_;if(Et<0||Et>=v.inDepth)continue;const yt=pt*ye[0],It=Ye+Et*pe[1];for(let Pt=0;Pt<v.outHeight;++Pt){const Ft=ht+Pt*q.strides[2],Xt=Pt*v.strideHeight-$;for(let $t=0;$t<S;++$t){const Yt=Xt+$t*B;if(Yt<0||Yt>=v.inHeight)continue;const en=yt+$t*ye[1],_n=It+Yt*pe[2];for(let An=0;An<v.outWidth;++An){const Rn=Ft+An*v.outChannels,Kn=An*v.strideWidth-V;for(let ni=0;ni<M;++ni){const jn=Kn+ni*F;if(jn<0||jn>=v.inWidth)continue;const Fi=en+ni*ye[2],cs=_n+jn*v.inChannels;let gs=Fi;for(let us=0;us<v.inChannels;++us){const As=ne[cs+us];for(let Ns=0;Ns<v.outChannels;++Ns)me[Rn+Ns]+=As*he[gs+Ns];gs+=v.outChannels}}}}}}}}return i.makeTensorInfo(q.shape,q.dtype,q.values)}const EZ={kernelName:wc,backendName:"cpu",kernelFunc:CZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function SZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,dy:u}=t,{strides:f,pad:g,filterShape:A}=o;yn([l,u],"conv3dBackpropFilterV2");const v=Ne(l.shape),C=Ne(u.shape),S=Wl(l.shape,A,f,1,g),M=S.strideDepth,_=S.strideHeight,B=S.strideWidth,F=S.filterDepth,P=S.filterHeight,U=S.filterWidth,V=new Hs(S.filterShape,"float32"),$=V.values,[q,ne,he,me]=V.strides,pe=i.data.get(u.dataId).values,[ye,Te,Ye,et]=C,nt=i.data.get(l.dataId).values,[ht,ct,pt,Et]=v,yt=S.padInfo.front,It=S.padInfo.left,Pt=S.padInfo.top;for(let Ft=0;Ft<F;++Ft){const Xt=Math.max(0,Math.ceil((yt-Ft)/M)),$t=Math.min(S.outDepth,(S.inDepth+yt-Ft)/M),Yt=Ft*q;for(let en=0;en<P;++en){const _n=Math.max(0,Math.ceil((Pt-en)/_)),An=Math.min(S.outHeight,(S.inHeight+Pt-en)/_),Rn=en*ne+Yt;for(let Kn=0;Kn<U;++Kn){const ni=Math.max(0,Math.ceil((It-Kn)/B)),jn=Math.min(S.outWidth,(S.inWidth+It-Kn)/B),Fi=Kn*he+Rn;for(let cs=0;cs<S.inChannels;++cs){const gs=cs*me+Fi;for(let us=0;us<S.outChannels;++us){let As=0;for(let Ns=0;Ns<S.batchSize;++Ns){const zs=Ns*ht,oc=Ns*ye;for(let De=Xt;De<$t;++De){const oe=(Ft+De*M-yt)*ct+zs,xe=De*Te+oc;for(let Be=_n;Be<An;++Be){const Me=(en+Be*_-Pt)*pt+oe,mt=Be*Ye+xe;for(let tt=ni;tt<jn;++tt){const Qt=(Kn+tt*B-It)*Et+Me,Cn=tt*et+mt;As+=nt[Qt+cs]*pe[Cn+us]}}}}$[gs+us]=As}}}}}return i.makeTensorInfo(V.shape,V.dtype,V.values)}const IZ={kernelName:Cc,backendName:"cpu",kernelFunc:SZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function TZ(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,filter:u}=t,{pad:f,strides:g,inputShape:A}=o;yn([l],"conv3dBackpropInputV2");const v=Ne(l.shape),C=Ne(u.shape),S=Wl(A,u.shape,g,1,f),M=new Hs(S.inShape,"float32"),_=M.values,[B,F,P,U]=M.strides,V=i.data.get(l.dataId).values,[$,q,ne,he]=v,me=i.data.get(u.dataId).values,[pe,ye,Te,Ye]=C,{batchSize:et,filterDepth:nt,filterHeight:ht,filterWidth:ct,inChannels:pt,inDepth:Et,inHeight:yt,inWidth:It,outChannels:Pt,outDepth:Ft,outHeight:Xt,outWidth:$t,strideDepth:Yt,strideHeight:en,strideWidth:_n}=S,An=nt-1-S.padInfo.front,Rn=ht-1-S.padInfo.top,Kn=ct-1-S.padInfo.left;for(let ni=0;ni<et;++ni)for(let jn=0;jn<pt;++jn)for(let Fi=0;Fi<Et;++Fi){const cs=Fi-An,gs=Math.max(0,Math.ceil(cs/Yt)),us=Math.min(Ft,(nt+cs)/Yt);for(let As=0;As<yt;++As){const Ns=As-Rn,zs=Math.max(0,Math.ceil(Ns/en)),oc=Math.min(Xt,(ht+Ns)/en);for(let De=0;De<It;++De){const oe=De-Kn,xe=Math.max(0,Math.ceil(oe/_n)),Be=Math.min($t,(ct+oe)/_n);let Me=0;for(let mt=gs;mt<us;++mt){const tt=mt*Yt-cs;for(let Qt=zs;Qt<oc;++Qt){const Cn=Qt*en-Ns;for(let Bn=xe;Bn<Be;++Bn){const ft=Bn*_n-oe,Xn=$*ni+q*mt+ne*Qt+he*Bn,Ti=pe*(nt-1-tt)+ye*(ht-1-Cn)+Te*(ct-1-ft)+Ye*jn;for(let kr=0;kr<Pt;++kr){const xr=V[Xn+kr],Pw=me[Ti+kr];Me+=xr*Pw}}}}_[B*ni+F*Fi+P*As+U*De+jn]=Me}}}return i.makeTensorInfo(M.shape,M.dtype,M.values)}const MZ={kernelName:nl,backendName:"cpu",kernelFunc:TZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _Z=is(oo,s=>Math.cos(s)),RZ={kernelName:oo,backendName:"cpu",kernelFunc:_Z};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kZ=is(Ea,s=>Math.cosh(s)),BZ={kernelName:Ea,backendName:"cpu",kernelFunc:kZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LZ(s){const{inputs:t,backend:i,attrs:o}=s,{image:l,boxes:u,boxInd:f}=t,{cropSize:g,method:A,extrapolationValue:v}=o,[C,S,M,_]=l.shape,B=u.shape[0],[F,P]=g,U=On([B,F,P,_],"float32"),V=i.data.get(u.dataId).values,$=i.data.get(f.dataId).values,q=i.data.get(l.dataId).values,ne=Ne(l.shape),he=Ne(U.shape);for(let me=0;me<B;me++){const pe=me*4,ye=V[pe],Te=V[pe+1],Ye=V[pe+2],et=V[pe+3],nt=$[me];if(nt>=C)continue;const ht=F>1?(Ye-ye)*(S-1)/(F-1):0,ct=P>1?(et-Te)*(M-1)/(P-1):0;for(let pt=0;pt<F;pt++){const Et=F>1?ye*(S-1)+pt*ht:.5*(ye+Ye)*(S-1);if(Et<0||Et>S-1){for(let yt=0;yt<P;yt++)for(let It=0;It<_;It++){const Pt=It+yt*he[2]+pt*he[1]+me*he[0];U.values[Pt]=v}continue}if(A==="bilinear"){const yt=Math.floor(Et),It=Math.ceil(Et),Pt=Et-yt;for(let Ft=0;Ft<P;Ft++){const Xt=P>1?Te*(M-1)+Ft*ct:.5*(Te+et)*(M-1);if(Xt<0||Xt>M-1){for(let _n=0;_n<_;_n++){const An=_n+Ft*he[2]+pt*he[1]+me*he[0];U.values[An]=v}continue}const $t=Math.floor(Xt),Yt=Math.ceil(Xt),en=Xt-$t;for(let _n=0;_n<_;_n++){let An=_n+$t*ne[2]+yt*ne[1]+nt*ne[0];const Rn=q[An];An=_n+Yt*ne[2]+yt*ne[1]+nt*ne[0];const Kn=q[An];An=_n+$t*ne[2]+It*ne[1]+nt*ne[0];const ni=q[An];An=_n+Yt*ne[2]+It*ne[1]+nt*ne[0];const jn=q[An],Fi=Rn+(Kn-Rn)*en,cs=ni+(jn-ni)*en;An=_n+Ft*he[2]+pt*he[1]+me*he[0],U.values[An]=Fi+(cs-Fi)*Pt}}}else for(let yt=0;yt<P;++yt){const It=P>1?Te*(M-1)+yt*ct:.5*(Te+et)*(M-1);if(It<0||It>M-1){for(let Xt=0;Xt<_;Xt++){const $t=Xt+yt*he[2]+pt*he[1]+me*he[0];U.values[$t]=v}continue}const Pt=Math.round(It),Ft=Math.round(Et);for(let Xt=0;Xt<_;Xt++){const $t=Xt+Pt*ne[2]+Ft*ne[1]+nt*ne[0],Yt=Xt+yt*he[2]+pt*he[1]+me*he[0];U.values[Yt]=q[$t]}}}}return i.makeTensorInfo(U.shape,U.dtype,U.values)}const NZ={kernelName:Bo,backendName:"cpu",kernelFunc:LZ};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function DZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,exclusive:f,reverse:g}=o;yn(l,"cumprod");const A=ji([u],l.shape.length);let v=l;A!=null&&(v=Ka({inputs:{x:l},backend:i,attrs:{perm:A}}));const C=Ss(1,l.shape.length)[0];if(C!==v.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${v.shape.length-1} but got axis=${C}`);const S=ar(v.dtype,"int32"),M=zt(N(v.shape),S),_=i.data.get(v.dataId).values,B=v.shape[v.shape.length-1],F=g?(U,V)=>U+B-V-1:(U,V)=>U+V;for(let U=0;U<_.length;U+=B)for(let V=0;V<B;V++){const $=F(U,V);if(V===0)M[$]=f?1:_[$];else{const q=F(U,V-1);M[$]=f?_[q]*M[q]:_[$]*M[q]}}const P=i.makeTensorInfo(v.shape,S,M);if(A!=null){const U=gl(A),V=Ka({inputs:{x:P},backend:i,attrs:{perm:U}});return i.disposeIntermediateTensorInfo(P),i.disposeIntermediateTensorInfo(v),V}return P}const FZ={kernelName:Sa,backendName:"cpu",kernelFunc:DZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function OZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,exclusive:f,reverse:g}=o;yn(l,"cumsum");const A=ji([u],l.shape.length);let v=l;A!=null&&(v=Ka({inputs:{x:l},backend:i,attrs:{perm:A}}));const C=Ss(1,l.shape.length)[0];if(C!==v.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${v.shape.length-1} but got axis=${C}`);const S=ar(v.dtype,"int32"),M=Tt(N(v.shape),S),_=i.data.get(v.dataId).values,B=v.shape[v.shape.length-1],F=g?(U,V)=>U+B-V-1:(U,V)=>U+V;for(let U=0;U<_.length;U+=B)for(let V=0;V<B;V++){const $=F(U,V);if(V===0)M[$]=f?0:_[$];else{const q=F(U,V-1);M[$]=f?_[q]+M[q]:_[$]+M[q]}}const P=i.makeTensorInfo(v.shape,S,M);if(A!=null){const U=gl(A),V=Ka({inputs:{x:P},backend:i,attrs:{perm:U}});return i.disposeIntermediateTensorInfo(P),i.disposeIntermediateTensorInfo(v),V}return P}const GZ={kernelName:ko,backendName:"cpu",kernelFunc:OZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function UZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,weights:u}=t,{size:f,binaryOutput:g}=o;if(l.shape.length===1){const A=i.data.get(l.dataId).values,v=i.data.get(u.dataId).values,C=h3(A,v,u.dtype,u.shape,f);return i.makeTensorInfo([f],u.dtype,C)}else if(l.shape.length===2){const A=i.bufferSync(l),v=i.bufferSync(u),C=F4(A,v,f,g);return i.makeTensorInfo(C.shape,u.dtype,C.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${l.shape.length}.`)}const PZ={kernelName:Vs,backendName:"cpu",kernelFunc:UZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{blockSize:u,dataFormat:f}=o;E(f==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${f}`);const g=l.shape[0],A=l.shape[1],v=l.shape[2],C=l.shape[3],S=A*u,M=v*u,_=C/(u*u),B=i.data.get(l.dataId).values,F=new Float32Array(g*S*M*_);let P=0;for(let U=0;U<g;++U)for(let V=0;V<S;++V){const $=Math.floor(V/u),q=V%u;for(let ne=0;ne<M;++ne){const he=Math.floor(ne/u),me=ne%u,pe=(q*u+me)*_;for(let ye=0;ye<_;++ye){const Te=ye+pe+C*(he+v*($+A*U));F[P++]=B[Te]}}}return i.makeTensorInfo([g,S,M,_],l.dtype,F)}const VZ={kernelName:Bh,backendName:"cpu",kernelFunc:zZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function k3(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u}=t,{strides:f,pad:g,dilations:A,dimRoundingMode:v}=o;yn([l,u],"depthwiseConv2DNative");const C=Ne(l.shape),S=Ne(u.shape);let M=A;M==null&&(M=[1,1]),E(or(f,M),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${f} and dilations '${M}'`);const _=qs(l.shape,u.shape,f,M,g,v,!0),{filterHeight:B,filterWidth:F,dilationHeight:P,dilationWidth:U,padInfo:V}=_,$=V.left,q=V.top,ne=_.outChannels/_.inChannels,he=new Hs(_.outShape,l.dtype),me=i.data.get(l.dataId).values,pe=i.data.get(u.dataId).values,ye=he.values;for(let Te=0;Te<_.batchSize;++Te){const Ye=Te*C[0],et=Te*he.strides[0];for(let nt=0;nt<_.outHeight;++nt){const ht=et+nt*he.strides[1],ct=nt*_.strideHeight-q;for(let pt=0;pt<B;++pt){const Et=ct+pt*P;if(Et<0||Et>=_.inHeight)continue;const yt=pt*S[0],It=Ye+Et*C[1];for(let Pt=0;Pt<_.outWidth;++Pt){const Ft=ht+Pt*he.strides[2],Xt=Pt*_.strideWidth-$;for(let $t=0;$t<F;++$t){const Yt=Xt+$t*U;if(Yt<0||Yt>=_.inWidth)continue;const en=yt+$t*S[1],_n=It+Yt*_.inChannels;let An=Ft,Rn=en;for(let Kn=0;Kn<_.inChannels;++Kn){const ni=me[_n+Kn];for(let jn=0;jn<ne;++jn)ye[An+jn]+=ni*pe[Rn+jn];An+=ne,Rn+=ne}}}}}}return i.makeTensorInfo(he.shape,he.dtype,he.values)}const WZ={kernelName:Cu,backendName:"cpu",kernelFunc:k3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function HZ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,dy:u}=t,{strides:f,dilations:g,pad:A,dimRoundingMode:v,filterShape:C}=o;yn([l,u],"depthwiseConv2dNativeBackpropFilter");const S=qs(l.shape,C,f,g,A,v,!0),{strideHeight:M,strideWidth:_,filterHeight:B,filterWidth:F}=S,P=new Hs(S.filterShape,"float32"),U=S.padInfo.left,V=S.padInfo.top,$=S.outChannels/S.inChannels,q=i.data.get(l.dataId).values,ne=new Hs(l.shape,l.dtype,q),he=i.data.get(u.dataId).values,me=new Hs(u.shape,u.dtype,he);for(let pe=0;pe<B;++pe){const ye=Math.max(0,Math.ceil((V-pe)/M)),Te=Math.min(S.outHeight,(S.inHeight+V-pe)/M);for(let Ye=0;Ye<F;++Ye){const et=Math.max(0,Math.ceil((U-Ye)/_)),nt=Math.min(S.outWidth,(S.inWidth+U-Ye)/_);for(let ht=0;ht<S.outChannels;++ht){const ct=Math.trunc(ht/$),pt=ht%$;let Et=0;for(let yt=0;yt<S.batchSize;++yt)for(let It=ye;It<Te;++It){const Pt=pe+It*M-V;for(let Ft=et;Ft<nt;++Ft){const Xt=Ye+Ft*_-U;Et+=ne.get(yt,Pt,Xt,ct)*me.get(yt,It,Ft,ht)}}P.set(Et,pe,Ye,ct,pt)}}}return i.makeTensorInfo(P.shape,P.dtype,P.values)}const XZ={kernelName:Lo,backendName:"cpu",kernelFunc:HZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function QZ(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,filter:u}=t,{strides:f,dilations:g,pad:A,dimRoundingMode:v,inputShape:C}=o;yn([l,u],"depthwiseConv2DNativeBackpropInput");const S=Ne(l.shape),M=Ne(u.shape),_=qs(C,u.shape,f,g,A,v,!0),B=new Hs(_.inShape,"float32"),F=B.values,[P,U,V]=B.strides,$=i.data.get(l.dataId).values,[q,ne,he]=S,me=i.data.get(u.dataId).values,[pe,ye,Te]=M,{batchSize:Ye,filterHeight:et,filterWidth:nt,inChannels:ht,inHeight:ct,inWidth:pt,outChannels:Et,outHeight:yt,outWidth:It,strideHeight:Pt,strideWidth:Ft}=_,Xt=et-1-_.padInfo.top,$t=nt-1-_.padInfo.left,Yt=Et/ht;for(let en=0;en<Ye;++en)for(let _n=0;_n<ht;++_n)for(let An=0;An<ct;++An){const Rn=An-Xt,Kn=Math.max(0,Math.ceil(Rn/Pt)),ni=Math.min(yt,(et+Rn)/Pt);for(let jn=0;jn<pt;++jn){const Fi=jn-$t,cs=Math.max(0,Math.ceil(Fi/Ft)),gs=Math.min(It,(nt+Fi)/Ft);let us=0;for(let As=Kn;As<ni;++As){const Ns=As*Pt-Rn;for(let zs=cs;zs<gs;++zs){const oc=zs*Ft-Fi,De=q*en+ne*As+he*zs,oe=pe*(et-1-Ns)+ye*(nt-1-oc)+Te*_n;for(let xe=0;xe<Yt;++xe){const Be=_n*Yt+xe,Me=$[De+Be],mt=me[oe+xe];us+=Me*mt}}}F[P*en+U*An+V*jn+_n]=us}}return i.makeTensorInfo(B.shape,B.dtype,B.values)}const KZ={kernelName:il,backendName:"cpu",kernelFunc:QZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ZZ(s){const{inputs:t,backend:i}=s,{x:o}=t,l=N(o.shape),u=i.data.get(o.dataId).values,f=On([l,l],o.dtype),g=f.values;for(let v=0;v<u.length;v++)g[v*l+v]=u[v];const A=[...o.shape,...o.shape];return i.makeTensorInfo(A,f.dtype,f.values)}const $Z={kernelName:Lm,backendName:"cpu",kernelFunc:ZZ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const YZ={kernelName:ce,backendName:"cpu",kernelFunc:({inputs:s,backend:t,attrs:i})=>{const{x:o,filter:l}=s,{strides:u,pad:f,dilations:g}=i,A=t,v=A.data.get(o.dataId).values,C=o.shape.length,S=A.data.get(l.dataId).values,M=l.shape.length,{batchSize:_,inHeight:B,inWidth:F,inChannels:P,outHeight:U,outWidth:V,padInfo:$,strideHeight:q,strideWidth:ne,filterHeight:he,filterWidth:me,dilationHeight:pe,dilationWidth:ye,outShape:Te}=nd(o.shape,l.shape,u,f,"NHWC",g),Ye=N(Te),et=Te.length,nt=Y(o.dtype,Ye);for(let ht=0;ht<_;++ht)for(let ct=0;ct<U;++ct){const pt=ct*q-$.top;for(let Et=0;Et<V;++Et){const yt=Et*ne-$.left;for(let It=0;It<P;++It){let Pt=Number.MIN_SAFE_INTEGER;for(let Xt=0;Xt<he;++Xt){const $t=pt+Xt*pe;if($t>=0&&$t<B)for(let Yt=0;Yt<me;++Yt){const en=yt+Yt*ye;if(en>=0&&en<F){const _n=_t([ht,$t,en,It],C,Ne(o.shape)),An=_t([Xt,Yt,It],M,Ne(l.shape)),Rn=v[_n]+S[An];Rn>Pt&&(Pt=Rn)}}}const Ft=_t([ht,ct,Et,It],et,Ne(Te));nt[Ft]=Pt}}}return{dataId:A.write(Gs(nt,o.dtype),Te,o.dtype),shape:Te,dtype:o.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jZ={kernelName:st,backendName:"cpu",kernelFunc:({inputs:s,backend:t,attrs:i})=>{const{x:o,filter:l,dy:u}=s,{strides:f,pad:g,dilations:A}=i,v=t,C=bt(o.shape,v.data.get(o.dataId).values),S=bt(l.shape,v.data.get(l.dataId).values),{batchSize:M,inHeight:_,inWidth:B,inChannels:F,outHeight:P,outWidth:U,padInfo:V,strideHeight:$,strideWidth:q,filterHeight:ne,filterWidth:he,dilationHeight:me,dilationWidth:pe,outShape:ye}=nd(o.shape,l.shape,f,g,"NHWC",A);E(u.rank===ye.length,()=>`Error in ${st}, dy must have the same rank as output ${ye.length}, but got ${u.rank}`);const Te=bt(ye,v.data.get(u.dataId).values),Ye=Vt(l.shape,l.dtype);for(let et=0;et<M;++et)for(let nt=0;nt<P;++nt){const ht=nt*$-V.top;for(let ct=0;ct<U;++ct){const pt=ct*q-V.left;for(let Et=0;Et<F;++Et){let yt=Number.MIN_SAFE_INTEGER,It=0,Pt=0;for(let Ft=0;Ft<ne;++Ft){const Xt=ht+Ft*me;if(Xt>=0&&Xt<_)for(let $t=0;$t<he;++$t){const Yt=pt+$t*pe;if(Yt>=0&&Yt<B){const en=C[et][Xt][Yt][Et]+S[Ft][$t][Et];en>yt&&(yt=en,It=Ft,Pt=$t)}}}Ye[It][Pt][Et]+=Te[et][nt][ct][Et]}}}return{dataId:v.write(Gs(Ye,o.dtype),l.shape,l.dtype),shape:l.shape,dtype:l.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qZ={kernelName:We,backendName:"cpu",kernelFunc:({inputs:s,backend:t,attrs:i})=>{const{x:o,filter:l,dy:u}=s,{strides:f,pad:g,dilations:A}=i,v=t,C=bt(o.shape,v.data.get(o.dataId).values),S=bt(l.shape,v.data.get(l.dataId).values),{batchSize:M,inHeight:_,inWidth:B,inChannels:F,outHeight:P,outWidth:U,padInfo:V,strideHeight:$,strideWidth:q,filterHeight:ne,filterWidth:he,dilationHeight:me,dilationWidth:pe,outShape:ye}=nd(o.shape,l.shape,f,g,"NHWC",A);E(u.rank===ye.length,()=>`Error in ${We}, dy must have the same rank as output ${ye.length}, but got ${u.rank}`);const Te=bt(ye,v.data.get(u.dataId).values),Ye=Vt(o.shape,o.dtype);for(let et=0;et<M;++et)for(let nt=0;nt<P;++nt){const ht=nt*$-V.top;for(let ct=0;ct<U;++ct){const pt=ct*q-V.left;for(let Et=0;Et<F;++Et){let yt=Number.MIN_SAFE_INTEGER,It=ht<0?0:ht,Pt=pt<0?0:pt;for(let Ft=0;Ft<ne;++Ft){const Xt=ht+Ft*me;if(Xt>=0&&Xt<_)for(let $t=0;$t<he;++$t){const Yt=pt+$t*pe;if(Yt>=0&&Yt<B){const en=C[et][Xt][Yt][Et]+S[Ft][$t][Et];en>yt&&(yt=en,It=Xt,Pt=Yt)}}}Ye[et][It][Pt][Et]+=Te[et][nt][ct][Et]}}}return{dataId:v.write(Gs(Ye,o.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uy(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o;yn(l,"sum");let g;l.dtype==="bool"?g=Bd({inputs:{x:l},backend:i,attrs:{dtype:"int32"}}):g=cu({inputs:{x:l},backend:i});const A=g.shape.length,v=J(u,g.shape),C=ji(v,A);let S=v,M=g;C!=null&&(M=Ka({inputs:{x:g},backend:i,attrs:{perm:C}}),S=Ss(S.length,A)),Rs("sum",S,M.shape.length);const[_,B]=Ei(M.shape,S),F=ar(M.dtype,"int32");let P=pw(i,_,F);const U=N(B),V=i.data.get(P.dataId).values,$=i.data.get(M.dataId).values;for(let q=0;q<V.length;++q){const ne=q*U;let he=0;for(let me=0;me<U;++me)he+=$[ne+me];V[q]=he}if(f){const q=ts(P.shape,v),ne=P;P=xs({inputs:{x:P},backend:i,attrs:{shape:q}}),i.disposeIntermediateTensorInfo(ne)}return i.disposeIntermediateTensorInfo(g),C!=null&&i.disposeIntermediateTensorInfo(M),P}const JZ={kernelName:Mc,backendName:"cpu",kernelFunc:uy};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function e8(s){const{inputs:t,backend:i,attrs:o}=s,{equation:l}=o,u=t,{allDims:f,summedDims:g,idDims:A}=vI(l,u.length);wI(f.length,A,u);const{path:v,steps:C}=CI(g,A),S=C.length;let M=null,_=f.length;const B=[];for(let F=0;F<S;++F){for(const P of C[F]){const{permutationIndices:U,expandDims:V}=xI(_,A[P]);let $;EI(U)?$=u[P]:($=Ka({inputs:{x:u[P]},backend:i,attrs:{perm:U}}),B.push($));const q=$.shape.slice();for(let ne=0;ne<V.length;++ne)q.splice(V[ne],0,1);O($.shape,q)||($=xs({inputs:{x:$},backend:i,attrs:{shape:q}}),B.push($)),M===null?M=$:(M=mw({inputs:{a:$,b:M},backend:i}),B.push(M))}F<S-1&&(v[F]>=0&&(M=uy({inputs:{x:M},backend:i,attrs:{axis:v[F]-(f.length-_),keepDims:!1}}),B.push(M)),_--)}for(const F of B)F!==M&&i.disposeIntermediateTensorInfo(F);return M}const t8={kernelName:Xe,backendName:"cpu",kernelFunc:e8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n8(s){const{inputs:t,backend:i}=s,{dy:o,y:l}=t;yn([o,l],"eluGrad");const u=new Float32Array(N(l.shape)),f=i.data.get(l.dataId).values,g=i.data.get(o.dataId).values;for(let A=0;A<f.length;++A){const v=f[A];v>=1?u[A]=g[A]:u[A]=g[A]*(v+1)}return i.makeTensorInfo(l.shape,"float32",u)}const i8={kernelName:sn,backendName:"cpu",kernelFunc:n8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const s8=dI,r8=fI,a8=pI,o8=mI,l8=gI,c8=AI,u8=is(un,s=>{const t=Math.sign(s),i=Math.abs(s),o=1/(1+s8*i);return t*(1-((((c8*o+l8)*o+o8)*o+a8)*o+r8)*o*Math.exp(-i*i))}),h8={kernelName:un,backendName:"cpu",kernelFunc:u8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Aw(s){const{inputs:t,backend:i,attrs:o}=s,{input:l}=t,{dim:u}=o,f=l.shape.length,g=l.shape.slice();let A=u;return u<0&&(E(-(f+1)<=u,()=>`Axis must be in the interval [${-(f+1)}, ${f}]`),A=f+u+1),g.splice(A,0,1),xs({inputs:{x:l},backend:i,attrs:{shape:g}})}const d8={kernelName:Un,backendName:"cpu",kernelFunc:Aw};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const f8=lr((s,t)=>s/t),IT=Rr(ot,f8),TT={kernelName:ot,backendName:"cpu",kernelFunc:IT};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function B3(s,t,i){const o=s.shape,l=o[0],u=o[1],f=i.data.get(s.dataId),g=f.complexTensorInfos.real,A=f.complexTensorInfos.imag,v=[l,u],C=N(v),S=re("float32",C),M=re("float32",C);for(let P=0;P<l;P++){const U=Up({inputs:{x:g},backend:i,attrs:{begin:[P,0],size:[1,u]}}),V=Up({inputs:{x:A},backend:i,attrs:{begin:[P,0],size:[1,u]}}),$=xo({inputs:{real:U,imag:V},backend:i}),{real:q,imag:ne}=p8($,t,i),he=th(q,ne);for(let me=0;me<u;me++){const pe=bI(he,me);S[P*u+me]=pe.real,M[P*u+me]=pe.imag}i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo($)}const _=i.makeTensorInfo(v,"float32",S),B=i.makeTensorInfo(v,"float32",M),F=xo({inputs:{real:_,imag:B},backend:i});return i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(B),F}function p8(s,t,i){const o=N(s.shape),l=i.data.get(s.dataId),u=i.data.get(l.complexTensorInfos.real.dataId).values,f=i.data.get(l.complexTensorInfos.imag.dataId).values;if(m8(o)){const g=MT(u,f,o,t,i),A=[s.shape[0],s.shape[1]];if(t){const v=i.makeTensorInfo(A,"float32",g.real),C=i.makeTensorInfo(A,"float32",g.imag),S=i.makeTensorInfo([],"float32",Do(o,"float32")),M=cu({inputs:{x:S},backend:i}),_=TT.kernelFunc({inputs:{a:v,b:S},backend:i}),B=TT.kernelFunc({inputs:{a:C,b:M},backend:i}),F=i.data.get(_.dataId).values,P=i.data.get(B.dataId).values;return i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(B),{real:F,imag:P}}return g}else{const g=th(u,f),A=g8(g,o,t);return AB(A)}}function m8(s){return(s&s-1)===0}function MT(s,t,i,o,l){if(i===1)return{real:s,imag:t};const u=th(s,t),f=i/2,g=bB(u),A=g.real,v=g.imag,C=[A.length],S=l.makeTensorInfo(C,"float32",A),M=l.makeTensorInfo(C,"float32",v),_=xo({inputs:{real:S,imag:M},backend:l}),B=yB(u),F=B.real,P=B.imag,U=[F.length],V=l.makeTensorInfo(U,"float32",F),$=l.makeTensorInfo(U,"float32",P),q=xo({inputs:{real:V,imag:$},backend:l}),ne=MT(A,v,f,o,l),he=ne.real,me=ne.imag,pe=[he.length],ye=l.makeTensorInfo(pe,"float32",he),Te=l.makeTensorInfo(pe,"float32",me),Ye=xo({inputs:{real:ye,imag:Te},backend:l}),et=MT(F,P,f,o,l),nt=et.real,ht=et.imag,ct=[nt.length],pt=l.makeTensorInfo(ct,"float32",nt),Et=l.makeTensorInfo(ct,"float32",ht),yt=xo({inputs:{real:pt,imag:Et},backend:l}),It=xB(i,o),Pt=[It.real.length],Ft=l.makeTensorInfo(Pt,"float32",It.real),Xt=l.makeTensorInfo(Pt,"float32",It.imag),$t=xo({inputs:{real:Ft,imag:Xt},backend:l}),Yt=mw({inputs:{a:$t,b:yt},backend:l}),en=Jg({inputs:{a:Ye,b:Yt},backend:l}),_n=ET({inputs:{a:Ye,b:Yt},backend:l}),An=Gp({inputs:{input:en},backend:l}),Rn=Gp({inputs:{input:_n},backend:l}),Kn=n0({inputs:{input:en},backend:l}),ni=n0({inputs:{input:_n},backend:l}),jn=i0({inputs:[An,Rn],backend:l,attrs:{axis:0}}),Fi=i0({inputs:[Kn,ni],backend:l,attrs:{axis:0}}),cs=l.data.get(jn.dataId).values,gs=l.data.get(Fi.dataId).values;return l.disposeIntermediateTensorInfo(S),l.disposeIntermediateTensorInfo(M),l.disposeIntermediateTensorInfo(_),l.disposeIntermediateTensorInfo(V),l.disposeIntermediateTensorInfo($),l.disposeIntermediateTensorInfo(q),l.disposeIntermediateTensorInfo(ye),l.disposeIntermediateTensorInfo(Te),l.disposeIntermediateTensorInfo(Ye),l.disposeIntermediateTensorInfo(pt),l.disposeIntermediateTensorInfo(Et),l.disposeIntermediateTensorInfo(yt),l.disposeIntermediateTensorInfo(Ft),l.disposeIntermediateTensorInfo(Xt),l.disposeIntermediateTensorInfo($t),l.disposeIntermediateTensorInfo(Yt),l.disposeIntermediateTensorInfo(en),l.disposeIntermediateTensorInfo(_n),l.disposeIntermediateTensorInfo(An),l.disposeIntermediateTensorInfo(Kn),l.disposeIntermediateTensorInfo(Rn),l.disposeIntermediateTensorInfo(ni),l.disposeIntermediateTensorInfo(jn),l.disposeIntermediateTensorInfo(Fi),{real:cs,imag:gs}}function g8(s,t,i){const o=new Float32Array(t*2);for(let l=0;l<t;l++){let u=0,f=0;for(let g=0;g<t;g++){const A=wB(l*g,t,i),v=bI(s,g);u+=v.real*A.real-v.imag*A.imag,f+=v.real*A.imag+v.imag*A.real}i&&(u/=t,f/=t),vB(o,u,f,l)}return o}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function A8(s){const{inputs:t,backend:i}=s,{input:o}=t,l=N(o.shape),u=o.shape[o.shape.length-1],f=l/u,g=xs({inputs:{x:o},backend:i,attrs:{shape:[f,u]}}),A=B3(g,!1,i),v=xs({inputs:{x:A},backend:i,attrs:{shape:o.shape}});return i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(A),v}const b8={kernelName:Ai,backendName:"cpu",kernelFunc:A8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _T(s){const{backend:t,attrs:i}=s,{shape:o,value:l,dtype:u}=i,f=u||Je(l),g=Y(f,N(o));return v8(g,l),t.makeTensorInfo(o,f,g)}const y8={kernelName:Yn,backendName:"cpu",kernelFunc:_T};function v8(s,t,i){s.fill(t)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const x8={kernelName:ys,backendName:"cpu",kernelFunc:({inputs:s,attrs:t,backend:i})=>{const{image:o}=s,l=i,u=re(o.dtype,N(o.shape)),[f,g,A,v]=o.shape,C=l.data.get(o.dataId).values;for(let S=0;S<f;S++){const M=S*A*g*v;for(let _=0;_<g;_++){const B=_*(A*v);for(let F=0;F<A;F++){const P=F*v;for(let U=0;U<v;U++){const V=Math.round(A-F-1),$=M+B+P+U;let q=C[$];if(V>=0&&V<A){const ne=V*v,he=M+B+ne+U;q=C[he]}u[$]=q}}}}return{dataId:l.write(u,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const w8=lr((s,t)=>Math.floor(s/t)),C8=Rr(ei,w8,null,"int32"),E8={kernelName:ei,backendName:"cpu",kernelFunc:C8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function S8(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u,bias:f,preluActivationWeights:g}=t,{strides:A,pad:v,dataFormat:C,dilations:S,dimRoundingMode:M,activation:_,leakyreluAlpha:B}=o;let F=R3({inputs:{x:l,filter:u},backend:i,attrs:{strides:A,pad:v,dataFormat:C,dilations:S,dimRoundingMode:M}});if(f){const P=F;if(C==="NCHW"&&f.shape.length===1&&f.shape[0]!==1){const U=xs({inputs:{x:f},backend:i,attrs:{shape:[f.shape[0],1,1]}});F=Jg({inputs:{a:F,b:U},backend:i}),i.disposeIntermediateTensorInfo(U)}else F=Jg({inputs:{a:F,b:f},backend:i});i.disposeIntermediateTensorInfo(P)}if(_){const P=F;if(C==="NCHW"&&_==="prelu"&&g.shape.length===1&&g.shape[0]!==1){const U=xs({inputs:{x:g},backend:i,attrs:{shape:[g.shape[0],1,1]}});F=gw(i,F,_,U,B),i.disposeIntermediateTensorInfo(U)}else F=gw(i,F,_,g,B);i.disposeIntermediateTensorInfo(P)}return F}const I8={kernelName:Rc,backendName:"cpu",kernelFunc:S8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function T8(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u,bias:f,preluActivationWeights:g}=t,{strides:A,pad:v,dataFormat:C,dilations:S,dimRoundingMode:M,activation:_,leakyreluAlpha:B}=o;let F=k3({inputs:{x:l,filter:u},backend:i,attrs:{strides:A,pad:v,dataFormat:C,dilations:S,dimRoundingMode:M}});if(f){const P=F;F=Jg({inputs:{a:F,b:f},backend:i}),i.disposeIntermediateTensorInfo(P)}if(_){const P=F;F=gw(i,F,_,g,B),i.disposeIntermediateTensorInfo(P)}return F}const M8={kernelName:CA,backendName:"cpu",kernelFunc:T8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _8(s){const{inputs:t,backend:i}=s,{params:o,indices:l}=t,u=N(o.shape),f=l.shape,g=f[f.length-1],[A,v,C,S]=qf(o,l);if(v===0)return i.makeTensorInfo(A,o.dtype,[]);const M=i.data.get(l.dataId).values,_=i.bufferSync(o),B=j4(M,_,o.dtype,v,g,C,S,o.shape,u);return i.makeTensorInfo(A,o.dtype,B.values)}const R8={kernelName:Ec,backendName:"cpu",kernelFunc:_8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function k8(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,indices:u}=t,{axis:f,batchDims:g}=o;yn([l,u],"gatherV2");const A=J(f,l.shape)[0],v=i.data.get(u.dataId).values,C=l.shape[A];for(let q=0;q<v.length;++q){const ne=v[q];E(ne<=C-1&&ne>=0,()=>`GatherV2: the index value ${ne} is not in [0, ${C-1}]`)}let S=g;g==null&&(S=0);const M=N(u.shape),_=OI(l,u,A,S),B=xs({inputs:{x:l},backend:i,attrs:{shape:[_.batchSize,_.outerSize,_.dimSize,_.sliceSize]}}),F=xs({inputs:{x:u},backend:i,attrs:{shape:[_.batchSize,M/_.batchSize]}}),P=[_.batchSize,_.outerSize,M/_.batchSize,_.sliceSize],U=i.bufferSync(F),V=i.bufferSync(B),$=q4(V,U,P);return i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(F),i.makeTensorInfo(_.outputShape,$.dtype,$.values)}const B8={kernelName:xn,backendName:"cpu",kernelFunc:k8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function L8(s){const{inputs:t,backend:i}=s,{input:o}=t,l=N(o.shape),u=o.shape[o.shape.length-1],f=l/u,g=xs({inputs:{x:o},backend:i,attrs:{shape:[f,u]}}),A=B3(g,!0,i),v=xs({inputs:{x:A},backend:i,attrs:{shape:o.shape}});return i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(A),v}const N8={kernelName:Ia,backendName:"cpu",kernelFunc:L8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const D8=is(Si,s=>Number.isFinite(s)?1:0,"bool"),F8={kernelName:Si,backendName:"cpu",kernelFunc:D8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const O8=is(Cs,s=>Math.abs(s)===1/0?1:0,"bool"),G8={kernelName:Cs,backendName:"cpu",kernelFunc:O8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const U8=is(sr,s=>Number.isNaN(s)?1:0,"bool"),P8={kernelName:sr,backendName:"cpu",kernelFunc:U8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function z8(s){const{backend:t,attrs:i}=s,{start:o,stop:l,num:u}=i,f=hQ(o,l,u);return t.makeTensorInfo([f.length],"float32",f)}const V8={kernelName:Eu,backendName:"cpu",kernelFunc:z8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const W8=is(lf,s=>Math.log1p(s)),H8={kernelName:lf,backendName:"cpu",kernelFunc:W8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const X8=lr((s,t)=>s&&t),Q8=Rr(Su,X8,null,"bool"),K8={kernelName:Su,backendName:"cpu",kernelFunc:Q8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Z8=is(Lh,s=>s?0:1,"bool"),$8={kernelName:Lh,backendName:"cpu",kernelFunc:Z8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Y8=lr((s,t)=>s||t),j8=Rr(Nh,Y8,null,"bool"),q8={kernelName:Nh,backendName:"cpu",kernelFunc:j8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function J8(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{depthRadius:u,bias:f,alpha:g,beta:A}=o;yn(l,"LRN");const v=l.shape[3],C=v-1,S=i.data.get(l.dataId).values,M=N(l.shape),_=new Float32Array(M);function B(F){const P=F%v;let U=F-P+Math.max(0,P-u);const V=F-P+Math.min(P+u,C);let $=0;for(;U<=V;U++){const q=S[U];$+=q*q}return $}for(let F=0;F<M;F++){const P=B(F),U=S[F]*Math.pow(f+g*P,-A);_[F]=U}return i.makeTensorInfo(l.shape,l.dtype,_)}const e$={kernelName:Ll,backendName:"cpu",kernelFunc:J8};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function t$(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,y:u,dy:f}=t,{depthRadius:g,bias:A,alpha:v,beta:C}=o;yn(f,"LRNGrad");const S=N(f.shape),M=f.shape[3],_=i.data.get(f.dataId).values,B=i.data.get(l.dataId).values,F=i.data.get(u.dataId).values,P=new Float32Array(S),U=S;for(let V=0;V<U;V++){const $=V%M,q=V-$+Math.max(0,$-g),ne=V-$+Math.min(M,$+g+1);let he=0;for(let me=q;me<ne;me++)he+=Math.pow(B[me],2);he=v*he+A;for(let me=q;me<ne;me++){let pe=-2*v*C*B[me]*F[V]/he;V===me&&(pe+=Math.pow(he,-C)),pe*=_[V],P[me]+=pe}}return i.makeTensorInfo(f.shape,l.dtype,P)}const n$={kernelName:Nm,backendName:"cpu",kernelFunc:t$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function L3(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{reductionIndices:u,keepDims:f}=o,g=i;let A=l.shape;const v=A.length,C=J(u,A);let S=C;const M=ji(S,v);let _=g.data.get(l.dataId).values;if(M!=null){const q=new Array(v);for(let ne=0;ne<q.length;ne++)q[ne]=A[M[ne]];_=m3(_,A,l.dtype,M,q),S=Ss(S.length,v),A=q}yn(l,"max"),Rs("max",S,v);const[B,F]=Ei(A,S),P=N(F),U=mQ(_,P,B,l.dtype),V=g.write(U,B,l.dtype);let $=B;return f&&($=ts(B,C)),{dataId:V,shape:$,dtype:l.dtype}}const i$={kernelName:Fh,backendName:"cpu",kernelFunc:L3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function s$(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t;yn(l,"maxPool");const{filterSize:u,strides:f,pad:g,dimRoundingMode:A}=o,v=1;E(or(f,v),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${f} and dilations '${v}'`);const C=Oa(l.shape,u,f,v,g,A);let S;if(C.filterWidth===1&&C.filterHeight===1&&O(C.inShape,C.outShape))S=cu({inputs:{x:l},backend:i});else{const M=i.data.get(l.dataId).values,_=Ne(l.shape),B=ST(M,l.shape,l.dtype,_,C,"max");S=i.makeTensorInfo(C.outShape,l.dtype,B.values)}return S}const r$={kernelName:Sc,backendName:"cpu",kernelFunc:s$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function a$(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{filterSize:u,strides:f,pad:g,dimRoundingMode:A,dataFormat:v}=o;yn(l,"maxPool3d");const C=go(l.shape,u,f,1,g,A,v),S=i.data.get(l.dataId).values,M=_3(S,l.shape,l.dtype,Ne(l.shape),C,"max");return i.makeTensorInfo(M.shape,"float32",M.values)}const o$={kernelName:Gh,backendName:"cpu",kernelFunc:a$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function l$(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,input:u}=t,{filterSize:f,strides:g,pad:A,dimRoundingMode:v}=o;yn([l,u],"maxPool3DGrad");const C=go(u.shape,f,g,1,A,v),S=i.bufferSync(u),M=YK(S,C),_=C.strideDepth,B=C.strideHeight,F=C.strideWidth,P=C.dilationDepth,U=C.dilationHeight,V=C.dilationWidth,$=C.effectiveFilterDepth,q=C.effectiveFilterHeight,ne=C.effectiveFilterWidth,he=$-1-C.padInfo.front,me=ne-1-C.padInfo.left,pe=q-1-C.padInfo.top,ye=On(u.shape,"float32"),Te=i.bufferSync(l);for(let Ye=0;Ye<C.batchSize;++Ye)for(let et=0;et<C.inChannels;++et)for(let nt=0;nt<C.inDepth;++nt)for(let ht=0;ht<C.inHeight;++ht)for(let ct=0;ct<C.inWidth;++ct){const pt=nt-he,Et=ht-pe,yt=ct-me;let It=0;for(let Pt=0;Pt<$;Pt+=P){const Ft=(pt+Pt)/_;if(!(Ft<0||Ft>=C.outDepth||Math.floor(Ft)!==Ft))for(let Xt=0;Xt<q;Xt+=U){const $t=(Et+Xt)/B;if(!($t<0||$t>=C.outHeight||Math.floor($t)!==$t))for(let Yt=0;Yt<ne;Yt+=V){const en=(yt+Yt)/F;if(en<0||en>=C.outWidth||Math.floor(en)!==en)continue;const _n=$*q*ne-1-M.get(Ye,Ft,$t,en,et),An=Pt*q*ne+Xt*ne+Yt,Rn=_n===An?1:0;if(Rn===0)continue;const Kn=Te.get(Ye,Ft,$t,en,et);It+=Kn*Rn}}}ye.set(It,Ye,nt,ht,ct,et)}return i.makeTensorInfo(ye.shape,ye.dtype,ye.values)}const c$={kernelName:Iu,backendName:"cpu",kernelFunc:l$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function u$(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,input:u,output:f}=t,g=u;yn([u,f],"maxPoolGrad");const{filterSize:A,strides:v,pad:C,dimRoundingMode:S}=o,M=Oa(g.shape,A,v,1,C,S),_=i.data.get(g.dataId).values,B=On(M.outShape,g.dtype,M3(_,g.shape,g.dtype,M).values),F=M.strideHeight,P=M.strideWidth,U=M.dilationHeight,V=M.dilationWidth,$=M.effectiveFilterHeight,q=M.effectiveFilterWidth,ne=q-1-M.padInfo.left,he=$-1-M.padInfo.top,me=On(g.shape,"float32"),pe=i.data.get(l.dataId).values,ye=On(l.shape,"float32",pe);for(let Te=0;Te<M.batchSize;++Te)for(let Ye=0;Ye<M.inChannels;++Ye)for(let et=0;et<M.inHeight;++et)for(let nt=0;nt<M.inWidth;++nt){const ht=et-he,ct=nt-ne;let pt=0;for(let Et=0;Et<$;Et+=U){const yt=(ht+Et)/F;if(!(yt<0||yt>=M.outHeight||Math.floor(yt)!==yt))for(let It=0;It<q;It+=V){const Pt=(ct+It)/P;if(Pt<0||Pt>=M.outWidth||Math.floor(Pt)!==Pt)continue;const Ft=$*q-1-B.get(Te,yt,Pt,Ye),Xt=Et*q+It,$t=Ft===Xt?1:0;if($t===0)continue;const Yt=ye.get(Te,yt,Pt,Ye);pt+=Yt*$t}}me.set(pt,Te,et,nt,Ye)}return i.makeTensorInfo(me.shape,me.dtype,me.values)}const h$={kernelName:No,backendName:"cpu",kernelFunc:u$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function d$(s,t,i,o,l){const u=Ne(t),f=ST(s,t,i,u,l,"max"),g=M3(s,t,i,l,!0,o);return[f.values,g.values]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const f$={kernelName:Nl,backendName:"cpu",kernelFunc:({inputs:s,attrs:t,backend:i})=>{const{x:o}=s,{filterSize:l,strides:u,pad:f,includeBatchInIndex:g}=t,A=i;yn(o,"MaxPoolWithArgmax");const v=A.data.get(o.dataId).values,C=Oa(o.shape,l,u,[1,1],f),[S,M]=d$(v,o.shape,o.dtype,g,C),_=A.write(S,C.outShape,o.dtype),B=A.write(M,C.outShape,o.dtype);return[{dataId:_,shape:C.outShape,dtype:o.dtype},{dataId:B,shape:C.outShape,dtype:"int32"}]}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function p$(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o,g=J(u,l.shape),A=Ei(l.shape,g)[1],v=N(A),C=[],S=i.makeTensorInfo([],"float32",new Float32Array([v]));C.push(S);const M=Bd({inputs:{x:l},backend:i,attrs:{dtype:"float32"}});C.push(M);const _=IT({inputs:{a:M,b:S},backend:i});C.push(_);const B=uy({inputs:{x:_},backend:i,attrs:{axis:u,keepDims:f}});return C.forEach(F=>i.disposeIntermediateTensorInfo(F)),B}const m$={kernelName:Uh,backendName:"cpu",kernelFunc:p$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function g$(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o;yn(l,"min");const g=J(u,l.shape);let A=g;const v=ji(A,l.shape.length);let C=l;v!=null&&(C=Ka({inputs:{x:l},backend:i,attrs:{perm:v}}),A=Ss(A.length,l.shape.length)),Rs("min",A,C.shape.length);const[S,M]=Ei(C.shape,A),_=N(M),B=Tt(N(S),C.dtype),F=i.data.get(C.dataId).values;for(let U=0;U<B.length;++U){const V=U*_;let $=F[V];for(let q=0;q<_;++q){const ne=F[V+q];(Number.isNaN(ne)||ne<$)&&($=ne)}B[U]=$}v!=null&&i.disposeIntermediateTensorInfo(C);const P=i.makeTensorInfo(S,C.dtype,B);if(f){const U=ts(S,g),V=xs({inputs:{x:P},backend:i,attrs:{shape:U}});return i.disposeIntermediateTensorInfo(P),V}return P}const A$={kernelName:Tu,backendName:"cpu",kernelFunc:g$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function b$(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{paddings:u,mode:f}=o;yn(l,"mirrorPad");const g=u.map((V,$)=>V[0]+l.shape[$]+V[1]),A=u.map(V=>V[0]),v=u.map((V,$)=>V[0]+l.shape[$]),C=f==="reflect"?0:1,S=i.data.get(l.dataId).values,M=l.shape.length,_=Ne(l.shape),B=N(g),F=g.length,P=Ne(g),U=re(l.dtype,B);for(let V=0;V<B;V++){let $=Ot(V,F,P);for(let ne=0;ne<F;ne++)$[ne]<A[ne]?$[ne]=A[ne]*2-$[ne]-C:$[ne]>=v[ne]&&($[ne]=(v[ne]-1)*2-$[ne]+C);$=$.map((ne,he)=>ne-A[he]);const q=_t($,M,_);U[V]=S[q]}return{dataId:i.write(U,g,l.dtype),shape:g,dtype:l.dtype}}const y$={kernelName:Mu,backendName:"cpu",kernelFunc:b$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const v$=lr((s,t)=>{const i=s%t;return s<0&&t<0||s>=0&&t>=0?i:(i+t)%t}),x$=Rr(Ic,v$),w$={kernelName:Ic,backendName:"cpu",kernelFunc:x$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function N3(s){const{inputs:t,backend:i,attrs:o}=s,{logits:l}=t,{dim:u}=o,f=l.shape.length;let g=u;if(g===-1&&(g=f-1),g!==f-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${f} and dim was ${g}`);const A=J([g],l.shape),v=L3({inputs:{x:l},backend:i,attrs:{reductionIndices:A,keepDims:!1}}),C=ts(v.shape,A),S=xs({inputs:{x:v},backend:i,attrs:{shape:C}}),M=ET({inputs:{a:l,b:S},backend:i}),_=f3({inputs:{x:M},backend:i}),B=uy({inputs:{x:_},backend:i,attrs:{axis:A,keepDims:!1}}),F=xs({inputs:{x:B},backend:i,attrs:{shape:C}}),P=IT({inputs:{a:_,b:F},backend:i});return i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(F),P}const C$={kernelName:Ef,backendName:"cpu",kernelFunc:N3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function E$(s){const{inputs:t,backend:i,attrs:o}=s,{logits:l}=t,{numSamples:u,seed:f,normalized:g}=o;yn(l,"multinomial");const A=g?l:N3({inputs:{logits:l},backend:i,attrs:{dim:-1}}),v=A.shape[0],C=A.shape[1],S=i.data.get(A.dataId).values,M=[v,u],_=Tt(N(M),"int32");for(let B=0;B<v;++B){const F=B*C,P=new Float32Array(C-1);P[0]=S[F];for(let $=1;$<P.length;++$)P[$]=P[$-1]+S[F+$];const U=Jc.alea(f.toString()),V=B*u;for(let $=0;$<u;++$){const q=U();_[V+$]=P.length;for(let ne=0;ne<P.length;ne++)if(q<P[ne]){_[V+$]=ne;break}}}return g||i.disposeIntermediateTensorInfo(A),i.makeTensorInfo(M,"int32",_)}const S$={kernelName:cA,backendName:"cpu",kernelFunc:E$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const I$=KS;function T$(s){const{inputs:t,backend:i,attrs:o}=s,{boxes:l,scores:u}=t,{maxOutputSize:f,iouThreshold:g,scoreThreshold:A}=o;yn(l,"NonMaxSuppression");const v=i.data.get(l.dataId).values,C=i.data.get(u.dataId).values,{selectedIndices:S}=I$(v,C,f,g,A);return i.makeTensorInfo([S.length],"int32",new Int32Array(S))}const M$={kernelName:Ru,backendName:"cpu",kernelFunc:T$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _$=ZS;function R$(s){const{inputs:t,backend:i,attrs:o}=s,{boxes:l,scores:u}=t,{maxOutputSize:f,iouThreshold:g,scoreThreshold:A,padToMaxOutputSize:v}=o;yn(l,"NonMaxSuppressionPadded");const C=i.data.get(l.dataId).values,S=i.data.get(u.dataId).values,{selectedIndices:M,validOutputs:_}=_$(C,S,f,g,A,v);return[i.makeTensorInfo([M.length],"int32",new Int32Array(M)),i.makeTensorInfo([],"int32",new Int32Array([_]))]}const k$={kernelName:uA,backendName:"cpu",kernelFunc:R$};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const B$=$S;function L$(s){const{inputs:t,backend:i,attrs:o}=s,{boxes:l,scores:u}=t,{maxOutputSize:f,iouThreshold:g,scoreThreshold:A,softNmsSigma:v}=o;yn(l,"NonMaxSuppressionWithScore");const C=i.data.get(l.dataId).values,S=i.data.get(u.dataId).values,M=f,_=g,B=A,F=v,{selectedIndices:P,selectedScores:U}=B$(C,S,M,_,B,F);return[i.makeTensorInfo([P.length],"int32",new Int32Array(P)),i.makeTensorInfo([U.length],"float32",new Float32Array(U))]}const N$={kernelName:cf,backendName:"cpu",kernelFunc:L$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function D$(s){const{inputs:t,backend:i,attrs:o}=s,{indices:l}=t,{dtype:u,depth:f,onValue:g,offValue:A}=o;yn(l,"oneHot");const v=N(l.shape),C=new Float32Array(v*f);C.fill(A);const S=i.data.get(l.dataId).values;for(let M=0;M<v;++M)S[M]>=0&&S[M]<f&&(C[M*f+S[M]]=g);return i.makeTensorInfo([...l.shape,f],u,C)}const F$={kernelName:Tc,backendName:"cpu",kernelFunc:D$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bw(s){const{inputs:t,backend:i}=s,{x:o}=t;if(o.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(o.dtype==="complex64"){const l=Gp({inputs:{input:o},backend:i}),u=bw({inputs:{x:l},backend:i}),f=n0({inputs:{input:o},backend:i}),g=bw({inputs:{x:f},backend:i}),A=xo({inputs:{real:u,imag:g},backend:i});return i.disposeIntermediateTensorInfo(l),i.disposeIntermediateTensorInfo(u),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(g),A}else return _T({backend:i,attrs:{shape:o.shape,value:0,dtype:o.dtype}})}const O$={kernelName:Km,backendName:"cpu",kernelFunc:bw};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function D3(s){const{inputs:t,backend:i}=s,{x:o}=t;if(o.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(o.dtype==="complex64"){const l=Gp({inputs:{input:o},backend:i}),u=D3({inputs:{x:l},backend:i}),f=n0({inputs:{input:o},backend:i}),g=bw({inputs:{x:f},backend:i}),A=xo({inputs:{real:u,imag:g},backend:i});return i.disposeIntermediateTensorInfo(l),i.disposeIntermediateTensorInfo(u),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(g),A}else return _T({backend:i,attrs:{shape:o.shape,value:1,dtype:o.dtype}})}const G$={kernelName:zh,backendName:"cpu",kernelFunc:D3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function F3(s){const{inputs:t,backend:i,attrs:o}=s,{axis:l}=o;if(t.length===1)return Aw({inputs:{input:t[0]},backend:i,attrs:{dim:l}});const u=t[0].shape,f=t[0].dtype;t.forEach(C=>{R(u,C.shape,"All tensors passed to stack must have matching shapes"),E(f===C.dtype,()=>"All tensors passed to stack must have matching dtypes")});const g=[],A=t.map(C=>{const S=Aw({inputs:{input:C},backend:i,attrs:{dim:l}});return g.push(S),S}),v=i0({inputs:A,backend:i,attrs:{axis:l}});return g.forEach(C=>i.disposeIntermediateTensorInfo(C)),v}const U$={kernelName:ku,backendName:"cpu",kernelFunc:F3};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function P$(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{paddings:u,constantValue:f}=o;yn(l,"pad");const g=u.map((U,V)=>U[0]+l.shape[V]+U[1]),A=u.map(U=>U[0]),v=i.data.get(l.dataId).values,C=N(l.shape),S=l.shape.length,M=Ne(l.shape),_=N(g),B=g.length,F=Ne(g),P=re(l.dtype,_);f!==0&&P.fill(f);for(let U=0;U<C;U++){const V=Ot(U,S,M).map((q,ne)=>q+A[ne]),$=_t(V,B,F);P[$]=v[U]}return{dataId:i.write(P,g,l.dtype),shape:g,dtype:l.dtype}}const O3={kernelName:uf,backendName:"cpu",kernelFunc:P$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const z$=lr((s,t)=>Math.pow(s,t)),V$=Rr(hf,z$),W$={kernelName:hf,backendName:"cpu",kernelFunc:V$};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function H$(s){const{inputs:t,backend:i,attrs:o}=s,{paramsNestedSplits:l,paramsDenseValues:u,indices:f}=t,g=l.map(P=>i.data.get(P.dataId).values),A=l.map(P=>P.shape),v=i.data.get(u.dataId).values,C=i.data.get(f.dataId).values,[S,M,_]=PQ(g,A,v,u.shape,u.dtype,C,f.shape),B=S.map(P=>i.makeTensorInfo([P.length],"int32",P)),F=i.makeTensorInfo(_,u.dtype,M);return B.concat([F])}const X$={kernelName:Om,backendName:"cpu",kernelFunc:H$};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Q$(s){const{inputs:t,backend:i,attrs:o}=s,{shape:l,values:u,defaultValue:f,rowPartitionTensors:g}=t,{rowPartitionTypes:A}=o,v=i.data.get(l.dataId).values,C=i.data.get(u.dataId).values,S=i.data.get(f.dataId).values,M=g.map(P=>i.data.get(P.dataId).values),_=g.map(P=>P.shape),[B,F]=VQ(v,l.shape,C,u.shape,u.dtype,S,f.shape,M,_,A);return i.makeTensorInfo(B,u.dtype,F)}const K$={kernelName:$v,backendName:"cpu",kernelFunc:Q$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Z$(s){const{backend:t,attrs:i}=s,{start:o,stop:l,dtype:u,step:f}=i,g=WQ(o,l,f,u);return t.makeTensorInfo([g.length],u,g)}const $$={kernelName:hA,backendName:"cpu",kernelFunc:Z$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Y$=is(df,s=>1/s),j$={kernelName:df,backendName:"cpu",kernelFunc:Y$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function q$(s){const{inputs:t,backend:i,attrs:o}=s,{images:l}=t,{alignCorners:u,halfPixelCenters:f,size:g}=o;yn(l,"resizeBilinear");const A=Ne(l.shape),[v,C]=g,[S,M,_,B]=l.shape,F=i.data.get(l.dataId).values,P=new Float32Array(N([S,v,C,B])),U=[u&&v>1?M-1:M,u&&C>1?_-1:_],V=[u&&v>1?v-1:v,u&&C>1?C-1:C];let $=0;const q=U[0]/V[0],ne=U[1]/V[1];for(let he=0;he<S;he++)for(let me=0;me<v;me++){let pe;f?pe=q*(me+.5)-.5:pe=q*me;const ye=Math.max(0,Math.floor(pe)),Te=pe-ye,Ye=Math.min(M-1,Math.ceil(pe)),et=he*A[0]+ye*A[1],nt=he*A[0]+Ye*A[1];for(let ht=0;ht<C;ht++){let ct;f?ct=ne*(ht+.5)-.5:ct=ne*ht;const pt=Math.max(0,Math.floor(ct)),Et=ct-pt,yt=Math.min(_-1,Math.ceil(ct)),It=et+pt*A[2],Pt=nt+pt*A[2],Ft=et+yt*A[2],Xt=nt+yt*A[2];for(let $t=0;$t<B;$t++){const Yt=F[It+$t],en=F[Pt+$t],_n=F[Ft+$t],An=F[Xt+$t],Rn=Yt+(_n-Yt)*Et,Kn=en+(An-en)*Et,ni=Rn+(Kn-Rn)*Te;P[$++]=ni}}}return i.makeTensorInfo([S,v,C,B],"float32",P)}const J$={kernelName:Um,backendName:"cpu",kernelFunc:q$};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function e6(s){const{inputs:t,backend:i,attrs:o}=s,{images:l,dy:u}=t,{alignCorners:f}=o;yn([u,l],"resizeBilinearGrad");const g=Ne(l.shape),[A,v,C,S]=l.shape,[,M,_]=u.shape,B=new Float32Array(A*v*C*S),F=[f&&M>1?v-1:v,f&&_>1?C-1:C],P=[f&&M>1?M-1:M,f&&_>1?_-1:_],U=F[0]/P[0],V=F[1]/P[1],$=i.data.get(u.dataId).values;let q=0;for(let ne=0;ne<A;ne++){const he=ne*g[0];for(let me=0;me<M;me++){const pe=me*U,ye=Math.floor(pe),Te=Math.min(Math.ceil(pe),v-1),Ye=he+ye*g[1],et=he+Te*g[1],nt=pe-ye,ht=1-nt;for(let ct=0;ct<_;ct++){const pt=ct*V,Et=Math.floor(pt),yt=Math.min(Math.ceil(pt),C-1),It=pt-Et,Pt=1-It,Ft=Ye+Et*g[2],Xt=Ye+yt*g[2],$t=et+Et*g[2],Yt=et+yt*g[2],en=ht*Pt,_n=ht*It,An=nt*Pt,Rn=nt*It;for(let Kn=0;Kn<S;Kn++){const ni=$[q++];B[Ft+Kn]+=ni*en,B[Xt+Kn]+=ni*_n,B[$t+Kn]+=ni*An,B[Yt+Kn]+=ni*Rn}}}}return i.makeTensorInfo([A,C,v,S],"float32",B)}const t6={kernelName:pA,backendName:"cpu",kernelFunc:e6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n6(s){const{inputs:t,backend:i,attrs:o}=s,{images:l}=t,{alignCorners:u,halfPixelCenters:f,size:g}=o;yn(l,"resizeNearestNeighbor");const A=Ne(l.shape),[v,C]=g,[S,M,_,B]=l.shape,F=i.data.get(l.dataId).values,P=new Float32Array(S*v*C*B),U=[u&&v>1?M-1:M,u&&C>1?_-1:_],V=[u&&v>1?v-1:v,u&&C>1?C-1:C],$=U[0]/V[0],q=U[1]/V[1];let ne=0;for(let he=0;he<S;he++){const me=he*A[0];for(let pe=0;pe<v;pe++){const ye=f?$*(pe+.5):$*pe;let Te=Math.min(M-1,u?Math.round(ye):Math.floor(ye));f&&(Te=Math.max(0,Te));const Ye=me+Te*A[1];for(let et=0;et<C;et++){const nt=f?q*(et+.5):q*et;let ht=Math.min(_-1,u?Math.round(nt):Math.floor(nt));f&&(ht=Math.max(0,ht));const ct=Ye+ht*A[2];for(let pt=0;pt<B;pt++){const Et=F[ct+pt];P[ne++]=Et}}}}return i.makeTensorInfo([S,v,C,B],l.dtype,P)}const i6={kernelName:Gm,backendName:"cpu",kernelFunc:n6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function s6(s){const{inputs:t,backend:i,attrs:o}=s,{images:l,dy:u}=t,{alignCorners:f}=o;yn([u,l],"resizeNearestNeighborGrad");const g=Ne(l.shape),A=Ne(u.shape),[v,C,S,M]=l.shape,[,_,B]=u.shape,F=new Float32Array(v*C*S*M),P=i.data.get(u.dataId).values,U=[f&&_>1?C-1:C,f&&B>1?S-1:S],V=[f&&_>1?_-1:_,f&&B>1?B-1:B],$=U[0]/V[0],q=U[1]/V[1],ne=1/$,he=1/q,me=Math.ceil(ne)*2+2,pe=Math.ceil(he)*2+2;for(let ye=0;ye<v;ye++){const Te=ye*g[0];for(let Ye=0;Ye<C;Ye++){const et=Te+Ye*g[1],nt=Math.floor(Ye*ne),ht=Math.floor(nt-me/2);for(let ct=0;ct<S;ct++){const pt=et+ct*g[2],Et=Math.floor(ct*he),yt=Math.floor(Et-pe/2);for(let It=0;It<M;It++){let Pt=0;for(let Ft=0;Ft<me;Ft++){const Xt=Ft+ht;if(Xt<0||Xt>=_)continue;const $t=Te+Xt*A[1],Yt=Xt*$,en=Math.min(C-1,f?Math.round(Yt):Math.floor(Yt));if(Ye===en)for(let _n=0;_n<pe;_n++){const An=_n+yt;if(An<0||An>=B)continue;const Rn=$t+An*A[2],Kn=An*q,ni=Math.min(S-1,f?Math.round(Kn):Math.floor(Kn));ct===ni&&(Pt+=P[Rn+It])}}F[pt+It]=Pt}}}}return i.makeTensorInfo(l.shape,l.dtype,F)}const r6={kernelName:fA,backendName:"cpu",kernelFunc:s6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function a6(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{dims:u}=o;yn(l,"reverse");const f=l.shape.length,g=J(u,l.shape);if(f===0)return cu({inputs:{x:l},backend:i});const A=new Hs(l.shape,l.dtype),v=i.bufferSync(l);for(let C=0;C<A.size;C++){const S=A.indexToLoc(C),M=S.slice();g.forEach(_=>M[_]=l.shape[_]-1-M[_]),A.set(v.get(...M),...S)}return i.makeTensorInfo(A.shape,A.dtype,A.values)}const o6={kernelName:Pm,backendName:"cpu",kernelFunc:a6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const l6={kernelName:wA,backendName:"cpu",kernelFunc:({inputs:s,attrs:t,backend:i})=>{const{image:o}=s,{radians:l,fillValue:u,center:f}=t,g=i,A=re(o.dtype,N(o.shape)),[v,C,S,M]=o.shape,[_,B]=cI(f,C,S),F=255,P=Math.sin(l),U=Math.cos(l),V=g.data.get(o.dataId).values;for(let $=0;$<v;$++){const q=$*S*C*M;for(let ne=0;ne<C;ne++){const he=ne*(S*M);for(let me=0;me<S;me++){const pe=me*M;for(let ye=0;ye<M;ye++){const Te=[v,ne,me,ye],Ye=Te[2],et=Te[1];let nt=(Ye-_)*U-(et-B)*P,ht=(Ye-_)*P+(et-B)*U;nt=Math.round(nt+_),ht=Math.round(ht+B);let ct=u;if(typeof u!="number"&&(ye===3?ct=F:ct=u[ye]),nt>=0&&nt<S&&ht>=0&&ht<C){const Et=ht*(S*M),yt=nt*M,It=q+Et+yt+ye;ct=V[It]}const pt=q+he+pe+ye;A[pt]=ct}}}}return{dataId:g.write(A,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const c6=is(mf,s=>{const t=Math.floor(s);return s-t<.5?Math.floor(s):s-t>.5?Math.ceil(s):t%2===0?t:t+1}),u6={kernelName:mf,backendName:"cpu",kernelFunc:c6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function h6(s){const{inputs:t,backend:i,attrs:o}=s,{indices:l,updates:u}=t,{shape:f}=o,{sliceRank:g,numUpdates:A,sliceSize:v,strides:C,outputSize:S}=Jf(u,l,f),M=!0,_=i.bufferSync(l),B=i.bufferSync(u),F=ly(_,B,f,S,v,A,g,C,0,M);return i.makeTensorInfo(f,F.dtype,F.values)}const d6={kernelName:mA,backendName:"cpu",kernelFunc:h6};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function f6(s,t){let i=0,o=s.length,l=0;for(;i<o;)l=Math.floor((i+o)/2),s[l]<t?i=l+1:o=l;return o}function p6(s,t){let i=0,o=s.length,l=0;for(;i<o;)l=Math.floor((i+o)/2),s[l]<=t?i=l+1:o=l;return o}function m6(s,t,i,o,l,u){const f=Y("int32",i*l);for(let g=0;g<i;++g){const A=s.slice(g*o,(g+1)*o),v=g*l;for(let C=0;C<l;++C)f[v+C]=u==="left"?f6(A,t[C+v]):p6(A,t[C+v])}return f}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function g6(s){const{inputs:t,backend:i,attrs:o}=s,{sortedSequence:l,values:u}=t,{side:f}=o,g=i.data.get(l.dataId).values,A=i.data.get(u.dataId).values,v=m6(g,A,l.shape[0],l.shape[1],u.shape[1],f);return i.makeTensorInfo(u.shape,"int32",v)}const A6={kernelName:Yv,backendName:"cpu",kernelFunc:g6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function b6(s){const{inputs:t,backend:i}=s,{condition:o,t:l,e:u}=t;yn([o,l,u],"select");const f=o.shape.length,g=i.data.get(o.dataId).values,A=i.data.get(l.dataId).values,v=i.data.get(u.dataId).values,C=ar(l.dtype,u.dtype),S=Tt(N(l.shape),C);let M=0;const _=f===0||f>1||l.shape.length===1?1:N(l.shape.slice(1));for(let B=0;B<g.length;B++)for(let F=0;F<_;F++)g[B]===1?S[M++]=A[B]:S[M++]=v[B];return i.makeTensorInfo(l.shape,C,S)}const y6={kernelName:zm,backendName:"cpu",kernelFunc:b6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const v6=V1,x6=W1,w6=is(Af,s=>s>=0?x6*s:v6*(Math.exp(s)-1)),C6={kernelName:Af,backendName:"cpu",kernelFunc:w6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const E6=is(vf,s=>s<0?-1:s>0?1:0),S6={kernelName:vf,backendName:"cpu",kernelFunc:E6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const I6=is(bf,s=>Math.sin(s)),T6={kernelName:bf,backendName:"cpu",kernelFunc:I6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const M6=is(yf,s=>Math.sinh(s)),_6={kernelName:yf,backendName:"cpu",kernelFunc:M6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const G3=Math.log(11920928955078125e-23)+2,R6=is(wf,s=>{const t=s>-G3,i=s<G3,o=Math.exp(s);let l;return i?l=o:t?l=s:l=Math.log(1+o),l}),k6={kernelName:wf,backendName:"cpu",kernelFunc:R6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function B6(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{blockShape:u,paddings:f}=o;yn([l],"spaceToBatchND");const g=N(u),A=[[0,0]];A.push(...f);for(let P=1+u.length;P<l.shape.length;++P)A.push([0,0]);const v=O3.kernelFunc({inputs:{x:l},backend:i,attrs:{paddings:A,constantValue:0}}),C=zb(v.shape,u,g,!1),S=Vb(C.length,u.length,!1),M=Wb(v.shape,u,g,!1),_=xs({inputs:{x:v},backend:i,attrs:{shape:C}}),B=Ka({inputs:{x:_},backend:i,attrs:{perm:S}}),F=xs({inputs:{x:B},backend:i,attrs:{shape:M}});return i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(B),F}const L6={kernelName:Wm,backendName:"cpu",kernelFunc:B6};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function N6(s){const{inputs:t,backend:i}=s,{indices:o,values:l,denseShape:u,defaultValue:f}=t;if(u.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${u.shape}`);if(o.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${o.shape}`);if(l.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${l.shape}`);if(f.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${f.shape}`);const g=i.data.get(o.dataId).values,A=i.data.get(l.dataId).values,v=i.data.get(u.dataId).values,C=i.data.get(f.dataId).values[0],[S,M,_,B,F]=YQ(g,o.shape,o.dtype,A,l.dtype,v,C);return[i.makeTensorInfo(M,o.dtype,S),i.makeTensorInfo([M[0]],l.dtype,_),i.makeTensorInfo([B.length],"bool",new Uint8Array(B.map(P=>Number(P)))),i.makeTensorInfo([F.length],o.dtype,new Int32Array(F))]}const D6={kernelName:gA,backendName:"cpu",kernelFunc:N6};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function F6(s){const{inputs:t,backend:i}=s,{inputIndices:o,inputShape:l,newShape:u}=t;if(o.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${o.shape}`);if(l.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${l.shape}`);if(u.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${u.shape}`);const f=Array.from(i.data.get(l.dataId).values),g=i.data.get(o.dataId).values,A=Array.from(i.data.get(u.dataId).values),[v,C,S]=jQ(g,o.shape,o.dtype,f,A);return[i.makeTensorInfo(C,o.dtype,v),i.makeTensorInfo([S.length],u.dtype,new Int32Array(S))]}const O6={kernelName:AA,backendName:"cpu",kernelFunc:F6};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function G6(s){const{inputs:t,backend:i}=s,{data:o,indices:l,segmentIds:u}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(l.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${l.shape}`);if(u.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${u.shape}`);if(l.shape[0]!==u.shape[0])throw new Error("segmentIds and indices should have same size.");const f=i.data.get(o.dataId).values,g=i.data.get(l.dataId).values,A=i.data.get(u.dataId).values,[v,C]=v3(f,o.shape,o.dtype,g,A,!0);return i.makeTensorInfo(C,o.dtype,v)}const U6={kernelName:bA,backendName:"cpu",kernelFunc:G6};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function P6(s){const{inputs:t,backend:i}=s,{data:o,indices:l,segmentIds:u}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(l.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${l.shape}`);if(u.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${u.shape}`);if(l.shape[0]!==u.shape[0])throw new Error("segmentIds and indices should have same size.");const f=i.data.get(o.dataId).values,g=i.data.get(l.dataId).values,A=i.data.get(u.dataId).values,[v,C]=v3(f,o.shape,o.dtype,g,A);return i.makeTensorInfo(C,o.dtype,v)}const z6={kernelName:Nu,backendName:"cpu",kernelFunc:P6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function V6(s){const{inputs:t,backend:i,attrs:o}=s,{sparseIndices:l,sparseValues:u,defaultValue:f}=t,{outputShape:g}=o,{sliceRank:A,numUpdates:v,sliceSize:C,strides:S,outputSize:M}=Jf(u,l,g),_=!1,B=i.bufferSync(l);let F;switch(u.dtype){case"bool":{const P=i.bufferSync(u),U=!!i.data.get(f.dataId).values[0];F=ly(B,P,g,M,C,v,A,S,U,_);break}case"float32":{const P=i.bufferSync(u),U=i.data.get(f.dataId).values[0];F=ly(B,P,g,M,C,v,A,S,U,_);break}case"int32":{const P=i.bufferSync(u),U=i.data.get(f.dataId).values[0];F=ly(B,P,g,M,C,v,A,S,U,_);break}case"string":{const P=i.bufferSync(u),U=oa(i.data.get(f.dataId).values[0]);F=ly(B,P,g,M,C,v,A,S,U,_);break}default:throw new Error(`Unsupported type ${u.dtype}`)}return i.makeTensorInfo(g,F.dtype,F.values)}const W6={kernelName:jv,backendName:"cpu",kernelFunc:V6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function H6(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{numOrSizeSplits:u,axis:f}=o,g=J(f,l.shape)[0],A=SI(l,u,g),v=new Array(l.shape.length).fill(0),C=l.shape.slice();return A.map(S=>{const M=[...C];M[g]=S;const _=Up({inputs:{x:l},backend:i,attrs:{begin:v,size:M}});return v[g]+=S,_})}const X6={kernelName:Cf,backendName:"cpu",kernelFunc:H6};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Q6={kernelName:yA,backendName:"cpu",kernelFunc:({inputs:s,backend:t})=>{const{x:i}=s,o=t;yn(i,"square");const l=o.data.get(i.dataId).values,u=new Float32Array(l.length);for(let f=0;f<l.length;++f){const g=l[f];u[f]=g*g}return{dataId:o.write(u,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const K6=is(Rf,(s,t)=>{const i=t;return isNaN(s)?NaN:s>0?1:i.alpha}),Z6={kernelName:Rf,backendName:"cpu",kernelFunc:K6};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $6(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{begin:u,end:f,strides:g,beginMask:A,endMask:v,ellipsisMask:C,newAxisMask:S,shrinkAxisMask:M}=o;yn(l,"stridedSlice");const{finalShapeSparse:_,finalShape:B,isIdentity:F,sliceDim0:P,isSimpleSlice:U,begin:V,end:$,strides:q}=nb(l.shape,u,f,g,A,v,C,S,M);let ne;if(F)ne=xs({inputs:{x:l},backend:i,attrs:{shape:B}});else if(P||U){E(l.shape.length>=1,()=>`Input must have rank at least 1, got: ${l.shape.length}`);const he=fg(V,$,q),me=Up({inputs:{x:l},backend:i,attrs:{begin:V,size:he}});ne=xs({inputs:{x:me},backend:i,attrs:{shape:B}}),i.disposeIntermediateTensorInfo(me)}else{const he=i.bufferSync(l),me=iK(_,he,q,V);ne=i.makeTensorInfo(B,me.dtype,me.values)}return ne}const Y6={kernelName:Hm,backendName:"cpu",kernelFunc:$6};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function j6(s){const{inputs:t,backend:i,attrs:o}=s,{separator:l,nGramWidths:u,leftPad:f,rightPad:g,padWidth:A,preserveShortSequences:v}=o,{data:C,dataSplits:S}=t,M=i.data.get(C.dataId).values,_=i.data.get(S.dataId).values,[B,F]=rK(M,_,l,u,f,g,A,v);return[i.makeTensorInfo([B.length],"string",B),i.makeTensorInfo(S.shape,"int32",F)]}const q6={kernelName:vA,backendName:"cpu",kernelFunc:j6};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function J6(s){const{inputs:t,backend:i,attrs:o}=s,{skipEmpty:l}=o,{input:u,delimiter:f}=t;if(u.dtype!=="string")throw new Error("Input must be of datatype string");if(u.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${u.shape}`);if(f.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${f.shape}`);const g=i.data.get(u.dataId).values,A=i.data.get(f.dataId).values[0],[v,C,S]=oK(g,A,l),M=C.length;return[i.makeTensorInfo([M,2],"int32",v),i.makeTensorInfo([M],"string",C),i.makeTensorInfo([2],"int32",new Int32Array(S))]}const e7={kernelName:Vh,backendName:"cpu",kernelFunc:J6};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function t7(s){const{inputs:t,backend:i,attrs:o}=s,{numBuckets:l}=o,{input:u}=t;if(u.dtype!=="string")throw new Error("Input must be of datatype string");if(l<=0)throw new Error("Number of buckets must be at least 1");const f=i.data.get(u.dataId).values,g=lK(f,l);return i.makeTensorInfo(u.shape,"int32",g)}const n7={kernelName:Wh,backendName:"cpu",kernelFunc:t7};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const i7=is(_c,s=>Math.tan(s)),s7={kernelName:_c,backendName:"cpu",kernelFunc:i7};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const r7=is(Hh,s=>Math.tanh(s)),a7={kernelName:Hh,backendName:"cpu",kernelFunc:r7};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function o7(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{reps:u}=o;yn(l,"tile");const f=dK(i.bufferSync(l),u);return i.makeTensorInfo(f.shape,f.dtype,f.values)}const l7={kernelName:Xh,backendName:"cpu",kernelFunc:o7};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function c7(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{k:u,sorted:f}=o;yn(l,"topk");const g=i.data.get(l.dataId).values,[A,v]=fK(g,l.shape,l.dtype,u,f);return[i.makeTensorInfo(A.shape,A.dtype,A.values),i.makeTensorInfo(v.shape,v.dtype,v.values)]}const u7={kernelName:Tf,backendName:"cpu",kernelFunc:c7};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function h7(s){const{inputs:t,attrs:i,backend:o}=s,{image:l,transforms:u}=t,{interpolation:f,fillMode:g,fillValue:A,outputShape:v}=i,[C,S,M,_]=l.shape,[B,F]=v??[S,M],P=[C,B,F,_],U=Ne(l.shape),V=U[0],$=U[1],q=U[2],ne=Ne(P),he=ne[0],me=ne[1],pe=ne[2],ye=re(l.dtype,N(P));ye.fill(A);const Te=o.data.get(l.dataId).values,Ye=o.data.get(u.dataId).values;for(let et=0;et<C;++et){const nt=u.shape[0]===1?Ye:Ye.subarray(et*8,et*8+8);for(let ht=0;ht<B;++ht)for(let ct=0;ct<F;++ct)for(let pt=0;pt<_;++pt){let Et;const yt=nt[6]*ct+nt[7]*ht+1;if(yt===0)continue;const It=(nt[0]*ct+nt[1]*ht+nt[2])/yt,Pt=(nt[3]*ct+nt[4]*ht+nt[5])/yt,Ft=U3(It,M,g),Xt=U3(Pt,S,g);switch(f){case"nearest":Et=A7(Te,S,M,V,$,q,et,Xt,Ft,pt,A);break;case"bilinear":Et=b7(Te,S,M,V,$,q,et,Xt,Ft,pt,A);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${f}`)}const $t=et*he+ht*me+ct*pe+pt;ye[$t]=Et}return o.makeTensorInfo(P,l.dtype,ye)}return{dataId:o.write(ye,P,l.dtype),shape:l.shape,dtype:l.dtype}}const d7={kernelName:Mf,backendName:"cpu",kernelFunc:h7};function U3(s,t,i){switch(i){case"reflect":return f7(s,t);case"wrap":return p7(s,t);case"nearest":return g7(s,t);case"constant":default:return m7(s)}}function f7(s,t){let i=s;if(i<0)if(t<=1)i=0;else{const o=2*t;i<o&&(i=o*Math.trunc(-i/o)+i),i=i<-t?i+o:-i-1}else if(i>t-1)if(t<=1)i=0;else{const o=2*t;i-=o*Math.trunc(i/o),i>=t&&(i=o-i-1)}return b(0,i,t-1)}function p7(s,t){let i=s;if(i<0)if(t<=1)i=0;else{const o=t-1;i+=t*(Math.trunc(-i/o)+1)}else if(i>t-1)if(t<=1)i=0;else{const o=t-1;i-=t*Math.trunc(i/o)}return b(0,i,t-1)}function m7(s,t){return s}function g7(s,t){return b(0,s,t-1)}function hy(s,t,i,o,l,u,f,g,A,v,C){const S=f*o+g*l+A*u+v;return 0<=g&&g<t&&0<=A&&A<i?s[S]:C}function A7(s,t,i,o,l,u,f,g,A,v,C){const S=Math.round(g),M=Math.round(A);return hy(s,t,i,o,l,u,f,S,M,v,C)}function b7(s,t,i,o,l,u,f,g,A,v,C){const S=Math.floor(g),M=Math.floor(A),_=S+1,B=M+1,F=(B-A)*hy(s,t,i,o,l,u,f,S,M,v,C)+(A-M)*hy(s,t,i,o,l,u,f,S,B,v,C),P=(B-A)*hy(s,t,i,o,l,u,f,_,M,v,C)+(A-M)*hy(s,t,i,o,l,u,f,_,B,v,C);return(_-g)*F+(g-S)*P}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function y7(s){const{inputs:t,attrs:i,backend:o}=s,{axis:l}=i,{x:u}=t;yn(u,"unique");const f=o.data.get(u.dataId).values,{outputValues:g,outputShape:A,indices:v}=pK(f,l,u.shape,u.dtype);return[o.makeTensorInfo(A,u.dtype,g),o.makeTensorInfo([v.length],"int32",v)]}const v7={kernelName:Xm,backendName:"cpu",kernelFunc:y7};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function x7(s){const{inputs:t,backend:i,attrs:o}=s,{value:l}=t;let{axis:u}=o;u<0&&(u+=l.shape.length);const f=l.shape.length,g=l.shape[u],A=new Array(f-1);let v=0;for(let _=0;_<f;_++)_!==u&&(A[v++]=l.shape[_]);const C=new Array(f).fill(0),S=l.shape.slice();S[u]=1;const M=new Array(g);for(let _=0;_<M.length;_++){C[u]=_;const B=Up({inputs:{x:l},backend:i,attrs:{begin:C,size:S}});M[_]=xs({inputs:{x:B},backend:i,attrs:{shape:A}}),i.disposeIntermediateTensorInfo(B)}return M}const w7={kernelName:_f,backendName:"cpu",kernelFunc:x7};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function C7(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,segmentIds:u}=t,{numSegments:f}=o;yn(l,"unsortedSegmentSum");const g=l.shape.length,A=u.shape.length,v=[],C=[],S=g-A;let M=u;for(let B=0;B<S;++B){const F=Aw({inputs:{input:M},backend:i,attrs:{dim:B+1}});M=F,C.push(F)}for(let B=0;B<f;++B){const F=Do(B,"int32"),P=i.makeTensorInfo([],"int32",F),U=d3({inputs:{a:P,b:M},backend:i}),V=Bd({inputs:{x:U},backend:i,attrs:{dtype:"float32"}}),$=mw({inputs:{a:V,b:l},backend:i}),q=uy({inputs:{x:$},backend:i,attrs:{axis:0,keepDims:!1}});v.push(q),C.push(P),C.push(U),C.push(V),C.push($),C.push(q)}const _=F3({inputs:v,backend:i,attrs:{axis:0}});return C.forEach(B=>i.disposeIntermediateTensorInfo(B)),_}const E7={kernelName:Qm,backendName:"cpu",kernelFunc:C7};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const S7=[EK,T4,IK,MK,D4,RK,BK,NK,FK,GK,PK,VK,HK,KK,$K,qK,eZ,nZ,sZ,wK,aZ,lZ,uZ,dZ,B4,U4,pZ,M4,mZ,AZ,bZ,vZ,wZ,EZ,IZ,MZ,RZ,BZ,NZ,FZ,GZ,PZ,VZ,WZ,XZ,KZ,$Z,YZ,jZ,qZ,t8,mK,i8,V4,h8,H4,d8,K4,b8,y8,x8,Y4,E8,I8,M8,R8,B8,tQ,sQ,_4,N8,gZ,F8,G8,P8,gK,oQ,uQ,V8,pQ,H8,K8,$8,q8,e$,n$,i$,bQ,r$,o$,c$,h$,f$,m$,A$,xQ,y$,w$,S$,CQ,IQ,M$,k$,N$,_Q,F$,G$,U$,O3,W$,bK,LQ,X$,K$,$$,R4,TT,j$,yK,vK,xK,J$,t6,i6,r6,o6,l6,u6,QQ,d6,A6,y6,C6,KQ,S6,T6,_6,$Q,C$,k6,L6,D6,O6,U6,z6,W6,X6,JQ,Q6,nK,Z6,Y6,q6,e7,n7,hK,JZ,s7,a7,l7,u7,d7,RQ,v7,w7,E7,O$];for(const s of S7)Ir(s);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Pp={},yw={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function I7(s,t){Pp[s]=t}function ac(s,t){if(!(s in Pp)||t!=null){const o=M7(s,t);if(o!==null)Pp[s]=o;else return console.log("Could not get context for WebGL version",s),null}const i=Pp[s];return i==null||i.isContextLost()?(delete Pp[s],ac(s)):(i.disable(i.DEPTH_TEST),i.disable(i.STENCIL_TEST),i.disable(i.BLEND),i.disable(i.DITHER),i.disable(i.POLYGON_OFFSET_FILL),i.disable(i.SAMPLE_COVERAGE),i.enable(i.SCISSOR_TEST),i.enable(i.CULL_FACE),i.cullFace(i.BACK),Pp[s])}function T7(s){if(typeof OffscreenCanvas<"u"&&s===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function M7(s,t){if(s!==1&&s!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const i=t??T7(s);return i.addEventListener("webglcontextlost",o=>{o.preventDefault(),delete Pp[s]},!1),Ee().getBool("SOFTWARE_WEBGL_ENABLED")&&(yw.failIfMajorPerformanceCaveat=!1),s===1?i.getContext("webgl",yw)||i.getContext("experimental-webgl",yw):i.getContext("webgl2",yw)}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var dy;(function(s){s[s.DENSE=0]="DENSE",s[s.SHARED_BATCH=1]="SHARED_BATCH"})(dy||(dy={}));var Ko;(function(s){s[s.RENDER=0]="RENDER",s[s.UPLOAD=1]="UPLOAD",s[s.PIXELS=2]="PIXELS",s[s.DOWNLOAD=3]="DOWNLOAD"})(Ko||(Ko={}));var Vr;(function(s){s[s.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",s[s.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",s[s.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",s[s.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",s[s.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Vr||(Vr={}));function fy(s,t){return[t,s]}function _7(s,t){return s*t}function vw(s){const t=N(s),i=Math.ceil(t/4);return W(i)}function s0(s,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(s/2))]}function R7(s,t){const[i,o]=s0(s,t);return i*o*4}function RT(s,t){const i=s;let o,l,u,f,g,A,v,C,S,M;return Ee().getNumber("WEBGL_VERSION")===2?(o=i.R32F,l=i.R16F,u=i.RGBA16F,f=i.RGBA32F,g=i.RED,v=4,C=1,S=i.HALF_FLOAT,M=i.FLOAT,A=i.RGBA8):(o=s.RGBA,l=s.RGBA,u=s.RGBA,f=i.RGBA,g=s.RGBA,v=4,C=4,S=t!=null?t.HALF_FLOAT_OES:null,M=s.FLOAT,A=s.RGBA),{internalFormatFloat:o,internalFormatHalfFloat:l,internalFormatPackedHalfFloat:u,internalFormatPackedFloat:f,textureFormatFloat:g,downloadTextureFormat:A,downloadUnpackNumChannels:v,defaultNumChannels:C,textureTypeHalfFloat:S,textureTypeFloat:M}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function vn(s,t){const i=t();return Ee().getBool("DEBUG")&&k7(s),i}function k7(s){const t=s.getError();if(t!==s.NO_ERROR)throw new Error("WebGL Error: "+D7(s,t))}const B7=596e-10,L7=65504;function N7(s){return!!(Ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||s===0||B7<Math.abs(s)&&Math.abs(s)<L7)}function D7(s,t){switch(t){case s.NO_ERROR:return"NO_ERROR";case s.INVALID_ENUM:return"INVALID_ENUM";case s.INVALID_VALUE:return"INVALID_VALUE";case s.INVALID_OPERATION:return"INVALID_OPERATION";case s.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case s.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case s.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function xw(s,t){return rh(s,()=>s.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function F7(s,t){const i=rh(s,()=>s.createShader(s.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(vn(s,()=>s.shaderSource(i,t)),vn(s,()=>s.compileShader(i)),s.getShaderParameter(i,s.COMPILE_STATUS)===!1)throw console.log(s.getShaderInfoLog(i)),new Error("Failed to compile vertex shader.");return i}function O7(s,t){const i=rh(s,()=>s.createShader(s.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(vn(s,()=>s.shaderSource(i,t)),vn(s,()=>s.compileShader(i)),Ee().get("ENGINE_COMPILE_ONLY"))return i;if(s.getShaderParameter(i,s.COMPILE_STATUS)===!1)throw P3(t,s.getShaderInfoLog(i)),new Error("Failed to compile fragment shader.");return i}const G7=/ERROR: [0-9]+:([0-9]+):/g;function P3(s,t){const i=G7.exec(t);if(i==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(s);return}const o=+i[1],l=s.split(`
`),u=l.length.toString().length+2,f=l.map((S,M)=>H((M+1).toString(),u)+S);let g=0;for(let S=0;S<f.length;S++)g=Math.max(f[S].length,g);const A=f.slice(0,o-1),v=f.slice(o-1,o),C=f.slice(o);console.log(A.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${H(v[0],g)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(C.join(`
`))}function U7(s){return rh(s,()=>s.createProgram(),"Unable to create WebGLProgram.")}function P7(s,t){if(vn(s,()=>s.linkProgram(t)),!Ee().get("ENGINE_COMPILE_ONLY")&&s.getProgramParameter(t,s.LINK_STATUS)===!1)throw console.log(s.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function kT(s,t){if(vn(s,()=>s.validateProgram(t)),s.getProgramParameter(t,s.VALIDATE_STATUS)===!1)throw console.log(s.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function z7(s,t){const i=rh(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return vn(s,()=>s.bindBuffer(s.ARRAY_BUFFER,i)),vn(s,()=>s.bufferData(s.ARRAY_BUFFER,t,s.STATIC_DRAW)),i}function V7(s,t){const i=rh(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return vn(s,()=>s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,i)),vn(s,()=>s.bufferData(s.ELEMENT_ARRAY_BUFFER,t,s.STATIC_DRAW)),i}function W7(s){return rh(s,()=>s.createTexture(),"Unable to create WebGLTexture.")}function H7(s,t){const i=Ee().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(s<=0||t<=0){const o=`[${s}x${t}]`;throw new Error("Requested texture size "+o+" is invalid.")}if(s>i||t>i){const o=`[${s}x${t}]`,l=`[${i}x${i}]`;throw new Error("Requested texture size "+o+" greater than WebGL maximum on this browser / GPU "+l+".")}}function X7(s){return rh(s,()=>s.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function z3(s,t,i,o,l,u,f){const g=s.getAttribLocation(t,i);return g===-1?!1:(vn(s,()=>s.bindBuffer(s.ARRAY_BUFFER,o)),vn(s,()=>s.vertexAttribPointer(g,l,s.FLOAT,!1,u,f)),vn(s,()=>s.enableVertexAttribArray(g)),!0)}function Q7(s,t,i){j7(s,i),vn(s,()=>s.activeTexture(s.TEXTURE0+i)),vn(s,()=>s.bindTexture(s.TEXTURE_2D,t))}function K7(s,t,i){return rh(s,()=>s.getUniformLocation(t,i),'uniform "'+i+'" not present in program.')}function Z7(s,t,i){return s.getUniformLocation(t,i)}function $7(s,t,i,o){vn(s,()=>Q7(s,t,o)),vn(s,()=>s.uniform1i(i,o))}function BT(s,t,i){vn(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,i)),vn(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,t,0))}function V3(s,t){vn(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,t)),vn(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,null,0))}function ww(s){const t=s.checkFramebufferStatus(s.FRAMEBUFFER);if(t!==s.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Y7(s,t))}function Y7(s,t){switch(t){case s.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case s.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function rh(s,t,i){const o=vn(s,()=>t());if(o==null)throw new Error(i);return o}function j7(s,t){const i=s.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,o=t+s.TEXTURE0;if(o<s.TEXTURE0||o>i){const l=`[gl.TEXTURE0, gl.TEXTURE${i}]`;throw new Error(`textureUnit must be in ${l}.`)}}function r0(s,t=2){return N(s.slice(0,s.length-t))}function a0(s){if(s.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[s.length>1?s[s.length-2]:1,s[s.length-1]]}function LT(s){let t=[1,1,1];return s.length===0||s.length===1&&s[0]===1||(t=[r0(s),...a0(s)]),t}function q7(s,t=!1){let i=Ee().getNumber("WEBGL_MAX_TEXTURE_SIZE"),o=Ee().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");o===1/0&&Ee().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(o=i/2),t&&(i=i*2,o=o*2,s=s.map((g,A)=>A>=s.length-2?y(s[A]):s[A]),s.length===1&&(s=[2,s[0]])),s.length!==2&&(s=ee(s).newShape);let l=N(s),u=null;s.length<=1&&l<=i?u=[1,l]:s.length===2&&s[0]<=i&&s[1]<=i?u=s:s.length===3&&s[0]*s[1]<=i&&s[2]<=i?u=[s[0]*s[1],s[2]]:s.length===3&&s[0]<=i&&s[1]*s[2]<=i?u=[s[0],s[1]*s[2]]:s.length===4&&s[0]*s[1]*s[2]<=i&&s[3]<=i?u=[s[0]*s[1]*s[2],s[3]]:s.length===4&&s[0]<=i&&s[1]*s[2]*s[3]<=i&&(u=[s[0],s[1]*s[2]*s[3]]);const f=u!=null&&Math.max(...u)>o&&Math.min(...u)<=(t?2:1)&&Math.min(...u)>0;if(u==null||f)if(t){const g=r0(s);let A=2,v=2;s.length&&([A,v]=a0(s)),l=g*(A/2)*(v/2),u=W(l).map(C=>C*2)}else u=W(l);return u}function Cw(s){return s%2===0}function Ew(s,t){if(s=s.slice(-2),t=t.slice(-2),O(s,t)||!s.length||!t.length||s[0]===0||s[1]===0||t[0]===0||t[1]===0)return!0;if(s.length!==t.length){const i=s.slice(-1)[0],o=t.slice(-1)[0];if(i===o||Cw(i)&&Cw(o)&&(s[0]===1||t[0]===1))return!0}return s[1]===t[1]&&Cw(s[0])&&Cw(t[0])}let NT,DT;function J7(s){if(NT==null){const t=ac(s);NT=t.getParameter(t.MAX_TEXTURE_SIZE)}return NT}function eY(s){if(DT==null){const t=ac(s);DT=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,DT)}function tY(s){if(s===0)return 0;let t;const i=ac(s);return El(i,"EXT_disjoint_timer_query_webgl2")&&s===2?t=2:El(i,"EXT_disjoint_timer_query")?t=1:t=0,t}function El(s,t){return s.getExtension(t)!=null}function W3(s){try{if(ac(s)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function nY(s){if(s===0)return!1;const t=ac(s);if(s===1){if(!El(t,"OES_texture_float"))return!1}else if(!El(t,"EXT_color_buffer_float"))return!1;return FT(t)}function iY(s){if(s===0)return!1;const t=ac(s);if(s===1){if(!El(t,"OES_texture_float")||!El(t,"WEBGL_color_buffer_float"))return!1}else{if(El(t,"EXT_color_buffer_float"))return FT(t);const i="EXT_color_buffer_half_float";if(El(t,i)){const o=t.getExtension(i);return sY(t,o)}return!1}return FT(t)}function FT(s){const t=RT(s),i=s.createTexture();s.bindTexture(s.TEXTURE_2D,i),s.texImage2D(s.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const u=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,u),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,i,0);const f=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(i),s.deleteFramebuffer(u),f}function sY(s,t){const i=RT(s,t),o=s.createTexture();s.bindTexture(s.TEXTURE_2D,o),s.texImage2D(s.TEXTURE_2D,0,i.internalFormatHalfFloat,1,1,0,i.textureFormatFloat,i.textureTypeHalfFloat,null);const f=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,f),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,o,0);const g=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(o),s.deleteFramebuffer(f),g}function rY(s){return s!==2?!1:ac(s).fenceSync!=null}function py(s,t){Array.isArray(s)||(s=[s]),s.forEach(i=>{i!=null&&E(i.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const In=Ee();In.registerFlag("HAS_WEBGL",()=>In.getNumber("WEBGL_VERSION")>0),In.registerFlag("WEBGL_VERSION",()=>W3(2)?2:W3(1)?1:0),In.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),In.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>In.get("WEBGL_VERSION")===2),In.registerFlag("WEBGL_CPU_FORWARD",()=>!0),In.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),In.registerFlag("WEBGL_PACK",()=>In.getBool("HAS_WEBGL")),In.registerFlag("WEBGL_PACK_NORMALIZATION",()=>In.getBool("WEBGL_PACK")),In.registerFlag("WEBGL_PACK_CLIP",()=>In.getBool("WEBGL_PACK")),In.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>In.getBool("WEBGL_PACK")),In.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>In.getBool("WEBGL_PACK")),In.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>In.getBool("WEBGL_PACK")),In.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>In.getBool("WEBGL_PACK")),In.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>In.getBool("WEBGL_PACK")),In.registerFlag("WEBGL_PACK_REDUCE",()=>In.getBool("WEBGL_PACK")),In.registerFlag("WEBGL_LAZILY_UNPACK",()=>In.getBool("WEBGL_PACK")),In.registerFlag("WEBGL_CONV_IM2COL",()=>In.getBool("WEBGL_PACK")),In.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>J7(In.getNumber("WEBGL_VERSION"))),In.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>eY(In.getNumber("WEBGL_VERSION"))),In.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const s=In.getNumber("WEBGL_VERSION");return s===0?0:tY(s)}),In.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>In.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Kf()),In.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>nY(In.getNumber("WEBGL_VERSION"))),In.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>In.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:In.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),In.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>iY(In.getNumber("WEBGL_VERSION"))),In.registerFlag("WEBGL_FENCE_API_ENABLED",()=>rY(In.getNumber("WEBGL_VERSION"))),In.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>In.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),In.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,s=>{if(s<0&&s!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${s}.`)}),In.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Kf()?1:-1,s=>{if(s<0&&s!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${s}.`)}),In.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),In.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),In.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),In.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),In.registerFlag("WEBGL_EXP_CONV",()=>!1),In.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>In.getBool("IS_TEST")),In.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),In.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),In.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fa(){let s,t,i,o,l,u,f,g,A,v;return Ee().getNumber("WEBGL_VERSION")===2?(s="#version 300 es",t="in",i="out",o="in",l="texture",u="outputColor",f="out vec4 outputColor;",g=Ee().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",A="",v=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(s="",t="attribute",i="varying",o="varying",l="texture2D",u="gl_FragColor",f="",g=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,A=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,v=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:s,attribute:t,varyingVs:i,varyingFs:o,texture2D:l,output:u,defineOutput:f,defineSpecialNaN:g,defineSpecialInf:A,defineRound:v}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zp(s,t,i="index"){const o=Ne(t);return o.map((l,u)=>{const f=`int ${s[u]} = ${i} / ${l}`,g=u===o.length-1?`int ${s[u+1]} = ${i} - ${s[u]} * ${l}`:`index -= ${s[u]} * ${l}`;return`${f}; ${g};`}).join("")}function Sw(s,t,i="index"){const o=Ne(t);return o.map((l,u)=>{const f=`int ${s[u]} = ${i} / outShapeStrides[${u}]`,g=u===o.length-1?`int ${s[u+1]} = ${i} - ${s[u]} * outShapeStrides[${u}]`:`index -= ${s[u]} * outShapeStrides[${u}]`;return`${f}; ${g};`}).join("")}function aY(s,t){const i=s.length,o=s.map(u=>`${t}[${u}]`),l=new Array(i-1);l[i-2]=o[i-1];for(let u=i-3;u>=0;--u)l[u]=`(${l[u+1]} * ${o[u+1]})`;return l}function oY(s,t,i="index"){const o=s.map((u,f)=>f),l=aY(o,t);return l.map((u,f)=>{const g=`int ${s[f]} = ${i} / ${l[f]}`,A=f===l.length-1?`int ${s[f+1]} = ${i} - ${s[f]} * ${l[f]}`:`index -= ${s[f]} * ${l[f]}`;return`${g}; ${A};`}).join("")}function OT(s){const t=Ne(s).map(i=>i.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function GT(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const H3=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const{getBroadcastDims:X3}=L5;function lY(s,t,i){const o=[];if(s.forEach(M=>{const _=N(M.shapeInfo.logicalShape);if(M.shapeInfo.isUniform?o.push(`uniform float ${M.name}${_>1?`[${_}]`:""};`):(o.push(`uniform sampler2D ${M.name};`),o.push(`uniform int offset${M.name};`)),i.enableShapeUniforms){const{uniformShape:B}=UT(i.packedInputs,M.shapeInfo.logicalShape,M.shapeInfo.texShape);switch(B.length){case 1:o.push(`uniform int ${M.name}Shape;`);break;case 2:o.push(`uniform ivec2 ${M.name}Shape;`);break;case 3:o.push(`uniform ivec3 ${M.name}Shape;`);break;case 4:o.push(`uniform ivec4 ${M.name}Shape;`);break}o.push(`uniform ivec2 ${M.name}TexShape;`)}}),i.enableShapeUniforms){switch(t.logicalShape.length){case 1:o.push("uniform int outShape;");break;case 2:o.push("uniform ivec2 outShape;"),o.push("uniform int outShapeStrides;");break;case 3:o.push("uniform ivec3 outShape;"),o.push("uniform ivec2 outShapeStrides;");break;case 4:o.push("uniform ivec4 outShape;"),o.push("uniform ivec3 outShapeStrides;");break}o.push("uniform ivec2 outTexShape;")}i.customUniforms&&i.customUniforms.forEach(M=>{o.push(`uniform ${M.type} ${M.name}${M.arrayIndex?`[${M.arrayIndex}]`:""};`)});const l=o.join(`
`),u=s.map(M=>cY(M,t,i.packedInputs,i.enableShapeUniforms)).join(`
`),f=t.texShape,g=fa(),A=dY(g);let v,C,S=mY(g);return t.isPacked?(v=uY(t.logicalShape,f,i.enableShapeUniforms),C=pY(g)):(v=hY(t.logicalShape,f,i.enableShapeUniforms),C=fY(g)),i.packedInputs&&(S+=yY),[S,A,C,l,v,u,i.userCode].join(`
`)}function o0(s,t=!1){const i=s.shapeInfo.logicalShape;switch(i.length){case 0:return kY(s,t);case 1:return LY(s,t);case 2:return DY(s,t);case 3:return OY(s,t);case 4:return UY(s,t);case 5:return PY(s);case 6:return zY(s);default:throw new Error(`${i.length}-D input sampling is not yet supported`)}}function Q3(s,t){switch(s.shapeInfo.logicalShape.length){case 0:return RY(s);case 1:return BY(s,t);case 2:return NY(s,t);case 3:return FY(s,t);default:return GY(s,t)}}function cY(s,t,i=!1,o){let l="";i?l+=Q3(s,o):l+=o0(s,o);const u=s.shapeInfo.logicalShape,f=t.logicalShape;return u.length<=f.length&&(i?l+=VY(s,t):l+=WY(s,t)),l}function uY(s,t,i){switch(s.length){case 0:return K3();case 1:return vY(s,t,i);case 2:return MY(s,t,i);case 3:return wY(s,t,i);default:return EY(s,t,i)}}function hY(s,t,i){switch(s.length){case 0:return K3();case 1:return xY(s,t,i);case 2:return _Y(s,t,i);case 3:return CY(s,t,i);case 4:return SY(s,t,i);case 5:return IY(s,t);case 6:return TY(s,t);default:throw new Error(`${s.length}-D output sampling is not yet supported`)}}function dY(s){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${s.texture2D}(textureSampler, uv).r;
    }
  `}function fY(s){return`
    void setOutput(float val) {
      ${s.output} = vec4(val, 0, 0, 0);
    }
  `}function pY(s){return`
    void setOutput(vec4 val) {
      ${s.output} = val;
    }
  `}function mY(s){return`${s.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${s.varyingFs} vec2 resultUV;
    ${s.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${s.defineSpecialNaN}
    ${s.defineSpecialInf}
    ${s.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${gY}
    ${AY}
    ${bY}
  `}const gY=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,AY=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,bY=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,yY=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function K3(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function vY(s,t,i){const o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return o[0]===1?i?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${o[1]}.0);
      }
    `:o[1]===1?i?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${o[0]}.0);
      }
    `:i?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));
      return 2 * (resTexRC.x * ${o[1]} + resTexRC.y);
    }
  `}function xY(s,t,i){return t[0]===1?i?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?i?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:i?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function wY(s,t,i){if(i)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],l=Math.ceil(s[2]/2),u=l*Math.ceil(s[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));
      int index = resTexRC.x * ${o[1]} + resTexRC.y;

      int b = index / ${u};
      index -= b * ${u};

      int r = 2 * (index / ${l});
      int c = imod(index, ${l}) * 2;

      return ivec3(b, r, c);
    }
  `}function CY(s,t,i){if(i)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Sw(["r","c","d"],s)}
    return ivec3(r, c, d);
  }
`;const o=zp(["r","c","d"],s);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${o}
      return ivec3(r, c, d);
    }
  `}function EY(s,t,i){if(i)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],l=Math.ceil(s[s.length-1]/2),u=l*Math.ceil(s[s.length-2]/2);let f=u,g="",A="b, r, c";for(let v=2;v<s.length-1;v++)f*=s[s.length-v-1],g=`
      int b${v} = index / ${f};
      index -= b${v} * ${f};
    `+g,A=`b${v}, `+A;return`
    ivec${s.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));
      int index = resTexRC.x * ${o[1]} + resTexRC.y;

      ${g}

      int b = index / ${u};
      index -= b * ${u};

      int r = 2 * (index / ${l});
      int c = imod(index, ${l}) * 2;

      return ivec${s.length}(${A});
    }
  `}function SY(s,t,i){if(i)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Sw(["r","c","d","d2"],s)}
      return ivec4(r, c, d, d2);
    }
  `;const o=zp(["r","c","d","d2"],s);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${o}
      return ivec4(r, c, d, d2);
    }
  `}function IY(s,t){const i=zp(["r","c","d","d2","d3"],s);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${i}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function TY(s,t){const i=zp(["r","c","d","d2","d3","d4"],s);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${i}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function MY(s,t,i){const o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(O(s,t))return i?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${o[0]}, ${o[1]}));
      }
    `;const l=Math.ceil(s[1]/2);return i?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));

      int index = resTexRC.x * ${o[1]} + resTexRC.y;
      int r = 2 * (index / ${l});
      int c = imod(index, ${l}) * 2;

      return ivec2(r, c);
    }
  `}function _Y(s,t,i){return O(s,t)?i?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:s[1]===1?i?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:s[0]===1?i?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:i?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${s[1]};
      int c = index - r * ${s[1]};
      return ivec2(r, c);
    }
  `}function Vp(s){return`offset${s}`}function RY(s){const t=s.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),o=fa();return`
    vec4 ${i}() {
      return ${o.texture2D}(${t}, halfCR);
    }
  `}function kY(s,t){const i=s.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1);if(s.shapeInfo.isUniform)return`float ${o}() {return ${i};}`;const[l,u]=s.shapeInfo.texShape;if(l===1&&u===1)return`
      float ${o}() {
        return sampleTexture(${i}, halfCR);
      }
    `;const f=Vp(i);if(t)return`
    float ${o}() {
      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], ${f});
      return sampleTexture(${i}, uv);
    }
  `;const[g,A]=s.shapeInfo.texShape;return`
    float ${o}() {
      vec2 uv = uvFromFlat(${g}, ${A}, ${f});
      return sampleTexture(${i}, uv);
    }
  `}function BY(s,t){const i=s.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),l=s.shapeInfo.texShape,u=fa();if(t)return`
    vec4 ${o}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${u.texture2D}(${i}, uv);
    }
  `;const f=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];return`
    vec4 ${o}(int index) {
      vec2 uv = packedUVfrom1D(
        ${f[0]}, ${f[1]}, index);
      return ${u.texture2D}(${i}, uv);
    }
  `}function LY(s,t){const i=s.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1);if(s.shapeInfo.isUniform)return`
      float ${o}(int index) {
        ${l0(s)}
      }
    `;const l=s.shapeInfo.texShape,u=l[0],f=l[1];if(f===1&&u===1)return`
      float ${o}(int index) {
        return sampleTexture(${i}, halfCR);
      }
    `;const g=Vp(i);return f===1?t?`
      float ${o}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${g}) + 0.5) / float(${i}TexShape[0]));
        return sampleTexture(${i}, uv);
      }
    `:`
      float ${o}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${g}) + 0.5) / ${u}.0);
        return sampleTexture(${i}, uv);
      }
    `:u===1?t?`
      float ${o}(int index) {
        vec2 uv = vec2((float(index + ${g}) + 0.5) / float(${i}TexShape[1]), 0.5);
        return sampleTexture(${i}, uv);
      }
    `:`
      float ${o}(int index) {
        vec2 uv = vec2((float(index + ${g}) + 0.5) / ${f}.0, 0.5);
        return sampleTexture(${i}, uv);
      }
    `:t?`
    float ${o}(int index) {
      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index + ${g});
      return sampleTexture(${i}, uv);
    }
  `:`
    float ${o}(int index) {
      vec2 uv = uvFromFlat(${u}, ${f}, index + ${g});
      return sampleTexture(${i}, uv);
    }
  `}function NY(s,t){const i=s.shapeInfo.logicalShape,o=s.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1),u=s.shapeInfo.texShape,f=u[0],g=u[1],A=fa();if(u!=null&&O(i,u))return t?`
      vec4 ${l}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);

        return ${A.texture2D}(${o}, uv);
      }
    `:`
      vec4 ${l}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${f}.0);

        return ${A.texture2D}(${o}, uv);
      }
    `;if(t)return`
    vec4 ${l}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${o}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${A.texture2D}(${o}, uv);
    }
  `;const v=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],C=Math.ceil(i[1]/2);return`
    vec4 ${l}(int row, int col) {
      vec2 uv = packedUVfrom2D(${C}, ${v[0]}, ${v[1]}, row, col);
      return ${A.texture2D}(${o}, uv);
    }
  `}function DY(s,t){const i=s.shapeInfo.logicalShape,o=s.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1),u=s.shapeInfo.texShape;if(u!=null&&O(i,u)){if(t)return`
      float ${l}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `;const M=u[0],_=u[1];return`
    float ${l}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${_}.0, ${M}.0);
      return sampleTexture(${o}, uv);
    }
  `}const{newShape:f,keptDims:g}=ee(i),A=f;if(A.length<i.length){const M=c0(s,A),_=["row","col"];return`
      ${o0(M,t)}
      float ${l}(int row, int col) {
        return ${l}(${u0(_,g)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${l}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${i[1]}, 1)));
        ${l0(s)}
      }
    `;const v=u[0],C=u[1],S=Vp(o);return C===1?t?`
      float ${l}(int row, int col) {
        float index = dot(vec3(row, col, ${S}), vec3(${o}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${o}TexShape[0]));
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${l}(int row, int col) {
      float index = dot(vec3(row, col, ${S}), vec3(${i[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${v}.0);
      return sampleTexture(${o}, uv);
    }
  `:v===1?t?`
      float ${l}(int row, int col) {
        float index = dot(vec3(row, col, ${S}), vec3(${o}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${o}TexShape[1]), 0.5);
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${l}(int row, int col) {
      float index = dot(vec3(row, col, ${S}), vec3(${i[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${C}.0, 0.5);
      return sampleTexture(${o}, uv);
    }
  `:t?`
      float ${l}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o}Shape[1] + col + ${S};
        vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index);
        return sampleTexture(${o}, uv);
      }
    `:`
  float ${l}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${i[1]} + col + ${S};
    vec2 uv = uvFromFlat(${v}, ${C}, index);
    return sampleTexture(${o}, uv);
  }
`}function FY(s,t){const i=s.shapeInfo.logicalShape,o=s.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1),u=s.shapeInfo.texShape,f=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];if(i[0]===1){const M=i.slice(1),_=[1,2],B=c0(s,M),F=["b","row","col"];return`
        ${Q3(B,t)}
        vec4 ${l}(int b, int row, int col) {
          return ${l}(${u0(F,_)});
        }
      `}const g=fa();if(t)return`
    vec4 ${l}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${o}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${o}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${g.texture2D}(${o}, uv);
    }
  `;const A=f[0],v=f[1],C=Math.ceil(i[2]/2),S=C*Math.ceil(i[1]/2);return`
    vec4 ${l}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${A}, ${v}, ${S}, ${C}, b, row, col);
      return ${g.texture2D}(${o}, uv);
    }
  `}function OY(s,t){const i=s.shapeInfo.logicalShape,o=s.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1),u=i[1]*i[2],f=i[2],{newShape:g,keptDims:A}=ee(i),v=g;if(v.length<i.length){const F=c0(s,v),P=["row","col","depth"];return`
        ${o0(F,t)}
        float ${l}(int row, int col, int depth) {
          return ${l}(${u0(P,A)});
        }
      `}if(s.shapeInfo.isUniform)return`
      float ${l}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${u}, ${f}, 1)));
        ${l0(s)}
      }
    `;const C=s.shapeInfo.texShape,S=C[0],M=C[1],_=s.shapeInfo.flatOffset;if(M===u&&_==null)return t?`
      float ${l}(int row, int col, int depth) {
        int stride1 = ${o}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
        float ${l}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${f}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${M}.0, ${S}.0);
          return sampleTexture(${o}, uv);
        }
      `;if(M===f&&_==null)return t?`
      float ${l}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${o}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${l}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${i[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${M}.0, ${S}.0);
      return sampleTexture(${o}, uv);
    }
  `;const B=Vp(o);return t?`
    float ${l}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${o}Shape[1] * ${o}Shape[2];
      int stride1 = ${o}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${B};
      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index);
      return sampleTexture(${o}, uv);
    }
    `:`
      float ${l}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${u} + col * ${f} + depth + ${B};
        vec2 uv = uvFromFlat(${S}, ${M}, index);
        return sampleTexture(${o}, uv);
      }
  `}function GY(s,t){const i=s.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),l=fa();if(t)return`
    vec4 ${o}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${i}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${i}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${i}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${l.texture2D}(${i}, uv);
    }
  `;const u=s.shapeInfo.logicalShape,f=u.length,g=s.shapeInfo.texShape,A=[Math.ceil(g[0]/2),Math.ceil(g[1]/2)],v=A[0],C=A[1],S=Math.ceil(u[f-1]/2);let M=S*Math.ceil(u[f-2]/2),_="int b, int row, int col",B=`b * ${M} + (row / 2) * ${S} + (col / 2)`;for(let F=2;F<f-1;F++)_=`int b${F}, `+_,M*=u[f-F-1],B=`b${F} * ${M} + `+B;return`
    vec4 ${o}(${_}) {
      int index = ${B};
      int texR = index / ${C};
      int texC = index - texR * ${C};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${C}, ${v});
      return ${l.texture2D}(${i}, uv);
    }
  `}function UY(s,t){const i=s.shapeInfo.logicalShape,o=s.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1),u=i[3],f=i[2]*u,g=i[1]*f,{newShape:A,keptDims:v}=ee(i);if(A.length<i.length){const V=c0(s,A),$=["row","col","depth","depth2"];return`
      ${o0(V,t)}
      float ${l}(int row, int col, int depth, int depth2) {
        return ${l}(${u0($,v)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${l}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${g}, ${f}, ${u}, 1)));
        ${l0(s)}
      }
    `;const C=s.shapeInfo.flatOffset,S=s.shapeInfo.texShape,M=S[0],_=S[1],B=`int stride2 = ${o}Shape[3];`,F=`int stride1 = ${o}Shape[2] * stride2;`,P=`int stride0 = ${o}Shape[1] * stride1;`;if(_===g&&C==null)return t?`
      float ${l}(int row, int col, int depth, int depth2) {
        ${B}
        ${F}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
      float ${l}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${f}, ${u}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${_}.0, ${M}.0);
        return sampleTexture(${o}, uv);
      }
    `;if(_===u&&C==null)return t?`
      float ${l}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${o}Shape[1] * ${o}Shape[2], ${o}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
      float ${l}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${i[1]*i[2]}, ${i[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${_}.0, ${M}.0);
        return sampleTexture(${o}, uv);
      }
    `;const U=Vp(o);return t?`
    float ${l}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${B}
      ${F}
      ${P}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index + ${U});
      return sampleTexture(${o}, uv);
    }
  `:`
    float ${l}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${g} + col * ${f} +
          depth * ${u} + depth2;
      vec2 uv = uvFromFlat(${M}, ${_}, index + ${U});
      return sampleTexture(${o}, uv);
    }
  `}function PY(s){const t=s.shapeInfo.logicalShape,i=s.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),l=t[4],u=t[3]*l,f=t[2]*u,g=t[1]*f,{newShape:A,keptDims:v}=ee(t);if(A.length<t.length){const F=c0(s,A),P=["row","col","depth","depth2","depth3"];return`
      ${o0(F)}
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        return ${o}(${u0(P,v)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${g}, ${f}, ${u}, ${l})) +
          depth3;
        ${l0(s)}
      }
    `;const C=s.shapeInfo.flatOffset,S=s.shapeInfo.texShape,M=S[0],_=S[1];if(_===g&&C==null)return`
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${f}, ${u}, ${l}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${_}.0, ${M}.0);
        return sampleTexture(${i}, uv);
      }
    `;if(_===l&&C==null)return`
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${_}.0, ${M}.0);
        return sampleTexture(${i}, uv);
      }
    `;const B=Vp(i);return`
    float ${o}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${g} + col * ${f} + depth * ${u} +
          depth2 * ${l} + depth3 + ${B};
      vec2 uv = uvFromFlat(${M}, ${_}, index);
      return sampleTexture(${i}, uv);
    }
  `}function zY(s){const t=s.shapeInfo.logicalShape,i=s.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),{newShape:l,keptDims:u}=ee(t);if(l.length<t.length){const P=c0(s,l),U=["row","col","depth","depth2","depth3","depth4"];return`
      ${o0(P)}
      float ${o}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${o}(${u0(U,u)});
      }
    `}const f=t[5],g=t[4]*f,A=t[3]*g,v=t[2]*A,C=t[1]*v;if(s.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${C}, ${v}, ${A}, ${g})) +
          dot(
            vec2(depth3, depth4),
            vec2(${f}, 1)));
        ${l0(s)}
      }
    `;const S=s.shapeInfo.flatOffset,M=s.shapeInfo.texShape,_=M[0],B=M[1];if(B===C&&S==null)return`
      float ${o}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${v}, ${A}, ${g}, ${f})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${B}.0, ${_}.0);
        return sampleTexture(${i}, uv);
      }
    `;if(B===f&&S==null)return`
      float ${o}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${B}.0, ${_}.0);
        return sampleTexture(${i}, uv);
      }
    `;const F=Vp(i);return`
    float ${o}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${C} + col * ${v} + depth * ${A} +
          depth2 * ${g} + depth3 * ${f} + depth4 + ${F};
      vec2 uv = uvFromFlat(${_}, ${B}, index);
      return sampleTexture(${i}, uv);
    }
  `}function l0(s){const t=s.name,i=N(s.shapeInfo.logicalShape);return i<2?`return ${t};`:`
    for (int i = 0; i < ${i}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function VY(s,t){const i=s.name,o=i.charAt(0).toUpperCase()+i.slice(1),l="get"+o+"AtOutCoords",u=s.shapeInfo.logicalShape.length,f=t.logicalShape.length,g=X3(s.shapeInfo.logicalShape,t.logicalShape),A=ws(f),v=f-u;let C;const S=["x","y","z","w","u","v"];u===0?C="":f<2&&g.length>=1?C="coords = 0;":C=g.map(P=>`coords.${S[P+v]} = 0;`).join(`
`);let M="";f<2&&u>0?M="coords":M=s.shapeInfo.logicalShape.map((P,U)=>`coords.${S[U+v]}`).join(", ");let _="return outputValue;";const B=N(s.shapeInfo.logicalShape)===1,F=N(t.logicalShape)===1;if(u===1&&!B&&!F)_=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(B&&!F)f===1?_=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:_=`
        return vec4(outputValue.x);
      `;else if(g.length){const P=u-2,U=u-1;g.indexOf(P)>-1&&g.indexOf(U)>-1?_="return vec4(outputValue.x);":g.indexOf(P)>-1?_="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":g.indexOf(U)>-1&&(_="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${l}() {
      ${A} coords = getOutputCoords();
      ${C}
      vec4 outputValue = get${o}(${M});
      ${_}
    }
  `}function WY(s,t){const i=s.name,o=i.charAt(0).toUpperCase()+i.slice(1),l="get"+o+"AtOutCoords",u=t.texShape,f=s.shapeInfo.texShape,g=s.shapeInfo.logicalShape.length,A=t.logicalShape.length;if(!s.shapeInfo.isUniform&&g===A&&s.shapeInfo.flatOffset==null&&O(f,u))return`
      float ${l}() {
        return sampleTexture(${i}, resultUV);
      }
    `;const v=ws(A),C=X3(s.shapeInfo.logicalShape,t.logicalShape),S=A-g;let M;const _=["x","y","z","w","u","v"];g===0?M="":A<2&&C.length>=1?M="coords = 0;":M=C.map(F=>`coords.${_[F+S]} = 0;`).join(`
`);let B="";return A<2&&g>0?B="coords":B=s.shapeInfo.logicalShape.map((F,P)=>`coords.${_[P+S]}`).join(", "),`
    float ${l}() {
      ${v} coords = getOutputCoords();
      ${M}
      return get${o}(${B});
    }
  `}function ws(s){if(s<=1)return"int";if(s===2)return"ivec2";if(s===3)return"ivec3";if(s===4)return"ivec4";if(s===5)return"ivec5";if(s===6)return"ivec6";throw Error(`GPU for rank ${s} is not yet supported`)}function UT(s,t,i){const{newShape:o,keptDims:l}=ee(t),u=t.length,f=s&&u===3&&t[0]===1,g=f?t.slice(1):o,A=!s&&u>1&&!O(t,i)&&o.length<u||f;return{useSqueezeShape:A,uniformShape:A?g:t,keptDims:l}}function c0(s,t){const i=JSON.parse(JSON.stringify(s));return i.shapeInfo.logicalShape=t,i}function u0(s,t){return t.map(i=>s[i]).join(", ")}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function HY(s,t,i,o){const l=i.map((C,S)=>{const M={logicalShape:C.shape,texShape:C.isUniform?null:C.texData.texShape,isUniform:C.isUniform,isPacked:C.isUniform?!1:C.texData.isPacked,flatOffset:null};return C.texData!=null&&C.texData.slice!=null&&C.texData.slice.flatOffset>0&&(M.flatOffset=C.texData.slice.flatOffset),{name:t.variableNames[S],shapeInfo:M}}),u=l.map(C=>C.shapeInfo),f={logicalShape:o.shape,texShape:o.texData.texShape,isUniform:!1,isPacked:o.texData.isPacked,flatOffset:null},g=lY(l,f,t),A=O7(s.gl,g),v=s.createProgram(A);return Ee().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:A,source:g,webGLProgram:v,inShapeInfos:u,outShapeInfo:f,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:A,source:g,webGLProgram:v,inShapeInfos:u,outShapeInfo:f},Z3(s,t,v))}function Z3(s,t,i){const o={},l={},u={},f=[];let g,A,v,C=null,S=null;S=s.getUniformLocation(i,"NAN",!1),Ee().getNumber("WEBGL_VERSION")===1&&(C=s.getUniformLocation(i,"INFINITY",!1));const M=!1;for(let _=0;_<t.variableNames.length;_++){const B=t.variableNames[_];o[B]=s.getUniformLocation(i,B,M),o[`offset${B}`]=s.getUniformLocation(i,`offset${B}`,M),t.enableShapeUniforms&&(l[`${B}Shape`]=s.getUniformLocation(i,`${B}Shape`,M),u[`${B}TexShape`]=s.getUniformLocation(i,`${B}TexShape`,M))}return t.enableShapeUniforms&&(g=s.getUniformLocation(i,"outShape",M),v=s.getUniformLocation(i,"outShapeStrides",M),A=s.getUniformLocation(i,"outTexShape",M)),t.customUniforms&&t.customUniforms.forEach((_,B)=>{f[B]=s.getUniformLocation(i,_.name,M)}),{uniformLocations:o,customUniformLocations:f,infLoc:C,nanLoc:S,inShapesLocations:l,inTexShapesLocations:u,outShapeLocation:g,outShapeStridesLocation:v,outTexShapeLocation:A}}function $3(s,t){if(s.length!==t.length)throw Error(`Binary was compiled with ${s.length} inputs, but was executed with ${t.length} inputs`);s.forEach((i,o)=>{const l=i.logicalShape,u=t[o],f=u.shape;if(!O(l,f))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${l} and ${f} must match`);if(i.isUniform&&u.isUniform)return;const g=i.texShape,A=u.isUniform?null:u.texData.texShape;if(!O(g,A))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${g} and ${A} must match`)})}function XY(s,t,i,o,l){t.program.enableShapeUniforms||($3(t.inShapeInfos,i),$3([t.outShapeInfo],[o]));const u=o.texData.texture,f=o.texData.texShape;o.texData.isPacked?s.setOutputPackedMatrixTexture(u.texture,f[0],f[1]):s.setOutputMatrixTexture(u.texture,f[0],f[1]),s.setProgram(t.webGLProgram),Ee().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&s.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&s.gl.uniform1f(t.nanLoc,NaN),i.forEach((A,v)=>{const C=t.program.variableNames[v],S=t.uniformLocations[C],M=t.uniformLocations[`offset${C}`],_=t.inShapesLocations[`${C}Shape`],B=t.inTexShapesLocations[`${C}TexShape`];if(_){const{uniformShape:F}=UT(t.program.packedInputs,A.shape,A.texData.texShape);switch(F.length){case 1:s.gl.uniform1iv(_,new Int32Array(F));break;case 2:s.gl.uniform2iv(_,new Int32Array(F));break;case 3:s.gl.uniform3iv(_,new Int32Array(F));break;case 4:s.gl.uniform4iv(_,new Int32Array(F));break}}if(B&&s.gl.uniform2i(B,A.texData.texShape[0],A.texData.texShape[1]),S!=null){if(A.isUniform){if(N(A.shape)<2)s.gl.uniform1f(S,A.uniformValues[0]);else{let F=A.uniformValues;F instanceof Float32Array||(F=new Float32Array(F)),s.gl.uniform1fv(S,F)}return}A.texData.slice!=null&&M!=null&&s.gl.uniform1i(M,A.texData.slice.flatOffset),s.setInputMatrixTexture(A.texData.texture.texture,S,v)}});const g=t.outShapeLocation;if(g)switch(o.shape.length){case 1:s.gl.uniform1iv(g,new Int32Array(o.shape));break;case 2:s.gl.uniform2iv(g,new Int32Array(o.shape));break;case 3:s.gl.uniform3iv(g,new Int32Array(o.shape));break;case 4:s.gl.uniform4iv(g,new Int32Array(o.shape));break}if(t.outShapeStridesLocation){const A=Ne(o.shape);switch(o.shape.length){case 2:s.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(A));break;case 3:s.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(A));break;case 4:s.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(A));break}}t.outTexShapeLocation&&s.gl.uniform2i(t.outTexShapeLocation,o.texData.texShape[0],o.texData.texShape[1]),t.program.customUniforms&&l&&t.program.customUniforms.forEach((A,v)=>{const C=t.customUniformLocations[v],S=l[v];if(A.type==="float")s.gl.uniform1fv(C,S);else if(A.type==="vec2")s.gl.uniform2fv(C,S);else if(A.type==="vec3")s.gl.uniform3fv(C,S);else if(A.type==="vec4")s.gl.uniform4fv(C,S);else if(A.type==="int")s.gl.uniform1iv(C,S);else if(A.type==="ivec2")s.gl.uniform2iv(C,S);else if(A.type==="ivec3")s.gl.uniform3iv(C,S);else if(A.type==="ivec4")s.gl.uniform4iv(C,S);else throw Error(`uniform type ${A.type} is not supported yet.`)}),s.executeProgram()}function QY(s,t,i){let o="";t.concat(i).forEach(f=>{const g=f.texData!=null&&f.texData.slice!=null&&f.texData.slice.flatOffset>0;if(s.enableShapeUniforms&&!f.isUniform){const A=f.texData.texShape,{useSqueezeShape:v,uniformShape:C,keptDims:S}=UT(s.packedInputs,f.shape,A);let M="",_="",B="";if(C.length===1&&s.packedInputs){const ne=[Math.ceil(A[0]/2),Math.ceil(A[1]/2)];M=`${ne[0]>1}_${ne[1]>1}`}else if(C.length===2&&!s.packedInputs)_=`${C[0]>1}_${C[1]>1}`;else if(C.length>2&&!s.packedInputs){const ne=Ne(C);B=`${ne[0]===A[1]}_${ne[ne.length-1]===A[1]}`}const F=f.shape.length,P=C.length===2&&O(f.shape,A),U=N(f.shape)===1,V=Pl(f.shape,i.shape),$=!s.packedInputs&&F===i.shape.length&&O(A,i.texData.texShape),q=s.packedInputs||C.length>2?"":`${A[0]>1}_${A[1]>1}`;o+=`${F}_${$}_${v?S:""}_${C.length}_${U}_${V}_${P}_${M}_${_}_${B}_${q}_${g}`}else{const A=f.isUniform?"uniform":f.texData.texShape;o+=`${f.shape}_${A}_${g}`}});const l=s.userCode;let u=s.constructor.name;return u+="_"+o+"_"+l+`${Ee().getNumber("WEBGL_VERSION")}`,u}function pa(s){return Ee().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&s<=4}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class KY{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=dy.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=fa();this.outputShape=t,this.enableShapeUniforms=pa(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Sw(["r","c","d"],t):zp(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${i.output} = result;
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ZY{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=dy.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=fa();this.outputShape=t,this.enableShapeUniforms=pa(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Sw(["r","c","d"],t):zp(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${i.output} = result;
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class $Y{constructor(t){this.variableNames=["A"],this.outTexUsage=Ko.DOWNLOAD;const i=fa();this.outputShape=t,this.userCode=`
      ${H3}

      void main() {
        float x = getAAtOutCoords();
        ${i.output} = encode_float(x);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class YY{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Ko.DOWNLOAD;const i=fa();this.outputShape=t,this.userCode=`
      ${H3}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${i.output} = encode_float(x);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class jY{constructor(t,i=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const o=fa();this.outputShape=t,this.enableShapeUniforms=pa(this.outputShape.length);let l="result";i&&(l="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?GT():OT(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${o.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${o.output} = vec4(${l}, 0., 0., 0.);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class qY{constructor(t,i=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const o=fa();this.outputShape=t,this.enableShapeUniforms=pa(this.outputShape.length);let l="",u="result";i&&(u="floor(result * 255. + 0.5)");for(let f=0;f<=1;f++)for(let g=0;g<=1;g++){const A=f*2+g;l+=`
          localCoords = coords;
          if(localCoords[2] + ${g} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${g};
          if (localCoords[1] + ${f} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${f};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${o.texture2D}(A, uv);

            if (offset == 0) {
              result[${A}] = values[0];
            } else if (offset == 1) {
              result[${A}] = values[1];
            } else if (offset == 2) {
              result[${A}] = values[2];
            } else {
              result[${A}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?GT():OT(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${l}

          ${o.output} = ${u};
        }
    `}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function JY(s){const t=fa(),i=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return F7(s,i)}function ej(s){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return z7(s,t)}function tj(s){const t=new Uint16Array([0,1,2,2,1,3]);return V7(s,t)}function my(s,t,i,o,l,u){H7(t,i);const f=W7(s),g=s.TEXTURE_2D;return vn(s,()=>s.bindTexture(g,f)),vn(s,()=>s.texParameteri(g,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE)),vn(s,()=>s.texParameteri(g,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE)),vn(s,()=>s.texParameteri(g,s.TEXTURE_MIN_FILTER,s.NEAREST)),vn(s,()=>s.texParameteri(g,s.TEXTURE_MAG_FILTER,s.NEAREST)),Ee().getNumber("WEBGL_VERSION")===1?vn(s,()=>s.texImage2D(g,0,o,t,i,0,l,u,null)):vn(s,()=>s.texStorage2D(g,1,o,t,i)),vn(s,()=>s.bindTexture(s.TEXTURE_2D,null)),{texture:f,texShape:[i,t]}}function Y3(s){return s.internalFormatFloat}function nj(s,t,i,o){const[l,u]=fy(t,i);return my(s,l,u,Y3(o),o.textureFormatFloat,s.FLOAT)}function j3(s){return s.internalFormatHalfFloat}function ij(s,t,i,o){const[l,u]=fy(t,i);return my(s,l,u,j3(o),o.textureFormatFloat,o.textureTypeHalfFloat)}function q3(s){return s.downloadTextureFormat}function sj(s,t,i,o){const[l,u]=fy(t,i);return my(s,l,u,q3(o),s.RGBA,s.UNSIGNED_BYTE)}function J3(s){return s.internalFormatPackedFloat}function rj(s,t,i,o){const[l,u]=s0(t,i);return my(s,l,u,J3(o),s.RGBA,s.FLOAT)}function eD(s){return s.internalFormatPackedHalfFloat}function aj(s,t,i,o){const[l,u]=s0(t,i);return my(s,l,u,eD(o),s.RGBA,o.textureTypeHalfFloat)}function oj(s,t,i){return vn(s,()=>s.bindBuffer(s.ARRAY_BUFFER,i)),z3(s,t,"clipSpacePos",i,3,20,0)&&z3(s,t,"uv",i,2,20,12)}function lj(s,t,i,o,l,u){vn(s,()=>s.bindTexture(s.TEXTURE_2D,t));let f,g,A;l instanceof Uint8Array?(f=new Uint8Array(i*o*4),g=s.UNSIGNED_BYTE,A=s.RGBA):(f=new Float32Array(i*o*4),g=s.FLOAT,A=u.internalFormatPackedFloat),f.set(l),Ee().getNumber("WEBGL_VERSION")===2?vn(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,i,o,s.RGBA,g,f)):vn(s,()=>s.texImage2D(s.TEXTURE_2D,0,A,i,o,0,s.RGBA,g,f)),vn(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function cj(s,t,i){vn(s,()=>s.bindTexture(s.TEXTURE_2D,t)),i.data instanceof Uint8Array?Ee().getNumber("WEBGL_VERSION")===2?vn(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,i.width,i.height,s.RGBA,s.UNSIGNED_BYTE,i.data)):vn(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,i.width,i.height,0,s.RGBA,s.UNSIGNED_BYTE,i.data)):Ee().getNumber("WEBGL_VERSION")===2?vn(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,s.RGBA,s.UNSIGNED_BYTE,i)):vn(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,s.RGBA,s.UNSIGNED_BYTE,i)),vn(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function uj(s,t,i,o){const l=s.createBuffer();vn(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,l));const u=16*t*i;return vn(s,()=>s.bufferData(s.PIXEL_PACK_BUFFER,u,s.STREAM_READ)),vn(s,()=>s.readPixels(0,0,i,t,s.RGBA,s.FLOAT,0)),vn(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,null)),l}function hj(s,t,i){const o=s,l=new Float32Array(i);return o.bindBuffer(o.PIXEL_PACK_BUFFER,t),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,l),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),l}function dj(s,t,i,o){const[l,u]=fy(t,i),f=4,g=new Uint8Array(_7(t*i,f));return vn(s,()=>s.readPixels(0,0,l,u,o.downloadTextureFormat,s.UNSIGNED_BYTE,g)),new Float32Array(g.buffer)}function fj(s,t,i,o,l,u,f,g){const A=s,v=new Float32Array(R7(u,f));return A.bindBuffer(A.PIXEL_PACK_BUFFER,t),A.getBufferSubData(A.PIXEL_PACK_BUFFER,0,v),A.bindBuffer(A.PIXEL_PACK_BUFFER,null),v}function pj(s,t,i){const o=new Float32Array(t*i*4);return vn(s,()=>s.readPixels(0,0,i,t,s.RGBA,s.FLOAT,o)),o}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class PT{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const i=Ee().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,I7(i,t)):this.gl=ac(i);let o="WEBGL_color_buffer_float";const l="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Ee().getNumber("WEBGL_VERSION")===1){const u="OES_texture_float",f="OES_texture_half_float";if(this.textureFloatExtension=xw(this.gl,u),El(this.gl,f))this.textureHalfFloatExtension=xw(this.gl,f);else if(Ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(o),El(this.gl,l))this.colorBufferHalfFloatExtension=xw(this.gl,l);else if(Ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(o="EXT_color_buffer_float",El(this.gl,o))this.colorBufferFloatExtension=this.gl.getExtension(o);else if(El(this.gl,l))this.colorBufferHalfFloatExtension=this.gl.getExtension(l);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=ej(this.gl),this.indexBuffer=tj(this.gl),this.framebuffer=X7(this.gl),this.textureConfig=RT(this.gl,this.textureHalfFloatExtension)}get debug(){return Ee().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;vn(t,()=>t.finish()),vn(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),vn(t,()=>t.deleteFramebuffer(this.framebuffer)),vn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),vn(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),vn(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,i){return this.throwIfDisposed(),nj(this.gl,t,i,this.textureConfig)}createFloat16MatrixTexture(t,i){return this.throwIfDisposed(),ij(this.gl,t,i,this.textureConfig)}createUnsignedBytesMatrixTexture(t,i){return this.throwIfDisposed(),sj(this.gl,t,i,this.textureConfig)}uploadPixelDataToTexture(t,i){this.throwIfDisposed(),cj(this.gl,t,i)}uploadDenseMatrixToTexture(t,i,o,l){this.throwIfDisposed(),lj(this.gl,t,i,o,l,this.textureConfig)}createFloat16PackedMatrixTexture(t,i){return this.throwIfDisposed(),aj(this.gl,t,i,this.textureConfig)}createPackedMatrixTexture(t,i){return this.throwIfDisposed(),rj(this.gl,t,i,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(V3(this.gl,this.framebuffer),this.outputTexture=null),vn(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,i,o){return this.downloadMatrixDriver(t,()=>dj(this.gl,i,o,this.textureConfig))}downloadPackedMatrixFromBuffer(t,i,o,l,u,f){return fj(this.gl,t,i,o,l,u,f,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,i){return hj(this.gl,t,i)}createBufferFromTexture(t,i,o){this.bindTextureToFrameBuffer(t);const l=uj(this.gl,i,o,this.textureConfig);return this.unbindTextureToFrameBuffer(),l}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let i,o;if(Ee().getBool("WEBGL_FENCE_API_ENABLED")){const l=t,u=l.fenceSync(l.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),o=()=>{const f=l.clientWaitSync(u,0,0);return f===l.ALREADY_SIGNALED||f===l.CONDITION_SATISFIED},i=u}else Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(i=this.beginQuery(),this.endQuery(),o=()=>this.isQueryAvailable(i,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):o=()=>!0;return{query:i,isFencePassed:o}}downloadMatrixFromPackedTexture(t,i,o){return this.downloadMatrixDriver(t,()=>pj(this.gl,i,o))}createProgram(t){this.throwIfDisposed();const i=this.gl;this.vertexShader==null&&(this.vertexShader=JY(i));const o=U7(i);return vn(i,()=>i.attachShader(o,this.vertexShader)),vn(i,()=>i.attachShader(o,t)),P7(i,o),this.debug&&kT(i,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=oj(i,this.program,this.vertexBuffer)),o}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&vn(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&kT(this.gl,this.program),vn(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,i,o=!0){return this.throwIfDisposed(),o?K7(this.gl,t,i):Z7(this.gl,t,i)}getAttributeLocation(t,i){return this.throwIfDisposed(),vn(this.gl,()=>this.gl.getAttribLocation(t,i))}getUniformLocationNoThrow(t,i){return this.throwIfDisposed(),this.gl.getUniformLocation(t,i)}setInputMatrixTexture(t,i,o){this.throwIfDisposed(),this.throwIfNoProgram(),$7(this.gl,t,i,o)}setOutputMatrixTexture(t,i,o){this.setOutputMatrixTextureDriver(t,o,i)}setOutputPackedMatrixTexture(t,i,o){this.throwIfDisposed();const[l,u]=s0(i,o);this.setOutputMatrixTextureDriver(t,l,u)}setOutputMatrixWriteRegion(t,i,o,l){this.setOutputMatrixWriteRegionDriver(o,t,l,i)}setOutputPackedMatrixWriteRegion(t,i,o,l){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&kT(this.gl,this.program),ww(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),vn(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),vn(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=xw(this.gl,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const o=this.gl,l=this.getQueryTimerExtensionWebGL2(),u=o.createQuery();return o.beginQuery(l.TIME_ELAPSED_EXT,u),u}const t=this.getQueryTimerExtensionWebGL1(),i=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,i),i}endQuery(){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const i=this.gl,o=this.getQueryTimerExtensionWebGL2();i.endQuery(o.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await K(()=>this.disposed||this.isQueryAvailable(t,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,i){if(i===0)return null;if(i===2){const o=this.gl;return o.getQueryParameter(t,o.QUERY_RESULT)/1e6}else{const o=this.getQueryTimerExtensionWebGL1();return o.getQueryObjectEXT(t,o.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,i){if(i===0)return!0;if(i===2){const o=this.gl,l=this.getQueryTimerExtensionWebGL2(),u=o.getQueryParameter(t,o.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(l.GPU_DISJOINT_EXT)),u&&!this.disjoint}else{const o=this.getQueryTimerExtensionWebGL1(),l=o.getQueryObjectEXT(t,o.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),l&&!this.disjoint}}pollFence(t){return new Promise(i=>{this.addItemToPoll(()=>t.isFencePassed(),()=>i())})}pollItems(){const t=mj(this.itemsToPoll.map(i=>i.isDoneFn));for(let i=0;i<=t;++i){const{resolveFn:o}=this.itemsToPoll[i];o()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,i){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:i}),this.itemsToPoll.length>1)return;let o;"setTimeoutCustom"in Ee().platform&&(o=Ee().platform.setTimeoutCustom.bind(Ee().platform)),K(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,o)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),BT(this.gl,t,this.framebuffer),this.debug&&ww(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(BT(this.gl,this.outputTexture,this.framebuffer),this.debug&&ww(this.gl)):V3(this.gl,this.framebuffer)}downloadMatrixDriver(t,i){this.bindTextureToFrameBuffer(t);const o=i();return this.unbindTextureToFrameBuffer(),o}setOutputMatrixTextureDriver(t,i,o){this.throwIfDisposed();const l=this.gl;BT(l,t,this.framebuffer),this.debug&&ww(l),this.outputTexture=t,vn(l,()=>l.viewport(0,0,i,o)),vn(l,()=>l.scissor(0,0,i,o))}setOutputMatrixWriteRegionDriver(t,i,o,l){this.throwIfDisposed(),vn(this.gl,()=>this.gl.scissor(t,i,o,l))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function mj(s){let t=0;for(;t<s.length&&s[t]();++t);return t-1}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function gj(s){const t=new Float32Array(s.length);for(let i=0;i<s.length;++i)t[i]=Math.abs(s[i]);return t}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zo(s){return(t,i,o,l,u)=>{const f=$n(t,i),g=f.length,A=Ne(f),v=N(f),C=re(u,v),S=t.length,M=i.length,_=Ne(t),B=Ne(i),F=Pl(t,f),P=Pl(i,f);if(F.length+P.length===0)for(let U=0;U<C.length;++U)C[U]=s(o[U%o.length],l[U%l.length]);else for(let U=0;U<C.length;++U){const V=Ot(U,g,A),$=V.slice(-S);F.forEach(me=>$[me]=0);const q=_t($,S,_),ne=V.slice(-M);P.forEach(me=>ne[me]=0);const he=_t(ne,M,B);C[U]=s(o[q],l[he])}return[C,f]}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Aj(s,t,i,o){if(o==="int32"){const l=Int32Array.from(s);return[t,"int32",l]}if(o==="bool"){const l=Gs([0],i),[u,f]=Zo((g,A)=>g!==A?1:0)(t,[],s,l,"bool");return[f,"bool",u]}throw new Error(`Error in Cast: failed to cast ${i} to ${o}`)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bj=Zo((s,t)=>s+t);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yj(s,t,i,o,l){const u=N(o),f=Tt(l,i);for(let g=0;g<s.length;g++){const A=s[g];if(A<0)throw new Error("Input x must be non-negative!");A>=l||(u>0?f[A]+=t[g]:f[A]+=1)}return f}function vj(s,t,i,o=!1){const l=s.shape[0],u=s.shape[1],f=On([l,i],t.dtype);for(let g=0;g<l;g++)for(let A=0;A<u;A++){const v=s.get(g,A);if(v<0)throw new Error("Input x must be non-negative!");v>=i||(o?f.set(1,g,v):t.size>0?f.set(f.get(g,v)+t.get(g,A),g,v):f.set(f.get(g,v)+1,g,v))}return f}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ld(s){return(t,i,o)=>{const l=re(i,t.length);for(let u=0;u<t.length;++u)l[u]=s(t[u],o);return l}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xj=Ld(s=>Math.ceil(s));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wj(s,t,i,o){const l=Y(i,N(t));if(o&&i!=="string"){let u=0;s.forEach(f=>{const g=N(f.shape);l.set(f.vals,u),u+=g})}else{let u=0;s.forEach(f=>{const g=i==="string"?nh(f.vals):f.vals;let A=0;for(let v=0;v<f.shape[0];++v){const C=v*t[1]+u;for(let S=0;S<f.shape[1];++S)l[C+S]=g[A++]}u+=f.shape[1]})}return l}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Cj=Zo((s,t)=>s===t?1:0);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ej=Ld(s=>Math.exp(s));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Sj=Ld(s=>Math.expm1(s));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ij=Ld(s=>Math.floor(s));/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Tj(s,t,i,o,l,u,f,g,A){const v=On([o,u],i);for(let C=0;C<o;C++){const S=[];let M=0;for(let _=0;_<l;_++){const B=s[C*l+_];M+=B*f[_],S.push(B)}if(M<0||M>=A/u)throw new Error(`Invalid indices: ${S} does not index into ${g}`);for(let _=0;_<u;_++)v.values[C*u+_]=t.get(...t.indexToLoc(M*u+_))}return v}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mj(s,t,i){const o=On(i,s.dtype);for(let l=0;l<o.size;++l){const u=o.indexToLoc(l).slice(),f=u[0],g=u[2],A=t.locToIndex([f,g]);u[2]=t.values[A];const v=s.locToIndex(u);0<=v&&v<s.values.length&&(o.values[l]=s.values[v])}return o}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const _j=Zo((s,t)=>s>t?1:0);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Rj=Zo((s,t)=>s>=t?1:0);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kj=Zo((s,t)=>s<t?1:0);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Bj=Zo((s,t)=>s<=t?1:0);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lj(s,t,i){const o=(t-s)/(i-1),l=Tt(i,"float32");l[0]=s;for(let u=1;u<l.length;u++)l[u]=l[u-1]+o;return l}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nj=Ld(s=>Math.log(s));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dj(s,t,i,o){const l=re(o,N(i));for(let u=0;u<l.length;++u){const f=u*t;let g=s[f];for(let A=0;A<t;++A){const v=s[f+A];(Number.isNaN(v)||v>g)&&(g=v)}l[u]=g}return l}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Fj=Zo((s,t)=>Math.max(s,t));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Oj=Zo((s,t)=>Math.min(s,t));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tD=Zo((s,t)=>s*t);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Gj(s,t,i){const o=Do(-1,i);return tD([],t,o,s,i)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Uj=Zo((s,t)=>s!==t?1:0);/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pj(s,t,i,o,l){const u=t.length,f=N(t),g=Ne(t),A=Ne(l),v=re(i,N(l));for(let C=0;C<f;++C){const S=Ot(C,u,g),M=new Array(S.length);for(let B=0;B<M.length;B++)M[B]=S[o[B]];const _=_t(M,u,A);v[_]=s[C]}return v}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zj(s,t,i,o){const[l,u]=Ei(s,o),f=ar(t,"int32"),g=Tt(N(l),f),A=N(u);for(let v=0;v<g.length;++v){const C=v*A;let S=1;for(let M=0;M<A;++M)S*=i[C+M];g[v]=S}return{outVals:g,outShape:l,outDtype:f}}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Vj(s,t,i){s.forEach((o,l)=>{if(o<0||o>=i){const u=Ot(l,t.length,Ne(t)).join(",");throw new Error(`indices[${u}] = ${o} is not in [0, ${i})`)}})}function Wj(s,t){for(let i=0;i<s.length;++i){const o=s[i],l=i===s.length-1?t:s[i+1].length;if(o.length===0)throw new Error("Ragged splits may not be empty");if(o[0]<0)throw new Error("Ragged splits must be non-negative");if(o[o.length-1]>l)throw new Error("Ragged splits must not point past values");for(let u=1;u<o.length;++u)if(o[u-1]>o[u])throw new Error("Ragged splits must be sorted in ascending order")}}function Hj(s,t,i,o){const l=[];let u=0;const f=t.length-1+i.length,g=new Array(f).fill(null).map(()=>[0]);Wj(i,o);let A=1;for(let v=0;v<t.length-1;++v){A*=t[v];const C=t[v+1];for(let S=1;S<A+1;++S)g[v].push(S*C)}for(let v=0;v<s.length;++v){let C=s[v],S=s[v]+1;for(let M=0;M<i.length;++M){const _=i[M],B=M+t.length-1;if(B>=0){const F=g[B],P=F[F.length-1]-_[C];for(let U=C;U<S;++U)g[B].push(_[U+1]+P)}C=_[C],S=_[S]}S!==C&&(l.push([C,S]),u+=S-C)}return{outSplits:g,valueSlices:l,numValues:u}}function Xj(s){const t=[];for(let i=0;i<s.length;++i){const o=s[i].length,l=Y("int32",o);t.push(l),s[i].forEach((u,f)=>l[f]=u)}return t}function nD(s,t){const i=s.slice(0,t);for(;i.length<t;)i.push(1);for(let o=t;o<s.length;o++)i[t-1]*=s[o];return i}function Qj(s,t,i,o,l,u){const f=nD(t,2)[1],g=nD(u,2)[1];let A=0;for(const v of i)for(let C=v[0];C<v[1];++C){for(let S=0;S<o;++S)l[A*g+S]=s[C*f+S];++A}}function Kj(s,t,i,o,l){const u=t.slice();u[0]=l;const f=Y(i,N(u)),g=s.length,A=g===0?0:g/t[0];return Qj(s,t,o,A,f,u),[f,u]}function Zj(s,t,i,o,l,u,f,g){if(s.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const A=t[0][0]-1;if(Vj(u,f,A),o.length===0)throw new Error("params.rank must be nonzero");const v=o[0],{outSplits:C,valueSlices:S,numValues:M}=Hj(u,f,s,v),_=Xj(C),B=Kj(i,o,l,S,M);return[_,B[0],B[1]]}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var Sl=bl;class Iw{constructor(t,i,o,l,u,f,g,A,v,C){this.shape=t,this.shapeShape=i,this.values=o,this.valuesShape=l,this.valuesDType=u,this.defaultValue=f,this.defaultValueShape=g,this.rowPartitionValues=A,this.rowPartitionValuesShapes=v,this.rowPartitionTypes=rI(C),this.raggedRank=aI(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Sl.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Sl.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const i=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Sl.VALUE_ROWIDS:return Iw.getMaxWidthValueRowID(i);case Sl.ROW_SPLITS:return Iw.getMaxWidthRowSplit(i);default:throw new Error(`Cannot handle partition type ${Sl[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const i=t.length;if(i===0||i===1)return 0;let o=0;for(let l=0;l<i-1;++l){const u=t[l+1]-t[l];u>o&&(o=u)}return o}static getMaxWidthValueRowID(t){const i=t.length;if(i===0)return 0;let o=0,l=t[0],u=0;for(let f=1;f<i;++f){const g=t[f];g!==l&&(l=g,u=Math.max(f-o,u),o=f)}return Math.max(i-o,u)}tensorShapeFromTensor(t,i,o=!0){if(i.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return sD(t,o)}calculateOutputSize(t){const i=this.valuesShape,o=this.defaultValueShape;oI(o,i);const l=this.tensorShapeFromTensor(this.shape,this.shapeShape),u=sI(this.raggedRank,l,i);u[0]<0&&(u[0]=t);for(let f=1;f<=this.raggedRank;++f)u[f]<0&&(u[f]=this.getMaxWidth(f));return u}calculateFirstParentOutputIndex(t,i,o){const l=Math.min(t,o),u=[];let f=0;for(let g=0;g<l;++g,f+=i)u.push(f);for(let g=l;g<t;++g)u.push(-1);return E(u.length===t,()=>"Final length of result must be equal to firstDimension."),u}calculateOutputIndexRowSplit(t,i,o,l){const u=t.length,f=[];for(let g=0;g<u-1;++g){const A=t[g+1]-t[g];let v=Math.min(l,A),C=i[g];C===-1&&(v=0);for(let S=0;S<v;++S)f.push(C),C+=o;for(let S=0;S<A-v;++S)f.push(-1)}if(u>0&&f.length!==t[u-1])throw new Error("Invalid row split size.");return f}calculateOutputIndexValueRowID(t,i,o,l){const u=t.length,f=[];if(u===0)return[];let g=0,A=t[0];if(A>=i.length)throw new Error(`Got currentValueRowId=${A}, which is not less than ${i.length}`);let v=i[A];f.push(v);for(let C=1;C<u;++C){const S=t[C];if(S===A)v>=0&&(++g,g<l?v+=o:v=-1);else{if(g=0,A=S,S>=i.length)throw new Error(`Got nextValueRowId=${S} which is not less than ${i.length}`);v=i[S]}f.push(v)}if(f.length!==t.length)throw new Error("Invalid row ids.");return f}calculateOutputIndex(t,i,o,l){const u=this.getRowPartitionTensor(t),f=this.getRowPartitionTypeByDimension(t);switch(f){case Sl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(u,i,o,l);case Sl.ROW_SPLITS:if(u.length-1>i.length)throw new Error(`Row partition size is greater than output size: ${u.length-1} > ${i.length}`);return this.calculateOutputIndexRowSplit(u,i,o,l);default:throw new Error(`Unsupported partition type: ${Sl[f]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const i=this.rowPartitionTypes[0];switch(i){case Sl.FIRST_DIM_SIZE:return t[0];case Sl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Sl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Sl[i]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),i=this.calculateOutputSize(t),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let f=o.length-2;f>=0;--f)o[f]=o[f+1]*i[f+1];const l=sD(i,!1),u=Y(this.valuesDType,N(l));if(o[0]*i[0]>0){let f=this.calculateFirstParentOutputIndex(t,o[0],i[0]);for(let g=1;g<=this.raggedRank;++g)f=this.calculateOutputIndex(g-1,f,o[g],i[g]);this.setOutput(this.raggedRank,f,u,l)}return[l,u]}setOutput(t,i,o,l){if(o.length===0)return;const u=this.values,f=o;let g=l.slice();g=g.slice(t+1);const A=N(g),v=i.length;let C=this.defaultValue;if(C.length!==A&&C.length!==1){const B=this.defaultValueShape;$e(()=>{const F=He(C,B);C=_s(F,g).dataSync()})}let S=0,M=0,_=0;for(let B=0;B<=v;++B){let F=B<v?i[B]:-1;if(F===_){++_;continue}if(M<_){const P=u.subarray(S*A),U=f.subarray(M*A),V=(_-M)*A;iD(U,P,V)}if(B>=v){const P=o.length;F=Math.floor(P/A)}if(F>_)if(this.defaultValue.length===1)f.subarray(_*A,F*A).fill(this.defaultValue[0]),_=F;else for(;F>_;){const P=f.slice(_*A);iD(P,C,A),++_}F<0?(S=B+1,M=_):(S=B,M=_,_=M+1)}}}function iD(s,t,i){for(let o=0;o<i;o++)s[o]=t[o]}function sD(s,t){const i=[];for(let o of s){if(o<0){if(!t)throw new Error(`Dimension ${o} must be >= 0`);if(o<-1)throw new Error(`Dimension ${o} must be >= -1`);o=-1}i.push(o)}return i}function $j(s,t,i,o,l,u,f,g,A,v){return new Iw(s,t,i,o,l,u,f,g,A,v).compute()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Yj(s,t,i,o){const l=s===t,u=s<t&&i<0,f=t<s&&i>1;if(l||u||f)return Tt(0,o);const g=Math.abs(Math.ceil((t-s)/i)),A=Tt(g,o);t<s&&i===1&&(i=-1),A[0]=s;for(let v=1;v<A.length;v++)A[v]=A[v-1]+i;return A}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jj=Ld(s=>1/Math.sqrt(s));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qj(s,t,i,o,l,u,f,g,A,v){const C=[o/l,l],S=s.values,M=t.values;if(o===0)return On(i,t.dtype);const _=On(C,t.dtype);typeof A=="string"||typeof A=="number"?_.values.fill(A):typeof A=="boolean"&&_.values.fill(+A);for(let B=0;B<u;B++){const F=[];let P=0;for(let U=0;U<f;U++){const V=S[B*f+U];F.push(V),P+=V*g[U]}if(P<0||P>=o/l)throw new Error(`Invalid indices: ${F} does not index into ${i}`);for(let U=0;U<l;U++)v?_.values[P*l+U]+=M[B*l+U]:_.values[P*l+U]=t.rank===0?M[0]:M[B*l+U]}return _}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Jj=Ld(s=>1/(1+Math.exp(-s)));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eq(s,t,i,o,l){const u=Ku(o,t,i),f=N(i),g=Ne(o);if(u){const S=np(t,g);return l==="string"?s.slice(S,S+f):s.subarray(S,S+f)}const A=l==="string"?nh(s):s,v=On(o,l,A),C=On(i,l);for(let S=0;S<C.size;++S){const M=C.indexToLoc(S),_=M.map((B,F)=>B+t[F]);C.set(v.get(..._),...M)}return l==="string"?GI(C.values):C.values}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tq(s,t,i,o,l,u,f){const g=t[0],A=u[0],v=new Array(A),C=new Array(g),S=t[1];if(A===0){if(g!==0)throw new Error(II(g));const P=Y(i,0),U=Y(l,0);return[P,[0,S],U,v,C]}let M=!0,_=0;const B=new Array(A).fill(0);for(let P=0;P<g;++P){const U=s[P*S];if(U<0)throw new Error(TI(P,U));if(U>=A)throw new Error(MI(P,U,A));++B[U],M=M&&U>=_,_=U}let F=!0;for(let P=0;P<A;++P){const U=B[P]===0;v[P]=U,F=F&&!U,B[P]=Math.max(B[P],1),P>0&&(B[P]+=B[P-1])}if(F&&M){const P=s,U=o;for(let V=0;V<g;++V)C[V]=V;return[P,[g,S],U,v,C]}else{const P=B[A-1],U=Y(i,P*S),V=Y(l,P),$=new Array(A).fill(0);for(let q=0;q<g;++q){const ne=s[q*S],he=$[ne],me=(ne===0?0:B[ne-1])+he;$[ne]++;for(let pe=0;pe<S;++pe)U[me*S+pe]=s[q*S+pe];V[me]=o[q],C[q]=me}for(let q=0;q<A;++q)if($[q]===0){const ne=q===0?0:B[q-1];U[ne*S+0]=q;for(let he=1;he<S;++he)U[ne*S+he]=0;V[ne]=f}return[U,[P,S],V,v,C]}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nq(s,t,i,o,l){const u=N(o),f=t[0],g=l.length,A=[];let v=1,C=-1;for(let F=0;F<g;++F){const P=l[F];if(P===-1){if(C!==-1)throw new Error(_I(C,F));C=F,A.push(1)}else{if(P<0)throw new Error(RI(F,P));v*=P,A.push(P)}}if(C!==-1){if(v<=0)throw new Error(kI());const F=Math.trunc(u/v);if(v*F!==u)throw new Error(BI(o,A));A[C]=F}if(N(A)!==u)throw new Error(LI(o,A));const S=o.length,M=[];if(S>0){M[S-1]=1;for(let F=S-2;F>=0;--F)M[F]=M[F+1]*o[F+1]}const _=[];if(g>0){_[g-1]=1;for(let F=g-2;F>=0;--F)_[F]=_[F+1]*A[F+1]}const B=Y(i,f*g);for(let F=0;F<f;++F){let P=0;for(let U=0;U<S;++U)P+=s[F*S+U]*M[U];for(let U=0;U<g;++U)B[F*g+U]=Math.trunc(P/_[U]),P%=_[U]}return[B,[f,g],A]}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function iq(s,t,i,o,l,u=!1,f=0){const g=o.length,A=[t[0],s.length/t[0]],v=A[1],C=g>0?l[g-1]+1:0;if(C<0)throw new Error(Hb());const S=t.slice();S[0]=C;const M=S.reduce((V,$)=>V*$,1),_=Y(i,M);if(g===0)return C>0&&_.fill(f),[_,S];if(C<=0)throw new Error(Hb());let B=0,F=1,P=0,U=l[B];for(;;){let V=0;if(F<g){if(V=l[F],U===V){++F;continue}if(U>=V)throw new Error(NI())}if(U<0||U>=C)throw new Error(DI(U,C));U>P&&_.fill(f,P*v,U*v);for(let $=B;$<F;++$){const q=o[$];if(q<0||q>=A[0])throw new Error(FI($,o[$],A[0]));for(let ne=0;ne<v;ne++)_[U*v+ne]+=s[q*v+ne]}if(u)for(let $=0;$<v;$++)_[U*v+$]/=F-B;if(B=F,++F,P=U+1,U=V,F>g)break}return P<C&&_.fill(f,P*v,C*v),[_,S]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sq=Ld(s=>Math.sqrt(s));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rq=Zo((s,t)=>{const i=s-t;return i*i});/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function aq(s,t,i,o){const l=On(s,t.dtype);for(let u=0;u<l.size;u++){const f=l.indexToLoc(u),g=new Array(f.length);for(let A=0;A<g.length;A++)g[A]=f[A]*i[A]+o[A];l.set(t.get(...g),...f)}return l}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class oq{constructor(t,i,o,l,u,f){this.separator=ri(t),this.nGramWidths=i,this.leftPad=ri(o),this.rightPad=ri(l),this.padWidth=u,this.preserveShort=f}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,i){const o=this.getPadWidth(i);return Math.max(0,t+2*o-i+1)}createNGrams(t,i,o,l,u,f){for(let g=0;g<u;++g){const A=this.getPadWidth(f),v=Math.max(0,A-g),C=Math.max(0,A-(u-(g+1))),S=f-(v+C),M=i+(v>0?0:g-A);let _=0;_+=v*this.leftPad.length;for(let V=0;V<S;++V)_+=t[M+V].length;_+=C*this.rightPad.length;const B=v+C+S-1;_+=B*this.separator.length,o[l+g]=new Uint8Array(_);const F=o[l+g];let P=0;const U=V=>V.forEach($=>F[P++]=$);for(let V=0;V<v;++V)U(this.leftPad),U(this.separator);for(let V=0;V<S-1;++V)U(t[M+V]),U(this.separator);if(S>0){U(t[M+S-1]);for(let V=0;V<C;++V)U(this.separator),U(this.rightPad)}else{for(let V=0;V<C-1;++V)U(this.rightPad),U(this.separator);U(this.rightPad)}}}compute(t,i){const o=t.length,l=i.length;if(l>0){let A=i[0];if(A!==0)throw new Error(`First split value must be 0, got ${A}`);for(let v=1;v<l;++v){let C=i[v]>=A;if(C=C&&i[v]<=o,!C)throw new Error(`Invalid split value ${i[v]}, must be in [${A}, ${o}]`);A=i[v]}if(A!==o)throw new Error(`Last split value must be data size. Expected ${o}, got ${A}`)}const u=l-1,f=Y("int32",l);if(o===0||l===0){const A=new Array(o);for(let v=0;v<=u;++v)f[v]=0;return[A,f]}f[0]=0;for(let A=1;A<=u;++A){const v=i[A]-i[A-1];let C=0;this.nGramWidths.forEach(S=>{C+=this.getNumNGrams(v,S)}),this.preserveShort&&v>0&&C===0&&(C=1),f[A]=f[A-1]+C}const g=new Array(f[u]);for(let A=0;A<u;++A){const v=i[A];let C=f[A];if(this.nGramWidths.forEach(S=>{const M=i[A+1]-i[A],_=this.getNumNGrams(M,S);this.createNGrams(t,v,g,C,_,S),C+=_}),this.preserveShort&&C===f[A]){const S=i[A+1]-i[A];if(S===0)continue;const M=S+2*this.padWidth;this.createNGrams(t,v,g,C,1,M)}}return[g,f]}}function lq(s,t,i,o,l,u,f,g){return new oq(i,o,l,u,f,g).compute(s,t)}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cq(s,t,i,o){if(!s.length)return;if(t.length===0){for(let u=0;u<s.length;++u)o.push(s.subarray(u,u+1));return}if(t.length===1){const u=t[0];let f=s.indexOf(u);for(;f!==-1;){const g=s.subarray(0,f);(!i||g.length!==0)&&o.push(g),s=s.subarray(f+1),f=s.indexOf(u)}(!i||s.length!==0)&&o.push(s);return}let l=0;for(let u=0;u<s.length+1;u++)if(u===s.length||t.indexOf(s[u])!==-1){const f=s.subarray(l,u);(!i||f.length!==0)&&o.push(f),l=u+1}}function uq(s,t,i){const o=s.length,l=[];let u=0,f=0;const g=new Array(o);for(let M=0;M<o;++M){const _=l.length;cq(s[M],t,i,l);const B=l.length-_;g[M]=B,u+=B,f=Math.max(f,B)}const A=Y("int32",u*2),v=new Array(u),C=[o,f];let S=0;for(let M=0;M<o;++M)for(let _=0;_<g[M];++_)A[S*2]=M,A[S*2+1]=_,v[S]=l[S],++S;return[A,v,C]}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hq(s,t){const i=Y("int32",s.length);for(let o=0;o<s.length;++o)i[o]=RA(s[o]).modulo(t).getLowBitsUnsigned();return i}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const dq=Zo((s,t)=>s-t);/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fq(s,t){const i=new Array(s.rank);for(let l=0;l<i.length;l++)i[l]=s.shape[l]*t[l];const o=On(i,s.dtype);for(let l=0;l<o.values.length;++l){const u=o.indexToLoc(l),f=new Array(s.rank);for(let A=0;A<f.length;A++)f[A]=u[A]%s.shape[A];const g=s.locToIndex(f);o.values[l]=s.values[g]}return o}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gy=(s,t)=>{const i=t.value-s.value;return i===0?s.index-t.index:i};function rD(s,t,i=0,o=s.length-1){for(;o>i;){if(o-i>600){const g=o-i+1,A=t-i+1,v=Math.log(g),C=.5*Math.exp(2*v/3),S=.5*Math.sqrt(v*C*(g-C)/g)*Math.sign(A-g/2),M=Math.max(i,Math.floor(t-A*C/g+S)),_=Math.min(o,Math.floor(t+(g-A)*C/g+S));rD(s,t,M,_)}const l=s[t];let u=i,f=o;for(w(s,i,t),gy(s[o],l)>0&&w(s,i,o);u<f;){for(w(s,u,f),u++,f--;gy(s[u],l)<0;)u=u+1;for(;gy(s[f],l)>0;)f=f-1}gy(s[i],l)===0?w(s,i,f):(f=f+1,w(s,f,o)),f<=t&&(i=f+1),t<=f&&(o=f-1)}}function pq(s,t,i,o,l){const u=t[t.length-1],[f,g]=[s.length/u,u],A=re(i,f*o),v=re("int32",f*o);for(let S=0;S<f;S++){const M=S*g,_=s.subarray(M,M+g);let B=new Array(_.length);_.forEach((V,$)=>B[$]={value:V,index:$}),o<B.length&&(rD(B,o),B=B.slice(0,o)),l&&B.sort(gy);const F=S*o,P=A.subarray(F,F+o),U=v.subarray(F,F+o);for(let V=0;V<o;V++)P[V]=B[V].value,U[V]=B[V].index}const C=t.slice();return C[C.length-1]=o,[On(C,i,A),On(C,"int32",v)]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mq(s,t,i,o){const l=J(t,i)[0],u=[1,i[0],1];for(let B=0;B<l;B++)u[0]*=i[B];u[1]=i[l];for(let B=l+1;B<i.length;B++)u[2]*=i[B];const f={},g=new Int32Array(i[l]),A=new Hs(u,o,s),v=[],C=u[0]===1&&u[2]===1;for(let B=0;B<i[l];B++){let F;if(C)F=s[B].toString();else{const P=[];for(let U=0;U<u[0];U++)for(let V=0;V<u[2];V++)P.push(A.get(U,B,V));F=P.join(",")}if(f[F]!==void 0)g[B]=f[F];else{const P=Object.keys(f).length;f[F]=P,g[B]=P,v.push(B)}}const S=u.slice();S[1]=Object.keys(f).length;const M=new Hs(S,o);v.forEach((B,F)=>{for(let P=0;P<u[0];P++)for(let U=0;U<u[2];U++)M.set(A.get(P,B,U),P,F,U)});const _=i.slice();return _[l]=S[1],{outputValues:M.values,outputShape:_,indices:g}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gq=Object.freeze(Object.defineProperty({__proto__:null,addImpl:bj,bincountImpl:yj,bincountReduceImpl:vj,castImpl:Aj,ceilImpl:xj,concatImpl:wj,equalImpl:Cj,expImpl:Ej,expm1Impl:Sj,floorImpl:Ij,gatherNdImpl:Tj,gatherV2Impl:Mj,greaterEqualImpl:Rj,greaterImpl:_j,lessEqualImpl:Bj,lessImpl:kj,linSpaceImpl:Lj,logImpl:Nj,maxImpl:Dj,maximumImpl:Fj,minimumImpl:Oj,multiplyImpl:tD,negImpl:Gj,notEqualImpl:Uj,prodImpl:zj,raggedGatherImpl:Zj,raggedTensorToTensorImpl:$j,rangeImpl:Yj,rsqrtImpl:jj,scatterImpl:qj,sigmoidImpl:Jj,simpleAbsImpl:gj,sliceImpl:eq,sparseFillEmptyRowsImpl:tq,sparseReshapeImpl:nq,sparseSegmentReductionImpl:iq,sqrtImpl:sq,squaredDifferenceImpl:rq,stridedSliceImpl:aq,stringNGramsImpl:lq,stringSplitImpl:uq,stringToHashBucketFastImpl:hq,subImpl:dq,tileImpl:fq,topKImpl:pq,transposeImpl:Pj,uniqueImpl:mq},Symbol.toStringTag,{value:"Module"}));/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const{addImpl:Aq,bincountImpl:aD,bincountReduceImpl:bq,castImpl:yq,ceilImpl:vq,concatImpl:xq,equalImpl:wq,expImpl:Cq,expm1Impl:Eq,floorImpl:Sq,gatherNdImpl:Iq,gatherV2Impl:Tq,greaterImpl:Mq,greaterEqualImpl:_q,lessImpl:Rq,lessEqualImpl:kq,linSpaceImpl:Bq,logImpl:Lq,maxImpl:Nq,maximumImpl:Dq,minimumImpl:Fq,multiplyImpl:Oq,negImpl:Gq,notEqualImpl:Uq,prodImpl:Pq,raggedGatherImpl:zq,raggedTensorToTensorImpl:Vq,rangeImpl:Wq,rsqrtImpl:Hq,scatterImpl:Xq,sigmoidImpl:Qq,simpleAbsImpl:oD,sliceImpl:Kq,sparseFillEmptyRowsImpl:Zq,sparseReshapeImpl:$q,sparseSegmentReductionImpl:lD,sqrtImpl:Yq,stridedSliceImpl:jq,stringNGramsImpl:qq,stringSplitImpl:Jq,stringToHashBucketFastImpl:eJ,subImpl:tJ,tileImpl:nJ,topKImpl:iJ,transposeImpl:zT,uniqueImpl:sJ}=gq;/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cD(s,t){return["x","y","z","w","u","v"].slice(0,t).map(i=>`${s}.${i}`)}function ma(s,t){return t===1?[s]:cD(s,t)}function rJ(s,t){if(s===1)return"rc";let i="";for(let o=0;o<s;o++)i+=t[o],o<s-1&&(i+=",");return i}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class aJ{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=pa(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const i=ma("rc",this.rank),o=ws(this.rank),l=this.getOutOfBoundsCondition(i),u=this.getSetup(i),f=this.getOutput(i);this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();

          if(${l}) {
            setOutput(vec4(0));
          } else {
            ${u}

            setOutput(vec4(${f}));
          }
        }
      `}}getSourceCoordsArr(t){const i=[];for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){let u=`${o===0?"r":"rp1"}, ${l===0?"c":"cp1"}`;for(let f=2;f<this.rank;f++)u=`${t[t.length-1-f]},`+u;i.push(u)}return i}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let i="";for(let o=this.rank-2;o<this.rank;o++)i+=`${t[o]} >= ${this.enableShapeUniforms?`outShape[${o}]`:this.outputShape[o]}`,o<this.rank-1&&(i+="||");return i}getSetup(t){if(this.rank===1)return"";const i=t.slice(-2),o=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],l=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${i[0]};
      int c = ${i[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${o};
      bool rEdge = rp1 >= ${l};
    `}getOutput(t){const i=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${i[0]}),
            cEdge ? 0. : getA(${i[1]}),
            rEdge ? 0. : getA(${i[2]}),
            rEdge || cEdge ? 0. : getA(${i[3]})`}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class uD{constructor(t,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=pa(this.outputShape.length);let o="";for(let l=0;l<4;l++){let u="thisRC = rc;";l%2===1&&(u+="thisRC.z += 1;"),l>1&&(u+="thisRC.y += 1;"),o+=`
        ${u}
        ${l>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${l}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${l>0?"}":""}
      `}this.userCode=`
      ${oJ(i,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?GT():OT(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${o}

        setOutput(result);
      }
    `}}function oJ(s,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?oY(["r","c","d"],"inputShape"):zp(["r","c","d"],s)}
      return ivec3(r, c, d);
    }
  `}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class lJ{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,i,o){const l=dD(i,o),u=fD(t,l,o);u in this.freeTextures||(this.freeTextures[u]=[]),u in this.usedTextures||(this.usedTextures[u]=[]);const f=hD(t,l,this.gpgpu.gl,this.gpgpu.textureConfig,o);if(this.freeTextures[u].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=f,this.log();const A=this.freeTextures[u].shift();return this.usedTextures[u].push(A),A}let g;return l===Vr.PACKED_2X2_FLOAT32?g=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):l===Vr.PACKED_2X2_FLOAT16?g=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):l===Vr.UNPACKED_FLOAT32?g=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):l===Vr.UNPACKED_FLOAT16?g=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):l===Vr.PACKED_4X1_UNSIGNED_BYTE&&(g=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[u].push(g),this.numUsedTextures++,this._numBytesAllocated+=f,this.log(),g}releaseTexture(t,i,o,l){if(this.freeTextures==null)return;const u=dD(o,l),f=fD(i,u,l);f in this.freeTextures||(this.freeTextures[f]=[]);const g=hD(i,u,this.gpgpu.gl,this.gpgpu.textureConfig,l),A=Ee().get("WEBGL_DELETE_TEXTURE_THRESHOLD");A!==-1&&this._numBytesAllocated>A?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=g):(this.freeTextures[f].push(t),this.numFreeTextures++,this._numBytesFree+=g),this.numUsedTextures--;const v=this.usedTextures[f],C=v.indexOf(t);if(C<0)throw new Error("Cannot release a texture that was never provided by this texture manager");v.splice(C,1),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const i=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*i)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(i=>{this.gpgpu.deleteMatrixTexture(i.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(i=>{this.gpgpu.deleteMatrixTexture(i.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function cJ(s,t){const i=s;if(t===i.R32F)return 4;if(t===i.R16F)return 2;if(t===i.RGBA32F||t===s.RGBA)return 16;if(t===i.RGBA16F)return 8;if(t===i.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function hD(s,t,i,o,l){const u=uJ(t,o);let f;if(l){const[A,v]=s0(s[0],s[1]);f=A*v}else{const[A,v]=fy(s[0],s[1]);f=A*v}const g=cJ(i,u);return f*g}function uJ(s,t){switch(s){case Vr.PACKED_2X2_FLOAT32:return J3(t);case Vr.PACKED_2X2_FLOAT16:return eD(t);case Vr.UNPACKED_FLOAT32:return Y3(t);case Vr.UNPACKED_FLOAT16:return j3(t);case Vr.PACKED_4X1_UNSIGNED_BYTE:return q3(t);default:throw new Error(`Unknown physical texture type ${s}`)}}function hJ(s){return Ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?s?Vr.PACKED_2X2_FLOAT32:Vr.UNPACKED_FLOAT32:s?Vr.PACKED_2X2_FLOAT16:Vr.UNPACKED_FLOAT16}function dD(s,t){if(s===Ko.UPLOAD)return Vr.PACKED_2X2_FLOAT32;if(s===Ko.RENDER||s==null)return hJ(t);if(s===Ko.DOWNLOAD||s===Ko.PIXELS)return Vr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${s}`)}function fD(s,t,i){return`${s[0]}_${s[1]}_${t}_${i}`}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ah{constructor(t,i){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=pa(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${i}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Il="if (isnan(x)) return x;",dJ="return x;",pD="return abs(x);",fJ="return (x >= 0.0) ? x : (exp(x) - 1.0);",pJ=Il+`
  return (x < 0.0) ? 0.0 : x;
`,mJ=Il+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,h0="return x;",gJ="return 1.0 / (1.0 + exp(-1.0 * x));";/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const AJ="return x;",bJ=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,yJ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,vJ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xJ="return 1.0 / (1.0 + exp(-1.0 * x));";class Wp{constructor(t,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=pa(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${i}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class wJ{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=pa(this.outputShape.length);const i=t.length,o=ma("rc",i),l=ws(i),u=rJ(i,o),f=o.slice(-2),g=i<=1?"rc":`vec2(${f.join(",")})`;this.userCode=`
      void main() {
        ${l} rc = getOutputCoords();
        vec4 packedInput = getA(${u});

        setOutput(getChannel(packedInput, ${g}));
      }
    `}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const CJ=Ji,EJ=1e-7,SJ=1e-4,VT={};function IJ(s){return s in VT||(VT[s]={}),VT[s]}const TJ=Ee().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),MJ=600;function _J(){return Ee().global.screen==null?1024:Ee().global.screen.height*Ee().global.screen.width*window.devicePixelRatio*MJ/1024/1024}class Tw extends c{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ee().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let i;if(t!=null){if(t instanceof PT)i=t;else{const o=ac(Ee().getNumber("WEBGL_VERSION"),t);i=new PT(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const o=ac(Ee().getNumber("WEBGL_VERSION"));i=new PT(o),this.binaryCache=IJ(Ee().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=i,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new lJ(this.gpgpu),this.numMBBeforeWarning=_J(),this.texData=new a(this,os())}nextDataId(){return Tw.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,i,o){if((Ee().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ee().getBool("DEBUG"))&&this.checkNumericalProblems(t),o==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const l={id:this.nextDataId()};return this.texData.set(l,{shape:i,dtype:o,values:t,usage:Ko.UPLOAD,refCount:1}),l}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const i=this.texData.get(t);i.refCount++}decRef(t){if(this.texData.has(t)){const i=this.texData.get(t);i.refCount--}}move(t,i,o,l,u){if(Ee().getBool("DEBUG")&&this.checkNumericalProblems(i),l==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:o,dtype:l,values:i,usage:Ko.UPLOAD,refCount:u})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const i=this.texData.get(t),{values:o,dtype:l,complexTensorInfos:u,slice:f,shape:g,isPacked:A}=i;if(f!=null){let M;A?M=new Wp(g,h0):M=new ah(g,h0);const _=this.runWebGLProgram(M,[{dataId:t,shape:g,dtype:l}],l),B=this.readSync(_.dataId);return this.disposeIntermediateTensorInfo(_),B}if(o!=null)return this.convertAndCacheOnCPU(t);if(l==="string")return o;const v=this.activeTimers!=null;let C;v&&(C=wi());let S;if(l==="complex64"){const M=this.readSync(u.real.dataId),_=this.readSync(u.imag.dataId);S=th(M,_)}else S=this.getValuesFromTexture(t);return v&&(this.downloadWaitMs+=wi()-C),this.convertAndCacheOnCPU(t,S)}async read(t){if(this.pendingRead.has(t)){const B=this.pendingRead.get(t);return new Promise(F=>B.push(F))}const i=this.texData.get(t),{values:o,shape:l,slice:u,dtype:f,complexTensorInfos:g,isPacked:A}=i;if(u!=null){let B;A?B=new Wp(l,h0):B=new ah(l,h0);const F=this.runWebGLProgram(B,[{dataId:t,shape:l,dtype:f}],f),P=this.read(F.dataId);return this.disposeIntermediateTensorInfo(F),P}if(o!=null)return this.convertAndCacheOnCPU(t);if(Ee().getBool("DEBUG")&&!Ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Ee().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let v=null,C;if(f!=="complex64"&&Ee().get("WEBGL_BUFFER_SUPPORTED")){C=this.decode(t);const B=this.texData.get(C.dataId);v=this.gpgpu.createBufferFromTexture(B.texture.texture,...vw(l))}this.pendingRead.set(t,[]),f!=="complex64"&&await this.gpgpu.createAndWaitForFence();let S;if(f==="complex64"){const B=await Promise.all([this.read(g.real.dataId),this.read(g.imag.dataId)]),F=B[0],P=B[1];S=th(F,P)}else if(v==null)S=this.getValuesFromTexture(t);else{const B=N(l);S=this.gpgpu.downloadFloat32MatrixFromBuffer(v,B)}if(C!=null&&this.disposeIntermediateTensorInfo(C),v!=null){const B=this.gpgpu.gl;vn(B,()=>B.deleteBuffer(v))}const M=this.convertAndCacheOnCPU(t,S),_=this.pendingRead.get(t);return this.pendingRead.delete(t),_.forEach(B=>B(M)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&os().removeDataId(t,this),this.pendingDeletes--),M}readToGPU(t,i={}){const o=this.texData.get(t),{values:l,shape:u,slice:f,dtype:g,isPacked:A,texture:v}=o;if(g==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(f!=null){let _;A?_=new Wp(u,h0):_=new ah(u,h0);const B=this.runWebGLProgram(_,[{dataId:t,shape:u,dtype:g}],g),F=this.readToGPU(B,i);return this.disposeIntermediateTensorInfo(B),F}if(v==null)throw l!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const C=this.decode(t,i.customTexShape),S=os().makeTensorFromTensorInfo(C),M=this.texData.get(C.dataId);return Object.assign({tensorRef:S},M.texture)}bufferSync(t){const i=this.readSync(t.dataId);if(t.dtype==="string")try{const o=i.map(l=>oa(l));return On(t.shape,t.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return On(t.shape,t.dtype,i)}checkNumericalProblems(t){if(t!=null)for(let i=0;i<t.length;i++){const o=t[i];if(!N7(o))throw Ee().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:i,dtype:o,isPacked:l}=this.texData.get(t),u=N(i);if(Ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const M=this.decode(t),_=this.texData.get(M.dataId),B=this.gpgpu.downloadMatrixFromPackedTexture(_.texture.texture,...vw(i)).subarray(0,u);return this.disposeIntermediateTensorInfo(M),B}const f=Ee().getBool("WEBGL_PACK")&&l===!0,g=f?LT(i):i,A=f?new YY(g):new $Y(g),v=this.runWebGLProgram(A,[{shape:g,dtype:o,dataId:t}],"float32"),C=this.texData.get(v.dataId),S=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(C.texture.texture,C.texShape[0],C.texShape[1]).subarray(0,u);return this.disposeIntermediateTensorInfo(v),S}timerAvailable(){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const i=this.activeTimers,o=[];let l=!1;this.programTimersStack==null?(this.programTimersStack=o,l=!0):this.activeTimers.push(o),this.activeTimers=o,t();const u=G(this.activeTimers.map(A=>A.query)).filter(A=>A!=null),f=G(this.activeTimers.map(A=>A.name)).filter(A=>A!=null);this.activeTimers=i,l&&(this.programTimersStack=null);const g={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const A=await Promise.all(u);g.kernelMs=I(A),g.getExtraProfileInfo=()=>A.map((v,C)=>({name:f[C],ms:v})).map(v=>`${v.name}: ${v.ms}`).join(", ")}else g.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,g})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:wi(),endMs:null}}endTimer(t){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=wi(),t)}async getQueryTime(t){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const i=t;return i.endMs-i.startMs}disposeData(t,i=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(i?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!i&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:o}=this.texData.get(t);return o!=null&&(this.disposeData(o.real.dataId,i),this.disposeData(o.imag.dataId,i)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:i,dtype:o,texShape:l,usage:u,isPacked:f,slice:g}=this.texData.get(t),A=g&&g.origDataId||t,v=this.dataRefCount.get(A);v>1?this.dataRefCount.set(A,v-1):(this.dataRefCount.delete(A),i!=null&&(this.numBytesInGPU-=this.computeBytes(l,o),this.textureManager.releaseTexture(i,l,u,f)));const C=this.texData.get(t);C.texture=null,C.texShape=null,C.isPacked=!1,C.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,i=TJ){return Ee().getBool("WEBGL_CPU_FORWARD")&&t.every(o=>this.texData.get(o.dataId).texture==null&&N(o.shape)<i)}getGPGPUContext(){return this.gpgpu}where(t){sa("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const i=t.dataSync();return CJ(t.shape,i)}packedUnaryOp(t,i,o){const l=new Wp(t.shape,i),u=this.compileAndRun(l,[t],o);return os().makeTensorFromTensorInfo(u)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const l=oD(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,l)}if(Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,pD,t.dtype);const i=new ah(t.shape,pD),o=this.compileAndRun(i,[t]);return os().makeTensorFromTensorInfo(o)}makeTensorInfo(t,i,o){let l;if(i==="string"&&o!=null&&o.length>0&&de(o[0])){const u=o.map(f=>ri(f));l=this.write(u,t,i)}else l=this.write(o,t,i);return this.texData.get(l).usage=null,{dataId:l,shape:t,dtype:i}}makeOutput(t,i,o){return os().makeTensorFromTensorInfo(this.makeTensorInfo(t,i,o),this)}unpackTensor(t){const i=new wJ(t.shape);return this.runWebGLProgram(i,[t],t.dtype)}packTensor(t){const i=new aJ(t.shape);return this.runWebGLProgram(i,[t],t.dtype,null,!0)}packedReshape(t,i){const o=[r0(t.shape),...a0(t.shape)],l={dtype:t.dtype,shape:o,dataId:t.dataId},u=[r0(i),...a0(i)],f=new uD(u,o),g=!0,A=[o],v=this.runWebGLProgram(f,[l],t.dtype,A,g);return{dataId:v.dataId,shape:i,dtype:v.dtype}}decode(t,i){const o=this.texData.get(t),{isPacked:l,shape:u,dtype:f}=o;if(i!=null){const M=N(u),_=i[0]*i[1]*4;E(M<=_,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const g=LT(u);let A;l?A=new ZY(g):A=new KY(g);const v=!0,C=[i??vw(g)],S=this.runWebGLProgram(A,[{shape:g,dtype:f,dataId:t}],f,C,v,i);return{dtype:f,shape:u,dataId:S.dataId}}runWebGLProgram(t,i,o,l,u=!1,f){const g=this.makeTensorInfo(t.outputShape,o),A=this.texData.get(g.dataId);if(t.packedOutput&&(A.isPacked=!0),t.outPackingScheme===dy.DENSE){const U=f??vw(t.outputShape);A.texShape=U.map(V=>V*2)}if(t.outTexUsage!=null&&(A.usage=t.outTexUsage),N(g.shape)===0)return A.values=re(g.dtype,0),g;const v=[],C=i.map(U=>{if(U.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let V=this.texData.get(U.dataId);if(V.texture==null){if(!t.packedInputs&&N(U.shape)<=Ee().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:U.shape,texData:null,isUniform:!0,uniformValues:V.values};t.packedInputs&&(V.isPacked=!0,V.shape=U.shape)}if(this.uploadToGPU(U.dataId),!!V.isPacked!=!!t.packedInputs)U=V.isPacked?this.unpackTensor(U):this.packTensor(U),v.push(U),V=this.texData.get(U.dataId);else if(V.isPacked&&!Ew(V.shape,U.shape)){const $=U,q=U.shape;U.shape=V.shape,U=this.packedReshape(U,q),v.push(U),V=this.texData.get(U.dataId),$.shape=q}return{shape:U.shape,texData:V,isUniform:!1}});this.uploadToGPU(g.dataId);const S={shape:g.shape,texData:A,isUniform:!1},M=QY(t,C,S),_=this.getAndSaveBinary(M,()=>HY(this.gpgpu,t,C,S)),B=this.activeTimers!=null;let F;B&&(F=this.startTimer()),Ee().get("ENGINE_COMPILE_ONLY")||XY(this.gpgpu,_,C,S,l),v.forEach(U=>this.disposeIntermediateTensorInfo(U)),B&&(F=this.endTimer(F),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(F)}));const P=Ee().get("WEBGL_FLUSH_THRESHOLD");if(P>0){const U=wi();U-this.lastGlFlushTime>P&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=U)}if(!Ee().getBool("WEBGL_LAZILY_UNPACK")&&A.isPacked&&u===!1){const U=this.unpackTensor(g);return this.disposeIntermediateTensorInfo(g),U}return g}compileAndRun(t,i,o,l,u=!1){return o=o||i[0].dtype,this.runWebGLProgram(t,i,o,l,u)}getAndSaveBinary(t,i){return t in this.binaryCache||(this.binaryCache[t]=i()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ee().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=$e(()=>{if(!Ee().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Ee().getBool("DEBUG");Ee().set("DEBUG",!1);const i=this.abs(Ni(1e-8)).dataSync()[0];if(Ee().set("DEBUG",t),i>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?EJ:SJ}uploadToGPU(t){const i=this.texData.get(t),{shape:o,dtype:l,values:u,texture:f,usage:g,isPacked:A}=i;if(f!=null)return;const v=this.activeTimers!=null;let C;v&&(C=wi());let S=i.texShape;if(S==null&&(S=q7(o,A),i.texShape=S),u!=null){const M=LT(o);let _,B=S[1],F=S[0];const P=u instanceof Uint8Array||u instanceof Uint8ClampedArray;(A||!P)&&([B,F]=s0(S[0],S[1])),A?_=new qY(M,P):_=new jY(M,P);const U=P?[F,B]:S,V=this.makeTensorInfo(U,l),$=this.texData.get(V.dataId);P?$.usage=Ko.PIXELS:$.usage=Ko.UPLOAD,$.texShape=U,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(V.dataId),B,F,u);const q=[[F,B]],ne=!0,he=this.runWebGLProgram(_,[V],l,q,ne),me=this.texData.get(he.dataId);i.texShape=me.texShape,i.isPacked=me.isPacked,i.usage=me.usage,Ee().get("ENGINE_COMPILE_ONLY")?this.disposeData(he.dataId):(i.texture=me.texture,i.values=null,this.texData.delete(he.dataId)),this.disposeIntermediateTensorInfo(V),v&&(this.uploadWaitMs+=wi()-C)}else{const M=this.acquireTexture(S,g,l,A);i.texture=M}}convertAndCacheOnCPU(t,i){const o=this.texData.get(t),{dtype:l}=o;return this.releaseGPUData(t),i!=null&&(o.values=RJ(i,l)),o.values}acquireTexture(t,i,o,l){if(this.numBytesInGPU+=this.computeBytes(t,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const u=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${u} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,i,l)}computeBytes(t,i){return t[0]*t[1]*Pe(i)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,i]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(i));return Promise.all(t)}else{for(const[,i]of Object.entries(this.binaryCache)){const o=new Promise(l=>{try{this.checkCompletion_(i),l(!0)}catch(u){throw u}});t.push(o)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await P1(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(P3(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,t]of Object.entries(this.binaryCache)){const{uniformLocations:i,customUniformLocations:o,infLoc:l,nanLoc:u,inShapesLocations:f,inTexShapesLocations:g,outShapeLocation:A,outShapeStridesLocation:v,outTexShapeLocation:C}=Z3(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=i,t.customUniformLocations=o,t.infLoc=l,t.nanLoc=u,t.inShapesLocations=f,t.inTexShapesLocations=g,t.outShapeLocation=A,t.outShapeStridesLocation=v,t.outTexShapeLocation=C}}}Tw.nextDataId=0;function RJ(s,t){if(t==="float32"||t==="complex64")return s;if(t==="int32"||t==="bool"){const i=t==="int32"?new Int32Array(s.length):new Uint8Array(s.length);for(let o=0;o<i.length;++o)i[o]=Math.round(s[o]);return i}else throw new Error(`Unknown dtype ${t}`)}/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/eg()&&YA("webgl",()=>new Tw,2);/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const WT=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class d0{constructor(t,i,o){this.variableNames=["A","B"],this.outputShape=$n(i,o),this.enableShapeUniforms=pa(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ay=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class by{constructor(t,i,o,l=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=$n(i,o);const u=this.outputShape.length;this.enableShapeUniforms=pa(u);let f="";if(l)if(u===0||N(this.outputShape)===1)f=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(f=`
          ${ws(u)} coords = getOutputCoords();
        `,u===1)this.enableShapeUniforms?f+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:f+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const g=ma("coords",u);this.enableShapeUniforms?f+=`
            bool nextRowOutOfBounds =
              (${g[u-2]} + 1) >= outShape[${u} - 2];
            bool nextColOutOfBounds =
              (${g[u-1]} + 1) >= outShape[${u} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:f+=`
            bool nextRowOutOfBounds =
              (${g[u-2]} + 1) >= ${this.outputShape[u-2]};
            bool nextColOutOfBounds =
              (${g[u-1]} + 1) >= ${this.outputShape[u-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${f}

        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wo(s){const{inputs:t,backend:i}=s,{x:o}=t;return i.incRef(o.dataId),{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}const kJ={kernelName:Sr,backendName:"webgl",kernelFunc:wo};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Nd(s){const{inputs:t,backend:i}=s,{real:o,imag:l}=t,u=i.makeTensorInfo(o.shape,"complex64"),f=i.texData.get(u.dataId),g=wo({inputs:{x:o},backend:i}),A=wo({inputs:{x:l},backend:i});return f.complexTensorInfos={real:g,imag:A},u}const BJ={kernelName:Ki,backendName:"webgl",kernelFunc:Nd};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mD="return (a < 0.) ? b * a : a;",gD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function LJ(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{alpha:u}=o,f=i.makeTensorInfo([],"float32",Do(u,"float32")),g=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new by(gD,l.shape,f.shape):new d0(mD,l.shape,f.shape),A=i.runWebGLProgram(g,[l,f],"float32");return i.disposeIntermediateTensorInfo(f),A}const NJ={kernelName:vs,backendName:"webgl",kernelFunc:LJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const AD="return (a < 0.) ? b * a : a;",bD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function DJ(s){const{inputs:t,backend:i}=s,{x:o,alpha:l}=t,u=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new by(bD,o.shape,l.shape):new d0(AD,o.shape,l.shape);return i.runWebGLProgram(u,[o,l],"float32")}const FJ={kernelName:Dm,backendName:"webgl",kernelFunc:DJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const f0="if (isnan(x)) return x;";function Di({opSnippet:s,packedOpSnippet:t,cpuKernelImpl:i,dtype:o}){return({inputs:l,backend:u})=>{const{x:f}=l,g=u,A=o||f.dtype;if(g.shouldExecuteOnCPU([f])&&i!=null){const S=g.texData.get(f.dataId),M=i(S.values,A);return g.makeTensorInfo(f.shape,A,M)}const v=Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let C;return v?C=new Wp(f.shape,t):C=new ah(f.shape,s),g.runWebGLProgram(C,[f],A)}}function Wr({opSnippet:s,packedOpSnippet:t,checkOutOfBounds:i=!1,supportsComplex:o=!1,cpuKernelImpl:l,dtype:u}){return({inputs:f,backend:g})=>{const{a:A,b:v}=f,C=g;if(o&&A.dtype==="complex64"){const B=C.texData.get(A.dataId),F=C.texData.get(v.dataId),[P,U]=[[B.complexTensorInfos.real,F.complexTensorInfos.real],[B.complexTensorInfos.imag,F.complexTensorInfos.imag]].map($=>{const[q,ne]=$,he={dataId:q.dataId,dtype:q.dtype,shape:A.shape},me={dataId:ne.dataId,dtype:ne.dtype,shape:v.shape},pe=new d0(s,A.shape,v.shape);return C.runWebGLProgram(pe,[he,me],ar(q.dtype,ne.dtype))}),V=Nd({inputs:{real:P,imag:U},backend:C});return C.disposeIntermediateTensorInfo(P),C.disposeIntermediateTensorInfo(U),V}const S=u||ar(A.dtype,v.dtype);if((A.dtype==="string"||v.dtype==="string"||C.shouldExecuteOnCPU([A,v]))&&l!=null){const B=C.texData.get(A.dataId).values,F=C.texData.get(v.dataId).values,P=A.dtype==="string"?nh(B):B,U=A.dtype==="string"?nh(F):F,[V,$]=l(A.shape,v.shape,P,U,S),q=C.makeTensorInfo($,S),ne=C.texData.get(q.dataId);return ne.values=V,q}const M=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let _;return M?_=new by(t,A.shape,v.shape,i):_=new d0(s,A.shape,v.shape),C.runWebGLProgram(_,[A,v],S)}}function yy(s,t=!1){if(s==="linear")return t?AJ:dJ;if(s==="relu")return t?yJ:pJ;if(s==="elu")return t?bJ:fJ;if(s==="relu6")return t?vJ:mJ;if(s==="prelu")return t?bD:AD;if(s==="leakyrelu")return t?gD:mD;if(s==="sigmoid")return t?xJ:gJ;throw new Error(`Activation ${s} has not been implemented for the WebGL backend.`)}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class yD{constructor(t,i,o,l=!1,u=!1,f=!1,g=null,A=!1,v=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o,this.enableShapeUniforms=pa(this.outputShape.length);const C=l?t[1]:t[2],S=Math.ceil(C/2),M=l?"i * 2, rc.y":"rc.y, i * 2",_=u?"rc.z, i * 2":"i * 2, rc.z",B=l?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],F=u?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let P="",U="";g&&(A?P=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${g}
        }`:v?P=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${g}
        }`:P=`vec4 activation(vec4 x) {
          ${g}
        }`,U="result = activation(result);");const V=f?"result += getBiasAtOutCoords();":"";f&&this.variableNames.push("bias"),A&&this.variableNames.push("preluActivationWeights"),v&&this.variableNames.push("leakyreluAlpha");let $="rc.x",q="rc.x";t[0]<i[0]?$=`int(min(float(rc.x), ${t[0]-1}.))`:i[0]<t[0]&&(q=`int(min(float(rc.x), ${i[0]-1}.))`),this.userCode=`
      ${P}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${S}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${S}; i++) {
          int batchA = ${$};
          int batchB = ${q};
          vec4 a = getMatrixA(batchA, ${M});
          vec4 b = getMatrixB(batchB, ${_});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${B[0]} * ${F[0]});
          result += (${B[1]} * ${F[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${V}

        ${U}

        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vD={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class xD{constructor(t,i,o){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=$n(i,o),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wD="return a * b;";function HT(s){const{inputs:t,backend:i}=s,{a:o,b:l}=t,u=ar(o.dtype,l.dtype);if(o.dtype==="complex64"){const g=i.texData.get(o.dataId),A=i.texData.get(l.dataId),v=new xD(vD.REAL,o.shape,l.shape),C=new xD(vD.IMAG,o.shape,l.shape),S=[{dataId:g.complexTensorInfos.real.dataId,dtype:g.complexTensorInfos.real.dtype,shape:o.shape},{dataId:g.complexTensorInfos.imag.dataId,dtype:g.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:A.complexTensorInfos.real.dataId,dtype:A.complexTensorInfos.real.dtype,shape:l.shape},{dataId:A.complexTensorInfos.imag.dataId,dtype:A.complexTensorInfos.imag.dtype,shape:l.shape}],M=i.runWebGLProgram(v,S,"float32"),_=i.runWebGLProgram(C,S,"float32"),B=Nd({inputs:{real:M,imag:_},backend:i});return i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(_),B}if(i.shouldExecuteOnCPU([o,l])){const g=i.texData.get(o.dataId),A=i.texData.get(l.dataId),[v,C]=Oq(o.shape,l.shape,g.values,A.values,u),S=i.makeTensorInfo(C,u),M=i.texData.get(S.dataId);return M.values=v,S}let f;return Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?f=new by(wD,o.shape,l.shape):f=new d0(wD,o.shape,l.shape),i.runWebGLProgram(f,[o,l],u)}const OJ={kernelName:dr,backendName:"webgl",kernelFunc:HT};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function GJ(s,t,i){const o=[r0(s.shape),...a0(s.shape)],l={dtype:s.dtype,shape:o,dataId:s.dataId},u=[r0(t),...a0(t)],f=new uD(u,o),g=!0,A=[o],v=i.runWebGLProgram(f,[l],s.dtype,A,g);return{dataId:v.dataId,shape:t,dtype:v.dtype}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rn(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{shape:u}=o,f=i,g=N(l.shape),A=j(u,g),v=N(A);E(g===v,()=>`The new shape (${A}) has ${v} elements and the old shape (${l.shape}) has ${g} elements. The new shape and old shape must have the same number of elements.`);const C=f.texData.get(l.dataId);return C.isPacked&&!Ew(l.shape,A)&&!(C.texture!==null&&Ew(C.shape,A))?GJ(l,A,f):(f.incRef(l.dataId),{dataId:l.dataId,shape:A,dtype:l.dtype})}const UJ={kernelName:pf,backendName:"webgl",kernelFunc:rn};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class CD{constructor(t,i){this.variableNames=["x"];const{windowSize:o,batchSize:l,inSize:u,outSize:f}=t;this.outputShape=[l,f];const g=Math.floor(o/4)*4,A=o%4;let v="sumValue += dot(values, ones);";if(i!=null){const S=1/i;v=`sumValue += dot(values * ${D(S)?S.toPrecision(2):S}, ones);`}let C="";u%o>0&&(C=`
        if (inIdx < 0 || inIdx >= ${u}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${C}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        float sumValue = 0.0;

        for (int i = 0; i < ${g}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${v}
        }

        int inIdx = inOffset + ${g};
        if (${A===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${v}
        } else if (${A===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${v}
        } else if (${A===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${v}
        }
        setOutput(sumValue);
      }
    `}}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class PJ{constructor(t,i){this.variableNames=["x"];const{windowSize:o,batchSize:l,inSize:u,outSize:f}=t;this.outputShape=[l,f];let g="0.0",A="";i==="prod"?g="1.0":i==="min"?(g="1.0 / 1e-20",A="min"):i==="max"&&(g="-1.0 / 1e-20",A="max");let v=`${i}(${i}(${i}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;i==="sum"?v="sumValue":i==="prod"?v="prodValue":i==="all"?v="allValue":i==="any"&&(v="anyValue");const C=Math.floor(o/4)*4,S=o%4;let M=`
      if (${i==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${i==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${A}(values, minMaxValue);
        if (${i==="min"} || ${i==="max"}) {
          minMaxValue = ${A}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,_="vec4";i==="all"?(g="1.0",M=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,_="bvec4"):i==="any"&&(g="0.0",M=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,_="bvec4");let B="";u%o>0&&(B=`
        if (inIdx < 0 || inIdx >= ${u}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${g};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${B}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        vec4 minMaxValue = vec4(${g});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${C}; i += 4) {
          int inIdx = inOffset + i;
          ${_} values = ${_}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${M}
        }

        int inIdx = inOffset + ${C};
        if (${S===1}) {
          ${_} values = ${_}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${M}
        } else if (${S===2}) {
          ${_} values = ${_}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${M}
        } else if (${S===3}) {
          ${_} values = ${_}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${M}
        }
        setOutput(${v});
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zJ(s){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const i=t.length?t[t.length-1].outSize:s[1],o=z1(i);t.push({inSize:i,windowSize:o,outSize:Math.ceil(i/o)})}return t}function Hp(s,t,i,o){const l=zJ(s.shape);let u=s;for(let f=0;f<l.length;f++){const{inSize:g,windowSize:A,outSize:v}=l[f];let C,S;i==="mean"?C=f===0?new CD({windowSize:A,inSize:g,batchSize:s.shape[0],outSize:v},g):new CD({windowSize:A,inSize:g,batchSize:s.shape[0],outSize:v}):C=new PJ({windowSize:A,inSize:g,batchSize:s.shape[0],outSize:v},i),S=u,u=o.runWebGLProgram(C,[u],t),S.dataId!==s.dataId&&o.disposeIntermediateTensorInfo(S)}return u}/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class VJ{constructor(t,i){this.variableNames=["A"];const o=new Array(t.length);for(let f=0;f<o.length;f++)o[f]=t[i[f]];this.outputShape=o,this.rank=o.length;const l=ws(this.rank),u=WJ(i);this.userCode=`
    void main() {
      ${l} resRC = getOutputCoords();
      setOutput(getA(${u}));
    }
    `}}function WJ(s){const t=s.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const i=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],o=new Array(t);for(let l=0;l<s.length;l++)o[s[l]]=i[l];return o.join()}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class HJ{constructor(t,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const o=new Array(t.length);for(let C=0;C<o.length;C++)o[C]=t[i[C]];if(this.outputShape=o,this.rank=o.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const l=ws(this.rank),u=cD("rc",this.rank),f=new Array(this.rank);for(let C=0;C<i.length;C++)f[i[C]]=u[C];const g=`vec2(${f.slice(-2).join()})`,A=`++${u[this.rank-1]} < ${o[this.rank-1]}`,v=`getChannel(getA(${f.join()}), ${g})`;this.userCode=`
    void main() {
      ${l} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${v};
      if(${A}) {
        result[1] = ${v};
      }
      --${u[this.rank-1]};
      if(++${u[this.rank-2]} < ${o[this.rank-2]}) {
        result[2] = ${v};
        if(${A}) {
          result[3] = ${v};
        }
      }
      setOutput(result);
    }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mw(s,t,i){const o=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new HJ(s.shape,t):new VJ(s.shape,t);return i.runWebGLProgram(o,[s],s.dtype)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function XJ(s,t,i,o){const l=t,u=s.shape.length,f=J(l,s.shape);let g=f;const A=ji(g,u),v=A!=null;let C=s;v&&(C=Mw(s,A,o),g=Ss(g.length,u)),Rs("sum",g,u);const[S,M]=Ei(C.shape,g);let _=S;i&&(_=ts(S,f));const B=N(M),F=N(s.shape)/B,P=rn({inputs:{x:C},attrs:{shape:[F,B]},backend:o}),U=Hf(s.dtype),V=Hp(P,U,"sum",o),$=rn({inputs:{x:V},attrs:{shape:_},backend:o});return o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(V),v&&o.disposeIntermediateTensorInfo(C),$}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _w(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o;return XJ(l,u,f,i)}const QJ={kernelName:Mc,backendName:"webgl",kernelFunc:_w};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ga(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{perm:u}=o,f=i,g=l.shape.length,A=new Array(g);for(let C=0;C<A.length;C++)A[C]=l.shape[u[C]];let v;if(f.shouldExecuteOnCPU([l])){const C=f.texData.get(l.dataId).values,S=zT(C,l.shape,l.dtype,u,A);v=f.makeTensorInfo(A,l.dtype);const M=f.texData.get(v.dataId);M.values=S}else v=Mw(l,u,f);return v}const KJ={kernelName:Du,backendName:"webgl",kernelFunc:ga};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ED=1e3;function Rw({a:s,b:t,transposeA:i,transposeB:o,backend:l,bias:u=null,preluActivationWeights:f=null,leakyreluAlpha:g=0,activation:A=null}){const v=s.shape.length,C=t.shape.length,S=i?s.shape[v-2]:s.shape[v-1],M=o?t.shape[C-1]:t.shape[C-2],_=i?s.shape[v-1]:s.shape[v-2],B=o?t.shape[C-2]:t.shape[C-1],F=s.shape.slice(0,-2),P=t.shape.slice(0,-2),U=N(F),V=N(P),$=$n(s.shape.slice(0,-2),t.shape.slice(0,-2)).concat([_,B]);E(S===M,()=>`Error in matMul: inner shapes (${S}) and (${M}) of Tensors with shapes ${s.shape} and ${t.shape} and transposeA=${i} and transposeB=${o} must match.`);const q=i?[U,S,_]:[U,_,S],ne=o?[V,B,M]:[V,M,B],he=rn({inputs:{x:s},backend:l,attrs:{shape:q}}),me=rn({inputs:{x:t},backend:l,attrs:{shape:ne}}),pe=[he,me],ye=Math.max(U,V),Te=i?he.shape[1]:he.shape[2],Ye=u!=null,et=f!=null,nt=A==="leakyrelu",ht=A!=null?yy(A,!0):null,ct=Ye||et||nt||ht!=null;let pt;if((_===1||B===1)&&Te>ED&&ct===!1){let yt=he,It=me;i&&(yt=ga({inputs:{x:he},backend:l,attrs:{perm:[0,2,1]}}),pe.push(yt)),o&&(It=ga({inputs:{x:me},backend:l,attrs:{perm:[0,2,1]}}),pe.push(It));const Pt=B!==1,Ft=B===1;let Xt=yt;Pt&&(Xt=rn({inputs:{x:yt},backend:l,attrs:{shape:[ye,Te,1]}}),pe.push(Xt));const $t=B===1?2:1;let Yt=It;Ft&&(Yt=rn({inputs:{x:It},backend:l,attrs:{shape:[ye,1,Te]}}),pe.push(Yt));const en=HT({inputs:{a:Xt,b:Yt},backend:l});pt=_w({inputs:{x:en},backend:l,attrs:{axis:$t,keepDims:!0}}),pe.push(en)}else{const yt=ar(s.dtype,t.dtype),It=new yD(q,ne,[ye,_,B],i,o,Ye,ht,et,nt),Pt=[he,me];if(u!=null&&Pt.push(u),et&&Pt.push(f),nt){const Ft=l.makeTensorInfo([],"float32",Do(g,"float32"));Pt.push(Ft),pe.push(Ft)}pt=l.runWebGLProgram(It,Pt,yt)}const Et=rn({inputs:{x:pt},backend:l,attrs:{shape:$}});pe.push(pt);for(const yt of pe)l.disposeIntermediateTensorInfo(yt);return Et}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ZJ(s){const{inputs:t,backend:i,attrs:o}=s,{a:l,b:u,bias:f,preluActivationWeights:g}=t,{transposeA:A,transposeB:v,activation:C,leakyreluAlpha:S}=o;return Rw({a:l,b:u,transposeA:A,transposeB:v,backend:i,bias:f,preluActivationWeights:g,leakyreluAlpha:S,activation:C})}const $J={kernelName:Gr,backendName:"webgl",kernelFunc:ZJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const SD="return abs(x);";function YJ(s){const{inputs:t,backend:i}=s,{x:o}=t;if(i.shouldExecuteOnCPU([o])&&o.dtype!=="complex64"){const u=i.texData.get(o.dataId),f=oD(u.values);return i.makeTensorInfo(o.shape,o.dtype,f)}let l;return Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?l=new Wp(o.shape,SD):l=new ah(o.shape,SD),i.runWebGLProgram(l,[o],o.dtype)}const jJ={kernelName:At,backendName:"webgl",kernelFunc:YJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qJ=Il+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,JJ=Di({opSnippet:qJ}),eee={kernelName:dn,backendName:"webgl",kernelFunc:JJ};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tee=Il+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,nee=Di({opSnippet:tee}),iee={kernelName:ge,backendName:"webgl",kernelFunc:nee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ID="return a + b;",see=Wr({opSnippet:ID,packedOpSnippet:ID,supportsComplex:!0,cpuKernelImpl:Aq}),ree={kernelName:se,backendName:"webgl",kernelFunc:see};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class aee{constructor(t,i){this.outputShape=[],this.outputShape=t,this.variableNames=i.map((u,f)=>`T${f}`);const o=[];this.variableNames.forEach(u=>{o.push(`float v${u} = get${u}AtOutCoords();`)});const l=this.variableNames.map(u=>`v${u}`).join(" + ");this.userCode=`
      void main() {
        ${o.join(`
        `)}

        float result = ${l};
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class oee{constructor(t,i){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=i.map((u,f)=>`T${f}`);const o=[];this.variableNames.forEach(u=>{o.push(`vec4 v${u} = get${u}AtOutCoords();`)});const l=this.variableNames.map(u=>`v${u}`).join(" + ");this.userCode=`
      void main() {
        ${o.join(`
        `)}

        vec4 result = ${l};
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function kw(s){const{inputs:t,backend:i}=s,o=t;if(o.length===1)return wo({inputs:{x:o[0]},backend:i});if(o.length>Ee().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const g=Math.floor(o.length/2),A=kw({inputs:o.slice(0,g),backend:i}),v=kw({inputs:o.slice(g),backend:i});return kw({inputs:[A,v],backend:i})}const l=o.map(g=>g.dtype).reduce((g,A)=>ar(g,A)),u=o.map(g=>g.shape),f=Ee().getBool("WEBGL_PACK")?new oee(o[0].shape,u):new aee(o[0].shape,u);return i.runWebGLProgram(f,o,l)}const lee={kernelName:Ge,backendName:"webgl",kernelFunc:kw};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cee(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o,g=l.shape.length,A=J(u,l.shape);let v=A;const C=ji(v,g);let S=l;C!=null&&(S=ga({inputs:{x:l},backend:i,attrs:{perm:C}}),v=Ss(v.length,g)),Rs("all",v,g);const[M,_]=Ei(S.shape,v),B=N(_),F=rn({inputs:{x:S},backend:i,attrs:{shape:[-1,B]}}),P=Hp(F,F.dtype,"all",i);let U;if(f){const V=ts(M,A);U=rn({inputs:{x:P},backend:i,attrs:{shape:V}})}else U=rn({inputs:{x:P},backend:i,attrs:{shape:M}});return i.disposeIntermediateTensorInfo(F),i.disposeIntermediateTensorInfo(P),C!=null&&i.disposeIntermediateTensorInfo(S),U}const uee={kernelName:ut,backendName:"webgl",kernelFunc:cee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hee(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o,g=l.shape.length,A=J(u,l.shape);let v=A;const C=ji(v,g);let S=l;C!=null&&(S=ga({inputs:{x:l},backend:i,attrs:{perm:C}}),v=Ss(v.length,g)),Rs("any",v,g);const[M,_]=Ei(S.shape,v),B=N(_),F=rn({inputs:{x:S},backend:i,attrs:{shape:[-1,B]}}),P=Hp(F,F.dtype,"any",i);let U;if(f){const V=ts(M,A);U=rn({inputs:{x:P},backend:i,attrs:{shape:V}})}else U=rn({inputs:{x:P},backend:i,attrs:{shape:M}});return i.disposeIntermediateTensorInfo(F),i.disposeIntermediateTensorInfo(P),C!=null&&i.disposeIntermediateTensorInfo(S),U}const dee={kernelName:kt,backendName:"webgl",kernelFunc:hee};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fee{constructor(t,i,o){this.variableNames=["A"];const{windowSize:l,batchSize:u,outSize:f}=t;o||this.variableNames.push("bestIndicesA"),this.outputShape=[u,f];const g=i==="max"?">":"<",A=o?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${l};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${l}; i++) {
          int inIdx = ${A};
          float candidate = getA(batch, inIdx);
          if (candidate ${g} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class pee{constructor(t,i,o,l){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,E(t.length>2,()=>`Packed arg${o.charAt(0).toUpperCase()+o.slice(1)} supports only inputs with rank above 2.`);const u=t[t.length-1],f=Math.ceil(u/i);this.outputShape=t.slice(0,-1),f>1&&this.outputShape.push(f),l||this.variableNames.push("bestIndicesA");const g=this.outputShape,A=g.length,v=ws(A),C=ma("coords",A);let S,M;if(f===1){M=A+1;const pe=ws(M);S=`
        ${pe} sourceLocR = ${pe}(${C.join()}, 0);
        ++${C[A-1]};
        ${pe} sourceLocG = ${pe}(${C.join()}, 0);
        ++${C[A-2]};
        ${pe} sourceLocA = ${pe}(${C.join()}, 0);
        --${C[A-1]};
        ${pe} sourceLocB = ${pe}(${C.join()}, 0);
        --${C[A-2]};`}else M=A,S=`
        ${v} sourceLocR = coords;
        ++${C[A-1]};
        ${v} sourceLocG = coords;
        ++${C[A-2]};
        ${v} sourceLocA = coords;
        --${C[A-1]};
        ${v} sourceLocB = coords;
        --${C[A-2]};`;const _=["x","y","z","w","u","v"].slice(0,M),B="."+_[M-1],F=_.map(pe=>"int "+pe),P=ma("sourceLocR",M-1).concat("inIdx.r"),U=ma("sourceLocG",M-1).concat("inIdx.g"),V=ma("sourceLocB",M-1).concat("inIdx.b"),$=ma("sourceLocA",M-1).concat("inIdx.a"),q=o==="max"?"greaterThan":"lessThan",ne=l?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${P.join()}),
                             getBestIndicesAChannel(${U.join()}),
                             getBestIndicesAChannel(${V.join()}),
                             getBestIndicesAChannel(${$.join()})));`,he=`vec4(
            getAChannel(${P.join()}),
            hasNextCol ? getAChannel(${U.join()}) : 0.,
            hasNextRow ? getAChannel(${V.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${$.join()}) : 0.)`,me=l?"":`
      float getBestIndicesAChannel(${F.join()}) {
        return getChannel(getBestIndicesA(${_.join()}),
                                          vec2(${_.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${F.join()}) {
        return getChannel(getA(${_.join()}),
                               vec2(${_.slice(-2).join()}));
      }
      ${me}
      void main() {
        ${v} coords = getOutputCoords();
        bool hasNextCol = ${C[A-1]} < ${g[A-1]-1};
        bool hasNextRow = ${C[A-2]} < ${g[A-2]-1};
        ${S}
        ivec4 srcIdx = ivec4(sourceLocR${B}, sourceLocG${B},
          sourceLocB${B}, sourceLocA${B}) * ${i};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${he};

        for (int i = 0; i < ${i}; i++) {
          inIdx = srcIdx;
          ${ne}
          vec4 candidate = ${he};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${q}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function TD(s,t,i,o=null){let l=t.shape[0],u=t.shape[1];o!=null&&(l=o.shape[0],u=o.shape[1]);const f=z1(u),g={windowSize:f,inSize:u,batchSize:l,outSize:Math.ceil(u/f)},A=new fee(g,i,o==null),v=[t];o!=null&&v.push(o);const C=s.runWebGLProgram(A,v,"int32");if(C.shape[1]===1)return C;const S=TD(s,t,i,C);return s.disposeIntermediateTensorInfo(C),S}function MD(s,t,i,o=null){const l=o!=null?o.shape:t.shape,u=l[l.length-1],f=z1(u),g=new pee(l,f,i,o==null),A=o==null?[t]:[t,o],v=s.runWebGLProgram(g,A,"int32");if(v.shape.length===t.shape.length){const C=MD(s,t,i,v);return s.disposeIntermediateTensorInfo(v),C}return v}function _D(s,t,i,o){const l=[i];if(Rs("arg"+o.charAt(0).toUpperCase()+o.slice(1),l,t.shape.length),!Ee().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const u=[],f=s.texData.get(t.dataId),g=f!==null&&f.isPacked;let A=t;g&&(A=s.unpackTensor(t),u.push(A));const[v,C]=Ei(A.shape,l),S=N(C),M=rn({inputs:{x:A},backend:s,attrs:{shape:[-1,S]}});u.push(M);const _=TD(s,M,o);u.push(_);const B=rn({inputs:{x:_},backend:s,attrs:{shape:v}});return u.forEach(F=>s.disposeIntermediateTensorInfo(F)),B}return MD(s,t,o)}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mee(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u}=o;let f=J(u,l.shape);const g=ji(f,l.shape.length);let A=l;const v=[];g!=null&&(A=ga({inputs:{x:l},backend:i,attrs:{perm:g}}),v.push(A),f=Ss(f.length,A.shape.length)),Rs("argMax",[f[0]],A.shape.length);const C=_D(i,A,f[0],"max");return v.forEach(S=>i.disposeIntermediateTensorInfo(S)),C}const gee={kernelName:xt,backendName:"webgl",kernelFunc:mee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Aee(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u}=o;let f=J(u,l.shape);const g=ji(f,l.shape.length);let A=l;const v=[];g!=null&&(A=ga({inputs:{x:l},backend:i,attrs:{perm:g}}),v.push(A),f=Ss(f.length,A.shape.length)),Rs("argMin",[f[0]],A.shape.length);const C=_D(i,A,f[0],"min");return v.forEach(S=>i.disposeIntermediateTensorInfo(S)),C}const bee={kernelName:fn,backendName:"webgl",kernelFunc:Aee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const yee=Il+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,vee=Di({opSnippet:yee}),xee={kernelName:Gt,backendName:"webgl",kernelFunc:vee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const wee=Il+"return log(x + sqrt(x * x + 1.0));",Cee=Di({opSnippet:wee}),Eee={kernelName:Jt,backendName:"webgl",kernelFunc:Cee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const See=Il+`
  return atan(x);
`,Iee=Di({opSnippet:See}),Tee={kernelName:Ln,backendName:"webgl",kernelFunc:Iee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Mee=WT+`
  return atan(a, b);
`,_ee=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ay+`
  return result;
`,Ree=Wr({opSnippet:Mee,packedOpSnippet:_ee}),kee={kernelName:bn,backendName:"webgl",kernelFunc:Ree};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Bee=Il+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Lee=Di({opSnippet:Bee}),Nee={kernelName:Zt,backendName:"webgl",kernelFunc:Lee};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class vy{constructor(t,i,o,l=!1,u=!1){if(this.variableNames=["x"],i==="avg"&&o)throw new Error("Cannot compute positions for average pool.");const f=t.filterWidth,g=t.strideHeight,A=t.strideWidth,v=t.dilationHeight,C=t.dilationWidth,S=t.effectiveFilterHeight,M=t.effectiveFilterWidth,_=t.padInfo.top,B=t.padInfo.left;this.outputShape=t.outShape;const F=i==="avg",P=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,U=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let V="0.0";if(F||(V="-1.0 / 1e-20"),o){this.userCode=`
        const ivec2 strides = ivec2(${g}, ${A});
        const ivec2 pads = ivec2(${_}, ${B});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${S};
              wR += ${v}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${M};
                wC += ${C}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${l?u?P:U:`wR * ${M} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let q=`${i}(${i}(${i}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;i==="avg"&&(q="avgValue / count");const ne=Math.floor(f/4)*4,he=f%4,me=`
      if (${F}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${g}, ${A});
      const ivec2 pads = ivec2(${_}, ${B});
      const float initializationValue = ${V};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${V});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${S};
            wR += ${v}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${ne}; wC += 4) {
            int xC = xCCorner + wC * ${C};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${C}, d),
              getValue(batch, xR, xC + 2 * ${C}, d),
              getValue(batch, xR, xC + 3 * ${C}, d)
            );

            ${me}
          }

          int xC = xCCorner + ${ne};
          if (${he===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${me}
          } else if (${he===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${C}, d),
              initializationValue,
              initializationValue
            );

            ${me}
          } else if (${he===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${C}, d),
              getValue(batch, xR, xC + 2 * ${C}, d),
              initializationValue
            );

            ${me}
          }
        }
        setOutput(${q});
      }
    `}}class XT{constructor(t,i,o,l=!1,u=!1){if(this.variableNames=["x"],i==="avg"&&o)throw new Error("Cannot compute positions for average pool.");const f=t.filterWidth,g=t.strideDepth,A=t.strideHeight,v=t.strideWidth,C=t.dilationDepth,S=t.dilationHeight,M=t.dilationWidth,_=t.effectiveFilterDepth,B=t.effectiveFilterHeight,F=t.effectiveFilterWidth,P=t.padInfo.front,U=t.padInfo.top,V=t.padInfo.left;this.outputShape=t.outShape;const $=i==="avg";let q="0.0";if($||(q="-1.0 / 1e-20"),o){this.userCode=`
        const ivec3 strides =
            ivec3(${g}, ${A}, ${v});
        const ivec3 pads = ivec3(${P}, ${U}, ${V});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${_};
              wD += ${C}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${B};
                wR += ${S}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${F};
                  wC += ${M}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${l?u?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${B} * ${F} +
                      wR * ${F} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const ne="max";let he=`${i}(${i}(${i}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;i==="avg"&&(he="avgValue / count");const me=Math.floor(f/4)*4,pe=f%4,ye=`
      if (${$}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${ne}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${g}, ${A}, ${v});
      const ivec3 pads = ivec3(${P}, ${U}, ${V});
      const float initializationValue = ${q};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${q});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${_};
            wD += ${C}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${B};
            wR += ${S}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${me}; wC += 4) {
              int xC = xCCorner + wC * ${M};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${M}, ch),
                getValue(batch, xD, xR, xC + 2 * ${M}, ch),
                getValue(batch, xD, xR, xC + 3 * ${M}, ch)
              );

              ${ye}
            }

            int xC = xCCorner + ${me};
            if (${pe===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${ye}
            } else if (${pe===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${M}, ch),
                initializationValue,
                initializationValue
              );

              ${ye}
            } else if (${pe===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${M}, ch),
                getValue(batch, xD, xR, xC + 2 * ${M}, ch),
                initializationValue
              );

              ${ye}
            }
          }
          setOutput(${he});
        }
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dee(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t;py(l,"avgPool");const{filterSize:u,strides:f,pad:g,dimRoundingMode:A}=o,v=1;E(or(f,v),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${f} and dilations '${v}'`);const C=Oa(l.shape,u,f,v,g,A);if(C.filterWidth===1&&C.filterHeight===1&&O(C.inShape,C.outShape))return wo({inputs:{x:l},backend:i});const S=new vy(C,"avg",!1);return i.runWebGLProgram(S,[l],"float32")}const Fee={kernelName:Jn,backendName:"webgl",kernelFunc:Dee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Oee(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{filterSize:u,strides:f,pad:g,dimRoundingMode:A,dataFormat:v}=o,C=[1,1,1],S=go(l.shape,u,f,C,g,A,v),M=new XT(S,"avg",!1);return i.runWebGLProgram(M,[l],"float32")}const Gee={kernelName:wt,backendName:"webgl",kernelFunc:Oee};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Uee{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const i=t.filterHeight,o=t.filterWidth,l=t.strideHeight,u=t.strideWidth,f=t.dilationHeight,g=t.dilationWidth,A=t.effectiveFilterHeight,v=t.effectiveFilterWidth,C=A-1-t.padInfo.top,S=v-1-t.padInfo.left,M=1/(i*o);this.userCode=`
      const ivec2 pads = ivec2(${C}, ${S});
      const float avgMultiplier = float(${M});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${A};
            wR += ${f}) {
          float dyR = float(dyRCorner + wR) / ${l}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${v};
            wC+= ${g}) {
            float dyC = float(dyCCorner + wC) / ${u}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Pee{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const i=t.filterDepth,o=t.filterHeight,l=t.filterWidth,u=t.strideDepth,f=t.strideHeight,g=t.strideWidth,A=t.dilationDepth,v=t.dilationHeight,C=t.dilationWidth,S=t.effectiveFilterDepth,M=t.effectiveFilterHeight,_=t.effectiveFilterWidth,B=S-1-t.padInfo.front,F=M-1-t.padInfo.top,P=_-1-t.padInfo.left,U=1/(i*o*l);this.userCode=`
      const ivec3 pads = ivec3(${B}, ${F}, ${P});
      const float avgMultiplier = float(${U});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${S};
            wD += ${A}) {
          float dyD = float(dyDCorner + wD) / ${u}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${M};
              wR += ${v}) {
            float dyR = float(dyRCorner + wR) / ${f}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${_};
                wC += ${C}) {
              float dyC = float(dyCCorner + wC) / ${g}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zee(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,input:u}=t,f=u,{filterSize:g,strides:A,pad:v,dimRoundingMode:C}=o,S=[1,1,1],M=go(f.shape,g,A,S,v,C),_=new Pee(M);return i.runWebGLProgram(_,[l],f.dtype)}const Vee={kernelName:Wt,backendName:"webgl",kernelFunc:zee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Wee(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,input:u}=t,f=u;py([l,u],"avgPoolGrad");const{filterSize:g,strides:A,pad:v}=o,C=Oa(f.shape,g,A,1,v),S=new Uee(C);return i.runWebGLProgram(S,[l],f.dtype)}const Hee={kernelName:ke,backendName:"webgl",kernelFunc:Wee};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xee(s){const{inputs:t,backend:i,attrs:o}=s,{a:l,b:u}=t,{transposeA:f,transposeB:g}=o;return Rw({a:l,b:u,transposeA:f,transposeB:g,backend:i})}const Qee={kernelName:jt,backendName:"webgl",kernelFunc:Xee};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Kee{constructor(t,i,o,l,u,f){this.outputShape=[],this.variableNames=["x","mean","variance"],$n(t,i),$n(t,o);let g="0.0";l!=null&&($n(t,l),this.variableNames.push("offset"),g="getOffsetAtOutCoords()");let A="1.0";u!=null&&($n(t,u),this.variableNames.push("scale"),A="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${g};
        float scale = ${A};
        float inv = scale * inversesqrt(variance + float(${f}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Zee{constructor(t,i,o,l,u,f){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],$n(t,i),$n(t,o);let g="vec4(0.0)";l!=null&&($n(t,l),this.variableNames.push("offset"),g="getOffsetAtOutCoords()");let A="vec4(1.0)";u!=null&&($n(t,u),this.variableNames.push("scale"),A="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${g};
        vec4 scale = ${A};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${f}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $ee={kernelName:Fs,backendName:"webgl",kernelFunc:({inputs:s,backend:t,attrs:i})=>{const{x:o,mean:l,variance:u,offset:f,scale:g}=s;E(l.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E(f==null||l.shape.length===f.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E(g==null||l.shape.length===g.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:A}=i;A==null&&(A=.001);const v=[o,l,u];let C=null;f!=null&&(C=f.shape,v.push(f));let S=null;g!=null&&(S=g.shape,v.push(g));const M=Ee().getBool("WEBGL_PACK_NORMALIZATION")?new Zee(o.shape,l.shape,u.shape,C,S,A):new Kee(o.shape,l.shape,u.shape,C,S,A);return t.runWebGLProgram(M,v,v[0].dtype)}};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Yee{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const i=ws(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const o=jee(this.rank);let l;const u=t.map((f,g)=>`sourceLoc.${QT[g]} = start[${g}] + coords.${QT[g]};`);l=`
        ${i} sourceLoc;
        ${i} coords = getOutputCoords();
        ${u.join(`
`)}
      `,this.userCode=`
      void main() {
        ${l}
        setOutput(getSource(${o}));
      }
    `}}const QT=["x","y","z","w","u","v"];function jee(s){if(s===1)return"sourceLoc";if(s<=6)return QT.slice(0,s).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${s} is not yet supported`)}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class qee{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const i=ws(this.rank),o=ma("coords",this.rank),l=ma("sourceLoc",this.rank),u=this.rank===1?"sourceLoc":`vec2(${l.slice(-2).join()})`,f=`getChannel(getSource(${l.join()}), ${u})`,g=`
      result.x = ${f};
      if (++${o[this.rank-1]} < ${t[this.rank-1]}) {
        ++${l[this.rank-1]};
        result.y = ${f};
        --${l[this.rank-1]};
      }
    `,A=this.rank===1?"":`
      --${o[this.rank-1]};
      if (++${o[this.rank-2]} < ${t[this.rank-2]}) {
        ++${l[this.rank-2]};
        result.z = ${f};
        if (++${o[this.rank-1]} < ${t[this.rank-1]}) {
          ++${l[this.rank-1]};
          result.w = ${f};
        }
      }
    `,v=this.rank<=4?`sourceLoc = coords +
            ${i}(${t.map((C,S)=>`start[${S}]`).join()});`:t.map((C,S)=>`${l[S]} = ${o[S]} + start[${S}];`).join(`
`);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        ${i} sourceLoc;
        ${v}
        vec4 result = vec4(0.);
        ${g}
        ${A}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Jee(s,t,i,o){const l=o.texData.get(s.dataId),u=o.makeTensorInfo(i,s.dtype),f=o.texData.get(u.dataId);Object.assign(f,l),f.refCount=1,f.shape=i,f.dtype=s.dtype;let g=np(t,Ne(s.shape));l.slice&&(g+=l.slice.flatOffset),f.slice={flatOffset:g,origDataId:l.slice&&l.slice.origDataId||s.dataId};const A=o.dataRefCount.get(f.slice.origDataId)||1;return o.dataRefCount.set(f.slice.origDataId,A+1),u}function p0(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{begin:u,size:f}=o,[g,A]=ip(l,u,f);if(dg(l,g,A),N(A)===0)return i.makeTensorInfo(A,l.dtype,[]);if(i.shouldExecuteOnCPU([l])||l.dtype==="string"){const S=i.texData.get(l.dataId),M=Kq(S.values,g,A,l.shape,l.dtype);return i.makeTensorInfo(A,l.dtype,M)}const{isPacked:v}=i.texData.get(l.dataId),C=Ku(l.shape,g,A);if(v||!C){const S=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qee(A):new Yee(A),M=[g];return i.runWebGLProgram(S,[l],l.dtype,M)}return i.uploadToGPU(l.dataId),Jee(l,g,A,i)}const ete={kernelName:Vm,backendName:"webgl",kernelFunc:p0};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const tte={kernelName:tn,backendName:"webgl",kernelFunc:s=>{const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{blockShape:u,crops:f}=o;E(l.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const g=u.reduce((V,$)=>V*$),A=zb(l.shape,u,g),v=Vb(A.length,u.length),C=Wb(l.shape,u,g),S=uI(f,u.length),M=hI(C,f,u.length),_=[],B=rn({inputs:{x:l},backend:i,attrs:{shape:A}}),F=ga({inputs:{x:B},backend:i,attrs:{perm:v}}),P=rn({inputs:{x:F},backend:i,attrs:{shape:C}}),U=p0({inputs:{x:P},backend:i,attrs:{begin:S,size:M}});return _.push(B),_.push(F),_.push(P),_.forEach(V=>i.disposeIntermediateTensorInfo(V)),U}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nte(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,weights:u}=t,{size:f}=o,g=i.readSync(l.dataId),A=i.readSync(u.dataId),v=aD(g,A,u.dtype,u.shape,f);return i.makeTensorInfo([f],u.dtype,v)}const ite={kernelName:cn,backendName:"webgl",kernelFunc:nte};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ste(s){const{inputs:t,backend:i}=s,{s0:o,s1:l}=t,u=i.readSync(o.dataId),f=i.readSync(l.dataId),g=$n(Array.from(u),Array.from(f));return i.makeTensorInfo([g.length],"int32",Int32Array.from(g))}const rte={kernelName:nn,backendName:"webgl",kernelFunc:ste};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const RD=Wr({opSnippet:"return float(a != b);",cpuKernelImpl:Uq,dtype:"bool"}),ate={kernelName:_u,backendName:"webgl",kernelFunc:RD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function xy(s){const{inputs:t,backend:i}=s,{input:o}=t,l=i.texData.get(o.dataId);return wo({inputs:{x:l.complexTensorInfos.real},backend:i})}const ote={kernelName:dA,backendName:"webgl",kernelFunc:xy};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lte="return float(int(x));";function cte(s,t){const i=new ah(s.shape,lte),o=t.runWebGLProgram(i,[s],"int32");return{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KT(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{dtype:u}=o;if(u==="complex64"){if(l.dtype==="complex64")return wo({inputs:{x:l},backend:i});const f=Zs(l.shape),g=KT({inputs:{x:l},backend:i,attrs:{dtype:"float32"}}),A=Nd({inputs:{real:g,imag:f},backend:i});return f.dispose(),i.disposeIntermediateTensorInfo(g),A}if(l.dtype==="complex64"){const f=xy({inputs:{input:l},backend:i}),g=KT({inputs:{x:f},backend:i,attrs:{dtype:u}});return i.disposeIntermediateTensorInfo(f),g}if(!Re(l.dtype,u)){const f=wo({inputs:{x:l},backend:i});return{dataId:f.dataId,shape:f.shape,dtype:u}}if(i.shouldExecuteOnCPU([l])){const f=i.texData.get(l.dataId).values,[g,A,v]=yq(f,l.shape,l.dtype,u);return i.makeTensorInfo(g,A,v)}if(u==="int32")return cte(l,i);if(u==="bool"){const f=i.makeTensorInfo([],"bool",re("bool",1)),g=RD({inputs:{a:l,b:f},backend:i});return i.disposeIntermediateTensorInfo(f),g}throw new Error(`Error in Cast: failed to cast ${l.dtype} to ${u}`)}const ute={kernelName:qt,backendName:"webgl",kernelFunc:KT};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kD="return ceil(x);",hte=Di({opSnippet:kD,packedOpSnippet:kD,cpuKernelImpl:vq}),dte={kernelName:mn,backendName:"webgl",kernelFunc:hte};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fte{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class pte{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mte(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{clipValueMin:u,clipValueMax:f}=o;let g;Ee().getBool("WEBGL_PACK_CLIP")?g=new pte(l.shape):g=new fte(l.shape);const A=[[u],[f]];return i.runWebGLProgram(g,[l],l.dtype,A)}const gte={kernelName:fi,backendName:"webgl",kernelFunc:mte};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ate{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function BD(s,t){return{dataId:t.dataId,dtype:t.dtype,shape:s.shape}}function bte(s){const{inputs:t,backend:i}=s,{x:o}=t,l=i.texData.get(o.dataId),u=new Ate(o.shape),f=[BD(o,l.complexTensorInfos.real),BD(o,l.complexTensorInfos.imag)];return i.runWebGLProgram(u,f,f[0].dtype)}const yte={kernelName:Ts,backendName:"webgl",kernelFunc:bte};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class vte{constructor(t){this.outputShape=[],this.outputShape=iu(t,1),this.variableNames=t.map((f,g)=>`T${g}`);const i=new Array(t.length-1);i[0]=t[0][1];for(let f=1;f<i.length;f++)i[f]=i[f-1]+t[f][1];const o=[`if (yC < ${i[0]}) setOutput(getT0(yR, yC));`];for(let f=1;f<i.length;f++){const g=i[f-1];o.push(`else if (yC < ${i[f]}) setOutput(getT${f}(yR, yC-${g}));`)}const l=i.length,u=i[i.length-1];o.push(`else setOutput(getT${l}(yR, yC-${u}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${o.join(`
        `)}
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class xte{constructor(t,i){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=iu(t,i);const o=this.outputShape,l=o.length,u=ws(l),f=ma("coords",l),g=["x","y","z","w","u","v"].slice(0,l);this.variableNames=t.map((F,P)=>`T${P}`);const A=new Array(t.length-1);A[0]=t[0][i];for(let F=1;F<A.length;F++)A[F]=A[F-1]+t[F][i];const v=g[i],C=g.slice(-2),S=g.join();let M=`if (${v} < ${A[0]}) {
        return getChannel(
            getT0(${S}), vec2(${C.join()}));
        }`;for(let F=1;F<A.length;F++){const P=A[F-1];M+=`
        if (${v} < ${A[F]}  && ${v} >= ${A[F-1]}) {
          return getChannel(
            getT${F}(${Bw(g,v,P)}),
            vec2(${Bw(C,v,P)}));
        }`}const _=A.length,B=A[A.length-1];M+=`
        return getChannel(
          getT${_}(${Bw(g,v,B)}),
          vec2(${Bw(C,v,B)}));`,this.userCode=`
      float getValue(${g.map(F=>"int "+F)}) {
        ${M}
      }

      void main() {
        ${u} coords = getOutputCoords();
        vec4 result = vec4(getValue(${f}), 0., 0., 0.);

        ${f[l-1]} = ${f[l-1]} + 1;
        if (${f[l-1]} < ${o[l-1]}) {
          result.g = getValue(${f});
        }

        ${f[l-2]} = ${f[l-2]} + 1;
        if (${f[l-2]} < ${o[l-2]}) {
          result.a = getValue(${f});
        }

        ${f[l-1]} = ${f[l-1]} - 1;
        if (${f[l-2]} < ${o[l-2]} &&
            ${f[l-1]} < ${o[l-1]}) {
          result.b = getValue(${f});
        }
        setOutput(result);
      }
    `}}function Bw(s,t,i){const o=s.indexOf(t);return s.map((l,u)=>u===o?`${l} - ${i}`:l).join()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lw(s){const{inputs:t,backend:i}=s,{input:o}=t,l=i.texData.get(o.dataId);return wo({inputs:{x:l.complexTensorInfos.imag},backend:i})}const wte={kernelName:Xr,backendName:"webgl",kernelFunc:Lw};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wy(s,t,i){const o=s[0].dtype;if(o==="complex64"){const S=s.map(P=>xy({inputs:{input:P},backend:i})),M=s.map(P=>Lw({inputs:{input:P},backend:i})),_=wy(S,t,i),B=wy(M,t,i),F=Nd({inputs:{real:_,imag:B},backend:i});return S.forEach(P=>i.disposeIntermediateTensorInfo(P)),M.forEach(P=>i.disposeIntermediateTensorInfo(P)),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(B),F}let l=i.shouldExecuteOnCPU(s);if(o==="string"&&(l=!0),l){const S=s.map(V=>{const $=[-1,N(V.shape.slice(t))];return rn({inputs:{x:V},backend:i,attrs:{shape:$}})}),M=S.map(V=>({vals:i.readSync(V.dataId),shape:V.shape})),_=iu(S.map(V=>V.shape),1),B=S[0].shape[0]===1,F=xq(M,_,o,B),P=iu(s.map(V=>V.shape),t),U=i.makeTensorInfo(P,o,F);return S.forEach(V=>i.disposeIntermediateTensorInfo(V)),U}const u=Ee().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>u){const S=[];for(let _=0;_<s.length;_+=u){const B=s.slice(_,_+u);S.push(wy(B,t,i))}const M=wy(S,t,i);for(const _ of S)i.disposeIntermediateTensorInfo(_);return M}if(Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1){const S=new xte(s.map(M=>M.shape),t);return i.runWebGLProgram(S,s,o)}const{tensors2D:f,outShape:g}=Cte(s,t,i),A=new vte(f.map(S=>S.shape)),v=i.runWebGLProgram(A,f,o);f.forEach(S=>i.disposeIntermediateTensorInfo(S));const C=rn({inputs:{x:v},attrs:{shape:g},backend:i});return i.disposeIntermediateTensorInfo(v),C}function Cte(s,t,i){const o=iu(s.map(l=>l.shape),t);return{tensors2D:s.map(l=>rn({inputs:{x:l},attrs:{shape:[-1,N(l.shape.slice(t))]},backend:i})),outShape:o}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function LD(s){const{inputs:t,backend:i,attrs:o}=s,{axis:l}=o,u=J(l,t[0].shape)[0],f=t.map(v=>v.shape);iI(f,u);const g=iu(t.map(v=>v.shape),u);if(N(g)===0)return i.makeTensorInfo(g,t[0].dtype,[]);const A=t.filter(v=>N(v.shape)>0);return A.length===1?wo({inputs:{x:A[0]},backend:i}):wy(A,u,i)}const Ete={kernelName:ir,backendName:"webgl",kernelFunc:LD};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class ND{constructor(t,i=!1,o=null,l=!1,u=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const f=t.padInfo.top,g=t.padInfo.left,A=t.strideHeight,v=t.strideWidth,C=t.dilationHeight,S=t.dilationWidth,M=t.filterHeight,_=t.filterWidth,B=Math.floor(t.inChannels/4)*4,F=t.inChannels%4,P=t.dataFormat==="channelsLast",U=P?1:2,V=P?2:3,$=P?3:1;let q="",ne="";o&&(l?q=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:u?q=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:q=`
          float activation(float x) {
            ${o}
          }
        `,ne="result = activation(result);");const he=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${q}

      const ivec2 strides = ivec2(${A}, ${v});
      const ivec2 pads = ivec2(${f}, ${g});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${$}];

        ivec2 xRCCorner =
            ivec2(coords[${U}], coords[${V}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${M}; wR++) {
          int xR = xRCorner + wR * ${C};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC++) {
            int xC = xCCorner + wC * ${S};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${B}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${P}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${F===1}) {

              if (${P}) {
                dotProd +=
                    getX(batch, xR, xC, ${B}) *
                    getW(wR, wC, ${B}, d2);
              } else {
                dotProd +=
                    getX(batch, ${B}, xR, xC) *
                    getW(wR, wC, ${B}, d2);
              }

            } else if (${F===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${B}, d2),
                getW(wR, wC, ${B} + 1, d2)
              );

              if (${P}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${B}),
                  getX(batch, xR, xC, ${B} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${B}, xR, xC),
                  getX(batch, ${B} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${F===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${B}, d2),
                getW(wR, wC, ${B} + 1, d2),
                getW(wR, wC, ${B} + 2, d2)
              );

              if (${P}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${B}),
                  getX(batch, xR, xC, ${B} + 1),
                  getX(batch, xR, xC, ${B} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${B}, xR, xC),
                  getX(batch, ${B} + 1, xR, xC),
                  getX(batch, ${B} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${he}
        ${ne}
        setOutput(result);
      }
    `}}class Ste{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.front,o=t.padInfo.top,l=t.padInfo.left,u=t.strideDepth,f=t.strideHeight,g=t.strideWidth,A=t.dilationDepth,v=t.dilationHeight,C=t.dilationWidth,S=t.filterDepth,M=t.filterHeight,_=t.filterWidth,B=Math.floor(t.inChannels/4)*4,F=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${u}, ${f}, ${g});
      const ivec3 pads = ivec3(${i}, ${o}, ${l});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${S}; wF++) {
          int xF = xFCorner + wF * ${A};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${M}; wR++) {
            int xR = xRCorner + wR * ${v};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${_}; wC++) {
              int xC = xCCorner + wC * ${C};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${B}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${F===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${B}) *
                  getW(wF, wR, wC, ${B}, d2);
              } else if (${F===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${B}),
                  getX(batch, xF, xR, xC, ${B} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${B}, d2),
                  getW(wF, wR, wC, ${B} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${F===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${B}),
                  getX(batch, xF, xR, xC, ${B} + 1),
                  getX(batch, xF, xR, xC, ${B} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${B}, d2),
                  getW(wF, wR, wC, ${B} + 1, d2),
                  getW(wF, wR, wC, ${B} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class DD{constructor(t,i=!1,o=null,l=!1,u=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=pa(this.outputShape.length);const f=t.padInfo.left,g=t.strideWidth,A=t.dilationWidth,v=t.filterHeight,C=t.filterWidth,S=C;let M=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let P=0;P<C;P++)M+=`
           vec4 xTexelC${P*2};
           int xTexelC${P*2}Ready;
           vec4 xTexelC${P*2+1};
           int xTexelC${P*2+1}Ready;
           vec4 xC${P};`;M+=`
     for (int r = 0; r < ${v}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let P=0;P<C;P++)M+=`
           xTexelC${P*2} = vec4(0.0);
           xTexelC${P*2}Ready = 0;
           xTexelC${P*2+1} = vec4(0.0);
           xTexelC${P*2+1}Ready = 0;
           xC${P} = vec4(0.0);`;M+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let P=0;P<(S+1)/2;P++){const U=P*2;if(M+=`
           xC = xCCorner + ${U*A};
           `,g===1){if(U<C&&(f%2===1?(M+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${U}Ready == 0) {
                   xTexelC${U} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${U}.zw = vec2(0.0);
                   }
                   xTexelC${U}Ready = 1;
                 }
               `,A===1&&U>0?M+=`
                 xC${U} = vec4(xTexelC${U-2}.zw, xTexelC${U}.xy);
                 `:M+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${U} = vec4(previous.zw, xTexelC${U}.xy);
                   } else {
                     xC${U} = vec4(0.0, 0.0, xTexelC${U}.xy);
                   }
                   `):M+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${U}Ready == 0) {
                   xTexelC${U} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${U}.zw = vec2(0.0);
                   }
                   xTexelC${U}Ready = 1;
                 }

                 xC${U} = xTexelC${U};
                 `,U+1<C)){const V=f%2===0?y(A):A;A%2===0&&f%2===1||A%2!==0&&f%2!==1?(M+=`
                   xCOffset = xC + imod(pads[1], 2) + ${V};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${U+1}Ready == 0) {
                     xTexelC${U+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${U+1}.zw = vec2(0.0);
                     }
                     xTexelC${U+1}Ready = 1;
                   }
                   `,A>1?M+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${U+1} = vec4(previous.zw, xTexelC${U+1}.xy);
                     } else {
                      xC${U+1} = vec4(0.0, 0.0, xTexelC${U+1}.xy);
                     }
                     `:M+=`
                     xC${U+1} = vec4(xTexelC${U}.zw, xTexelC${U+1}.xy);
                     `):V===1?M+=`
                     xC${U+1} = xTexelC${U};
                     `:M+=`
                     xCOffset = xC + ${V};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${U+1}Ready == 0) {
                       xTexelC${U+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${U+1}.zw = vec2(0.0);
                       }
                       xTexelC${U+1}Ready = 1;
                     }

                     xC${U+1} = xTexelC${U+1};
                     `}}else U<C&&(f%2===1?(M+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${U}Ready == 0) {
                   xTexelC${U} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${U}.zw = vec2(0.0);
                   }
                   xTexelC${U}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${U+1}Ready == 0) {
                   xTexelC${U+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${U+1}.zw = vec2(0.0);
                   }
                   xTexelC${U+1}Ready = 1;
                 }

                 xC${U} = vec4(xTexelC${U}.zw, xTexelC${U+1}.zw);
               `,U+1<C&&(M+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${U+1} = vec4(xTexelC${U+1}.xy, final.xy);
                 `)):(M+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${U}Ready == 0) {
                   xTexelC${U} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${U}.zw = vec2(0.0);
                   }
                   xTexelC${U}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${U+1}Ready == 0) {
                   xTexelC${U+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${U+1}.zw = vec2(0.);
                   }
                   xTexelC${U+1}Ready = 1;
                 }

                 xC${U} = vec4(
                   xTexelC${U}.xy, xTexelC${U+1}.xy);
               `,U+1<C&&(M+=`
                   xC${U+1} = vec4(xTexelC${U}.zw, xTexelC${U+1}.zw);
                 `)));U<C&&(M+=`
             wTexel = getW(r, ${U}, d1, d2);
             dotProd += xC${U}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${U}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,U+1<C&&(M+=`
               wTexel = getW(r, ${U+1}, d1, d2);
               dotProd += xC${U+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${U+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}M+=`
     }
   `,M+=`
     }
   `,M+=`
     }
   `;let _="",B="";o&&(l?_=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${o}
         }`:u?_=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${o}
         }`:_=`vec4 activation(vec4 x) {
           ${o}
         }`,B="result = activation(result);");const F=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${_}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${M}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${F}
         ${B}
         setOutput(result);
       }
     `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ite{constructor(t,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=pa(this.outputShape.length);const{dataFormat:o}=i,l=fa(),u=o==="channelsLast",f=u?1:2,g=u?2:3,A=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let v="";for(let C=0;C<=1;C++)for(let S=0;S<=1;S++)v+=`
          blockIndex = rc.z + ${S};
          pos = rc.y + ${C};

          ${A}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${f}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${g}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${u}) {
                  innerDims = vec2(d1, ch);
                  result[${C*2+S}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${C*2+S}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${v}

        ${l.output} = result;
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Nw(s,t){const i=s.length;return i>=3?t?[...s.slice(0,-3),s[i-3]*s[i-2],s[i-1]]:[...s.slice(0,-3),s[i-3],s[i-2]*s[i-1]]:!t&&i===1&&s[0]>1?[s[0],1]:null}function FD({x:s,filter:t,convInfo:i,backend:o,bias:l=null,preluActivationWeights:u=null,leakyreluAlpha:f=0,activation:g=null}){const A=s.shape,v=o.texData.get(s.dataId),C=i.inChannels,S=A[0]*A[1]*A[2],M=i.outChannels,_=i.dataFormat==="channelsLast",B=!1,F=!1;let P;const U=[];if(u!=null){const V=Nw(u.shape,_);V!=null&&(u=rn({inputs:{x:u},backend:o,attrs:{shape:V}}),U.push(u))}if(l!=null){const V=Nw(l.shape,_);V!=null&&(l=rn({inputs:{x:l},backend:o,attrs:{shape:V}}),U.push(l))}if(!((S===1||M===1)&&C>ED)&&v.isPacked&&_&&v.texture!=null&&A[2]%2!==0&&O(v.shape.slice(-3),A.slice(-3))){const V=A[0]*A[1]*(A[2]+1),$={dataId:s.dataId,shape:[1,V,i.inChannels],dtype:s.dtype},q=v.shape;v.shape=v.shape.slice(),v.shape[v.shape.length-2]++,E(Ew(v.shape,$.shape),()=>`packed reshape ${v.shape} to ${$.shape} isn't free`);const ne=rn({inputs:{x:t},backend:o,attrs:{shape:[1,i.inChannels,i.outChannels]}});U.push(ne);const he=Rw({a:$,b:ne,backend:o,transposeA:B,transposeB:F,bias:l,activation:g,preluActivationWeights:u,leakyreluAlpha:f}),me=o.texData.get(he.dataId);E(me.isPacked,()=>"batchMatMul result is expected to be packed"),v.shape=q,me.shape=i.outShape,P=wo({inputs:{x:he},backend:o}),P.shape=i.outShape,U.push(he)}else{const V=i.outHeight*i.outWidth,$=rn({inputs:{x:s},backend:o,attrs:{shape:_?[i.batchSize,V,i.inChannels]:[i.batchSize,i.inChannels,V]}}),q=rn({inputs:{x:t},backend:o,attrs:{shape:[1,i.inChannels,i.outChannels]}}),ne=Rw({a:_?$:q,b:_?q:$,transposeA:!_,transposeB:F,backend:o,bias:l,activation:g,preluActivationWeights:u,leakyreluAlpha:f});P=rn({inputs:{x:ne},backend:o,attrs:{shape:i.outShape}}),U.push($),U.push(q),U.push(ne)}for(const V of U)o.disposeIntermediateTensorInfo(V);return P}function OD({x:s,filter:t,convInfo:i,backend:o,bias:l=null,preluActivationWeights:u=null,leakyreluAlpha:f=0,activation:g=null}){const{filterWidth:A,filterHeight:v,inChannels:C,outWidth:S,outHeight:M,dataFormat:_}=i,B=_==="channelsLast",F=A*v*C,P=M*S,U=[i.batchSize,F,P],V=!0,$=!1,q=[];if(u!=null){const yt=Nw(u.shape,B);yt!=null&&(u=rn({inputs:{x:u},backend:o,attrs:{shape:yt}}),q.push(u))}if(l!=null){const yt=Nw(l.shape,B);yt!=null&&(l=rn({inputs:{x:l},backend:o,attrs:{shape:yt}}),q.push(l))}const ne=rn({inputs:{x:t},backend:o,attrs:{shape:[1,F,N(t.shape)/F]}});q.push(ne);const he=new Ite(U,i),me=[s.shape,[i.padInfo.top,i.padInfo.left],[i.strideHeight,i.strideWidth],[i.dilationHeight,i.dilationWidth],[i.inChannels],[i.filterWidth*i.inChannels],[i.outWidth]],pe=o.runWebGLProgram(he,[s],"float32",me),ye=rn({inputs:{x:pe},backend:o,attrs:{shape:U}});q.push(pe),q.push(ye);const Te=l!=null,Ye=u!=null,et=g==="leakyrelu",nt=g?yy(g,!0):null,ht=new yD(B?ye.shape:ne.shape,B?ne.shape:ye.shape,B?[i.batchSize,P,i.outChannels]:[i.batchSize,i.outChannels,P],V,$,Te,nt,Ye,et),ct=B?[ye,ne]:[ne,ye];if(l&&ct.push(l),Ye&&ct.push(u),et){const yt=o.makeTensorInfo([],"float32",Do(f,"float32"));ct.push(yt),q.push(yt)}const pt=o.runWebGLProgram(ht,ct,"float32"),Et=rn({inputs:{x:pt},backend:o,attrs:{shape:i.outShape}});q.push(pt);for(const yt of q)o.disposeIntermediateTensorInfo(yt);return Et}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Tte(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u}=t,{strides:f,pad:g,dataFormat:A,dilations:v,dimRoundingMode:C}=o,S=pl(A),M=qs(l.shape,u.shape,f,v,g,C,!1,S);let _;if(M.filterHeight===1&&M.filterWidth===1&&M.dilationHeight===1&&M.dilationWidth===1&&M.strideHeight===1&&M.strideWidth===1&&(M.padInfo.type==="SAME"||M.padInfo.type==="VALID"))_=FD({x:l,filter:u,convInfo:M,backend:i});else if(M.strideWidth<=2&&S==="channelsLast"&&Ee().getBool("WEBGL_EXP_CONV")){const F=new DD(M),P=[[M.padInfo.top,M.padInfo.left],[M.strideHeight,M.strideWidth],[M.dilationHeight,M.dilationWidth],[M.inHeight,M.inWidth]];_=i.runWebGLProgram(F,[l,u],"float32",P)}else if(Ee().getBool("WEBGL_CONV_IM2COL"))_=OD({x:l,filter:u,convInfo:M,backend:i});else{const F=new ND(M);_=i.runWebGLProgram(F,[l,u],"float32")}const B=rn({inputs:{x:_},backend:i,attrs:{shape:M.outShape}});return i.disposeIntermediateTensorInfo(_),B}const Mte={kernelName:ro,backendName:"webgl",kernelFunc:Tte};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class _te{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const i=t.strideHeight,o=t.strideWidth,l=t.padInfo.top,u=t.padInfo.left,f=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${i} - ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${o} - ${u};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${f}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Rte{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const i=t.filterHeight,o=t.filterWidth,l=t.strideHeight,u=t.strideWidth,f=t.dataFormat==="channelsLast",g=i-1-t.padInfo.top,A=o-1-t.padInfo.left,v=f?1:2,C=f?2:3,S=f?3:1;this.userCode=`
      const ivec2 pads = ivec2(${g}, ${A});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${S}];

        ivec2 dyCorner = ivec2(coords[${v}], coords[${C}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i}; wR++) {
          float dyR = float(dyRCorner + wR) / ${l}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${i} - 1 - wR;

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${u}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${o} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${f}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class kte{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const i=t.strideDepth,o=t.strideHeight,l=t.strideWidth,u=t.padInfo.front,f=t.padInfo.top,g=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${i} - ${u};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${o} - ${f};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${l} - ${g};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Bte{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const i=t.filterDepth,o=t.filterHeight,l=t.filterWidth,u=t.strideDepth,f=t.strideHeight,g=t.strideWidth,A=i-1-t.padInfo.front,v=o-1-t.padInfo.top,C=l-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${A}, ${v}, ${C});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${i}; wF++) {
          float dyF = float(dyFCorner + wF) / ${u}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${i} - 1 - wF;

          for (int wR = 0; wR < ${o}; wR++) {
            float dyR = float(dyRCorner + wR) / ${f}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${o} - 1 - wR;

            for (int wC = 0; wC < ${l}; wC++) {
              float dyC = float(dyCCorner + wC) / ${g}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${l} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Lte(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,dy:u}=t,{strides:f,pad:g,dataFormat:A,dimRoundingMode:v,filterShape:C}=o,S=pl(A),M=qs(l.shape,C,f,1,g,v,!1,S),_=new _te(M);return i.runWebGLProgram(_,[l,u],"float32")}const Nte={kernelName:xc,backendName:"webgl",kernelFunc:Lte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dte(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,filter:u}=t,{inputShape:f,strides:g,pad:A,dataFormat:v,dimRoundingMode:C}=o,S=pl(v),M=qs(f,u.shape,g,1,A,C,!1,S),_=new Rte(M);return i.runWebGLProgram(_,[l,u],"float32")}const Fte={kernelName:ao,backendName:"webgl",kernelFunc:Dte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ote(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u}=t,{strides:f,pad:g,dilations:A}=o,v=Wl(l.shape,u.shape,f,A,g),C=new Ste(v);return i.runWebGLProgram(C,[l,u],"float32")}const Gte={kernelName:wc,backendName:"webgl",kernelFunc:Ote};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ute(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,dy:u}=t,{strides:f,pad:g,filterShape:A}=o,v=Wl(l.shape,A,f,1,g),C=new kte(v);return i.runWebGLProgram(C,[l,u],"float32")}const Pte={kernelName:Cc,backendName:"webgl",kernelFunc:Ute};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zte(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,filter:u}=t,{pad:f,strides:g,inputShape:A}=o,v=Wl(A,u.shape,g,1,f),C=new Bte(v);return i.runWebGLProgram(C,[l,u],"float32")}const Vte={kernelName:nl,backendName:"webgl",kernelFunc:zte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Wte=f0+`
  return cos(x);
`,Hte=Di({opSnippet:Wte}),Xte={kernelName:oo,backendName:"webgl",kernelFunc:Hte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Qte=Di({opSnippet:`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`}),Kte={kernelName:Ea,backendName:"webgl",kernelFunc:Qte};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Zte{constructor(t,i,o,l,u){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[f,g,A,v]=t,[C]=i,[S,M]=o;this.outputShape=[C,S,M,v];const _=l==="bilinear"?1:0,[B,F]=[`${g-1}.0`,`${A-1}.0`],[P,U,V]=S>1?[`${(g-1)/(S-1)}`,"(y2-y1) * height_ratio",`y1*${B} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${B}`],[$,q,ne]=M>1?[`${(A-1)/(M-1)}`,"(x2-x1) * width_ratio",`x1*${F} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${F}`];this.userCode=`
      const float height_ratio = float(${P});
      const float width_ratio = float(${$});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${f}) {
          return;
        }

        float height_scale = ${U};
        float width_scale = ${q};

        float in_y = ${V};
        if( in_y < 0.0 || in_y > ${B} ) {
          setOutput(float(${u}));
          return;
        }
        float in_x = ${ne};
        if( in_x < 0.0 || in_x > ${F} ) {
          setOutput(float(${u}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${_} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const $te={kernelName:Bo,backendName:"webgl",kernelFunc:s=>{const{inputs:t,backend:i,attrs:o}=s,{image:l,boxes:u,boxInd:f}=t,{cropSize:g,method:A,extrapolationValue:v}=o,C=new Zte(l.shape,u.shape,g,A,v);return i.runWebGLProgram(C,[l,u,f],"float32")}};var Cy;(function(s){s.Prod="*",s.Sum="+"})(Cy||(Cy={}));class GD{constructor(t,i,o,l){this.op=t,this.outputShape=i,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const u=this.outputShape.length,f=this.op===Cy.Prod?"1.0":"0.0",g=o?f:`getX(${UD(u,"coords",this.op)})`,A=this.outputShape[this.outputShape.length-1];let v="",C="";o?(v=l?`end != ${A-1}`:"end != 0",C=l?"end + 1":"end - 1"):(v=l?`end + pow2 < ${A}`:"end >= pow2",C=l?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ws(u)} coords = getOutputCoords();
        int end = ${PD(u,"coords",this.op)};
        float val = ${g};
        int pow2 = int(pow(2.0, index));
        if (${v}) {
          int idx = ${C};
          ${PD(u,"coords",this.op)} = idx;
          val ${this.op}= getX(${UD(u,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function UD(s,t,i){if(s===1)return`${t}`;if(s===2)return`${t}.x, ${t}.y`;if(s===3)return`${t}.x, ${t}.y, ${t}.z`;if(s===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${i} for rank ${s} is not yet supported`)}function PD(s,t,i){if(s===1)return`${t}`;if(s===2)return`${t}.y`;if(s===3)return`${t}.z`;if(s===4)return`${t}.w`;throw new Error(`Cumulative ${i} for rank ${s} is not yet supported`)}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zD(s,t,i,o,l,u){const f=t.shape.length,g=ji([o],f);let A=t;g!=null&&(A=ga({inputs:{x:t},backend:i,attrs:{perm:g}}));const v=Ss(1,f)[0];if(v!==f-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${o}`);const C=A.shape[v];let S=wo({inputs:{x:A},backend:i});for(let M=0;M<=Math.ceil(Math.log2(C))-1;M++){const _=new GD(s,A.shape,!1,u),B=[[M]],F=S;S=i.runWebGLProgram(_,[S],S.dtype,B),i.disposeIntermediateTensorInfo(F)}if(l){const M=new GD(s,A.shape,l,u),_=S;S=i.runWebGLProgram(M,[S],S.dtype),i.disposeIntermediateTensorInfo(_)}if(g!=null){const M=gl(g),_=ga({inputs:{x:S},backend:i,attrs:{perm:M}});return i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(A),_}return S}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Yte(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,exclusive:f,reverse:g}=o;return zD(Cy.Prod,l,i,u,f,g)}const jte={kernelName:Sa,backendName:"webgl",kernelFunc:Yte};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qte(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,exclusive:f,reverse:g}=o;return zD(Cy.Sum,l,i,u,f,g)}const Jte={kernelName:ko,backendName:"webgl",kernelFunc:qte};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ene(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,weights:u}=t,{size:f,binaryOutput:g}=o;if(l.shape.length===1){const A=i.readSync(l.dataId),v=i.readSync(u.dataId),C=aD(A,v,u.dtype,u.shape,f);return i.makeTensorInfo([f],u.dtype,C)}else if(l.shape.length===2){const A=i.bufferSync(l),v=i.bufferSync(u),C=bq(A,v,f,g);return i.makeTensorInfo(C.shape,u.dtype,C.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${l.shape.length}.`)}const tne={kernelName:Vs,backendName:"webgl",kernelFunc:ene};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class nne{constructor(t,i,o){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=i,this.dataFormat=o,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${i};
      int offset_h = imod(h, ${i});
      int in_w = w / ${i};
      int offset_w = imod(w, ${i});
      int offset_d = (offset_h * ${i} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ine(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{blockSize:u,dataFormat:f}=o,g=l.shape[0],A=f==="NHWC"?l.shape[1]:l.shape[2],v=f==="NHWC"?l.shape[2]:l.shape[3],C=f==="NHWC"?l.shape[3]:l.shape[1],S=A*u,M=v*u,_=C/(u*u),B=f==="NHWC"?[g,S,M,_]:[g,_,S,M],F=new nne(B,u,f);return i.runWebGLProgram(F,[l],l.dtype)}const sne={kernelName:Bh,backendName:"webgl",kernelFunc:ine};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class VD{constructor(t,i=!1,o=null,l=!1,u=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=pa(this.outputShape.length);const f=t.filterHeight,g=t.filterWidth,A=t.outChannels/t.inChannels;let v="",C="";o&&(l?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:u?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:v=`
          float activation(float x) {
            ${o}
          }
        `,C="result = activation(result);");const S=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${A};
        int q = d2 - d1 * ${A};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${S}
        ${C}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class WD{constructor(t,i=!1,o=null,l=!1,u=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=pa(this.outputShape.length);const f=t.outChannels/t.inChannels,g=t.padInfo.left,A=t.strideWidth,v=t.dilationWidth,C=t.filterHeight,S=t.filterWidth,M=S;let _=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let U=0;U<S;U++)_+=`
          vec4 xTexelC${U*2};
          int xTexelC${U*2}Ready;
          vec4 xTexelC${U*2+1};
          int xTexelC${U*2+1}Ready;
          vec4 xC${U};`;_+=`
    for (int r = 0; r < ${C}; r++) {
      `;for(let U=0;U<S;U++)_+=`
          xTexelC${U*2} = vec4(0.0);
          xTexelC${U*2}Ready = 0;
          xTexelC${U*2+1} = vec4(0.0);
          xTexelC${U*2+1}Ready = 0;
          xC${U} = vec4(0.0);`;_+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let U=0;U<(M+1)/2;U++){const V=U*2;if(_+=`
          xC = xCCorner + ${V*v};
          `,A===1){if(V<S&&(g%2===1?(_+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${V}Ready == 0) {
                  xTexelC${V} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${V}.zw = vec2(0.0);
                  }
                  xTexelC${V}Ready = 1;
                }
              `,v===1&&V>0?_+=`
                xC${V} = vec4(xTexelC${V-2}.zw, xTexelC${V}.xy);
                `:_+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${V} = vec4(previous.zw, xTexelC${V}.xy);
                  } else {
                    xC${V} = vec4(0.0, 0.0, xTexelC${V}.xy);
                  }
                  `):_+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${V}Ready == 0) {
                  xTexelC${V} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${V}.zw = vec2(0.0);
                  }
                  xTexelC${V}Ready = 1;
                }

                xC${V} = xTexelC${V};
                `,V+1<S)){const $=g%2===0?y(v):v;v%2===0&&g%2===1||v%2!==0&&g%2!==1?(_+=`
                  xCOffset = xC + imod(pads[1], 2) + ${$};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${V+1}Ready == 0) {
                    xTexelC${V+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${V+1}.zw = vec2(0.0);
                    }
                    xTexelC${V+1}Ready = 1;
                  }
                  `,v>1?_+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${V+1} = vec4(previous.zw, xTexelC${V+1}.xy);
                    } else {
                     xC${V+1} = vec4(0.0, 0.0, xTexelC${V+1}.xy);
                    }
                    `:_+=`
                    xC${V+1} = vec4(xTexelC${V}.zw, xTexelC${V+1}.xy);
                    `):$===1?_+=`
                    xC${V+1} = xTexelC${V};
                    `:_+=`
                    xCOffset = xC + ${$};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${V+1}Ready == 0) {
                      xTexelC${V+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${V+1}.zw = vec2(0.0);
                      }
                      xTexelC${V+1}Ready = 1;
                    }

                    xC${V+1} = xTexelC${V+1};
                    `}}else V<S&&(g%2===1?(_+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${V}Ready == 0) {
                  xTexelC${V} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${V}.zw = vec2(0.0);
                  }
                  xTexelC${V}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${V+1}Ready == 0) {
                  xTexelC${V+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${V+1}.zw = vec2(0.0);
                  }
                  xTexelC${V+1}Ready = 1;
                }

                xC${V} = vec4(xTexelC${V}.zw, xTexelC${V+1}.zw);
              `,V+1<S&&(_+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${V+1} = vec4(xTexelC${V+1}.xy, final.xy);
                `)):(_+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${V}Ready == 0) {
                  xTexelC${V} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${V}.zw = vec2(0.0);
                  }
                  xTexelC${V}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${V+1}Ready == 0) {
                  xTexelC${V+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${V+1}.zw = vec2(0.);
                  }
                  xTexelC${V+1}Ready = 1;
                }

                xC${V} = vec4(
                  xTexelC${V}.xy, xTexelC${V+1}.xy);
              `,V+1<S&&(_+=`
                  xC${V+1} = vec4(xTexelC${V}.zw, xTexelC${V+1}.zw);
                `)));V<S&&(_+=`
            wTexel = getW(r, ${V}, d1, q);
            dotProd += xC${V} * vec4(wTexel.xz, wTexel.xz);
          `,V+1<S&&(_+=`
              wTexel = getW(r, ${V+1}, d1, q);
              dotProd += xC${V+1} * vec4(wTexel.xz, wTexel.xz);
            `))}_+=`
    }
  `,_+=`
      }
    `;let B="",F="";o&&(l?B=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:u?B=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:B=`vec4 activation(vec4 x) {
          ${o}
        }`,F="result = activation(result);");const P=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${B}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${f};
        int q = d2 - d1 * ${f};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${_}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${P}
        ${F}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rne(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u}=t,{strides:f,pad:g,dilations:A,dimRoundingMode:v}=o;let C=A;C==null&&(C=[1,1]),E(or(f,C),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${f} and dilations '${C}'`);const S=qs(l.shape,u.shape,f,C,g,v,!0);let M;Ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&S.strideWidth<=2&&S.outChannels/S.inChannels===1?M=new WD(S):M=new VD(S);const _=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]];return i.runWebGLProgram(M,[l,u],"float32",_)}const ane={kernelName:Cu,backendName:"webgl",kernelFunc:rne};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class one{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const i=t.strideHeight,o=t.strideWidth,l=t.padInfo.top,u=t.padInfo.left,f=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${f} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${i} - ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${o} - ${u};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class lne{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const i=t.filterHeight,o=t.filterWidth,l=t.strideHeight,u=t.strideWidth,f=i-1-t.padInfo.top,g=o-1-t.padInfo.left,A=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${f}, ${g});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${i}; wR++) {
          float dyR = float(dyRCorner + wR) / ${l}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${i} - 1 - wR;

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${u}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${o} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${A}; dm++) {
              int d2 = d1 * ${A} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cne(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,dy:u}=t,{strides:f,dilations:g,pad:A,dimRoundingMode:v,filterShape:C}=o,S=qs(l.shape,C,f,g,A,v,!0),M=new one(S);return i.runWebGLProgram(M,[l,u],"float32")}const une={kernelName:Lo,backendName:"webgl",kernelFunc:cne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hne(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,filter:u}=t,{strides:f,dilations:g,pad:A,dimRoundingMode:v,inputShape:C}=o,S=qs(C,u.shape,f,g,A,v,!0),M=new lne(S);return i.runWebGLProgram(M,[l,u],"float32")}const dne={kernelName:il,backendName:"webgl",kernelFunc:hne};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fne{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function pne(s){const{inputs:t,backend:i}=s,{x:o}=t,l=[...o.shape,...o.shape],u=N(o.shape),f=rn({inputs:{x:o},backend:i,attrs:{shape:[u]}}),g=new fne(u),A=i.runWebGLProgram(g,[f],f.dtype),v=rn({inputs:{x:A},backend:i,attrs:{shape:l}});return i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(A),v}const mne={kernelName:Lm,backendName:"webgl",kernelFunc:pne};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class gne{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:i,inWidth:o,padInfo:l,strideHeight:u,strideWidth:f,filterHeight:g,filterWidth:A,dilationHeight:v,dilationWidth:C}=t,{top:S,left:M}=l;this.userCode=`
      const ivec2 strides = ivec2(${u}, ${f});
      const ivec2 pads = ivec2(${S}, ${M});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${g}; h++) {
          int hIn = hBeg + h * ${v};

          if (hIn >= 0 && hIn < ${i}) {
            for (int w = 0; w < ${A}; w++) {
              int wIn = wBeg + w * ${C};

              if (wIn >= 0 && wIn < ${o}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ane(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u}=t,{strides:f,pad:g,dilations:A}=o,v=nd(l.shape,u.shape,f,g,"NHWC",A);let C;const S=new gne(v);C=i.runWebGLProgram(S,[l,u],"float32");const M=rn({inputs:{x:C},backend:i,attrs:{shape:v.outShape}});return i.disposeIntermediateTensorInfo(C),M}const bne={kernelName:ce,backendName:"webgl",kernelFunc:Ane};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function yne(s){const{inputs:t,backend:i,attrs:o}=s,{equation:l}=o,u=t,{allDims:f,summedDims:g,idDims:A}=vI(l,u.length);wI(f.length,A,u);const{path:v,steps:C}=CI(g,A),S=C.length;let M=null,_=f.length;const B=[];for(let F=0;F<S;++F){for(const P of C[F]){const{permutationIndices:U,expandDims:V}=xI(_,A[P]);let $;EI(U)?$=u[P]:($=ga({inputs:{x:u[P]},backend:i,attrs:{perm:U}}),B.push($));const q=$.shape.slice();for(let ne=0;ne<V.length;++ne)q.splice(V[ne],0,1);O($.shape,q)||($=rn({inputs:{x:$},backend:i,attrs:{shape:q}}),B.push($)),M===null?M=$:(M=HT({inputs:{a:$,b:M},backend:i}),B.push(M))}F<S-1&&(v[F]>=0&&(M=_w({inputs:{x:M},backend:i,attrs:{axis:v[F]-(f.length-_),keepDims:!1}}),B.push(M)),_--)}for(const F of B)F!==M&&i.disposeIntermediateTensorInfo(F);return M}const vne={kernelName:Xe,backendName:"webgl",kernelFunc:yne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xne=Di({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),wne={kernelName:Nt,backendName:"webgl",kernelFunc:xne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Cne="return (b >= 1.0) ? a : a * (b + 1.0);",Ene=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Sne={kernelName:sn,backendName:"webgl",kernelFunc:s=>{const{inputs:t,backend:i}=s,{dy:o,y:l}=t,u=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new by(Ene,o.shape,l.shape):new d0(Cne,o.shape,l.shape);return i.runWebGLProgram(u,[o,l],o.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ine=Wr({opSnippet:"return float(a == b);",packedOpSnippet:`
  return vec4(equal(a, b));
`,dtype:"bool",cpuKernelImpl:wq}),Tne={kernelName:ln,backendName:"webgl",kernelFunc:Ine};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Mne=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${dI};
  float a1 = ${fI};
  float a2 = ${pI};
  float a3 = ${mI};
  float a4 = ${gI};
  float a5 = ${AI};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,_ne=Di({opSnippet:Mne}),Rne={kernelName:un,backendName:"webgl",kernelFunc:_ne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const kne=f0+`
  return exp(x);
`,HD=Di({opSnippet:kne,packedOpSnippet:`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:Cq,dtype:"float32"}),Bne={kernelName:Dn,backendName:"webgl",kernelFunc:HD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ZT(s){const{inputs:t,attrs:i,backend:o}=s,{dim:l}=i,{input:u}=t,f=u.shape.length,g=u.shape.slice();let A=l;return l<0&&(E(-(f+1)<=l,()=>`Axis must be in the interval [${-(f+1)}, ${f}]`),A=f+l+1),g.splice(A,0,1),rn({inputs:{x:u},backend:o,attrs:{shape:g}})}const Lne={kernelName:Un,backendName:"webgl",kernelFunc:ZT};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const XD="return exp(x) - 1.0;",Nne=Di({opSnippet:XD,packedOpSnippet:XD,cpuKernelImpl:Eq}),Dne={kernelName:Mn,backendName:"webgl",kernelFunc:Nne};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class QD{constructor(t,i,o){this.variableNames=["real","imag"];const l=i[1];this.outputShape=i;const u=o?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,f=o?`${l}.0`:"1.0";let g;if(t==="real")g="return real * expR - imag * expI;";else if(t==="imag")g="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${u};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${g}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${l});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${l}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${f};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function KD(s,t,i){const o=i.texData.get(s.dataId),l=N(s.shape),u=s.shape[s.shape.length-1],f=l/u,g=rn({inputs:{x:s},backend:i,attrs:{shape:[f,u]}}),A=g.shape,v=new QD("real",A,t),C=new QD("imag",A,t),S=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:A},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:A}],M=i.runWebGLProgram(v,S,"float32"),_=i.runWebGLProgram(C,S,"float32"),B=Nd({inputs:{real:M,imag:_},backend:i});i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(_);const F=rn({inputs:{x:B},backend:i,attrs:{shape:s.shape}});return i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(B),F}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Fne(s){const{inputs:t,backend:i}=s,{input:o}=t;return KD(o,!1,i)}const One={kernelName:Ai,backendName:"webgl",kernelFunc:Fne};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Gne{constructor(t,i){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ey(s){const{backend:t,attrs:i}=s,{shape:o,value:l}=i;let{dtype:u}=i;if(u=u||Je(l),u==="string"){const f=Y(u,N(o));return f.fill(l),t.makeTensorInfo(o,u,f)}else{const f=new Gne(o,l),g=[[l]];return t.runWebGLProgram(f,[],u,g)}}const Une={kernelName:Yn,backendName:"webgl",kernelFunc:Ey};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Pne{constructor(t){this.variableNames=["Image"],this.outputShape=[];const i=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${i} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${i}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const zne={kernelName:ys,backendName:"webgl",kernelFunc:({inputs:s,backend:t})=>{const{image:i}=s,o=t,l=new Pne(i.shape);return o.runWebGLProgram(l,[i],i.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ZD="return floor(x);",Vne=Di({opSnippet:ZD,packedOpSnippet:ZD,cpuKernelImpl:Sq}),Wne={kernelName:ss,backendName:"webgl",kernelFunc:Vne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Hne=Wr({opSnippet:`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,packedOpSnippet:`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,dtype:"int32"}),Xne={kernelName:ei,backendName:"webgl",kernelFunc:Hne};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Qne{constructor(t){this.variableNames=["A"];const i=fa(),[o,l]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}.0, ${o}.0);

        vec4 values = ${i.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Kne{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const i=fa(),[o,l]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${l}.0, ${o}.0);
            vec4 values = ${i.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${i.output} = result;
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Zne={kernelName:xA,backendName:"webgl",kernelFunc:$ne};let m0,$T=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function $ne(s){const{inputs:t,backend:i,attrs:o}=s;let{pixels:l}=t;const{numChannels:u}=o,f=typeof HTMLVideoElement<"u"&&l instanceof HTMLVideoElement,g=typeof HTMLImageElement<"u"&&l instanceof HTMLImageElement,[A,v]=f?[l.videoWidth,l.videoHeight]:[l.width,l.height],C=[v,A],S=[v,A,u];if(g||f){const F=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(m0==null||F!==$T)&&($T=F,m0=document.createElement("canvas").getContext("2d",{willReadFrequently:$T})),m0.canvas.width=A,m0.canvas.height=v,m0.drawImage(l,0,0,A,v),l=m0.canvas}const M=i.makeTensorInfo(C,"int32");i.texData.get(M.dataId).usage=Ko.PIXELS,i.gpgpu.uploadPixelDataToTexture(i.getTexture(M.dataId),l);const _=Ee().getBool("WEBGL_PACK")?new Kne(S):new Qne(S),B=i.runWebGLProgram(_,[M],"int32");return i.disposeData(M.dataId),B}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Yne(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u,bias:f,preluActivationWeights:g}=t,{strides:A,pad:v,dataFormat:C,dilations:S,dimRoundingMode:M,activation:_,leakyreluAlpha:B}=o,F=pl(C),P=qs(l.shape,u.shape,A,S,v,M,!1,F);let U;const V=[],$=f!=null,q=g!=null,ne=_==="leakyrelu",he=()=>{const pe=[l,u],ye=(Te,Ye)=>{if(Ye==="NCHW"&&Te.shape.length===1&&Te.shape[0]!==1){const et=rn({inputs:{x:Te},backend:i,attrs:{shape:[Te.shape[0],1,1]}});return V.push(et),et}return Te};if($&&pe.push(ye(f,C)),q&&pe.push(ye(g,C)),ne){const Te=i.makeTensorInfo([],"float32",Do(B,"float32"));pe.push(Te),V.push(Te)}return pe};if(P.filterHeight===1&&P.filterWidth===1&&P.dilationHeight===1&&P.dilationWidth===1&&P.strideHeight===1&&P.strideWidth===1&&(P.padInfo.type==="SAME"||P.padInfo.type==="VALID"))U=FD({x:l,filter:u,convInfo:P,backend:i,bias:f,activation:_,preluActivationWeights:g,leakyreluAlpha:B});else if(P.strideWidth<=2&&F==="channelsLast"&&Ee().getBool("WEBGL_EXP_CONV")){const pe=_?yy(_,!0):null,ye=new DD(P,$,pe,q,ne),Te=[[P.padInfo.top,P.padInfo.left],[P.strideHeight,P.strideWidth],[P.dilationHeight,P.dilationWidth],[P.inHeight,P.inWidth]],Ye=he();U=i.runWebGLProgram(ye,Ye,"float32",Te)}else if(Ee().getBool("WEBGL_CONV_IM2COL"))U=OD({x:l,filter:u,convInfo:P,backend:i,bias:f,activation:_,preluActivationWeights:g,leakyreluAlpha:B});else{const pe=_?yy(_,!1):null,ye=new ND(P,$,pe,q,ne),Te=he();U=i.runWebGLProgram(ye,Te,"float32")}const me=rn({inputs:{x:U},backend:i,attrs:{shape:P.outShape}});return V.push(U),V.forEach(pe=>i.disposeIntermediateTensorInfo(pe)),me}const jne={kernelName:Rc,backendName:"webgl",kernelFunc:Yne};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qne(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,filter:u,bias:f,preluActivationWeights:g}=t,{strides:A,pad:v,dilations:C,dimRoundingMode:S,activation:M,leakyreluAlpha:_}=o,B=[];let F=C;F==null&&(F=[1,1]),E(or(A,F),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${A} and dilations '${F}'`);const P=qs(l.shape,u.shape,A,F,v,S,!0),U=Ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&P.strideWidth<=2&&P.outChannels/P.inChannels===1,V=M?yy(M,U):null,$=[l,u],q=f!=null,ne=g!=null,he=M==="leakyrelu";if(q&&$.push(f),ne&&$.push(g),he){const Te=i.makeTensorInfo([],"float32",Do(_,"float32"));$.push(Te),B.push(Te)}let me;U?me=new WD(P,q,V,ne,he):me=new VD(P,q,V,ne,he);const pe=[[P.padInfo.top,P.padInfo.left],[P.strideHeight,P.strideWidth],[P.dilationHeight,P.dilationWidth],[P.inHeight,P.inWidth]],ye=i.runWebGLProgram(me,$,"float32",pe);return B.forEach(Te=>i.disposeIntermediateTensorInfo(Te)),ye}const Jne={kernelName:CA,backendName:"webgl",kernelFunc:qne};class eie{constructor(t,i,o,l){this.sliceDim=t,this.strides=i,this.paramsShape=l,this.variableNames=["x","indices"],this.outputShape=o;const u=ws(o.length);let f=`
    int index;`;for(let g=0;g<this.sliceDim;g++)f+=`
          index = round(getIndices(coords[0], ${g}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[g]};
          flattenIndex += index * ${this.strides[g]};`;this.userCode=`
         void main() {
          ${u} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${f}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tie(s){const{inputs:t,backend:i}=s,{params:o,indices:l}=t,u=l.shape,f=u[u.length-1],g=N(o.shape),[A,v,C,S]=qf(o,l),M=rn({inputs:{x:l},backend:i,attrs:{shape:[v,f]}}),_=rn({inputs:{x:o},backend:i,attrs:{shape:[N(o.shape)/C,C]}});if(i.shouldExecuteOnCPU([o,l])||o.dtype==="string"){const U=i.readSync(l.dataId),V=i.bufferSync(o),$=Iq(U,V,o.dtype,v,f,C,S,o.shape,g);return i.makeTensorInfo(A,o.dtype,$.values)}const B=new eie(f,S,[v,C],o.shape),F=i.runWebGLProgram(B,[_,M],_.dtype),P=rn({inputs:{x:F},backend:i,attrs:{shape:A}});return i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(F),P}const nie={kernelName:Ec,backendName:"webgl",kernelFunc:tie};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class iie{constructor(t,i){this.variableNames=["A","indices"],this.outputShape=i,this.rank=i.length;const o=ws(this.rank),l=sie(t);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${l}));
      }
    `}}function sie(s,t){const i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[];for(let l=0;l<s.length;l++)l===2?o.push("index"):o.push(`${i[l]}`);return o.join()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $D(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,indices:u}=t,{axis:f,batchDims:g}=o,A=J(f,l.shape)[0];if(Ee().get("DEBUG")){const V=i.readSync(u.dataId),$=l.shape[A];for(let q=0;q<V.length;++q){const ne=V[q];E(ne<=$-1&&ne>=0,()=>`GatherV2: the index value ${ne} is not in [0, ${$-1}]`)}}const v=OI(l,u,A,g),C=N(u.shape),S=[],M=rn({inputs:{x:l},backend:i,attrs:{shape:[v.batchSize,v.outerSize,v.dimSize,v.sliceSize]}}),_=rn({inputs:{x:u},backend:i,attrs:{shape:[v.batchSize,C/v.batchSize]}});S.push(M),S.push(_);const B=[v.batchSize,v.outerSize,C/v.batchSize,v.sliceSize];if(i.shouldExecuteOnCPU([l,u])||l.dtype==="string"){const V=i.bufferSync(_),$=i.bufferSync(M),q=Tq($,V,B);return S.forEach(ne=>i.disposeIntermediateTensorInfo(ne)),i.makeTensorInfo(v.outputShape,q.dtype,q.values)}const F=new iie(M.shape,B),P=i.runWebGLProgram(F,[M,_],M.dtype);S.push(P);const U=rn({inputs:{x:P},backend:i,attrs:{shape:v.outputShape}});return S.forEach(V=>i.disposeIntermediateTensorInfo(V)),U}const rie={kernelName:xn,backendName:"webgl",kernelFunc:$D};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aie=Wr({opSnippet:"return float(a > b);",packedOpSnippet:`
  return vec4(greaterThan(a, b));
`,cpuKernelImpl:Mq,dtype:"bool"}),oie={kernelName:Qn,backendName:"webgl",kernelFunc:aie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const lie=Wr({opSnippet:"return float(a >= b);",packedOpSnippet:`
  return vec4(greaterThanEqual(a, b));
`,dtype:"bool",cpuKernelImpl:_q}),cie={kernelName:Ws,backendName:"webgl",kernelFunc:lie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function uie(s){const{inputs:t,backend:i}=s,{input:o}=t;return KD(o,!0,i)}const hie={kernelName:Ia,backendName:"webgl",kernelFunc:uie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const die=Di({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),fie={kernelName:Si,backendName:"webgl",kernelFunc:die};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const pie=Di({opSnippet:"return float(isinf(x));",dtype:"bool"}),mie={kernelName:Cs,backendName:"webgl",kernelFunc:pie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gie=Di({opSnippet:"return float(isnan(x));",dtype:"bool"}),Aie={kernelName:sr,backendName:"webgl",kernelFunc:gie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const bie=Wr({opSnippet:"return float(a < b);",packedOpSnippet:`
  return vec4(lessThan(a, b));
`,cpuKernelImpl:Rq,dtype:"bool"}),yie={kernelName:lo,backendName:"webgl",kernelFunc:bie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const vie=Wr({opSnippet:"return float(a <= b);",packedOpSnippet:`
  return vec4(lessThanEqual(a, b));
`,cpuKernelImpl:kq,dtype:"bool"}),xie={kernelName:co,backendName:"webgl",kernelFunc:vie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wie(s){const{backend:t,attrs:i}=s,{start:o,stop:l,num:u}=i,f=Bq(o,l,u);return t.makeTensorInfo([f.length],"float32",f)}const Cie={kernelName:Eu,backendName:"webgl",kernelFunc:wie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Eie=f0+`
  return x < 0.0 ? 0./0. : log(x);
`,Sie=Di({opSnippet:Eie,packedOpSnippet:`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,cpuKernelImpl:Lq}),Iie={kernelName:of,backendName:"webgl",kernelFunc:Sie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Tie=f0+`
  return log(1.0 + x);
`,Mie=Di({opSnippet:Tie}),_ie={kernelName:lf,backendName:"webgl",kernelFunc:Mie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Rie=Wr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,dtype:"bool"}),kie={kernelName:Su,backendName:"webgl",kernelFunc:Rie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Bie=Di({opSnippet:"return float(!(x >= 1.0));"}),Lie={kernelName:Lh,backendName:"webgl",kernelFunc:Bie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Nie=Wr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dtype:"bool"}),Die={kernelName:Nh,backendName:"webgl",kernelFunc:Nie};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Fie{constructor(t,i,o,l,u){this.variableNames=["x"],this.outputShape=[];const f=i,g=t[3]-1;this.outputShape=t;let A;const v=`float(${o}) + float(${l}) * sum`;u===.5?A=`inversesqrt(${v})`:u===1?A=`1.0/(${v})`:A=`exp(log(${v}) * float(-${u}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${f}; j <= ${f}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${g}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${A};
        setOutput(val);
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Oie{constructor(t,i,o,l,u){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const f=i,g=t[3]-1;this.outputShape=t;let A;const v=`float(${o}) + float(${l}) * sum`;u===.5?A=`inversesqrt(${v})`:u===1?A=`1.0/(${v})`:A=`exp(log(${v}) * float(-${u}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${f};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${f}; j <= ${f}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${g}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${A};
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Gie={kernelName:Ll,backendName:"webgl",kernelFunc:s=>{const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{depthRadius:u,bias:f,alpha:g,beta:A}=o,v=Ee().getBool("WEBGL_PACK_NORMALIZATION")?new Oie(l.shape,u,f,g,A):new Fie(l.shape,u,f,g,A);return i.runWebGLProgram(v,[l],l.dtype)}};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Uie{constructor(t,i,o,l,u){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=i,this.bias=o,this.alpha=l,this.beta=u,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${i})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${i} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${l}) * norm + float(${o});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${l})
                * float(${u})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${u});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Pie={kernelName:Nm,backendName:"webgl",kernelFunc:s=>{const{inputs:t,backend:i,attrs:o}=s,{x:l,y:u,dy:f}=t,{depthRadius:g,bias:A,alpha:v,beta:C}=o,S=new Uie(l.shape,g,A,v,C);return i.runWebGLProgram(S,[l,u,f],l.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function zie(s,t,i,o){const l=N(t),u=N(s.shape)/l,f=rn({inputs:{x:s},attrs:{shape:[u,l]},backend:o}),g=Hp(f,s.dtype,"max",o),A=rn({inputs:{x:g},attrs:{shape:i},backend:o});return o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(g),A}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function YD(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{reductionIndices:u,keepDims:f}=o,g=l.shape.length,A=J(u,l.shape);let v=A;const C=ji(v,g),S=C!=null,M=i.shouldExecuteOnCPU([l]);let _=l;if(S){if(M){const V=i.texData.get(_.dataId).values,$=new Array(g);for(let he=0;he<$.length;he++)$[he]=l.shape[C[he]];const q=zT(V,l.shape,l.dtype,C,$);_=i.makeTensorInfo($,l.dtype);const ne=i.texData.get(_.dataId);ne.values=q}else _=Mw(l,C,i);v=Ss(v.length,g)}Rs("max",v,g);const[B,F]=Ei(_.shape,v);let P=B;f&&(P=ts(B,A));let U;if(M){const V=i.texData.get(_.dataId).values,$=Nq(V,N(F),P,l.dtype);U=i.makeTensorInfo(P,l.dtype);const q=i.texData.get(U.dataId);q.values=$}else U=zie(_,F,P,i);return S&&i.disposeIntermediateTensorInfo(_),U}const Vie={kernelName:Fh,backendName:"webgl",kernelFunc:YD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Wie=WT+`
  return max(a, b);
`,Hie=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ay+`
  return result;
`,Xie=Wr({opSnippet:Wie,packedOpSnippet:Hie,cpuKernelImpl:Dq}),Qie={kernelName:Oh,backendName:"webgl",kernelFunc:Xie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Kie(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t;py(l,"maxPool");const{filterSize:u,strides:f,pad:g,dimRoundingMode:A}=o,v=1;E(or(f,v),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${f} and dilations '${v}'`);const C=Oa(l.shape,u,f,v,g,A);if(C.filterWidth===1&&C.filterHeight===1&&O(C.inShape,C.outShape))return wo({inputs:{x:l},backend:i});const S=new vy(C,"max",!1);return i.runWebGLProgram(S,[l],l.dtype)}const Zie={kernelName:Sc,backendName:"webgl",kernelFunc:Kie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function $ie(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{filterSize:u,strides:f,pad:g,dataFormat:A,dimRoundingMode:v}=o,C=[1,1,1],S=go(l.shape,u,f,C,g,v,A),M=new XT(S,"max",!1);return i.runWebGLProgram(M,[l],l.dtype)}const Yie={kernelName:Gh,backendName:"webgl",kernelFunc:$ie};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class jie{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const i=t.strideHeight,o=t.strideWidth,l=t.dilationHeight,u=t.effectiveFilterHeight,f=t.effectiveFilterWidth,g=u-1-t.padInfo.top,A=f-1-t.padInfo.left,v=u*f-1;this.userCode=`
      const ivec2 pads = ivec2(${g}, ${A});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
          wR += ${l}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${f}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${v} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${f} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class qie{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const i=t.strideDepth,o=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,f=t.dilationHeight,g=t.dilationWidth,A=t.effectiveFilterDepth,v=t.effectiveFilterHeight,C=t.effectiveFilterWidth,S=A-1-t.padInfo.front,M=v-1-t.padInfo.top,_=C-1-t.padInfo.left,B=A*v*C-1;this.userCode=`
      const ivec3 pads = ivec3(${S}, ${M}, ${_});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${A};
           wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${v};
              wR += ${f}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${C};
                wC += ${g}) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${B} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${v} * ${C} +
                  wR * ${C} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Jie(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,input:u}=t,f=u,{filterSize:g,strides:A,pad:v,dimRoundingMode:C}=o,S=[1,1,1],M=go(f.shape,g,A,S,v,C),_=new XT(M,"max",!0),B=i.runWebGLProgram(_,[f],f.dtype),F=new qie(M),P=i.runWebGLProgram(F,[l,B],f.dtype);return i.disposeIntermediateTensorInfo(B),P}const ese={kernelName:Iu,backendName:"webgl",kernelFunc:Jie};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tse(s){const{inputs:t,backend:i,attrs:o}=s,{dy:l,input:u,output:f}=t,g=u;py([u,f],"maxPoolGrad");const{filterSize:A,strides:v,pad:C,dimRoundingMode:S}=o,M=Oa(g.shape,A,v,1,C,S),_=!0,B=new vy(M,"max",_),F=i.runWebGLProgram(B,[g],g.dtype),P=new jie(M),U=i.runWebGLProgram(P,[l,F],g.dtype);return i.disposeIntermediateTensorInfo(F),U}const nse={kernelName:No,backendName:"webgl",kernelFunc:tse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ise(s,t,i,o){let l=new vy(i,"max",!1);const u=o.runWebGLProgram(l,[s],"float32");l=new vy(i,"max",!0,!0,t);const f=o.runWebGLProgram(l,[s],"float32");return[u,f]}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sse={kernelName:Nl,backendName:"webgl",kernelFunc:({inputs:s,attrs:t,backend:i})=>{const{x:o}=s,{filterSize:l,strides:u,pad:f,includeBatchInIndex:g}=t,A=i;E(o.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.shape.length}.`);const v=[1,1];E(or(u,v),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${u} and dilations '${v}'`);const C=Oa(o.shape,l,u,v,f),[S,M]=ise(o,g,C,A);return[S,M]}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function rse(s,t,i,o){const l=N(t),u=N(s.shape)/l,f=rn({inputs:{x:s},attrs:{shape:[u,l]},backend:o}),g=Hp(f,"float32","mean",o),A=rn({inputs:{x:g},attrs:{shape:i},backend:o});return o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(g),A}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ase={kernelName:Uh,backendName:"webgl",kernelFunc:({inputs:s,attrs:t,backend:i})=>{const{x:o}=s,{keepDims:l,axis:u}=t,f=i,g=o.shape.length,A=J(u,o.shape);let v=A;const C=ji(v,g),S=C!=null,M=f.shouldExecuteOnCPU([o]),_=[];let B=o;if(S){if(M){const $=f.texData.get(B.dataId).values,q=new Array(g);for(let me=0;me<q.length;me++)q[me]=o.shape[C[me]];const ne=zT($,o.shape,o.dtype,C,q);B=f.makeTensorInfo(q,o.dtype);const he=f.texData.get(B.dataId);he.values=ne}else B=Mw(o,C,f);_.push(B),v=Ss(v.length,g)}Rs("sum",v,g);const[F,P]=Ei(B.shape,v);let U=F;l&&(U=ts(F,A));const V=rse(B,P,U,f);for(const $ of _)f.disposeIntermediateTensorInfo($);return V}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ose(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o,g=l.shape.length,A=J(u,l.shape);let v=A;const C=ji(v,g);let S=l;C!=null&&(S=ga({inputs:{x:l},backend:i,attrs:{perm:C}}),v=Ss(v.length,l.shape.length)),Rs("min",v,g);const[M,_]=Ei(S.shape,v),B=N(_),F=rn({inputs:{x:S},backend:i,attrs:{shape:[-1,B]}}),P=Hp(F,F.dtype,"min",i);let U;if(f){const V=ts(M,A);U=rn({inputs:{x:P},backend:i,attrs:{shape:V}})}else U=rn({inputs:{x:P},backend:i,attrs:{shape:M}});return i.disposeIntermediateTensorInfo(F),i.disposeIntermediateTensorInfo(P),C!=null&&i.disposeIntermediateTensorInfo(S),U}const lse={kernelName:Tu,backendName:"webgl",kernelFunc:ose};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const cse=WT+`
  return min(a, b);
`,use=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ay+`
  return result;
`,hse=Wr({opSnippet:cse,packedOpSnippet:use,cpuKernelImpl:Fq}),dse={kernelName:Ph,backendName:"webgl",kernelFunc:hse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fse{constructor(t,i,o){this.variableNames=["x"],this.outputShape=i.map((C,S)=>C[0]+t[S]+C[1]);const l=t.length,u=ws(l),f=i.map(C=>C[0]).join(","),g=i.map((C,S)=>C[0]+t[S]).join(","),A=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,l),v=o==="reflect"?0:1;if(l===1){this.userCode=`
        int start = ${f};
        int end = ${g};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${v};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${v};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${u} start = ${u}(${f});
      ${u} end = ${u}(${g});

      void main() {
        ${u} outC = getOutputCoords();
        for (int i = 0; i < ${l}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${v};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${v};
          }
        }
        ${u} coords = outC - start;
        setOutput(getX(${A}));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class pse{constructor(t,i,o){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i.map((B,F)=>B[0]+t[F]+B[1]);const l=t.length,u=ws(l),f=i.map(B=>B[0]).join(","),g=i.map((B,F)=>B[0]+t[F]).join(","),A=ma("rc",l),v=ma("source",l),C=`${A[l-1]} < ${this.outputShape[l-1]}`,S=l===1?"source":`vec2(${v.slice(-2).join()})`,M=o==="reflect"?0:1;let _="";if(l===1){const B=`
        ${u} source = rc;
        if (source < start) {
          source = start * 2 - source - ${M};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${M};
        }
        source -= start;
      `;_=`
        ${u} rc = outputLoc;
        ${B}
        result[0] = getChannel(getX(${v.join()}), ${S});
        ${A[l-1]} += 1;
        if(${C}) {
          ${B}
          result[1] = getChannel(getX(${v.join()}), ${S});
        }
      `}else{const B=`
        ${u} source = rc;
        ${u} lt = ${u}(lessThan(source, start));
        ${u} gte = ${u}(greaterThanEqual(source, end));
        ${u} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${M}) +
                gte * ((end - 1) * 2 - source + ${M});
        source -= start;
      `;_=`
        ${u} rc = outputLoc;
        ${B}
        result[0] = getChannel(getX(${v.join()}), ${S});
        ${A[l-1]} += 1;
        if(${C}) {
          ${B}
          result[1] = getChannel(getX(${v.join()}), ${S});
        }
        rc = outputLoc;
        ${A[l-2]} += 1;
        if(${A[l-2]} < ${this.outputShape[l-2]}) {
          ${B}
          result[2] = getChannel(getX(${v.join()}), ${S});
          ${A[l-1]} += 1;
          if(${C}) {
            ${B}
            result[3] = getChannel(getX(${v.join()}), ${S});
          }
        }
      `}this.userCode=`
      const ${u} start = ${u}(${f});
      const ${u} end = ${u}(${g});

      void main() {
        ${u} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${_}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const mse={kernelName:Mu,backendName:"webgl",kernelFunc:({inputs:s,backend:t,attrs:i})=>{const{x:o}=s,{paddings:l,mode:u}=i,f=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pse(o.shape,l,u):new fse(o.shape,l,u);return t.runWebGLProgram(f,[o],o.dtype)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const gse=`if (b == 0.0) return NAN;
  return mod(a, b);`,Ase=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Ay+`
  return result;
`,bse=Wr({opSnippet:gse,packedOpSnippet:Ase}),yse={kernelName:Ic,backendName:"webgl",kernelFunc:bse};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class vse{constructor(t,i,o){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,o],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${i-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${i-1}));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jD=Wr({opSnippet:`
if (a == b) {
  return 1.0;
};
return a / b;`,packedOpSnippet:`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,checkOutOfBounds:!0}),xse={kernelName:ot,backendName:"webgl",kernelFunc:jD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const qD="return a - b;",JD=Wr({opSnippet:qD,packedOpSnippet:qD,supportsComplex:!0,cpuKernelImpl:tJ}),wse={kernelName:If,backendName:"webgl",kernelFunc:JD};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function eF(s){const{inputs:t,backend:i,attrs:o}=s,{logits:l}=t,{dim:u}=o,f=J([u],l.shape),g=YD({inputs:{x:l},backend:i,attrs:{reductionIndices:f,keepDims:!1}}),A=ts(g.shape,f),v=rn({inputs:{x:g},backend:i,attrs:{shape:A}}),C=JD({inputs:{a:l,b:v},backend:i}),S=HD({inputs:{x:C},backend:i}),M=_w({inputs:{x:S},backend:i,attrs:{axis:f,keepDims:!1}}),_=rn({inputs:{x:M},backend:i,attrs:{shape:A}}),B=jD({inputs:{a:S,b:_},backend:i});return i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(_),B}const Cse={kernelName:Ef,backendName:"webgl",kernelFunc:eF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ese(s){const{inputs:t,backend:i,attrs:o}=s,{logits:l}=t,{numSamples:u,seed:f,normalized:g}=o,A=g?l:eF({inputs:{logits:l},backend:i,attrs:{dim:l.shape.length-1}}),v=A.shape[0],C=A.shape[1],S=new vse(v,C,u),M=[[f]],_=i.runWebGLProgram(S,[A],"int32",M);return g||i.disposeIntermediateTensorInfo(A),_}const Sse={kernelName:cA,backendName:"webgl",kernelFunc:Ese};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Ise=Il+`
  return -x;
`,Tse=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Mse(s){const{inputs:t,backend:i}=s,{x:o}=t;if(i.shouldExecuteOnCPU([o])){const u=i.texData.get(o.dataId),[f,g]=Gq(u.values,o.shape,o.dtype);return i.makeTensorInfo(g,o.dtype,f)}let l;return Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?l=new Wp(o.shape,Tse):l=new ah(o.shape,Ise),i.runWebGLProgram(l,[o],o.dtype)}const _se={kernelName:sl,backendName:"webgl",kernelFunc:Mse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Rse=KS;function kse(s){sa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:i,attrs:o}=s,{boxes:l,scores:u}=t,{maxOutputSize:f,iouThreshold:g,scoreThreshold:A}=o,v=i.readSync(l.dataId),C=i.readSync(u.dataId),{selectedIndices:S}=Rse(v,C,f,g,A);return i.makeTensorInfo([S.length],"int32",new Int32Array(S))}const Bse={kernelName:Ru,backendName:"webgl",kernelFunc:kse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Lse=ZS;function Nse(s){sa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:i,attrs:o}=s,{boxes:l,scores:u}=t,{maxOutputSize:f,iouThreshold:g,scoreThreshold:A,padToMaxOutputSize:v}=o,C=i.readSync(l.dataId),S=i.readSync(u.dataId),{selectedIndices:M,validOutputs:_}=Lse(C,S,f,g,A,v);return[i.makeTensorInfo([M.length],"int32",new Int32Array(M)),i.makeTensorInfo([],"int32",new Int32Array([_]))]}const Dse={kernelName:uA,backendName:"webgl",kernelFunc:Nse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Fse=$S;function Ose(s){sa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:i,attrs:o}=s,{boxes:l,scores:u}=t,{maxOutputSize:f,iouThreshold:g,scoreThreshold:A,softNmsSigma:v}=o,C=i.readSync(l.dataId),S=i.readSync(u.dataId),M=f,_=g,B=A,F=v,{selectedIndices:P,selectedScores:U}=Fse(C,S,M,_,B,F);return[i.makeTensorInfo([P.length],"int32",new Int32Array(P)),i.makeTensorInfo([U.length],"float32",new Float32Array(U))]}const Gse={kernelName:cf,backendName:"webgl",kernelFunc:Ose};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Use{constructor(t,i,o,l){this.variableNames=["indices"],this.outputShape=[t,i],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${l}), float(${o}),
                      float(index == coords.y)));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Pse={kernelName:Tc,backendName:"webgl",kernelFunc:s=>{const{inputs:t,backend:i,attrs:o}=s,{indices:l}=t,{dtype:u,depth:f,onValue:g,offValue:A}=o,v=N(l.shape),C=new Use(v,f,g,A),S=rn({inputs:{x:l},backend:i,attrs:{shape:[v]}}),M=i.runWebGLProgram(C,[S],u);i.disposeIntermediateTensorInfo(S);const _=[...l.shape,f],B=rn({inputs:{x:M},backend:i,attrs:{shape:_}});return i.disposeIntermediateTensorInfo(M),B}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Dw(s){const{inputs:t,backend:i}=s,{x:o}=t;if(o.dtype==="complex64"){const l=xy({inputs:{input:o},backend:i}),u=Dw({inputs:{x:l},backend:i}),f=Lw({inputs:{input:o},backend:i}),g=Dw({inputs:{x:f},backend:i}),A=Nd({inputs:{real:u,imag:g},backend:i});return i.disposeIntermediateTensorInfo(l),i.disposeIntermediateTensorInfo(u),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(g),A}else return Ey({attrs:{shape:o.shape,dtype:o.dtype,value:o.dtype==="string"?"":0},backend:i})}const zse={kernelName:Km,backendName:"webgl",kernelFunc:Dw};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function tF(s){const{inputs:t,backend:i}=s,{x:o}=t;if(o.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(o.dtype==="complex64"){const l=xy({inputs:{input:o},backend:i}),u=tF({inputs:{x:l},backend:i}),f=Lw({inputs:{input:o},backend:i}),g=Dw({inputs:{x:f},backend:i}),A=Nd({inputs:{real:u,imag:g},backend:i});return i.disposeIntermediateTensorInfo(l),i.disposeIntermediateTensorInfo(u),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(g),A}else return Ey({attrs:{shape:o.shape,dtype:o.dtype,value:1},backend:i})}const Vse={kernelName:zh,backendName:"webgl",kernelFunc:tF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Wse(s){const{inputs:t,backend:i,attrs:o}=s,{axis:l}=o;if(t.length===1)return ZT({inputs:{input:t[0]},backend:i,attrs:{dim:l}});const u=t[0].shape,f=t[0].dtype;t.forEach(C=>{R(u,C.shape,"All tensors passed to stack must have matching shapes"),E(f===C.dtype,()=>"All tensors passed to stack must have matching dtypes")});const g=[],A=t.map(C=>{const S=ZT({inputs:{input:C},backend:i,attrs:{dim:l}});return g.push(S),S}),v=LD({inputs:A,backend:i,attrs:{axis:l}});return g.forEach(C=>i.disposeIntermediateTensorInfo(C)),v}const Hse={kernelName:ku,backendName:"webgl",kernelFunc:Wse};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Xse{constructor(t,i,o){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=i.map((v,C)=>v[0]+t[C]+v[1]);const l=t.length,u=ws(l),f=i.map(v=>v[0]).join(","),g=i.map((v,C)=>v[0]+t[C]).join(","),A=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,l);if(l===1){this.userCode=`
        int start = ${f};
        int end = ${g};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${u} start = ${u}(${f});
      ${u} end = ${u}(${g});

      void main() {
        ${u} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${u} coords = outC - start;
          setOutput(getX(${A}));
        }
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Qse{constructor(t,i,o){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=i.map((F,P)=>F[0]+t[P]+F[1]);const l=t.length,u=ws(l),f=i.map(F=>F[0]).join(","),g=i.map((F,P)=>F[0]+t[P]).join(","),A=ma("rc",l),v=ma("source",l),C=`${A[l-1]} < ${this.outputShape[l-1]}`,S=l===1?"source":`vec2(${v.slice(-2).join()})`,M=[`${u} rc = outputLoc;`,`${A[l-1]} += 1;
       if(${C}) {
      `,l===1?"":`}
       rc = outputLoc;
       ${A[l-2]} += 1;
       if(${A[l-2]} < ${this.outputShape[l-2]}) {`,l===1?"":`  ${A[l-1]} += 1;
         if(${C}) {`],_=l===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let B="";for(let F=0,P=l===1?2:4;F<P;F++)B+=`
        ${M[F]}
        if (${_}) {
          result[${F}] = float(value);
        } else {
          ${u} source = rc - start;
          result[${F}] = getChannel(getX(${v.join()}), ${S});
        }
      `;B+=l===1?"} ":"}}",this.userCode=`
      const ${u} start = ${u}(${f});
      const ${u} end = ${u}(${g});

      void main() {
        ${u} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${B}
        setOutput(result);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const nF=s=>{const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{paddings:u,constantValue:f}=o;if(N(l.shape)===0){const v=u.map((C,S)=>C[0]+l.shape[S]+C[1]);return Ey({backend:i,attrs:{shape:v,value:f,dtype:l.dtype}})}const g=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qse(l.shape,u,f):new Xse(l.shape,u,f),A=[[f]];return i.runWebGLProgram(g,[l],l.dtype,A)},Kse={kernelName:uf,backendName:"webgl",kernelFunc:nF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Zse=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,$se=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Ay+`
  return result;
`,Yse=Wr({opSnippet:Zse,packedOpSnippet:$se}),jse={kernelName:hf,backendName:"webgl",kernelFunc:Yse};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qse(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{axis:u,keepDims:f}=o,g=l.shape.length,A=[],v=J(u,l.shape);let C=v;const S=ji(C,g);let M=l;S!=null&&(M=ga({inputs:{x:l},backend:i,attrs:{perm:S}}),C=Ss(C.length,g),A.push(M)),Rs("prod",C,g);let _;if(i.shouldExecuteOnCPU([M])){const B=i.texData.get(M.dataId).values,{outVals:F,outShape:P,outDtype:U}=Pq(M.shape,M.dtype,B,C);_=i.makeTensorInfo(P,U,F)}else{const[B,F]=Ei(M.shape,C),P=N(F),U=rn({inputs:{x:M},backend:i,attrs:{shape:[-1,P]}}),V=Hf(l.dtype),$=Hp(U,V,"prod",i);_=rn({inputs:{x:$},backend:i,attrs:{shape:B}}),A.push(U),A.push($)}if(f){A.push(_);const B=ts(_.shape,v);_=rn({inputs:{x:_},backend:i,attrs:{shape:B}})}return A.forEach(B=>i.disposeIntermediateTensorInfo(B)),_}const Jse={kernelName:Fm,backendName:"webgl",kernelFunc:qse};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function ere(s){const{inputs:t,backend:i,attrs:o}=s,{paramsNestedSplits:l,paramsDenseValues:u,indices:f}=t,{outputRaggedRank:g}=o,A=l.map(U=>i.readSync(U.dataId)),v=l.map(U=>U.shape),C=i.readSync(u.dataId),S=i.readSync(f.dataId),[M,_,B]=zq(A,v,C,u.shape,u.dtype,S,f.shape,g),F=M.map(U=>i.makeTensorInfo([U.length],"int32",U)),P=i.makeTensorInfo(B,u.dtype,_);return F.concat([P])}const tre={kernelName:Om,backendName:"webgl",kernelFunc:ere};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function nre(s){const{inputs:t,backend:i,attrs:o}=s,{shape:l,values:u,defaultValue:f,rowPartitionTensors:g}=t,{rowPartitionTypes:A}=o,v=i.readSync(l.dataId),C=i.readSync(u.dataId),S=i.readSync(f.dataId),M=g.map(P=>i.readSync(P.dataId)),_=g.map(P=>P.shape),[B,F]=Vq(v,l.shape,C,u.shape,u.dtype,S,f.shape,M,_,A);return i.makeTensorInfo(B,u.dtype,F)}const ire={kernelName:$v,backendName:"webgl",kernelFunc:nre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const iF=s=>{const{backend:t,attrs:i}=s,{start:o,stop:l,step:u,dtype:f}=i,g=Wq(o,l,u,f);return t.makeTensorInfo([g.length],f,g)},sre={kernelName:hA,backendName:"webgl",kernelFunc:iF};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rre=Di({opSnippet:"return 1.0 / x;"}),are={kernelName:df,backendName:"webgl",kernelFunc:rre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ore=Il+`
  return (x < 0.0) ? 0.0 : x;
`,lre=Di({opSnippet:ore,packedOpSnippet:`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),cre={kernelName:ff,backendName:"webgl",kernelFunc:lre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ure=Il+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,hre=Di({opSnippet:ure,packedOpSnippet:`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),dre={kernelName:Bu,backendName:"webgl",kernelFunc:hre};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class fre{constructor(t,i,o,l,u){this.variableNames=["A"],this.outputShape=[];const[f,g,A,v]=t;this.outputShape=[f,i,o,v];const C=[l&&i>1?g-1:g,l&&o>1?A-1:A],S=[l&&i>1?i-1:i,l&&o>1?o-1:o];let M;u?M="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":M="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${C[0]/S[0]},
          ${C[1]/S[1]});
      const vec2 inputShapeRC = vec2(${g}.0, ${A}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${M};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class pre{constructor(t,i,o,l,u){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[f,g,A,v]=t;this.outputShape=[f,i,o,v];const C=[l&&i>1?g-1:g,l&&o>1?A-1:A],S=[l&&i>1?i-1:i,l&&o>1?o-1:o];let M;u?M="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":M="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${C[0]/S[0]},
          ${C[1]/S[1]},
          ${C[1]/S[1]});
      const vec3 inputShapeRC = vec3(${g}.0, ${A}.0,
                                     ${A}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${M};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${v-1};
        bool hasNextRow = coords.z < ${o-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mre(s){const{inputs:t,backend:i,attrs:o}=s,{images:l}=t,{alignCorners:u,halfPixelCenters:f,size:g}=o,[A,v]=g,C=Ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new pre(l.shape,A,v,u,f):new fre(l.shape,A,v,u,f);return i.runWebGLProgram(C,[l],"float32")}const gre={kernelName:Um,backendName:"webgl",kernelFunc:mre};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Are{constructor(t,i,o){this.variableNames=["dy"],this.outputShape=[],this.outputShape=i;const[,l,u]=i,[,f,g]=t,A=[o&&f>1?l-1:l,o&&g>1?u-1:u],v=[o&&f>1?f-1:f,o&&g>1?g-1:g],C=A[0]/v[0],S=A[1]/v[1],M=1/C,_=1/S,B=Math.ceil(M)*2+2,F=Math.ceil(_)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${C});
        const float widthScale = float(${S});

        const float invHeightScale = float(${M});
        const float invWidthScale = float(${_});

        const int winHeight = int(${B});
        const int winWidth = int(${F});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${f}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${g}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${l-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${u-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function bre(s){const{inputs:t,backend:i,attrs:o}=s,{images:l,dy:u}=t,{alignCorners:f}=o,g=new Are(u.shape,l.shape,f);return i.runWebGLProgram(g,[u],u.dtype)}const yre={kernelName:pA,backendName:"webgl",kernelFunc:bre};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class vre{constructor(t,i,o,l,u){this.variableNames=["A"],this.outputShape=[];const[f,g,A,v]=t;this.outputShape=[f,i,o,v];const C=[l&&i>1?g-1:g,l&&o>1?A-1:A],S=[l&&i>1?i-1:i,l&&o>1?o-1:o],M=l?"0.5":"0.0";let _;u?_="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":_="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${C[0]/S[0]},
          ${C[1]/S[1]});
      const vec2 inputShapeRC = vec2(${g}.0, ${A}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${_};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${M})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class xre{constructor(t,i,o,l,u){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[f,g,A,v]=t;this.outputShape=[f,i,o,v];const C=[l&&i>1?g-1:g,l&&o>1?A-1:A],S=[l&&i>1?i-1:i,l&&o>1?o-1:o],M=l?"0.5":"0.0";let _;u?_="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":_="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${C[0]/S[0]},
          ${C[1]/S[1]},
          ${C[1]/S[1]});
      const vec3 inputShapeRC = vec3(${g}.0, ${A}.0,
                                     ${A}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${_};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${M})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${v-1};
        bool hasNextRow = coords.z < ${o-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function wre(s){const{inputs:t,backend:i,attrs:o}=s,{images:l}=t,{alignCorners:u,halfPixelCenters:f,size:g}=o,[A,v]=g,C=Ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new xre(l.shape,A,v,u,f):new vre(l.shape,A,v,u,f);return i.runWebGLProgram(C,[l],l.dtype)}const Cre={kernelName:Gm,backendName:"webgl",kernelFunc:wre};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ere{constructor(t,i,o){this.variableNames=["dy"],this.outputShape=[],this.outputShape=i;const[,l,u]=i,[,f,g]=t,A=[o&&f>1?l-1:l,o&&g>1?u-1:u],v=[o&&f>1?f-1:f,o&&g>1?g-1:g],C=A[0]/v[0],S=A[1]/v[1],M=1/C,_=1/S,B=Math.ceil(M)*2+2,F=Math.ceil(_)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${C});
        const float widthScale = float(${S});

        const float invHeightScale = float(${M});
        const float invWidthScale = float(${_});

        const int winHeight = int(${B});
        const int winWidth = int(${F});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${f}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${g}) {
              continue;
            }

            float sourceFracRow =
              float(${A[0]}) *
                (float(dyR) / float(${v[0]}));

            float sourceFracCol =
                float(${A[1]}) *
                  (float(dyC) / float(${v[1]}));

            int sourceNearestRow = int(min(
                float(int(${l}) - 1),
                ${o} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${u}) - 1),
                ${o} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Sre(s){const{inputs:t,backend:i,attrs:o}=s,{images:l,dy:u}=t,{alignCorners:f}=o,g=new Ere(u.shape,l.shape,f);return i.runWebGLProgram(g,[u],u.dtype)}const Ire={kernelName:fA,backendName:"webgl",kernelFunc:Sre};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Tre{constructor(t,i){this.variableNames=["x"];const o=t.length;if(o>4)throw new Error(`WebGL backend: Reverse of rank-${o} tensor is not yet supported`);if(this.outputShape=t,o===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const l=g=>i.indexOf(g)!==-1&&t[g]!==1?`${t[g]} - coords[${g}] - 1`:`coords[${g}]`,u=t.map((g,A)=>l(A)).join(","),f=ws(o);this.userCode=`
      void main() {
        ${f} coords = getOutputCoords();
        setOutput(getX(${u}));
      }
    `}}/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Mre{constructor(t,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const o=t.length;if(o>4)throw new Error(`WebGL backend: Reverse of rank-${o} tensor is not yet supported`);this.outputShape=t;const l=ma("rc",o),u=`${l[o-1]} + 1 < ${this.outputShape[o-1]}`,f=`${l[o-2]} + 1 < ${this.outputShape[o-2]}`,g=ws(o);o===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${u}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${g} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${A(l.slice())};
          if(${u}){
            result.g = ${v(l.slice())};
          }
          if(${f}) {
            result.b = ${C(l.slice())};
            if(${u}) {
              result.a = ${S(l.slice())};
            }
          }
          setOutput(result);
        }
    `;function A(B){return M(B)}function v(B){return B[o-1]="("+B[o-1]+" + 1)",M(B)}function C(B){return B[o-2]="("+B[o-2]+" + 1)",M(B)}function S(B){return B[o-1]="("+B[o-1]+" + 1)",B[o-2]="("+B[o-2]+" + 1)",M(B)}function M(B){const F=t.map((V,$)=>_($,B)),P=F.join(","),U=F.slice(-2).join(",");return`getChannel(getX(${P}), vec2(${U}))`}function _(B,F){return i.indexOf(B)!==-1&&t[B]!==1?`${t[B]} - ${F[B]} - 1`:`${F[B]}`}}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function _re(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{dims:u}=o,f=l.shape.length,g=J(u,l.shape);if(f===0)return wo({inputs:{x:l},backend:i});const A=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mre(l.shape,g):new Tre(l.shape,g);return i.runWebGLProgram(A,[l],l.dtype)}const Rre={kernelName:Pm,backendName:"webgl",kernelFunc:_re};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class kre{constructor(t,i){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const o=t[1],l=t[2];this.outputShape=t;let u="";typeof i=="number"?u=`float outputValue = ${i.toFixed(2)};`:u=`
        vec3 fill = vec3(${i.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${u}
          if(coordX >= 0 && coordX < ${l} && coordY >= 0 && coordY < ${o}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Bre={kernelName:wA,backendName:"webgl",kernelFunc:({inputs:s,attrs:t,backend:i})=>{const{image:o}=s,{radians:l,fillValue:u,center:f}=t,g=i,A=new kre(o.shape,u),[v,C]=cI(f,o.shape[1],o.shape[2]),S=[[v,C,Math.sin(l),Math.cos(l)]];return g.runWebGLProgram(A,[o],o.dtype,S)}};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Lre=Di({opSnippet:`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`}),Nre={kernelName:mf,backendName:"webgl",kernelFunc:Lre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Dre=Di({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Hq}),Fre={kernelName:gf,backendName:"webgl",kernelFunc:Dre};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class sF{constructor(t,i,o,l,u,f,g=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=f;const A=ws(u.length),v=ws(f.length);let C="";o===1?C="i":o===2&&(C="i, j");const S=`getIndices(${C})`;let M="";l===1?M="i":l===2&&(M="i, coords[1]");const _=`getUpdates(${M})`,B=i>1?"strides[j]":"strides";this.userCode=`
        ${A} strides = ${A}(${u});

        void main() {
          ${v} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${i}; j++) {
              int index = round(${S});
              flattenedIndex += index * ${B};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${_};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Ore(s){const{inputs:t,backend:i,attrs:o}=s,{indices:l,updates:u}=t,{shape:f}=o,{sliceRank:g,numUpdates:A,sliceSize:v,strides:C,outputSize:S}=Jf(u,l,f),M=[S/v,v];if(S===0)return i.makeTensorInfo(f,l.dtype);const _=rn({inputs:{x:l},backend:i,attrs:{shape:[A,g]}}),B=rn({inputs:{x:u},backend:i,attrs:{shape:[A,v]}}),F=i.makeTensorInfo([],"float32",new Float32Array([0])),P=new sF(A,g,_.shape.length,B.shape.length,C,M),U=i.runWebGLProgram(P,[B,_,F],B.dtype),V=rn({inputs:{x:U},backend:i,attrs:{shape:f}});return i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo(F),V}const Gre={kernelName:mA,backendName:"webgl",kernelFunc:Ore};/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Ure{constructor(t,i,o,l){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,o];const u="while (left < right) {",f=`for (int i = 0; i < ${Math.ceil(Math.log2(i+1))}; ++i) { if (left >= right) break;`,g=Ee().getNumber("WEBGL_VERSION")===2?u:f,A=l==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${g}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${A} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
* @license
* Copyright 2022 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Pre(s){const{inputs:t,backend:i,attrs:o}=s,{sortedSequence:l,values:u}=t,{side:f}=o,g=new Ure(l.shape[0],l.shape[1],u.shape[1],f),A=[[l.shape[1]]];return i.runWebGLProgram(g,[l,u],"int32",A)}const zre={kernelName:Yv,backendName:"webgl",kernelFunc:Pre};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Vre{constructor(t,i,o){this.variableNames=["c","a","b"],this.outputShape=i;let l,u;if(o>4)throw Error(`Where for rank ${o} is not yet supported`);if(o===1)u="resRC",l="resRC";else{const g=["resRC.x","resRC.y","resRC.z","resRC.w"],A=[],v=[];for(let C=0;C<i.length;C++)v.push(`${g[C]}`),C<t&&A.push(`${g[C]}`);l=A.join(),u=v.join()}const f=ws(o);this.userCode=`
      void main() {
        ${f} resRC = getOutputCoords();
        float cVal = getC(${l});
        if (cVal >= 1.0) {
          setOutput(getA(${u}));
        } else {
          setOutput(getB(${u}));
        }
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Wre(s){const{inputs:t,backend:i}=s,{condition:o,t:l,e:u}=t,f=new Vre(o.shape.length,l.shape,l.shape.length);return i.runWebGLProgram(f,[o,l,u],ar(l.dtype,u.dtype))}const Hre={kernelName:zm,backendName:"webgl",kernelFunc:Wre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Xre=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${V1};
  float scale = ${W1};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Qre=Di({opSnippet:Xre}),Kre={kernelName:Af,backendName:"webgl",kernelFunc:Qre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Zre=f0+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,$re=Di({opSnippet:Zre,packedOpSnippet:`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:Qq}),Yre={kernelName:xf,backendName:"webgl",kernelFunc:$re};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const jre=Di({opSnippet:`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`}),qre={kernelName:vf,backendName:"webgl",kernelFunc:jre};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Jre=f0+`
  return sin(x);
`,eae=Di({opSnippet:Jre}),tae={kernelName:bf,backendName:"webgl",kernelFunc:eae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const nae=Di({opSnippet:`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`}),iae={kernelName:yf,backendName:"webgl",kernelFunc:nae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const sae=Di({opSnippet:`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`}),rae={kernelName:wf,backendName:"webgl",kernelFunc:sae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aae={kernelName:Wm,backendName:"webgl",kernelFunc:s=>{const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{blockShape:u,paddings:f}=o;E(l.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const g=u.reduce((U,V)=>U*V),A=[[0,0]];A.push(...f);for(let U=1+u.length;U<l.shape.length;++U)A.push([0,0]);const v=[],C=nF({inputs:{x:l},backend:i,attrs:{paddings:A,constantValue:0}}),S=zb(C.shape,u,g,!1),M=Vb(S.length,u.length,!1),_=Wb(C.shape,u,g,!1),B=rn({inputs:{x:C},backend:i,attrs:{shape:S}}),F=ga({inputs:{x:B},backend:i,attrs:{perm:M}}),P=rn({inputs:{x:F},backend:i,attrs:{shape:_}});return v.push(C),v.push(B),v.push(F),v.forEach(U=>i.disposeIntermediateTensorInfo(U)),P}};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oae(s){const{inputs:t,backend:i}=s,{indices:o,values:l,denseShape:u,defaultValue:f}=t;if(u.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${u.shape}`);if(o.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${o.shape}`);if(l.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${l.shape}`);if(f.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${f.shape}`);const g=i.readSync(o.dataId),A=i.readSync(l.dataId),v=i.readSync(u.dataId),C=i.readSync(f.dataId)[0],[S,M,_,B,F]=Zq(g,o.shape,o.dtype,A,l.dtype,v,C);return[i.makeTensorInfo(M,o.dtype,S),i.makeTensorInfo([M[0]],l.dtype,_),i.makeTensorInfo([B.length],"bool",new Uint8Array(B.map(P=>Number(P)))),i.makeTensorInfo([F.length],o.dtype,new Int32Array(F))]}const lae={kernelName:gA,backendName:"webgl",kernelFunc:oae};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function cae(s){const{inputs:t,backend:i}=s,{inputIndices:o,inputShape:l,newShape:u}=t;if(o.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${o.shape}`);if(l.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${l.shape}`);if(u.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${u.shape}`);const f=Array.from(i.readSync(l.dataId)),g=i.readSync(o.dataId),A=Array.from(i.readSync(u.dataId)),[v,C,S]=$q(g,o.shape,o.dtype,f,A);return[i.makeTensorInfo(C,o.dtype,v),i.makeTensorInfo([S.length],u.dtype,new Int32Array(S))]}const uae={kernelName:AA,backendName:"webgl",kernelFunc:cae};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function hae(s){const{inputs:t,backend:i}=s,{data:o,indices:l,segmentIds:u}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(l.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${l.shape}`);if(u.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${u.shape}`);const f=i.readSync(o.dataId),g=i.readSync(l.dataId),A=i.readSync(u.dataId),[v,C]=lD(f,o.shape,o.dtype,g,A,!0);return i.makeTensorInfo(C,o.dtype,v)}const dae={kernelName:bA,backendName:"webgl",kernelFunc:hae};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function fae(s){const{inputs:t,backend:i}=s,{data:o,indices:l,segmentIds:u}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(l.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${l.shape}`);if(u.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${u.shape}`);const f=i.readSync(o.dataId),g=i.readSync(l.dataId),A=i.readSync(u.dataId),[v,C]=lD(f,o.shape,o.dtype,g,A);return i.makeTensorInfo(C,o.dtype,v)}const pae={kernelName:Nu,backendName:"webgl",kernelFunc:fae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function mae(s){const{inputs:t,backend:i,attrs:o}=s,{sparseIndices:l,sparseValues:u,defaultValue:f}=t,{outputShape:g}=o,{sliceRank:A,numUpdates:v,sliceSize:C,strides:S,outputSize:M}=Jf(u,l,g),_=!1;if(u.dtype==="string"){const U=i.bufferSync(l),V=i.bufferSync(u),$=oa(i.readSync(f.dataId)[0]),q=Xq(U,V,g,M,C,v,A,S,$,_);return i.makeTensorInfo(g,q.dtype,q.values)}const B=new sF(v,A,l.shape.length,u.shape.length,S,[M,1],_),F=i.runWebGLProgram(B,[u,l,f],u.dtype),P=rn({inputs:{x:F},backend:i,attrs:{shape:g}});return i.disposeIntermediateTensorInfo(F),P}const gae={kernelName:jv,backendName:"webgl",kernelFunc:mae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Aae(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{numOrSizeSplits:u,axis:f}=o,g=J(f,l.shape)[0],A=SI(l,u,g),v=l.shape.length,C=new Array(v).fill(0),S=l.shape.slice();return A.map(M=>{const _=[...S];_[g]=M;const B=p0({inputs:{x:l},backend:i,attrs:{begin:C,size:_}});return C[g]+=M,B})}const bae={kernelName:Cf,backendName:"webgl",kernelFunc:Aae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const rF="return sqrt(x);",yae=Di({opSnippet:rF,packedOpSnippet:rF,cpuKernelImpl:Yq}),vae={kernelName:Lu,backendName:"webgl",kernelFunc:yae};/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const xae=Di({opSnippet:"return x * x;"}),wae={kernelName:yA,backendName:"webgl",kernelFunc:xae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const aF="return (a - b) * (a - b);",Cae=Wr({opSnippet:aF,packedOpSnippet:aF}),Eae={kernelName:Sf,backendName:"webgl",kernelFunc:Cae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Sae({inputs:s,attrs:t,backend:i}){const{x:o}=s,l=Il+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,u=new ah(o.shape,l);return i.runWebGLProgram(u,[o],o.dtype)}const Iae={kernelName:Rf,backendName:"webgl",kernelFunc:Sae};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Tae{constructor(t,i,o){this.variableNames=["x"],this.outputShape=o;const l=o.length,u=ws(o.length),f=ws(o.length);let g="";if(l===1)g="coords * strides + begin";else{let A=0;g=o.map((v,C)=>(A++,o.length===1?`coords * strides[${C}] + begin[${C}]`:`coords[${A-1}] * strides[${C}] + begin[${C}]`)).join(",")}this.userCode=`
      ${u} begin = ${u}(${t});
      ${u} strides = ${u}(${i});

      void main() {
        ${f} coords = getOutputCoords();
        setOutput(getX(${g}));
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Mae(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{begin:u,end:f,strides:g,beginMask:A,endMask:v,ellipsisMask:C,newAxisMask:S,shrinkAxisMask:M}=o,{finalShapeSparse:_,finalShape:B,isIdentity:F,sliceDim0:P,isSimpleSlice:U,begin:V,end:$,strides:q}=nb(l.shape,u,f,g,A,v,C,S,M);let ne;if(F)ne=rn({inputs:{x:l},backend:i,attrs:{shape:B}});else if(P||U){E(l.shape.length>=1,()=>`Input must have rank at least 1, got: ${l.shape.length}`);const me=fg(V,$,q),pe=p0({inputs:{x:l},backend:i,attrs:{begin:V,size:me}});ne=rn({inputs:{x:pe},backend:i,attrs:{shape:B}}),i.disposeIntermediateTensorInfo(pe)}else if(i.shouldExecuteOnCPU([l])){const me=i.readSync(l.dataId),pe=On(l.shape,l.dtype,me),ye=jq(_,pe,q,V);ne=i.makeTensorInfo(B,l.dtype,ye.values)}else{const me=new Tae(V,q,_);ne=i.runWebGLProgram(me,[l],l.dtype)}const he=rn({inputs:{x:ne},backend:i,attrs:{shape:B}});return i.disposeIntermediateTensorInfo(ne),he}const _ae={kernelName:Hm,backendName:"webgl",kernelFunc:Mae};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Rae(s){const{inputs:t,backend:i,attrs:o}=s,{separator:l,nGramWidths:u,leftPad:f,rightPad:g,padWidth:A,preserveShortSequences:v}=o,{data:C,dataSplits:S}=t,M=i.readSync(C.dataId),_=i.readSync(S.dataId),[B,F]=qq(M,_,l,u,f,g,A,v);return[i.makeTensorInfo([B.length],"string",B),i.makeTensorInfo(S.shape,"int32",F)]}const kae={kernelName:vA,backendName:"webgl",kernelFunc:Rae};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Bae(s){const{inputs:t,backend:i,attrs:o}=s,{skipEmpty:l}=o,{input:u,delimiter:f}=t;if(u.dtype!=="string")throw new Error("Input must be of datatype string");if(u.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${u.shape}`);if(f.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${f.shape}`);const g=i.readSync(u.dataId),A=i.readSync(f.dataId)[0],[v,C,S]=Jq(g,A,l),M=C.length;return[i.makeTensorInfo([M,2],"int32",v),i.makeTensorInfo([M],"string",C),i.makeTensorInfo([2],"int32",new Int32Array(S))]}const Lae={kernelName:Vh,backendName:"webgl",kernelFunc:Bae};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Nae(s){const{inputs:t,backend:i,attrs:o}=s,{numBuckets:l}=o,{input:u}=t;if(u.dtype!=="string")throw new Error("Input must be of datatype string");if(l<=0)throw new Error("Number of buckets must be at least 1");const f=i.readSync(u.dataId),g=eJ(f,l);return i.makeTensorInfo(u.shape,"int32",g)}const Dae={kernelName:Wh,backendName:"webgl",kernelFunc:Nae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Fae=Di({opSnippet:"return tan(x);"}),Oae={kernelName:_c,backendName:"webgl",kernelFunc:Fae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const Gae=Di({opSnippet:`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`}),Uae={kernelName:Hh,backendName:"webgl",kernelFunc:Gae};/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Pae{constructor(t,i){this.variableNames=["A"];const o=new Array(t.length);for(let f=0;f<o.length;f++)o[f]=t[f]*i[f];this.outputShape=o,this.rank=o.length;const l=ws(this.rank),u=zae(t);this.userCode=`
      void main() {
        ${l} resRC = getOutputCoords();
        setOutput(getA(${u}));
      }
    `}}function zae(s){const t=s.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${s[0]})`;const i=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],o=[];for(let l=0;l<s.length;l++)o.push(`imod(${i[l]}, ${s[l]})`);return o.join()}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function oF(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{reps:u}=o;if(l.dtype==="string"||l.shape.length>5){const g=i.readSync(l.dataId),A=l.dtype==="string"?g.map(S=>oa(S)):g,v=On(l.shape,l.dtype,A),C=nJ(v,u);return i.makeTensorInfo(C.shape,C.dtype,C.values)}const f=new Pae(l.shape,u);return i.runWebGLProgram(f,[l],l.dtype)}const Vae={kernelName:Xh,backendName:"webgl",kernelFunc:oF};class Wae{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Hae{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Xp(s,t){t!==null&&s.disposeIntermediateTensorInfo(t)}function lF(s){let t=1;for(;t<s;)t*=2;return t}function Xae(s){const{inputs:t,backend:i,attrs:o}=s,{x:l}=t,{k:u,sorted:f}=o,g=Ee().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),A=Ee().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),v=l.shape,C=v[v.length-1];if(i.shouldExecuteOnCPU([l])||C<g||u>A){const ye=i.readSync(l.dataId),[Te,Ye]=iJ(ye,v,l.dtype,u,f);return[i.makeTensorInfo(Te.shape,Te.dtype,Te.values),i.makeTensorInfo(Ye.shape,Ye.dtype,Ye.values)]}if(u===0)return v[v.length-1]=0,[i.makeTensorInfo(v,l.dtype,[]),i.makeTensorInfo(v,"int32",[])];if(C===1)return[l,Ey({attrs:{shape:v,dtype:"int32",value:0},backend:i})];const S=i.texData.get(l.dataId),M=S!==null&&S.isPacked,_=M?i.unpackTensor(l):l,B=N(v)/C,F=rn({inputs:{x:_},attrs:{shape:[B,C]},backend:i});M&&Xp(i,_);const P=lF(u),U=lF(C);let V=null;const $=()=>V===null?[F,F]:[F,V],q=(ye,Te,Ye)=>{const et=$(),nt=new Wae(Ye),ht=[[C],[V===null?1:0],[Number.NEGATIVE_INFINITY],[ye],[Te]],ct=V;V=i.runWebGLProgram(nt,et,"int32",ht),Xp(i,ct)};for(let ye=1;ye<P;ye*=2){const Te=ye*2;for(let Ye=ye;Ye>=1;Ye/=2)q(Te,Ye,[B,U])}for(let ye=U;ye>P;ye/=2){const Te=$(),Ye=new Hae([B,ye/2]),et=[[C],[V===null?1:0],[P]],nt=V;V=i.runWebGLProgram(Ye,Te,"int32",et),Xp(i,nt);const ht=P/2,ct=ht*2;for(let pt=ht;pt>=1;pt/=2)q(ct,pt,V.shape)}let ne=V;V=p0({inputs:{x:V},backend:i,attrs:{begin:0,size:[B,u]}}),Xp(i,ne);let he=$D({inputs:{x:F,indices:V},backend:i,attrs:{axis:1,batchDims:1}});Xp(i,F);const me=v.slice(0,-1);me.push(u),ne=V,V=rn({inputs:{x:V},attrs:{shape:me},backend:i}),Xp(i,ne);const pe=he;return he=rn({inputs:{x:he},attrs:{shape:me},backend:i}),Xp(i,pe),[he,V]}const Qae={kernelName:Tf,backendName:"webgl",kernelFunc:Xae};/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Kae{constructor(t,i,o,l,u,f){this.variableNames=["Image","Transforms"],this.outputShape=f;const g=o==="nearest"?1:2;let A;switch(l){case"constant":A=1;break;case"reflect":A=2;break;case"wrap":A=3;break;case"nearest":A=4;break;default:A=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${A} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${A} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${A} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${i}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${u});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${u});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${i}));
                float mapY = mapCoord(inY, float(${t}));

                if (${g} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Zae(s){const{inputs:t,backend:i,attrs:o}=s,{image:l,transforms:u}=t,{interpolation:f,fillMode:g,fillValue:A,outputShape:v}=o,[C,S,M,_]=l.shape,[B,F]=v??[S,M],P=[C,B,F,_],U=new Kae(S,M,f,g,A,P);return i.runWebGLProgram(U,[l,u],"float32")}const $ae={kernelName:Mf,backendName:"webgl",kernelFunc:Zae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the License);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an AS IS BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function Yae(s){const{inputs:t,attrs:i,backend:o}=s,{axis:l}=i,{x:u}=t;py(u,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const f=o.readSync(u.dataId),{outputValues:g,outputShape:A,indices:v}=sJ(f,l,u.shape,u.dtype);return[o.makeTensorInfo(A,u.dtype,g),o.makeTensorInfo([v.length],"int32",v)]}const jae={kernelName:Xm,backendName:"webgl",kernelFunc:Yae};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function qae(s){const{inputs:t,backend:i,attrs:o}=s,{value:l}=t;let{axis:u}=o;u<0&&(u+=l.shape.length);const f=l,g=f.shape.length,A=l.shape[u],v=new Array(g-1);let C=0;for(let F=0;F<g;F++)F!==u&&(v[C++]=f.shape[F]);const S=[],M=new Array(g).fill(0),_=f.shape.slice();_[u]=1;const B=new Array(A);for(let F=0;F<B.length;F++){M[u]=F;const P=p0({inputs:{x:f},backend:i,attrs:{begin:M,size:_}}),U=rn({inputs:{x:P},backend:i,attrs:{shape:v}});B[F]=U,S.push(P)}return S.forEach(F=>i.disposeIntermediateTensorInfo(F)),B}const Jae={kernelName:_f,backendName:"webgl",kernelFunc:qae};/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class eoe{constructor(t,i){this.variableNames=["x","segmentIds"];const o=t.windowSize,l=t.batchSize,u=t.inSize,f=t.numSegments,g=f*Math.ceil(u/o);this.outputShape=[l,g];const A="0.0",v="sumValue",C=Math.floor(o/4)*4,S=o%4,M=`
        sumValue += dot(values, segFilter);
    `;let _="";u%o>0&&(_=`
        if (inIdx < 0 || inIdx >= ${u}) {
          return initializationValue;
        }
      `);let B="";u%o>0&&(B=`
        if (inIdx < 0 || inIdx >= ${u}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${A};

      float getValue(int batch, int inIdx) {
        ${_}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${B}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${f})) * float(${o}));
        int currentSeg = int(mod(float(outIdx), float(${f})));

        float sumValue = 0.0;

        for (int i = 0; i < ${C}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${M}
        }

        int inIdx = inOffset + ${C};
        if (${S===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${M}
        } else if (${S===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${M}
        } else if (${S===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${M}
        }
        setOutput(${v});
      }
    `}}/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function toe(s){const{inputs:t,backend:i,attrs:o}=s,{x:l,segmentIds:u}=t,{numSegments:f}=o,g=l.shape.length,A=[];let v=0;const C=ji([v],g);let S=l;C!=null&&(S=ga({inputs:{x:l},backend:i,attrs:{perm:C}}),A.push(S),v=Ss(1,g)[0]);const M=IB(S.shape,v,f),_=N([S.shape[v]]),B=rn({inputs:{x:S},backend:i,attrs:{shape:[-1,_]}});A.push(B);const F=Hf(l.dtype),P=(q,ne,he,me,pe)=>{const ye=q.shape[0],Te=q.shape[1],Ye=SB(Te,pe),et={windowSize:Ye,inSize:Te,batchSize:ye,numSegments:pe},nt=new eoe(et,ne),ht=i.compileAndRun(nt,[q,he],me);if(A.push(ht),ht.shape[1]===pe)return ht;const ct=iF({backend:i,attrs:{start:0,stop:pe,step:1,dtype:"float32"}}),pt=oF({inputs:{x:ct},backend:i,attrs:{reps:[Te/Ye]}});return A.push(ct),A.push(pt),P(ht,ne,pt,me,pe)},U=P(B,"unsortedSegmentSum",u,F,f),V=rn({inputs:{x:U},backend:i,attrs:{shape:M}});let $=V;if(C!=null){A.push(V);const q=gl(C);$=ga({inputs:{x:$},backend:i,attrs:{perm:q}})}return A.forEach(q=>i.disposeIntermediateTensorInfo(q)),$}const noe={kernelName:Qm,backendName:"webgl",kernelFunc:toe};/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/const ioe=[$J,jJ,eee,iee,ree,lee,uee,dee,gee,bee,xee,Eee,Tee,kee,Nee,Fee,Gee,Vee,Hee,Qee,$ee,tte,ite,rte,ute,dte,gte,BJ,yte,Ete,Mte,Nte,Fte,Gte,Pte,Vte,Xte,Kte,$te,jte,Jte,tne,sne,ane,une,dne,mne,bne,vne,wne,Sne,Tne,Rne,Bne,Lne,Dne,One,Une,zne,Wne,Xne,Zne,jne,Jne,nie,rie,oie,cie,kJ,hie,wte,fie,mie,Aie,NJ,yie,xie,Cie,Iie,_ie,kie,Lie,Die,Gie,Pie,Vie,Qie,Zie,Yie,ese,nse,sse,ase,lse,dse,mse,yse,Sse,OJ,_se,Bse,Dse,Gse,ate,Pse,Vse,Hse,Kse,jse,FJ,Jse,tre,ire,sre,ote,xse,are,cre,dre,UJ,gre,yre,Cre,Ire,Rre,Bre,Nre,Fre,Gre,zre,Hre,Kre,Yre,qre,tae,iae,ete,Cse,rae,aae,lae,uae,dae,pae,gae,bae,vae,wae,Eae,Iae,_ae,kae,Lae,Dae,wse,QJ,Oae,Uae,Vae,Qae,$ae,KJ,jae,Jae,noe,zse];for(const s of ioe)Ir(s);const cF="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIEd0e2NvbnN0cnVjdG9yKGU9W10sbj1RdCl7aWYodGhpcy5kYXRhPWUsdGhpcy5sZW5ndGg9dGhpcy5kYXRhLmxlbmd0aCx0aGlzLmNvbXBhcmU9bix0aGlzLmxlbmd0aD4wKWZvcihsZXQgdD0odGhpcy5sZW5ndGg+PjEpLTE7dD49MDt0LS0pdGhpcy5fZG93bih0KX1wdXNoKGUpe3RoaXMuZGF0YS5wdXNoKGUpLHRoaXMubGVuZ3RoKyssdGhpcy5fdXAodGhpcy5sZW5ndGgtMSl9cG9wKCl7aWYodGhpcy5sZW5ndGg9PT0wKXJldHVybjtjb25zdCBlPXRoaXMuZGF0YVswXSxuPXRoaXMuZGF0YS5wb3AoKTtyZXR1cm4gdGhpcy5sZW5ndGgtLSx0aGlzLmxlbmd0aD4wJiYodGhpcy5kYXRhWzBdPW4sdGhpcy5fZG93bigwKSksZX1wZWVrKCl7cmV0dXJuIHRoaXMuZGF0YVswXX1fdXAoZSl7Y29uc3R7ZGF0YTpuLGNvbXBhcmU6dH09dGhpcyxzPW5bZV07Zm9yKDtlPjA7KXtjb25zdCByPWUtMT4+MSxpPW5bcl07aWYodChzLGkpPj0wKWJyZWFrO25bZV09aSxlPXJ9bltlXT1zfV9kb3duKGUpe2NvbnN0e2RhdGE6bixjb21wYXJlOnR9PXRoaXMscz10aGlzLmxlbmd0aD4+MSxyPW5bZV07Zm9yKDtlPHM7KXtsZXQgaT0oZTw8MSkrMSxoPW5baV07Y29uc3QgbD1pKzE7aWYobDx0aGlzLmxlbmd0aCYmdChuW2xdLGgpPDAmJihpPWwsaD1uW2xdKSx0KGgscik+PTApYnJlYWs7bltlXT1oLGU9aX1uW2VdPXJ9fWZ1bmN0aW9uIFF0KG8sZSl7cmV0dXJuIG88ZT8tMTpvPmU/MTowfWNvbnN0IHl0PW89Pntjb25zdHt2MTplLHYyOm59PW87bGV0IHQ9MDtmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKyl7bGV0IHI9KGVbc11ebltzXSk+Pj4wO3QrPVd0KHIpfXJldHVybiB0fSxXdD1vPT57dmFyIGU9by0obz4+MSYxNDMxNjU1NzY1KTtyZXR1cm4gZT0oZT4+MiY4NTg5OTM0NTkpKyhlJjg1ODk5MzQ1OSksZT0oZT4+NCkrZSYyNTI2NDUxMzUsZT0oZT4+OCkrZSYxNjcxMTkzNSxlPShlPj4xNikrZSY2NTUzNSxlfSx1dD0xLE50PW89Pntjb25zdHtrZXl3aWR0aDplLGtleWhlaWdodDpuLHF1ZXJ5d2lkdGg6dCxxdWVyeWhlaWdodDpzLG1hdGNoZXM6cn09byxpPXQqMS4yLGg9LWksbD1zKjEuMix1PS1sLGY9MTIsZz0xMCxhPS0xLGo9MSx5PTEvTWF0aC5sb2coMTApLG09TWF0aC5tYXgoZSxuKSxNPU1hdGguZmxvb3IoZS8yKSx6PU1hdGguZmxvb3Iobi8yKSxFPVtdO2ZvcihsZXQgdj0wO3Y8ci5sZW5ndGg7disrKXtjb25zdCBWPXJbdl0ucXVlcnlwb2ludC5zY2FsZSxKPXJbdl0ua2V5cG9pbnQuc2NhbGU7Sj09MCYmY29uc29sZS5sb2coIkVSUk9SIGRpdmlkZSB6ZXJvIik7Y29uc3QgTj1WL0o7RS5wdXNoKE4qbSl9RS5zb3J0KCh2LFYpPT52LVYpO2NvbnN0IFI9LjI1KkVbTWF0aC5mbG9vcihFLmxlbmd0aC8yKS0oRS5sZW5ndGglMj09MD8xOjApLTFdLHE9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGktaCkvUikpLGI9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGwtdSkvUikpLEY9cSpiLFg9RipmLGM9W10scD1bXSxTPXt9O2ZvcihsZXQgdj0wO3Y8ci5sZW5ndGg7disrKXtjb25zdCBWPXJbdl0ucXVlcnlwb2ludCxKPXJbdl0ua2V5cG9pbnQse3g6Tix5OkIsc2NhbGU6JCxhbmdsZTpDfT1adCh7cXVlcnlwb2ludDpWLGtleXBvaW50Okosa2V5Y2VudGVyWDpNLGtleWNlbnRlclk6eixzY2FsZU9uZU92ZXJMb2dLOnl9KTtpZihOPGh8fE4+PWl8fEI8dXx8Qj49bHx8Qzw9LU1hdGguUEl8fEM+TWF0aC5QSXx8JDxhfHwkPj1qKXtjW3ZdPSExO2NvbnRpbnVlfWxldCBVPXEqKE4taCkvKGktaCksd3Q9YiooQi11KS8obC11KSxwdD1mKihDK01hdGguUEkpLygyKk1hdGguUEkpLGR0PWcqKCQtYSkvKGotYSk7cFt2XT17YmluWDpVLGJpblk6d3QsYmluQW5nbGU6cHQsYmluU2NhbGU6ZHR9O2xldCBydD1NYXRoLmZsb29yKFUtLjUpLGl0PU1hdGguZmxvb3Iod3QtLjUpLGx0PU1hdGguZmxvb3IoZHQtLjUpLGp0PShNYXRoLmZsb29yKHB0LS41KStmKSVmO2lmKHJ0PDB8fHJ0KzE+PXF8fGl0PDB8fGl0KzE+PWJ8fGx0PDB8fGx0KzE+PWcpe2Nbdl09ITE7Y29udGludWV9Zm9yKGxldCBodD0wO2h0PDI7aHQrKyl7bGV0IGt0PXJ0K2h0O2ZvcihsZXQgYnQ9MDtidDwyO2J0Kyspe2xldCBobj1pdCtidDtmb3IobGV0IEl0PTA7SXQ8MjtJdCsrKXtsZXQgdW49KGp0K0l0KSVmO2ZvcihsZXQgUnQ9MDtSdDwyO1J0Kyspe2xldCBjbj1sdCtSdDtjb25zdCB2dD1rdCtobipxK3VuKkYrY24qWDtTW3Z0XT09PXZvaWQgMCYmKFNbdnRdPTApLFNbdnRdKz0xfX19fWNbdl09ITB9bGV0IGQ9MCxQPS0xO2lmKE9iamVjdC5rZXlzKFMpLmZvckVhY2godj0+e1Nbdl0+ZCYmKGQ9U1t2XSxQPXYpfSksZDwzKXJldHVybltdO2NvbnN0IE89TWF0aC5mbG9vcihQJVglRiVxKSxUPU1hdGguZmxvb3IoKFAtTyklWCVGL3EpLEQ9TWF0aC5mbG9vcigoUC1PLVQqcSklWC9GKSxZPU1hdGguZmxvb3IoKFAtTy1UKnEtRCpGKS9YKSxHPVtdO2ZvcihsZXQgdj0wO3Y8ci5sZW5ndGg7disrKXtpZighY1t2XSljb250aW51ZTtjb25zdCBWPXBbdl07aWYoTWF0aC5hYnMoVi5iaW5YLShPKy41KSk+PXV0fHxNYXRoLmFicyhWLmJpblktKFQrLjUpKT49dXR8fE1hdGguYWJzKFYuYmluU2NhbGUtKFkrLjUpKT49dXQpY29udGludWU7Y29uc3QgJD1NYXRoLmFicyhWLmJpbkFuZ2xlLShEKy41KSk7TWF0aC5taW4oJCxmLSQpPj11dHx8Ry5wdXNoKHJbdl0pfXJldHVybiBHfSxadD0oe3F1ZXJ5cG9pbnQ6byxrZXlwb2ludDplLGtleWNlbnRlclg6bixrZXljZW50ZXJZOnQsc2NhbGVPbmVPdmVyTG9nSzpzfSk9PntsZXQgcj1vLmFuZ2xlLWUuYW5nbGU7cjw9LU1hdGguUEk/cis9MipNYXRoLlBJOnI+TWF0aC5QSSYmKHItPTIqTWF0aC5QSSk7Y29uc3QgaT1vLnNjYWxlL2Uuc2NhbGUsaD1pKk1hdGguY29zKHIpLGw9aSpNYXRoLnNpbihyKSx1PVtoLC1sLGwsaF0sZj1bdVswXSplLngrdVsxXSplLnksdVsyXSplLngrdVszXSplLnldLGc9by54LWZbMF0sYT1vLnktZlsxXTtyZXR1cm57eDp1WzBdKm4rdVsxXSp0K2cseTp1WzJdKm4rdVszXSp0K2EsYW5nbGU6cixzY2FsZTpNYXRoLmxvZyhpKSpzfX0seHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmdW5jdGlvbiBjdChvKXtyZXR1cm4geHQuY2FsbChvKS5lbmRzV2l0aCgiQXJyYXldIil9ZnVuY3Rpb24gQXQobyl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOnt9O2lmKCFjdChvKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnB1dCBtdXN0IGJlIGFuIGFycmF5Iik7aWYoby5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3Qgbm90IGJlIGVtcHR5Iik7dmFyIG49ZS5mcm9tSW5kZXgsdD1uPT09dm9pZCAwPzA6bixzPWUudG9JbmRleCxyPXM9PT12b2lkIDA/by5sZW5ndGg6cztpZih0PDB8fHQ+PW8ubGVuZ3RofHwhTnVtYmVyLmlzSW50ZWdlcih0KSl0aHJvdyBuZXcgRXJyb3IoImZyb21JbmRleCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBzbWFsbGVyIHRoYW4gbGVuZ3RoIik7aWYocjw9dHx8cj5vLmxlbmd0aHx8IU51bWJlci5pc0ludGVnZXIocikpdGhyb3cgbmV3IEVycm9yKCJ0b0luZGV4IG11c3QgYmUgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gZnJvbUluZGV4IGFuZCBhdCBtb3N0IGVxdWFsIHRvIGxlbmd0aCIpO2Zvcih2YXIgaT1vW3RdLGg9dCsxO2g8cjtoKyspb1toXT5pJiYoaT1vW2hdKTtyZXR1cm4gaX1mdW5jdGlvbiB0ZShvKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e307aWYoIWN0KG8pKXRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKTt2YXIgbj1lLmZyb21JbmRleCx0PW49PT12b2lkIDA/MDpuLHM9ZS50b0luZGV4LHI9cz09PXZvaWQgMD9vLmxlbmd0aDpzO2lmKHQ8MHx8dD49by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHQpKXRocm93IG5ldyBFcnJvcigiZnJvbUluZGV4IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHNtYWxsZXIgdGhhbiBsZW5ndGgiKTtpZihyPD10fHxyPm8ubGVuZ3RofHwhTnVtYmVyLmlzSW50ZWdlcihyKSl0aHJvdyBuZXcgRXJyb3IoInRvSW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBmcm9tSW5kZXggYW5kIGF0IG1vc3QgZXF1YWwgdG8gbGVuZ3RoIik7Zm9yKHZhciBpPW9bdF0saD10KzE7aDxyO2grKylvW2hdPGkmJihpPW9baF0pO3JldHVybiBpfWZ1bmN0aW9uIHF0KG8pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7fTtpZihjdChvKSl7aWYoby5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3Qgbm90IGJlIGVtcHR5Iil9ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnB1dCBtdXN0IGJlIGFuIGFycmF5Iik7dmFyIG47aWYoZS5vdXRwdXQhPT12b2lkIDApe2lmKCFjdChlLm91dHB1dCkpdGhyb3cgbmV3IFR5cGVFcnJvcigib3V0cHV0IG9wdGlvbiBtdXN0IGJlIGFuIGFycmF5IGlmIHNwZWNpZmllZCIpO249ZS5vdXRwdXR9ZWxzZSBuPW5ldyBBcnJheShvLmxlbmd0aCk7dmFyIHQ9dGUobykscz1BdChvKTtpZih0PT09cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigibWluaW11bSBhbmQgbWF4aW11bSBpbnB1dCB2YWx1ZXMgYXJlIGVxdWFsLiBDYW5ub3QgcmVzY2FsZSBhIGNvbnN0YW50IGFycmF5Iik7dmFyIHI9ZS5taW4saT1yPT09dm9pZCAwP2UuYXV0b01pbk1heD90OjA6cixoPWUubWF4LGw9aD09PXZvaWQgMD9lLmF1dG9NaW5NYXg/czoxOmg7aWYoaT49bCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigibWluIG9wdGlvbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXggb3B0aW9uIik7Zm9yKHZhciB1PShsLWkpLyhzLXQpLGY9MDtmPG8ubGVuZ3RoO2YrKyluW2ZdPShvW2ZdLXQpKnUraTtyZXR1cm4gbn1jb25zdCBmdD0iICIucmVwZWF0KDIpLF90PSIgIi5yZXBlYXQoNCk7ZnVuY3Rpb24gZWUoKXtyZXR1cm4genQodGhpcyl9ZnVuY3Rpb24genQobyxlPXt9KXtjb25zdHttYXhSb3dzOm49MTUsbWF4Q29sdW1uczp0PTEwLG1heE51bVNpemU6cz04fT1lO3JldHVybmAke28uY29uc3RydWN0b3IubmFtZX0gewoke2Z0fVsKJHtfdH0ke25lKG8sbix0LHMpfQoke2Z0fV0KJHtmdH1yb3dzOiAke28ucm93c30KJHtmdH1jb2x1bW5zOiAke28uY29sdW1uc30KfWB9ZnVuY3Rpb24gbmUobyxlLG4sdCl7Y29uc3R7cm93czpzLGNvbHVtbnM6cn09byxpPU1hdGgubWluKHMsZSksaD1NYXRoLm1pbihyLG4pLGw9W107Zm9yKGxldCB1PTA7dTxpO3UrKyl7bGV0IGY9W107Zm9yKGxldCBnPTA7ZzxoO2crKylmLnB1c2goc2Uoby5nZXQodSxnKSx0KSk7bC5wdXNoKGAke2Yuam9pbigiICIpfWApfXJldHVybiBoIT09ciYmKGxbbC5sZW5ndGgtMV0rPWAgLi4uICR7ci1ufSBtb3JlIGNvbHVtbnNgKSxpIT09cyYmbC5wdXNoKGAuLi4gJHtzLWV9IG1vcmUgcm93c2ApLGwuam9pbihgCiR7X3R9YCl9ZnVuY3Rpb24gc2UobyxlKXtjb25zdCBuPVN0cmluZyhvKTtpZihuLmxlbmd0aDw9ZSlyZXR1cm4gbi5wYWRFbmQoZSwiICIpO2NvbnN0IHQ9by50b1ByZWNpc2lvbihlLTIpO2lmKHQubGVuZ3RoPD1lKXJldHVybiB0O2NvbnN0IHM9by50b0V4cG9uZW50aWFsKGUtMikscj1zLmluZGV4T2YoImUiKSxpPXMuc2xpY2Uocik7cmV0dXJuIHMuc2xpY2UoMCxlLWkubGVuZ3RoKStpfWZ1bmN0aW9uIG9lKG8sZSl7by5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5hZGRTKHQpOnRoaXMuYWRkTSh0KX0sby5wcm90b3R5cGUuYWRkUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpK3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5hZGRNPWZ1bmN0aW9uKHQpe2lmKHQ9ZS5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSt0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5hZGQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IGUodCkuYWRkKHMpfSxvLnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnN1YlModCk6dGhpcy5zdWJNKHQpfSxvLnByb3RvdHlwZS5zdWJTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciktdCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLnN1Yk09ZnVuY3Rpb24odCl7aWYodD1lLmNoZWNrTWF0cml4KHQpLHRoaXMucm93cyE9PXQucm93c3x8dGhpcy5jb2x1bW5zIT09dC5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwiKTtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpLXQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnN1Yj1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgZSh0KS5zdWIocyl9LG8ucHJvdG90eXBlLnN1YnRyYWN0PW8ucHJvdG90eXBlLnN1YixvLnByb3RvdHlwZS5zdWJ0cmFjdFM9by5wcm90b3R5cGUuc3ViUyxvLnByb3RvdHlwZS5zdWJ0cmFjdE09by5wcm90b3R5cGUuc3ViTSxvLnN1YnRyYWN0PW8uc3ViLG8ucHJvdG90eXBlLm11bD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMubXVsUyh0KTp0aGlzLm11bE0odCl9LG8ucHJvdG90eXBlLm11bFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSp0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubXVsTT1mdW5jdGlvbih0KXtpZih0PWUuY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikqdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ubXVsPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBlKHQpLm11bChzKX0sby5wcm90b3R5cGUubXVsdGlwbHk9by5wcm90b3R5cGUubXVsLG8ucHJvdG90eXBlLm11bHRpcGx5Uz1vLnByb3RvdHlwZS5tdWxTLG8ucHJvdG90eXBlLm11bHRpcGx5TT1vLnByb3RvdHlwZS5tdWxNLG8ubXVsdGlwbHk9by5tdWwsby5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5kaXZTKHQpOnRoaXMuZGl2TSh0KX0sby5wcm90b3R5cGUuZGl2Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpL3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5kaXZNPWZ1bmN0aW9uKHQpe2lmKHQ9ZS5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKS90LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5kaXY9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IGUodCkuZGl2KHMpfSxvLnByb3RvdHlwZS5kaXZpZGU9by5wcm90b3R5cGUuZGl2LG8ucHJvdG90eXBlLmRpdmlkZVM9by5wcm90b3R5cGUuZGl2UyxvLnByb3RvdHlwZS5kaXZpZGVNPW8ucHJvdG90eXBlLmRpdk0sby5kaXZpZGU9by5kaXYsby5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5tb2RTKHQpOnRoaXMubW9kTSh0KX0sby5wcm90b3R5cGUubW9kUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpJXQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5tb2RNPWZ1bmN0aW9uKHQpe2lmKHQ9ZS5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSV0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5tb2Q9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IGUodCkubW9kKHMpfSxvLnByb3RvdHlwZS5tb2R1bHVzPW8ucHJvdG90eXBlLm1vZCxvLnByb3RvdHlwZS5tb2R1bHVzUz1vLnByb3RvdHlwZS5tb2RTLG8ucHJvdG90eXBlLm1vZHVsdXNNPW8ucHJvdG90eXBlLm1vZE0sby5tb2R1bHVzPW8ubW9kLG8ucHJvdG90eXBlLmFuZD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMuYW5kUyh0KTp0aGlzLmFuZE0odCl9LG8ucHJvdG90eXBlLmFuZFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSZ0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUuYW5kTT1mdW5jdGlvbih0KXtpZih0PWUuY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikmdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8uYW5kPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBlKHQpLmFuZChzKX0sby5wcm90b3R5cGUub3I9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLm9yUyh0KTp0aGlzLm9yTSh0KX0sby5wcm90b3R5cGUub3JTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLm9yTT1mdW5jdGlvbih0KXtpZih0PWUuY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ub3I9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IGUodCkub3Iocyl9LG8ucHJvdG90eXBlLnhvcj1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMueG9yUyh0KTp0aGlzLnhvck0odCl9LG8ucHJvdG90eXBlLnhvclM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKV50KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUueG9yTT1mdW5jdGlvbih0KXtpZih0PWUuY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciledC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ueG9yPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBlKHQpLnhvcihzKX0sby5wcm90b3R5cGUubGVmdFNoaWZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5sZWZ0U2hpZnRTKHQpOnRoaXMubGVmdFNoaWZ0TSh0KX0sby5wcm90b3R5cGUubGVmdFNoaWZ0Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpPDx0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubGVmdFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PWUuY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik8PHQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLmxlZnRTaGlmdD1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgZSh0KS5sZWZ0U2hpZnQocyl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTKHQpOnRoaXMuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdE0odCl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PWUuY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IGUodCkuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdChzKX0sby5wcm90b3R5cGUucmlnaHRTaGlmdD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMucmlnaHRTaGlmdFModCk6dGhpcy5yaWdodFNoaWZ0TSh0KX0sby5wcm90b3R5cGUucmlnaHRTaGlmdFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKT4+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5yaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PWUuY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+Pj50LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5yaWdodFNoaWZ0PWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBlKHQpLnJpZ2h0U2hpZnQocyl9LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdD1vLnByb3RvdHlwZS5yaWdodFNoaWZ0LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdFM9by5wcm90b3R5cGUucmlnaHRTaGlmdFMsby5wcm90b3R5cGUuemVyb0ZpbGxSaWdodFNoaWZ0TT1vLnByb3RvdHlwZS5yaWdodFNoaWZ0TSxvLnplcm9GaWxsUmlnaHRTaGlmdD1vLnJpZ2h0U2hpZnQsby5wcm90b3R5cGUubm90PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsfnRoaXMuZ2V0KHQscykpO3JldHVybiB0aGlzfSxvLm5vdD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkubm90KCl9LG8ucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYWJzKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hYnM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLmFicygpfSxvLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hY29zPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KS5hY29zKCl9LG8ucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zaCh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYWNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLmFjb3NoKCl9LG8ucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmFzaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLmFzaW4oKX0sby5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hc2luaD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkuYXNpbmgoKX0sby5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYXRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkuYXRhbigpfSxvLnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmF0YW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KS5hdGFuaCgpfSxvLnByb3RvdHlwZS5jYnJ0PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jYnJ0KHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jYnJ0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KS5jYnJ0KCl9LG8ucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNlaWwodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNlaWw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLmNlaWwoKX0sby5wcm90b3R5cGUuY2x6MzI9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNsejMyKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jbHozMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkuY2x6MzIoKX0sby5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jb3ModGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvcz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkuY29zKCl9LG8ucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNvc2godGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLmNvc2goKX0sby5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHAodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmV4cD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkuZXhwKCl9LG8ucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHBtMSh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZXhwbTE9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLmV4cG0xKCl9LG8ucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5mbG9vcih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZmxvb3I9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLmZsb29yKCl9LG8ucHJvdG90eXBlLmZyb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguZnJvdW5kKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5mcm91bmQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLmZyb3VuZCgpfSxvLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZyh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KS5sb2coKX0sby5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzFwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxcD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkubG9nMXAoKX0sby5wcm90b3R5cGUubG9nMTA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzEwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxMD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkubG9nMTAoKX0sby5wcm90b3R5cGUubG9nMj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgubG9nMih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkubG9nMigpfSxvLnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgucm91bmQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnJvdW5kPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KS5yb3VuZCgpfSxvLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaWduKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaWduPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KS5zaWduKCl9LG8ucHJvdG90eXBlLnNpbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguc2luKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLnNpbigpfSxvLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KS5zaW5oKCl9LG8ucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnNxcnQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnNxcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLnNxcnQoKX0sby5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC50YW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkudGFuKCl9LG8ucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbmg9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpLnRhbmgoKX0sby5wcm90b3R5cGUudHJ1bmM9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRydW5jKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby50cnVuYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCkudHJ1bmMoKX0sby5wb3c9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IGUodCkucG93KHMpfSxvLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnBvd1ModCk6dGhpcy5wb3dNKHQpfSxvLnByb3RvdHlwZS5wb3dTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLE1hdGgucG93KHRoaXMuZ2V0KHMsciksdCkpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5wb3dNPWZ1bmN0aW9uKHQpe2lmKHQ9ZS5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsTWF0aC5wb3codGhpcy5nZXQocyxyKSx0LmdldChzLHIpKSk7cmV0dXJuIHRoaXN9fWZ1bmN0aW9uIFEobyxlLG4pe2xldCB0PW4/by5yb3dzOm8ucm93cy0xO2lmKGU8MHx8ZT50KXRocm93IG5ldyBSYW5nZUVycm9yKCJSb3cgaW5kZXggb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gVyhvLGUsbil7bGV0IHQ9bj9vLmNvbHVtbnM6by5jb2x1bW5zLTE7aWYoZTwwfHxlPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkNvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2UiKX1mdW5jdGlvbiBBKG8sZSl7aWYoZS50bzFEQXJyYXkmJihlPWUudG8xREFycmF5KCkpLGUubGVuZ3RoIT09by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJ2ZWN0b3Igc2l6ZSBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2YgY29sdW1ucyIpO3JldHVybiBlfWZ1bmN0aW9uIHR0KG8sZSl7aWYoZS50bzFEQXJyYXkmJihlPWUudG8xREFycmF5KCkpLGUubGVuZ3RoIT09by5yb3dzKXRocm93IG5ldyBSYW5nZUVycm9yKCJ2ZWN0b3Igc2l6ZSBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2Ygcm93cyIpO3JldHVybiBlfWZ1bmN0aW9uIHJlKG8sZSxuKXtyZXR1cm57cm93OmllKG8sZSksY29sdW1uOmxlKG8sbil9fWZ1bmN0aW9uIGllKG8sZSl7aWYodHlwZW9mIGUhPSJvYmplY3QiKXRocm93IG5ldyBUeXBlRXJyb3IoInVuZXhwZWN0ZWQgdHlwZSBmb3Igcm93IGluZGljZXMiKTtpZihlLnNvbWUodD0+dDwwfHx0Pj1vLnJvd3MpKXRocm93IG5ldyBSYW5nZUVycm9yKCJyb3cgaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIik7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSl8fChlPUFycmF5LmZyb20oZSkpLGV9ZnVuY3Rpb24gbGUobyxlKXtpZih0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigidW5leHBlY3RlZCB0eXBlIGZvciBjb2x1bW4gaW5kaWNlcyIpO2lmKGUuc29tZSh0PT50PDB8fHQ+PW8uY29sdW1ucykpdGhyb3cgbmV3IFJhbmdlRXJyb3IoImNvbHVtbiBpbmRpY2VzIGFyZSBvdXQgb2YgcmFuZ2UiKTtyZXR1cm4gQXJyYXkuaXNBcnJheShlKXx8KGU9QXJyYXkuZnJvbShlKSksZX1mdW5jdGlvbiBGdChvLGUsbix0LHMpe2lmKGFyZ3VtZW50cy5sZW5ndGghPT01KXRocm93IG5ldyBSYW5nZUVycm9yKCJleHBlY3RlZCA0IGFyZ3VtZW50cyIpO2lmKGF0KCJzdGFydFJvdyIsZSksYXQoImVuZFJvdyIsbiksYXQoInN0YXJ0Q29sdW1uIix0KSxhdCgiZW5kQ29sdW1uIixzKSxlPm58fHQ+c3x8ZTwwfHxlPj1vLnJvd3N8fG48MHx8bj49by5yb3dzfHx0PDB8fHQ+PW8uY29sdW1uc3x8czwwfHxzPj1vLmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIlN1Ym1hdHJpeCBpbmRpY2VzIGFyZSBvdXQgb2YgcmFuZ2UiKX1mdW5jdGlvbiBndChvLGU9MCl7bGV0IG49W107Zm9yKGxldCB0PTA7dDxvO3QrKyluLnB1c2goZSk7cmV0dXJuIG59ZnVuY3Rpb24gYXQobyxlKXtpZih0eXBlb2YgZSE9Im51bWJlciIpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtvfSBtdXN0IGJlIGEgbnVtYmVyYCl9ZnVuY3Rpb24gZXQobyl7aWYoby5pc0VtcHR5KCkpdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBtYXRyaXggaGFzIG5vIGVsZW1lbnRzIHRvIGluZGV4Iil9ZnVuY3Rpb24gaGUobyl7bGV0IGU9Z3Qoby5yb3dzKTtmb3IobGV0IG49MDtuPG8ucm93czsrK24pZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7Kyt0KWVbbl0rPW8uZ2V0KG4sdCk7cmV0dXJuIGV9ZnVuY3Rpb24gdWUobyl7bGV0IGU9Z3Qoby5jb2x1bW5zKTtmb3IobGV0IG49MDtuPG8ucm93czsrK24pZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7Kyt0KWVbdF0rPW8uZ2V0KG4sdCk7cmV0dXJuIGV9ZnVuY3Rpb24gY2Uobyl7bGV0IGU9MDtmb3IobGV0IG49MDtuPG8ucm93cztuKyspZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKWUrPW8uZ2V0KG4sdCk7cmV0dXJuIGV9ZnVuY3Rpb24gZmUobyl7bGV0IGU9Z3Qoby5yb3dzLDEpO2ZvcihsZXQgbj0wO248by5yb3dzOysrbilmb3IobGV0IHQ9MDt0PG8uY29sdW1uczsrK3QpZVtuXSo9by5nZXQobix0KTtyZXR1cm4gZX1mdW5jdGlvbiBnZShvKXtsZXQgZT1ndChvLmNvbHVtbnMsMSk7Zm9yKGxldCBuPTA7bjxvLnJvd3M7KytuKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCllW3RdKj1vLmdldChuLHQpO3JldHVybiBlfWZ1bmN0aW9uIGFlKG8pe2xldCBlPTE7Zm9yKGxldCBuPTA7bjxvLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKyllKj1vLmdldChuLHQpO3JldHVybiBlfWZ1bmN0aW9uIG1lKG8sZSxuKXtjb25zdCB0PW8ucm93cyxzPW8uY29sdW1ucyxyPVtdO2ZvcihsZXQgaT0wO2k8dDtpKyspe2xldCBoPTAsbD0wLHU9MDtmb3IobGV0IGY9MDtmPHM7ZisrKXU9by5nZXQoaSxmKS1uW2ldLGgrPXUsbCs9dSp1O2U/ci5wdXNoKChsLWgqaC9zKS8ocy0xKSk6ci5wdXNoKChsLWgqaC9zKS9zKX1yZXR1cm4gcn1mdW5jdGlvbiB3ZShvLGUsbil7Y29uc3QgdD1vLnJvd3Mscz1vLmNvbHVtbnMscj1bXTtmb3IobGV0IGk9MDtpPHM7aSsrKXtsZXQgaD0wLGw9MCx1PTA7Zm9yKGxldCBmPTA7Zjx0O2YrKyl1PW8uZ2V0KGYsaSktbltpXSxoKz11LGwrPXUqdTtlP3IucHVzaCgobC1oKmgvdCkvKHQtMSkpOnIucHVzaCgobC1oKmgvdCkvdCl9cmV0dXJuIHJ9ZnVuY3Rpb24gcGUobyxlLG4pe2NvbnN0IHQ9by5yb3dzLHM9by5jb2x1bW5zLHI9dCpzO2xldCBpPTAsaD0wLGw9MDtmb3IobGV0IHU9MDt1PHQ7dSsrKWZvcihsZXQgZj0wO2Y8cztmKyspbD1vLmdldCh1LGYpLW4saSs9bCxoKz1sKmw7cmV0dXJuIGU/KGgtaSppL3IpLyhyLTEpOihoLWkqaS9yKS9yfWZ1bmN0aW9uIGRlKG8sZSl7Zm9yKGxldCBuPTA7bjxvLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChuLHQsby5nZXQobix0KS1lW25dKX1mdW5jdGlvbiB5ZShvLGUpe2ZvcihsZXQgbj0wO248by5yb3dzO24rKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQobix0LG8uZ2V0KG4sdCktZVt0XSl9ZnVuY3Rpb24gTWUobyxlKXtmb3IobGV0IG49MDtuPG8ucm93cztuKyspZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKW8uc2V0KG4sdCxvLmdldChuLHQpLWUpfWZ1bmN0aW9uIEVlKG8pe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjxvLnJvd3M7bisrKXtsZXQgdD0wO2ZvcihsZXQgcz0wO3M8by5jb2x1bW5zO3MrKyl0Kz1NYXRoLnBvdyhvLmdldChuLHMpLDIpLyhvLmNvbHVtbnMtMSk7ZS5wdXNoKE1hdGguc3FydCh0KSl9cmV0dXJuIGV9ZnVuY3Rpb24gU2UobyxlKXtmb3IobGV0IG49MDtuPG8ucm93cztuKyspZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKW8uc2V0KG4sdCxvLmdldChuLHQpL2Vbbl0pfWZ1bmN0aW9uIGplKG8pe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjxvLmNvbHVtbnM7bisrKXtsZXQgdD0wO2ZvcihsZXQgcz0wO3M8by5yb3dzO3MrKyl0Kz1NYXRoLnBvdyhvLmdldChzLG4pLDIpLyhvLnJvd3MtMSk7ZS5wdXNoKE1hdGguc3FydCh0KSl9cmV0dXJuIGV9ZnVuY3Rpb24ga2UobyxlKXtmb3IobGV0IG49MDtuPG8ucm93cztuKyspZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKW8uc2V0KG4sdCxvLmdldChuLHQpL2VbdF0pfWZ1bmN0aW9uIGJlKG8pe2NvbnN0IGU9by5zaXplLTE7bGV0IG49MDtmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0KyspZm9yKGxldCBzPTA7czxvLnJvd3M7cysrKW4rPU1hdGgucG93KG8uZ2V0KHMsdCksMikvZTtyZXR1cm4gTWF0aC5zcXJ0KG4pfWZ1bmN0aW9uIEllKG8sZSl7Zm9yKGxldCBuPTA7bjxvLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChuLHQsby5nZXQobix0KS9lKX1jbGFzcyBfe3N0YXRpYyBmcm9tMURBcnJheShlLG4sdCl7aWYoZSpuIT09dC5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoImRhdGEgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGdpdmVuIGRpbWVuc2lvbnMiKTtsZXQgcj1uZXcgSShlLG4pO2ZvcihsZXQgaT0wO2k8ZTtpKyspZm9yKGxldCBoPTA7aDxuO2grKylyLnNldChpLGgsdFtpKm4raF0pO3JldHVybiByfXN0YXRpYyByb3dWZWN0b3IoZSl7bGV0IG49bmV3IEkoMSxlLmxlbmd0aCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspbi5zZXQoMCx0LGVbdF0pO3JldHVybiBufXN0YXRpYyBjb2x1bW5WZWN0b3IoZSl7bGV0IG49bmV3IEkoZS5sZW5ndGgsMSk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspbi5zZXQodCwwLGVbdF0pO3JldHVybiBufXN0YXRpYyB6ZXJvcyhlLG4pe3JldHVybiBuZXcgSShlLG4pfXN0YXRpYyBvbmVzKGUsbil7cmV0dXJuIG5ldyBJKGUsbikuZmlsbCgxKX1zdGF0aWMgcmFuZChlLG4sdD17fSl7aWYodHlwZW9mIHQhPSJvYmplY3QiKXRocm93IG5ldyBUeXBlRXJyb3IoIm9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QiKTtjb25zdHtyYW5kb206cz1NYXRoLnJhbmRvbX09dDtsZXQgcj1uZXcgSShlLG4pO2ZvcihsZXQgaT0wO2k8ZTtpKyspZm9yKGxldCBoPTA7aDxuO2grKylyLnNldChpLGgscygpKTtyZXR1cm4gcn1zdGF0aWMgcmFuZEludChlLG4sdD17fSl7aWYodHlwZW9mIHQhPSJvYmplY3QiKXRocm93IG5ldyBUeXBlRXJyb3IoIm9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QiKTtjb25zdHttaW46cz0wLG1heDpyPTFlMyxyYW5kb206aT1NYXRoLnJhbmRvbX09dDtpZighTnVtYmVyLmlzSW50ZWdlcihzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtaW4gbXVzdCBiZSBhbiBpbnRlZ2VyIik7aWYoIU51bWJlci5pc0ludGVnZXIocikpdGhyb3cgbmV3IFR5cGVFcnJvcigibWF4IG11c3QgYmUgYW4gaW50ZWdlciIpO2lmKHM+PXIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgaD1yLXMsbD1uZXcgSShlLG4pO2ZvcihsZXQgdT0wO3U8ZTt1KyspZm9yKGxldCBmPTA7ZjxuO2YrKyl7bGV0IGc9cytNYXRoLnJvdW5kKGkoKSpoKTtsLnNldCh1LGYsZyl9cmV0dXJuIGx9c3RhdGljIGV5ZShlLG4sdCl7bj09PXZvaWQgMCYmKG49ZSksdD09PXZvaWQgMCYmKHQ9MSk7bGV0IHM9TWF0aC5taW4oZSxuKSxyPXRoaXMuemVyb3MoZSxuKTtmb3IobGV0IGk9MDtpPHM7aSsrKXIuc2V0KGksaSx0KTtyZXR1cm4gcn1zdGF0aWMgZGlhZyhlLG4sdCl7bGV0IHM9ZS5sZW5ndGg7bj09PXZvaWQgMCYmKG49cyksdD09PXZvaWQgMCYmKHQ9bik7bGV0IHI9TWF0aC5taW4ocyxuLHQpLGk9dGhpcy56ZXJvcyhuLHQpO2ZvcihsZXQgaD0wO2g8cjtoKyspaS5zZXQoaCxoLGVbaF0pO3JldHVybiBpfXN0YXRpYyBtaW4oZSxuKXtlPXRoaXMuY2hlY2tNYXRyaXgoZSksbj10aGlzLmNoZWNrTWF0cml4KG4pO2xldCB0PWUucm93cyxzPWUuY29sdW1ucyxyPW5ldyBJKHQscyk7Zm9yKGxldCBpPTA7aTx0O2krKylmb3IobGV0IGg9MDtoPHM7aCsrKXIuc2V0KGksaCxNYXRoLm1pbihlLmdldChpLGgpLG4uZ2V0KGksaCkpKTtyZXR1cm4gcn1zdGF0aWMgbWF4KGUsbil7ZT10aGlzLmNoZWNrTWF0cml4KGUpLG49dGhpcy5jaGVja01hdHJpeChuKTtsZXQgdD1lLnJvd3Mscz1lLmNvbHVtbnMscj1uZXcgdGhpcyh0LHMpO2ZvcihsZXQgaT0wO2k8dDtpKyspZm9yKGxldCBoPTA7aDxzO2grKylyLnNldChpLGgsTWF0aC5tYXgoZS5nZXQoaSxoKSxuLmdldChpLGgpKSk7cmV0dXJuIHJ9c3RhdGljIGNoZWNrTWF0cml4KGUpe3JldHVybiBfLmlzTWF0cml4KGUpP2U6bmV3IEkoZSl9c3RhdGljIGlzTWF0cml4KGUpe3JldHVybiBlIT1udWxsJiZlLmtsYXNzPT09Ik1hdHJpeCJ9Z2V0IHNpemUoKXtyZXR1cm4gdGhpcy5yb3dzKnRoaXMuY29sdW1uc31hcHBseShlKXtpZih0eXBlb2YgZSE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgVHlwZUVycm9yKCJjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24iKTtmb3IobGV0IG49MDtuPHRoaXMucm93cztuKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKWUuY2FsbCh0aGlzLG4sdCk7cmV0dXJuIHRoaXN9dG8xREFycmF5KCl7bGV0IGU9W107Zm9yKGxldCBuPTA7bjx0aGlzLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyllLnB1c2godGhpcy5nZXQobix0KSk7cmV0dXJuIGV9dG8yREFycmF5KCl7bGV0IGU9W107Zm9yKGxldCBuPTA7bjx0aGlzLnJvd3M7bisrKXtlLnB1c2goW10pO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyllW25dLnB1c2godGhpcy5nZXQobix0KSl9cmV0dXJuIGV9dG9KU09OKCl7cmV0dXJuIHRoaXMudG8yREFycmF5KCl9aXNSb3dWZWN0b3IoKXtyZXR1cm4gdGhpcy5yb3dzPT09MX1pc0NvbHVtblZlY3Rvcigpe3JldHVybiB0aGlzLmNvbHVtbnM9PT0xfWlzVmVjdG9yKCl7cmV0dXJuIHRoaXMucm93cz09PTF8fHRoaXMuY29sdW1ucz09PTF9aXNTcXVhcmUoKXtyZXR1cm4gdGhpcy5yb3dzPT09dGhpcy5jb2x1bW5zfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5yb3dzPT09MHx8dGhpcy5jb2x1bW5zPT09MH1pc1N5bW1ldHJpYygpe2lmKHRoaXMuaXNTcXVhcmUoKSl7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgbj0wO248PWU7bisrKWlmKHRoaXMuZ2V0KGUsbikhPT10aGlzLmdldChuLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiExfWlzRWNoZWxvbkZvcm0oKXtsZXQgZT0wLG49MCx0PS0xLHM9ITAscj0hMTtmb3IoO2U8dGhpcy5yb3dzJiZzOyl7Zm9yKG49MCxyPSExO248dGhpcy5jb2x1bW5zJiZyPT09ITE7KXRoaXMuZ2V0KGUsbik9PT0wP24rKzp0aGlzLmdldChlLG4pPT09MSYmbj50PyhyPSEwLHQ9bik6KHM9ITEscj0hMCk7ZSsrfXJldHVybiBzfWlzUmVkdWNlZEVjaGVsb25Gb3JtKCl7bGV0IGU9MCxuPTAsdD0tMSxzPSEwLHI9ITE7Zm9yKDtlPHRoaXMucm93cyYmczspe2ZvcihuPTAscj0hMTtuPHRoaXMuY29sdW1ucyYmcj09PSExOyl0aGlzLmdldChlLG4pPT09MD9uKys6dGhpcy5nZXQoZSxuKT09PTEmJm4+dD8ocj0hMCx0PW4pOihzPSExLHI9ITApO2ZvcihsZXQgaT1uKzE7aTx0aGlzLnJvd3M7aSsrKXRoaXMuZ2V0KGUsaSkhPT0wJiYocz0hMSk7ZSsrfXJldHVybiBzfWVjaGVsb25Gb3JtKCl7bGV0IGU9dGhpcy5jbG9uZSgpLG49MCx0PTA7Zm9yKDtuPGUucm93cyYmdDxlLmNvbHVtbnM7KXtsZXQgcz1uO2ZvcihsZXQgcj1uO3I8ZS5yb3dzO3IrKyllLmdldChyLHQpPmUuZ2V0KHMsdCkmJihzPXIpO2lmKGUuZ2V0KHMsdCk9PT0wKXQrKztlbHNle2Uuc3dhcFJvd3MobixzKTtsZXQgcj1lLmdldChuLHQpO2ZvcihsZXQgaT10O2k8ZS5jb2x1bW5zO2krKyllLnNldChuLGksZS5nZXQobixpKS9yKTtmb3IobGV0IGk9bisxO2k8ZS5yb3dzO2krKyl7bGV0IGg9ZS5nZXQoaSx0KS9lLmdldChuLHQpO2Uuc2V0KGksdCwwKTtmb3IobGV0IGw9dCsxO2w8ZS5jb2x1bW5zO2wrKyllLnNldChpLGwsZS5nZXQoaSxsKS1lLmdldChuLGwpKmgpfW4rKyx0Kyt9fXJldHVybiBlfXJlZHVjZWRFY2hlbG9uRm9ybSgpe2xldCBlPXRoaXMuZWNoZWxvbkZvcm0oKSxuPWUuY29sdW1ucyx0PWUucm93cyxzPXQtMTtmb3IoO3M+PTA7KWlmKGUubWF4Um93KHMpPT09MClzLS07ZWxzZXtsZXQgcj0wLGk9ITE7Zm9yKDtyPHQmJmk9PT0hMTspZS5nZXQocyxyKT09PTE/aT0hMDpyKys7Zm9yKGxldCBoPTA7aDxzO2grKyl7bGV0IGw9ZS5nZXQoaCxyKTtmb3IobGV0IHU9cjt1PG47dSsrKXtsZXQgZj1lLmdldChoLHUpLWwqZS5nZXQocyx1KTtlLnNldChoLHUsZil9fXMtLX1yZXR1cm4gZX1zZXQoKXt0aHJvdyBuZXcgRXJyb3IoInNldCBtZXRob2QgaXMgdW5pbXBsZW1lbnRlZCIpfWdldCgpe3Rocm93IG5ldyBFcnJvcigiZ2V0IG1ldGhvZCBpcyB1bmltcGxlbWVudGVkIil9cmVwZWF0KGU9e30pe2lmKHR5cGVvZiBlIT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7cm93czpuPTEsY29sdW1uczp0PTF9PWU7aWYoIU51bWJlci5pc0ludGVnZXIobil8fG48PTApdGhyb3cgbmV3IFR5cGVFcnJvcigicm93cyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHQpfHx0PD0wKXRocm93IG5ldyBUeXBlRXJyb3IoImNvbHVtbnMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIiKTtsZXQgcz1uZXcgSSh0aGlzLnJvd3Mqbix0aGlzLmNvbHVtbnMqdCk7Zm9yKGxldCByPTA7cjxuO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXMuc2V0U3ViTWF0cml4KHRoaXMsdGhpcy5yb3dzKnIsdGhpcy5jb2x1bW5zKmkpO3JldHVybiBzfWZpbGwoZSl7Zm9yKGxldCBuPTA7bjx0aGlzLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsZSk7cmV0dXJuIHRoaXN9bmVnKCl7cmV0dXJuIHRoaXMubXVsUygtMSl9Z2V0Um93KGUpe1EodGhpcyxlKTtsZXQgbj1bXTtmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5wdXNoKHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufWdldFJvd1ZlY3RvcihlKXtyZXR1cm4gSS5yb3dWZWN0b3IodGhpcy5nZXRSb3coZSkpfXNldFJvdyhlLG4pe1EodGhpcyxlKSxuPUEodGhpcyxuKTtmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LG5bdF0pO3JldHVybiB0aGlzfXN3YXBSb3dzKGUsbil7USh0aGlzLGUpLFEodGhpcyxuKTtmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspe2xldCBzPXRoaXMuZ2V0KGUsdCk7dGhpcy5zZXQoZSx0LHRoaXMuZ2V0KG4sdCkpLHRoaXMuc2V0KG4sdCxzKX1yZXR1cm4gdGhpc31nZXRDb2x1bW4oZSl7Vyh0aGlzLGUpO2xldCBuPVtdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyluLnB1c2godGhpcy5nZXQodCxlKSk7cmV0dXJuIG59Z2V0Q29sdW1uVmVjdG9yKGUpe3JldHVybiBJLmNvbHVtblZlY3Rvcih0aGlzLmdldENvbHVtbihlKSl9c2V0Q29sdW1uKGUsbil7Vyh0aGlzLGUpLG49dHQodGhpcyxuKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspdGhpcy5zZXQodCxlLG5bdF0pO3JldHVybiB0aGlzfXN3YXBDb2x1bW5zKGUsbil7Vyh0aGlzLGUpLFcodGhpcyxuKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0Kyspe2xldCBzPXRoaXMuZ2V0KHQsZSk7dGhpcy5zZXQodCxlLHRoaXMuZ2V0KHQsbikpLHRoaXMuc2V0KHQsbixzKX1yZXR1cm4gdGhpc31hZGRSb3dWZWN0b3IoZSl7ZT1BKHRoaXMsZSk7Zm9yKGxldCBuPTA7bjx0aGlzLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsdGhpcy5nZXQobix0KStlW3RdKTtyZXR1cm4gdGhpc31zdWJSb3dWZWN0b3IoZSl7ZT1BKHRoaXMsZSk7Zm9yKGxldCBuPTA7bjx0aGlzLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsdGhpcy5nZXQobix0KS1lW3RdKTtyZXR1cm4gdGhpc31tdWxSb3dWZWN0b3IoZSl7ZT1BKHRoaXMsZSk7Zm9yKGxldCBuPTA7bjx0aGlzLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsdGhpcy5nZXQobix0KSplW3RdKTtyZXR1cm4gdGhpc31kaXZSb3dWZWN0b3IoZSl7ZT1BKHRoaXMsZSk7Zm9yKGxldCBuPTA7bjx0aGlzLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsdGhpcy5nZXQobix0KS9lW3RdKTtyZXR1cm4gdGhpc31hZGRDb2x1bW5WZWN0b3IoZSl7ZT10dCh0aGlzLGUpO2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQobix0LHRoaXMuZ2V0KG4sdCkrZVtuXSk7cmV0dXJuIHRoaXN9c3ViQ29sdW1uVmVjdG9yKGUpe2U9dHQodGhpcyxlKTtmb3IobGV0IG49MDtuPHRoaXMucm93cztuKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KG4sdCx0aGlzLmdldChuLHQpLWVbbl0pO3JldHVybiB0aGlzfW11bENvbHVtblZlY3RvcihlKXtlPXR0KHRoaXMsZSk7Zm9yKGxldCBuPTA7bjx0aGlzLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsdGhpcy5nZXQobix0KSplW25dKTtyZXR1cm4gdGhpc31kaXZDb2x1bW5WZWN0b3IoZSl7ZT10dCh0aGlzLGUpO2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQobix0LHRoaXMuZ2V0KG4sdCkvZVtuXSk7cmV0dXJuIHRoaXN9bXVsUm93KGUsbil7USh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KSpuKTtyZXR1cm4gdGhpc31tdWxDb2x1bW4oZSxuKXtXKHRoaXMsZSk7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXRoaXMuc2V0KHQsZSx0aGlzLmdldCh0LGUpKm4pO3JldHVybiB0aGlzfW1heCgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBOYU47bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IG49MDtuPHRoaXMucm93cztuKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuZ2V0KG4sdCk+ZSYmKGU9dGhpcy5nZXQobix0KSk7cmV0dXJuIGV9bWF4SW5kZXgoKXtldCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLDApLG49WzAsMF07Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLmdldCh0LHMpPmUmJihlPXRoaXMuZ2V0KHQscyksblswXT10LG5bMV09cyk7cmV0dXJuIG59bWluKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLDApO2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5nZXQobix0KTxlJiYoZT10aGlzLmdldChuLHQpKTtyZXR1cm4gZX1taW5JbmRleCgpe2V0KHRoaXMpO2xldCBlPXRoaXMuZ2V0KDAsMCksbj1bMCwwXTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk8ZSYmKGU9dGhpcy5nZXQodCxzKSxuWzBdPXQsblsxXT1zKTtyZXR1cm4gbn1tYXhSb3coZSl7aWYoUSh0aGlzLGUpLHRoaXMuaXNFbXB0eSgpKXJldHVybiBOYU47bGV0IG49dGhpcy5nZXQoZSwwKTtmb3IobGV0IHQ9MTt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5nZXQoZSx0KT5uJiYobj10aGlzLmdldChlLHQpKTtyZXR1cm4gbn1tYXhSb3dJbmRleChlKXtRKHRoaXMsZSksZXQodGhpcyk7bGV0IG49dGhpcy5nZXQoZSwwKSx0PVtlLDBdO2ZvcihsZXQgcz0xO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLmdldChlLHMpPm4mJihuPXRoaXMuZ2V0KGUscyksdFsxXT1zKTtyZXR1cm4gdH1taW5Sb3coZSl7aWYoUSh0aGlzLGUpLHRoaXMuaXNFbXB0eSgpKXJldHVybiBOYU47bGV0IG49dGhpcy5nZXQoZSwwKTtmb3IobGV0IHQ9MTt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5nZXQoZSx0KTxuJiYobj10aGlzLmdldChlLHQpKTtyZXR1cm4gbn1taW5Sb3dJbmRleChlKXtRKHRoaXMsZSksZXQodGhpcyk7bGV0IG49dGhpcy5nZXQoZSwwKSx0PVtlLDBdO2ZvcihsZXQgcz0xO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLmdldChlLHMpPG4mJihuPXRoaXMuZ2V0KGUscyksdFsxXT1zKTtyZXR1cm4gdH1tYXhDb2x1bW4oZSl7aWYoVyh0aGlzLGUpLHRoaXMuaXNFbXB0eSgpKXJldHVybiBOYU47bGV0IG49dGhpcy5nZXQoMCxlKTtmb3IobGV0IHQ9MTt0PHRoaXMucm93czt0KyspdGhpcy5nZXQodCxlKT5uJiYobj10aGlzLmdldCh0LGUpKTtyZXR1cm4gbn1tYXhDb2x1bW5JbmRleChlKXtXKHRoaXMsZSksZXQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCxlKSx0PVswLGVdO2ZvcihsZXQgcz0xO3M8dGhpcy5yb3dzO3MrKyl0aGlzLmdldChzLGUpPm4mJihuPXRoaXMuZ2V0KHMsZSksdFswXT1zKTtyZXR1cm4gdH1taW5Db2x1bW4oZSl7aWYoVyh0aGlzLGUpLHRoaXMuaXNFbXB0eSgpKXJldHVybiBOYU47bGV0IG49dGhpcy5nZXQoMCxlKTtmb3IobGV0IHQ9MTt0PHRoaXMucm93czt0KyspdGhpcy5nZXQodCxlKTxuJiYobj10aGlzLmdldCh0LGUpKTtyZXR1cm4gbn1taW5Db2x1bW5JbmRleChlKXtXKHRoaXMsZSksZXQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCxlKSx0PVswLGVdO2ZvcihsZXQgcz0xO3M8dGhpcy5yb3dzO3MrKyl0aGlzLmdldChzLGUpPG4mJihuPXRoaXMuZ2V0KHMsZSksdFswXT1zKTtyZXR1cm4gdH1kaWFnKCl7bGV0IGU9TWF0aC5taW4odGhpcy5yb3dzLHRoaXMuY29sdW1ucyksbj1bXTtmb3IobGV0IHQ9MDt0PGU7dCsrKW4ucHVzaCh0aGlzLmdldCh0LHQpKTtyZXR1cm4gbn1ub3JtKGU9ImZyb2Jlbml1cyIpe2xldCBuPTA7aWYoZT09PSJtYXgiKXJldHVybiB0aGlzLm1heCgpO2lmKGU9PT0iZnJvYmVuaXVzIil7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyluPW4rdGhpcy5nZXQodCxzKSp0aGlzLmdldCh0LHMpO3JldHVybiBNYXRoLnNxcnQobil9ZWxzZSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdW5rbm93biBub3JtIHR5cGU6ICR7ZX1gKX1jdW11bGF0aXZlU3VtKCl7bGV0IGU9MDtmb3IobGV0IG49MDtuPHRoaXMucm93cztuKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKWUrPXRoaXMuZ2V0KG4sdCksdGhpcy5zZXQobix0LGUpO3JldHVybiB0aGlzfWRvdChlKXtfLmlzTWF0cml4KGUpJiYoZT1lLnRvMURBcnJheSgpKTtsZXQgbj10aGlzLnRvMURBcnJheSgpO2lmKG4ubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoInZlY3RvcnMgZG8gbm90IGhhdmUgdGhlIHNhbWUgc2l6ZSIpO2xldCB0PTA7Zm9yKGxldCBzPTA7czxuLmxlbmd0aDtzKyspdCs9bltzXSplW3NdO3JldHVybiB0fW1tdWwoZSl7ZT1JLmNoZWNrTWF0cml4KGUpO2xldCBuPXRoaXMucm93cyx0PXRoaXMuY29sdW1ucyxzPWUuY29sdW1ucyxyPW5ldyBJKG4scyksaT1uZXcgRmxvYXQ2NEFycmF5KHQpO2ZvcihsZXQgaD0wO2g8cztoKyspe2ZvcihsZXQgbD0wO2w8dDtsKyspaVtsXT1lLmdldChsLGgpO2ZvcihsZXQgbD0wO2w8bjtsKyspe2xldCB1PTA7Zm9yKGxldCBmPTA7Zjx0O2YrKyl1Kz10aGlzLmdldChsLGYpKmlbZl07ci5zZXQobCxoLHUpfX1yZXR1cm4gcn1zdHJhc3NlbjJ4MihlKXtlPUkuY2hlY2tNYXRyaXgoZSk7bGV0IG49bmV3IEkoMiwyKTtjb25zdCB0PXRoaXMuZ2V0KDAsMCkscz1lLmdldCgwLDApLHI9dGhpcy5nZXQoMCwxKSxpPWUuZ2V0KDAsMSksaD10aGlzLmdldCgxLDApLGw9ZS5nZXQoMSwwKSx1PXRoaXMuZ2V0KDEsMSksZj1lLmdldCgxLDEpLGc9KHQrdSkqKHMrZiksYT0oaCt1KSpzLGo9dCooaS1mKSx3PXUqKGwtcykseT0odCtyKSpmLG09KGgtdCkqKHMraSksTT0oci11KSoobCtmKSx6PWcrdy15K00sRT1qK3ksaz1hK3csUj1nLWEraittO3JldHVybiBuLnNldCgwLDAseiksbi5zZXQoMCwxLEUpLG4uc2V0KDEsMCxrKSxuLnNldCgxLDEsUiksbn1zdHJhc3NlbjN4MyhlKXtlPUkuY2hlY2tNYXRyaXgoZSk7bGV0IG49bmV3IEkoMywzKTtjb25zdCB0PXRoaXMuZ2V0KDAsMCkscz10aGlzLmdldCgwLDEpLHI9dGhpcy5nZXQoMCwyKSxpPXRoaXMuZ2V0KDEsMCksaD10aGlzLmdldCgxLDEpLGw9dGhpcy5nZXQoMSwyKSx1PXRoaXMuZ2V0KDIsMCksZj10aGlzLmdldCgyLDEpLGc9dGhpcy5nZXQoMiwyKSxhPWUuZ2V0KDAsMCksaj1lLmdldCgwLDEpLHc9ZS5nZXQoMCwyKSx5PWUuZ2V0KDEsMCksbT1lLmdldCgxLDEpLE09ZS5nZXQoMSwyKSx6PWUuZ2V0KDIsMCksRT1lLmdldCgyLDEpLGs9ZS5nZXQoMiwyKSxSPSh0K3Mrci1pLWgtZi1nKSptLHE9KHQtaSkqKC1qK20pLGI9aCooLWErait5LW0tTS16K2spLEY9KC10K2kraCkqKGEtaittKSxYPShpK2gpKigtYStqKSxjPXQqYSxwPSgtdCt1K2YpKihhLXcrTSksUz0oLXQrdSkqKHctTSksZD0odStmKSooLWErdyksUD0odCtzK3ItaC1sLXUtZikqTSxPPWYqKC1hK3creS1tLU0teitFKSxUPSgtcitmK2cpKihtK3otRSksRD0oci1nKSoobS1FKSxZPXIqeixHPShmK2cpKigteitFKSx2PSgtcitoK2wpKihNK3otayksVj0oci1sKSooTS1rKSxKPShoK2wpKigteitrKSxOPXMqeSxCPWwqRSwkPWkqdyxDPXUqaixVPWcqayx3dD1jK1krTixwdD1SK0YrWCtjK1QrWStHLGR0PWMrcCtkK1ArWSt2K0oscnQ9cStiK0YrYytZK3YrVixpdD1xK0YrWCtjK0IsbHQ9WSt2K1YrSiskLGp0PWMrcCtTK08rVCtEK1ksaHQ9VCtEK1krRytDLGt0PWMrcCtTK2QrVTtyZXR1cm4gbi5zZXQoMCwwLHd0KSxuLnNldCgwLDEscHQpLG4uc2V0KDAsMixkdCksbi5zZXQoMSwwLHJ0KSxuLnNldCgxLDEsaXQpLG4uc2V0KDEsMixsdCksbi5zZXQoMiwwLGp0KSxuLnNldCgyLDEsaHQpLG4uc2V0KDIsMixrdCksbn1tbXVsU3RyYXNzZW4oZSl7ZT1JLmNoZWNrTWF0cml4KGUpO2xldCBuPXRoaXMuY2xvbmUoKSx0PW4ucm93cyxzPW4uY29sdW1ucyxyPWUucm93cyxpPWUuY29sdW1ucztzIT09ciYmY29uc29sZS53YXJuKGBNdWx0aXBseWluZyAke3R9IHggJHtzfSBhbmQgJHtyfSB4ICR7aX0gbWF0cml4OiBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaC5gKTtmdW5jdGlvbiBoKGcsYSxqKXtsZXQgdz1nLnJvd3MseT1nLmNvbHVtbnM7aWYodz09PWEmJnk9PT1qKXJldHVybiBnO3tsZXQgbT1fLnplcm9zKGEsaik7cmV0dXJuIG09bS5zZXRTdWJNYXRyaXgoZywwLDApLG19fWxldCBsPU1hdGgubWF4KHQsciksdT1NYXRoLm1heChzLGkpO249aChuLGwsdSksZT1oKGUsbCx1KTtmdW5jdGlvbiBmKGcsYSxqLHcpe2lmKGo8PTUxMnx8dzw9NTEyKXJldHVybiBnLm1tdWwoYSk7aiUyPT09MSYmdyUyPT09MT8oZz1oKGcsaisxLHcrMSksYT1oKGEsaisxLHcrMSkpOmolMj09PTE/KGc9aChnLGorMSx3KSxhPWgoYSxqKzEsdykpOnclMj09PTEmJihnPWgoZyxqLHcrMSksYT1oKGEsaix3KzEpKTtsZXQgeT1wYXJzZUludChnLnJvd3MvMiwxMCksbT1wYXJzZUludChnLmNvbHVtbnMvMiwxMCksTT1nLnN1Yk1hdHJpeCgwLHktMSwwLG0tMSksej1hLnN1Yk1hdHJpeCgwLHktMSwwLG0tMSksRT1nLnN1Yk1hdHJpeCgwLHktMSxtLGcuY29sdW1ucy0xKSxrPWEuc3ViTWF0cml4KDAseS0xLG0sYS5jb2x1bW5zLTEpLFI9Zy5zdWJNYXRyaXgoeSxnLnJvd3MtMSwwLG0tMSkscT1hLnN1Yk1hdHJpeCh5LGEucm93cy0xLDAsbS0xKSxiPWcuc3ViTWF0cml4KHksZy5yb3dzLTEsbSxnLmNvbHVtbnMtMSksRj1hLnN1Yk1hdHJpeCh5LGEucm93cy0xLG0sYS5jb2x1bW5zLTEpLFg9ZihfLmFkZChNLGIpLF8uYWRkKHosRikseSxtKSxjPWYoXy5hZGQoUixiKSx6LHksbSkscD1mKE0sXy5zdWIoayxGKSx5LG0pLFM9ZihiLF8uc3ViKHEseikseSxtKSxkPWYoXy5hZGQoTSxFKSxGLHksbSksUD1mKF8uc3ViKFIsTSksXy5hZGQoeixrKSx5LG0pLE89ZihfLnN1YihFLGIpLF8uYWRkKHEsRikseSxtKSxUPV8uYWRkKFgsUyk7VC5zdWIoZCksVC5hZGQoTyk7bGV0IEQ9Xy5hZGQocCxkKSxZPV8uYWRkKGMsUyksRz1fLnN1YihYLGMpO0cuYWRkKHApLEcuYWRkKFApO2xldCB2PV8uemVyb3MoMipULnJvd3MsMipULmNvbHVtbnMpO3JldHVybiB2PXYuc2V0U3ViTWF0cml4KFQsMCwwKSx2PXYuc2V0U3ViTWF0cml4KEQsVC5yb3dzLDApLHY9di5zZXRTdWJNYXRyaXgoWSwwLFQuY29sdW1ucyksdj12LnNldFN1Yk1hdHJpeChHLFQucm93cyxULmNvbHVtbnMpLHYuc3ViTWF0cml4KDAsai0xLDAsdy0xKX1yZXR1cm4gZihuLGUsbCx1KX1zY2FsZVJvd3MoZT17fSl7aWYodHlwZW9mIGUhPSJvYmplY3QiKXRocm93IG5ldyBUeXBlRXJyb3IoIm9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QiKTtjb25zdHttaW46bj0wLG1heDp0PTF9PWU7aWYoIU51bWJlci5pc0Zpbml0ZShuKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtaW4gbXVzdCBiZSBhIG51bWJlciIpO2lmKCFOdW1iZXIuaXNGaW5pdGUodCkpdGhyb3cgbmV3IFR5cGVFcnJvcigibWF4IG11c3QgYmUgYSBudW1iZXIiKTtpZihuPj10KXRocm93IG5ldyBSYW5nZUVycm9yKCJtaW4gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4Iik7bGV0IHM9bmV3IEkodGhpcy5yb3dzLHRoaXMuY29sdW1ucyk7Zm9yKGxldCByPTA7cjx0aGlzLnJvd3M7cisrKXtjb25zdCBpPXRoaXMuZ2V0Um93KHIpO2kubGVuZ3RoPjAmJnF0KGkse21pbjpuLG1heDp0LG91dHB1dDppfSkscy5zZXRSb3cocixpKX1yZXR1cm4gc31zY2FsZUNvbHVtbnMoZT17fSl7aWYodHlwZW9mIGUhPSJvYmplY3QiKXRocm93IG5ldyBUeXBlRXJyb3IoIm9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QiKTtjb25zdHttaW46bj0wLG1heDp0PTF9PWU7aWYoIU51bWJlci5pc0Zpbml0ZShuKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtaW4gbXVzdCBiZSBhIG51bWJlciIpO2lmKCFOdW1iZXIuaXNGaW5pdGUodCkpdGhyb3cgbmV3IFR5cGVFcnJvcigibWF4IG11c3QgYmUgYSBudW1iZXIiKTtpZihuPj10KXRocm93IG5ldyBSYW5nZUVycm9yKCJtaW4gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4Iik7bGV0IHM9bmV3IEkodGhpcy5yb3dzLHRoaXMuY29sdW1ucyk7Zm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXtjb25zdCBpPXRoaXMuZ2V0Q29sdW1uKHIpO2kubGVuZ3RoJiZxdChpLHttaW46bixtYXg6dCxvdXRwdXQ6aX0pLHMuc2V0Q29sdW1uKHIsaSl9cmV0dXJuIHN9ZmxpcFJvd3MoKXtjb25zdCBlPU1hdGguY2VpbCh0aGlzLmNvbHVtbnMvMik7Zm9yKGxldCBuPTA7bjx0aGlzLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8ZTt0Kyspe2xldCBzPXRoaXMuZ2V0KG4sdCkscj10aGlzLmdldChuLHRoaXMuY29sdW1ucy0xLXQpO3RoaXMuc2V0KG4sdCxyKSx0aGlzLnNldChuLHRoaXMuY29sdW1ucy0xLXQscyl9cmV0dXJuIHRoaXN9ZmxpcENvbHVtbnMoKXtjb25zdCBlPU1hdGguY2VpbCh0aGlzLnJvd3MvMik7Zm9yKGxldCBuPTA7bjx0aGlzLmNvbHVtbnM7bisrKWZvcihsZXQgdD0wO3Q8ZTt0Kyspe2xldCBzPXRoaXMuZ2V0KHQsbikscj10aGlzLmdldCh0aGlzLnJvd3MtMS10LG4pO3RoaXMuc2V0KHQsbixyKSx0aGlzLnNldCh0aGlzLnJvd3MtMS10LG4scyl9cmV0dXJuIHRoaXN9a3JvbmVja2VyUHJvZHVjdChlKXtlPUkuY2hlY2tNYXRyaXgoZSk7bGV0IG49dGhpcy5yb3dzLHQ9dGhpcy5jb2x1bW5zLHM9ZS5yb3dzLHI9ZS5jb2x1bW5zLGk9bmV3IEkobipzLHQqcik7Zm9yKGxldCBoPTA7aDxuO2grKylmb3IobGV0IGw9MDtsPHQ7bCsrKWZvcihsZXQgdT0wO3U8czt1KyspZm9yKGxldCBmPTA7ZjxyO2YrKylpLnNldChzKmgrdSxyKmwrZix0aGlzLmdldChoLGwpKmUuZ2V0KHUsZikpO3JldHVybiBpfXRyYW5zcG9zZSgpe2xldCBlPW5ldyBJKHRoaXMuY29sdW1ucyx0aGlzLnJvd3MpO2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspZS5zZXQodCxuLHRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfXNvcnRSb3dzKGU9VHQpe2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKyl0aGlzLnNldFJvdyhuLHRoaXMuZ2V0Um93KG4pLnNvcnQoZSkpO3JldHVybiB0aGlzfXNvcnRDb2x1bW5zKGU9VHQpe2ZvcihsZXQgbj0wO248dGhpcy5jb2x1bW5zO24rKyl0aGlzLnNldENvbHVtbihuLHRoaXMuZ2V0Q29sdW1uKG4pLnNvcnQoZSkpO3JldHVybiB0aGlzfXN1Yk1hdHJpeChlLG4sdCxzKXtGdCh0aGlzLGUsbix0LHMpO2xldCByPW5ldyBJKG4tZSsxLHMtdCsxKTtmb3IobGV0IGk9ZTtpPD1uO2krKylmb3IobGV0IGg9dDtoPD1zO2grKylyLnNldChpLWUsaC10LHRoaXMuZ2V0KGksaCkpO3JldHVybiByfXN1Yk1hdHJpeFJvdyhlLG4sdCl7aWYobj09PXZvaWQgMCYmKG49MCksdD09PXZvaWQgMCYmKHQ9dGhpcy5jb2x1bW5zLTEpLG4+dHx8bjwwfHxuPj10aGlzLmNvbHVtbnN8fHQ8MHx8dD49dGhpcy5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJBcmd1bWVudCBvdXQgb2YgcmFuZ2UiKTtsZXQgcz1uZXcgSShlLmxlbmd0aCx0LW4rMSk7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspZm9yKGxldCBpPW47aTw9dDtpKyspe2lmKGVbcl08MHx8ZVtyXT49dGhpcy5yb3dzKXRocm93IG5ldyBSYW5nZUVycm9yKGBSb3cgaW5kZXggb3V0IG9mIHJhbmdlOiAke2Vbcl19YCk7cy5zZXQocixpLW4sdGhpcy5nZXQoZVtyXSxpKSl9cmV0dXJuIHN9c3ViTWF0cml4Q29sdW1uKGUsbix0KXtpZihuPT09dm9pZCAwJiYobj0wKSx0PT09dm9pZCAwJiYodD10aGlzLnJvd3MtMSksbj50fHxuPDB8fG4+PXRoaXMucm93c3x8dDwwfHx0Pj10aGlzLnJvd3MpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkFyZ3VtZW50IG91dCBvZiByYW5nZSIpO2xldCBzPW5ldyBJKHQtbisxLGUubGVuZ3RoKTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKylmb3IobGV0IGk9bjtpPD10O2krKyl7aWYoZVtyXTwwfHxlW3JdPj10aGlzLmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2U6ICR7ZVtyXX1gKTtzLnNldChpLW4scix0aGlzLmdldChpLGVbcl0pKX1yZXR1cm4gc31zZXRTdWJNYXRyaXgoZSxuLHQpe2lmKGU9SS5jaGVja01hdHJpeChlKSxlLmlzRW1wdHkoKSlyZXR1cm4gdGhpcztsZXQgcz1uK2Uucm93cy0xLHI9dCtlLmNvbHVtbnMtMTtGdCh0aGlzLG4scyx0LHIpO2ZvcihsZXQgaT0wO2k8ZS5yb3dzO2krKylmb3IobGV0IGg9MDtoPGUuY29sdW1ucztoKyspdGhpcy5zZXQobitpLHQraCxlLmdldChpLGgpKTtyZXR1cm4gdGhpc31zZWxlY3Rpb24oZSxuKXtsZXQgdD1yZSh0aGlzLGUsbikscz1uZXcgSShlLmxlbmd0aCxuLmxlbmd0aCk7Zm9yKGxldCByPTA7cjx0LnJvdy5sZW5ndGg7cisrKXtsZXQgaT10LnJvd1tyXTtmb3IobGV0IGg9MDtoPHQuY29sdW1uLmxlbmd0aDtoKyspe2xldCBsPXQuY29sdW1uW2hdO3Muc2V0KHIsaCx0aGlzLmdldChpLGwpKX19cmV0dXJuIHN9dHJhY2UoKXtsZXQgZT1NYXRoLm1pbih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKSxuPTA7Zm9yKGxldCB0PTA7dDxlO3QrKyluKz10aGlzLmdldCh0LHQpO3JldHVybiBufWNsb25lKCl7bGV0IGU9bmV3IEkodGhpcy5yb3dzLHRoaXMuY29sdW1ucyk7Zm9yKGxldCBuPTA7bjx0aGlzLnJvd3M7bisrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyllLnNldChuLHQsdGhpcy5nZXQobix0KSk7cmV0dXJuIGV9c3VtKGUpe3N3aXRjaChlKXtjYXNlInJvdyI6cmV0dXJuIGhlKHRoaXMpO2Nhc2UiY29sdW1uIjpyZXR1cm4gdWUodGhpcyk7Y2FzZSB2b2lkIDA6cmV0dXJuIGNlKHRoaXMpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtlfWApfX1wcm9kdWN0KGUpe3N3aXRjaChlKXtjYXNlInJvdyI6cmV0dXJuIGZlKHRoaXMpO2Nhc2UiY29sdW1uIjpyZXR1cm4gZ2UodGhpcyk7Y2FzZSB2b2lkIDA6cmV0dXJuIGFlKHRoaXMpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtlfWApfX1tZWFuKGUpe2NvbnN0IG49dGhpcy5zdW0oZSk7c3dpdGNoKGUpe2Nhc2Uicm93Ijp7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKW5bdF0vPXRoaXMuY29sdW1ucztyZXR1cm4gbn1jYXNlImNvbHVtbiI6e2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyluW3RdLz10aGlzLnJvd3M7cmV0dXJuIG59Y2FzZSB2b2lkIDA6cmV0dXJuIG4vdGhpcy5zaXplO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtlfWApfX12YXJpYW5jZShlLG49e30pe2lmKHR5cGVvZiBlPT0ib2JqZWN0IiYmKG49ZSxlPXZvaWQgMCksdHlwZW9mIG4hPSJvYmplY3QiKXRocm93IG5ldyBUeXBlRXJyb3IoIm9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QiKTtjb25zdHt1bmJpYXNlZDp0PSEwLG1lYW46cz10aGlzLm1lYW4oZSl9PW47aWYodHlwZW9mIHQhPSJib29sZWFuIil0aHJvdyBuZXcgVHlwZUVycm9yKCJ1bmJpYXNlZCBtdXN0IGJlIGEgYm9vbGVhbiIpO3N3aXRjaChlKXtjYXNlInJvdyI6e2lmKCFBcnJheS5pc0FycmF5KHMpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1lYW4gbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBtZSh0aGlzLHQscyl9Y2FzZSJjb2x1bW4iOntpZighQXJyYXkuaXNBcnJheShzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtZWFuIG11c3QgYmUgYW4gYXJyYXkiKTtyZXR1cm4gd2UodGhpcyx0LHMpfWNhc2Ugdm9pZCAwOntpZih0eXBlb2YgcyE9Im51bWJlciIpdGhyb3cgbmV3IFR5cGVFcnJvcigibWVhbiBtdXN0IGJlIGEgbnVtYmVyIik7cmV0dXJuIHBlKHRoaXMsdCxzKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7ZX1gKX19c3RhbmRhcmREZXZpYXRpb24oZSxuKXt0eXBlb2YgZT09Im9iamVjdCImJihuPWUsZT12b2lkIDApO2NvbnN0IHQ9dGhpcy52YXJpYW5jZShlLG4pO2lmKGU9PT12b2lkIDApcmV0dXJuIE1hdGguc3FydCh0KTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl0W3NdPU1hdGguc3FydCh0W3NdKTtyZXR1cm4gdH1jZW50ZXIoZSxuPXt9KXtpZih0eXBlb2YgZT09Im9iamVjdCImJihuPWUsZT12b2lkIDApLHR5cGVvZiBuIT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7Y2VudGVyOnQ9dGhpcy5tZWFuKGUpfT1uO3N3aXRjaChlKXtjYXNlInJvdyI6e2lmKCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoImNlbnRlciBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIGRlKHRoaXMsdCksdGhpc31jYXNlImNvbHVtbiI6e2lmKCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoImNlbnRlciBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIHllKHRoaXMsdCksdGhpc31jYXNlIHZvaWQgMDp7aWYodHlwZW9mIHQhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoImNlbnRlciBtdXN0IGJlIGEgbnVtYmVyIik7cmV0dXJuIE1lKHRoaXMsdCksdGhpc31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7ZX1gKX19c2NhbGUoZSxuPXt9KXtpZih0eXBlb2YgZT09Im9iamVjdCImJihuPWUsZT12b2lkIDApLHR5cGVvZiBuIT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7bGV0IHQ9bi5zY2FsZTtzd2l0Y2goZSl7Y2FzZSJyb3ciOntpZih0PT09dm9pZCAwKXQ9RWUodGhpcyk7ZWxzZSBpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJzY2FsZSBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIFNlKHRoaXMsdCksdGhpc31jYXNlImNvbHVtbiI6e2lmKHQ9PT12b2lkIDApdD1qZSh0aGlzKTtlbHNlIGlmKCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoInNjYWxlIG11c3QgYmUgYW4gYXJyYXkiKTtyZXR1cm4ga2UodGhpcyx0KSx0aGlzfWNhc2Ugdm9pZCAwOntpZih0PT09dm9pZCAwKXQ9YmUodGhpcyk7ZWxzZSBpZih0eXBlb2YgdCE9Im51bWJlciIpdGhyb3cgbmV3IFR5cGVFcnJvcigic2NhbGUgbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBJZSh0aGlzLHQpLHRoaXN9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke2V9YCl9fXRvU3RyaW5nKGUpe3JldHVybiB6dCh0aGlzLGUpfX1fLnByb3RvdHlwZS5rbGFzcz0iTWF0cml4Iix0eXBlb2YgU3ltYm9sPCJ1IiYmKF8ucHJvdG90eXBlW1N5bWJvbC5mb3IoIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tIildPWVlKTtmdW5jdGlvbiBUdChvLGUpe3JldHVybiBvLWV9Xy5yYW5kb209Xy5yYW5kLF8ucmFuZG9tSW50PV8ucmFuZEludCxfLmRpYWdvbmFsPV8uZGlhZyxfLnByb3RvdHlwZS5kaWFnb25hbD1fLnByb3RvdHlwZS5kaWFnLF8uaWRlbnRpdHk9Xy5leWUsXy5wcm90b3R5cGUubmVnYXRlPV8ucHJvdG90eXBlLm5lZyxfLnByb3RvdHlwZS50ZW5zb3JQcm9kdWN0PV8ucHJvdG90eXBlLmtyb25lY2tlclByb2R1Y3Q7Y2xhc3MgSSBleHRlbmRzIF97Y29uc3RydWN0b3IoZSxuKXtpZihzdXBlcigpLEkuaXNNYXRyaXgoZSkpcmV0dXJuIGUuY2xvbmUoKTtpZihOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0wKWlmKHRoaXMuZGF0YT1bXSxOdW1iZXIuaXNJbnRlZ2VyKG4pJiZuPj0wKWZvcihsZXQgdD0wO3Q8ZTt0KyspdGhpcy5kYXRhLnB1c2gobmV3IEZsb2F0NjRBcnJheShuKSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJuQ29sdW1ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciIpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlKSl7Y29uc3QgdD1lO2lmKGU9dC5sZW5ndGgsbj1lP3RbMF0ubGVuZ3RoOjAsdHlwZW9mIG4hPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIkRhdGEgbXVzdCBiZSBhIDJEIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQiKTt0aGlzLmRhdGE9W107Zm9yKGxldCBzPTA7czxlO3MrKyl7aWYodFtzXS5sZW5ndGghPT1uKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmNvbnNpc3RlbnQgYXJyYXkgZGltZW5zaW9ucyIpO3RoaXMuZGF0YS5wdXNoKEZsb2F0NjRBcnJheS5mcm9tKHRbc10pKX19ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIG9yIGFuIGFycmF5Iik7dGhpcy5yb3dzPWUsdGhpcy5jb2x1bW5zPW59c2V0KGUsbix0KXtyZXR1cm4gdGhpcy5kYXRhW2VdW25dPXQsdGhpc31nZXQoZSxuKXtyZXR1cm4gdGhpcy5kYXRhW2VdW25dfXJlbW92ZVJvdyhlKXtyZXR1cm4gUSh0aGlzLGUpLHRoaXMuZGF0YS5zcGxpY2UoZSwxKSx0aGlzLnJvd3MtPTEsdGhpc31hZGRSb3coZSxuKXtyZXR1cm4gbj09PXZvaWQgMCYmKG49ZSxlPXRoaXMucm93cyksUSh0aGlzLGUsITApLG49RmxvYXQ2NEFycmF5LmZyb20oQSh0aGlzLG4pKSx0aGlzLmRhdGEuc3BsaWNlKGUsMCxuKSx0aGlzLnJvd3MrPTEsdGhpc31yZW1vdmVDb2x1bW4oZSl7Vyh0aGlzLGUpO2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKyl7Y29uc3QgdD1uZXcgRmxvYXQ2NEFycmF5KHRoaXMuY29sdW1ucy0xKTtmb3IobGV0IHM9MDtzPGU7cysrKXRbc109dGhpcy5kYXRhW25dW3NdO2ZvcihsZXQgcz1lKzE7czx0aGlzLmNvbHVtbnM7cysrKXRbcy0xXT10aGlzLmRhdGFbbl1bc107dGhpcy5kYXRhW25dPXR9cmV0dXJuIHRoaXMuY29sdW1ucy09MSx0aGlzfWFkZENvbHVtbihlLG4pe3R5cGVvZiBuPiJ1IiYmKG49ZSxlPXRoaXMuY29sdW1ucyksVyh0aGlzLGUsITApLG49dHQodGhpcyxuKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0Kyspe2NvbnN0IHM9bmV3IEZsb2F0NjRBcnJheSh0aGlzLmNvbHVtbnMrMSk7bGV0IHI9MDtmb3IoO3I8ZTtyKyspc1tyXT10aGlzLmRhdGFbdF1bcl07Zm9yKHNbcisrXT1uW3RdO3I8dGhpcy5jb2x1bW5zKzE7cisrKXNbcl09dGhpcy5kYXRhW3RdW3ItMV07dGhpcy5kYXRhW3RdPXN9cmV0dXJuIHRoaXMuY29sdW1ucys9MSx0aGlzfX1vZShfLEkpO2NsYXNzIG50IGV4dGVuZHMgX3tjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuZGF0YT1lLHRoaXMucm93cz1lLmxlbmd0aCx0aGlzLmNvbHVtbnM9ZVswXS5sZW5ndGh9c2V0KGUsbix0KXtyZXR1cm4gdGhpcy5kYXRhW2VdW25dPXQsdGhpc31nZXQoZSxuKXtyZXR1cm4gdGhpcy5kYXRhW2VdW25dfX1jbGFzcyBSZXtjb25zdHJ1Y3RvcihlKXtlPW50LmNoZWNrTWF0cml4KGUpO2xldCBuPWUuY2xvbmUoKSx0PW4ucm93cyxzPW4uY29sdW1ucyxyPW5ldyBGbG9hdDY0QXJyYXkodCksaT0xLGgsbCx1LGYsZyxhLGosdyx5O2ZvcihoPTA7aDx0O2grKylyW2hdPWg7Zm9yKHc9bmV3IEZsb2F0NjRBcnJheSh0KSxsPTA7bDxzO2wrKyl7Zm9yKGg9MDtoPHQ7aCsrKXdbaF09bi5nZXQoaCxsKTtmb3IoaD0wO2g8dDtoKyspe2Zvcih5PU1hdGgubWluKGgsbCksZz0wLHU9MDt1PHk7dSsrKWcrPW4uZ2V0KGgsdSkqd1t1XTt3W2hdLT1nLG4uc2V0KGgsbCx3W2hdKX1mb3IoZj1sLGg9bCsxO2g8dDtoKyspTWF0aC5hYnMod1toXSk+TWF0aC5hYnMod1tmXSkmJihmPWgpO2lmKGYhPT1sKXtmb3IodT0wO3U8czt1KyspYT1uLmdldChmLHUpLG4uc2V0KGYsdSxuLmdldChsLHUpKSxuLnNldChsLHUsYSk7aj1yW2ZdLHJbZl09cltsXSxyW2xdPWosaT0taX1pZihsPHQmJm4uZ2V0KGwsbCkhPT0wKWZvcihoPWwrMTtoPHQ7aCsrKW4uc2V0KGgsbCxuLmdldChoLGwpL24uZ2V0KGwsbCkpfXRoaXMuTFU9bix0aGlzLnBpdm90VmVjdG9yPXIsdGhpcy5waXZvdFNpZ249aX1pc1Npbmd1bGFyKCl7bGV0IGU9dGhpcy5MVSxuPWUuY29sdW1ucztmb3IobGV0IHQ9MDt0PG47dCsrKWlmKGUuZ2V0KHQsdCk9PT0wKXJldHVybiEwO3JldHVybiExfXNvbHZlKGUpe2U9SS5jaGVja01hdHJpeChlKTtsZXQgbj10aGlzLkxVO2lmKG4ucm93cyE9PWUucm93cyl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgbWF0cml4IGRpbWVuc2lvbnMiKTtpZih0aGlzLmlzU2luZ3VsYXIoKSl0aHJvdyBuZXcgRXJyb3IoIkxVIG1hdHJpeCBpcyBzaW5ndWxhciIpO2xldCBzPWUuY29sdW1ucyxyPWUuc3ViTWF0cml4Um93KHRoaXMucGl2b3RWZWN0b3IsMCxzLTEpLGk9bi5jb2x1bW5zLGgsbCx1O2Zvcih1PTA7dTxpO3UrKylmb3IoaD11KzE7aDxpO2grKylmb3IobD0wO2w8cztsKyspci5zZXQoaCxsLHIuZ2V0KGgsbCktci5nZXQodSxsKSpuLmdldChoLHUpKTtmb3IodT1pLTE7dT49MDt1LS0pe2ZvcihsPTA7bDxzO2wrKylyLnNldCh1LGwsci5nZXQodSxsKS9uLmdldCh1LHUpKTtmb3IoaD0wO2g8dTtoKyspZm9yKGw9MDtsPHM7bCsrKXIuc2V0KGgsbCxyLmdldChoLGwpLXIuZ2V0KHUsbCkqbi5nZXQoaCx1KSl9cmV0dXJuIHJ9Z2V0IGRldGVybWluYW50KCl7bGV0IGU9dGhpcy5MVTtpZighZS5pc1NxdWFyZSgpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IG11c3QgYmUgc3F1YXJlIik7bGV0IG49dGhpcy5waXZvdFNpZ24sdD1lLmNvbHVtbnM7Zm9yKGxldCBzPTA7czx0O3MrKyluKj1lLmdldChzLHMpO3JldHVybiBufWdldCBsb3dlclRyaWFuZ3VsYXJNYXRyaXgoKXtsZXQgZT10aGlzLkxVLG49ZS5yb3dzLHQ9ZS5jb2x1bW5zLHM9bmV3IEkobix0KTtmb3IobGV0IHI9MDtyPG47cisrKWZvcihsZXQgaT0wO2k8dDtpKyspcj5pP3Muc2V0KHIsaSxlLmdldChyLGkpKTpyPT09aT9zLnNldChyLGksMSk6cy5zZXQocixpLDApO3JldHVybiBzfWdldCB1cHBlclRyaWFuZ3VsYXJNYXRyaXgoKXtsZXQgZT10aGlzLkxVLG49ZS5yb3dzLHQ9ZS5jb2x1bW5zLHM9bmV3IEkobix0KTtmb3IobGV0IHI9MDtyPG47cisrKWZvcihsZXQgaT0wO2k8dDtpKyspcjw9aT9zLnNldChyLGksZS5nZXQocixpKSk6cy5zZXQocixpLDApO3JldHVybiBzfWdldCBwaXZvdFBlcm11dGF0aW9uVmVjdG9yKCl7cmV0dXJuIEFycmF5LmZyb20odGhpcy5waXZvdFZlY3Rvcil9fWZ1bmN0aW9uIFoobyxlKXtsZXQgbj0wO3JldHVybiBNYXRoLmFicyhvKT5NYXRoLmFicyhlKT8obj1lL28sTWF0aC5hYnMobykqTWF0aC5zcXJ0KDErbipuKSk6ZSE9PTA/KG49by9lLE1hdGguYWJzKGUpKk1hdGguc3FydCgxK24qbikpOjB9Y2xhc3MgdmV7Y29uc3RydWN0b3IoZSl7ZT1udC5jaGVja01hdHJpeChlKTtsZXQgbj1lLmNsb25lKCksdD1lLnJvd3Mscz1lLmNvbHVtbnMscj1uZXcgRmxvYXQ2NEFycmF5KHMpLGksaCxsLHU7Zm9yKGw9MDtsPHM7bCsrKXtsZXQgZj0wO2ZvcihpPWw7aTx0O2krKylmPVooZixuLmdldChpLGwpKTtpZihmIT09MCl7Zm9yKG4uZ2V0KGwsbCk8MCYmKGY9LWYpLGk9bDtpPHQ7aSsrKW4uc2V0KGksbCxuLmdldChpLGwpL2YpO2ZvcihuLnNldChsLGwsbi5nZXQobCxsKSsxKSxoPWwrMTtoPHM7aCsrKXtmb3IodT0wLGk9bDtpPHQ7aSsrKXUrPW4uZ2V0KGksbCkqbi5nZXQoaSxoKTtmb3IodT0tdS9uLmdldChsLGwpLGk9bDtpPHQ7aSsrKW4uc2V0KGksaCxuLmdldChpLGgpK3Uqbi5nZXQoaSxsKSl9fXJbbF09LWZ9dGhpcy5RUj1uLHRoaXMuUmRpYWc9cn1zb2x2ZShlKXtlPUkuY2hlY2tNYXRyaXgoZSk7bGV0IG49dGhpcy5RUix0PW4ucm93cztpZihlLnJvd3MhPT10KXRocm93IG5ldyBFcnJvcigiTWF0cml4IHJvdyBkaW1lbnNpb25zIG11c3QgYWdyZWUiKTtpZighdGhpcy5pc0Z1bGxSYW5rKCkpdGhyb3cgbmV3IEVycm9yKCJNYXRyaXggaXMgcmFuayBkZWZpY2llbnQiKTtsZXQgcz1lLmNvbHVtbnMscj1lLmNsb25lKCksaT1uLmNvbHVtbnMsaCxsLHUsZjtmb3IodT0wO3U8aTt1KyspZm9yKGw9MDtsPHM7bCsrKXtmb3IoZj0wLGg9dTtoPHQ7aCsrKWYrPW4uZ2V0KGgsdSkqci5nZXQoaCxsKTtmb3IoZj0tZi9uLmdldCh1LHUpLGg9dTtoPHQ7aCsrKXIuc2V0KGgsbCxyLmdldChoLGwpK2Yqbi5nZXQoaCx1KSl9Zm9yKHU9aS0xO3U+PTA7dS0tKXtmb3IobD0wO2w8cztsKyspci5zZXQodSxsLHIuZ2V0KHUsbCkvdGhpcy5SZGlhZ1t1XSk7Zm9yKGg9MDtoPHU7aCsrKWZvcihsPTA7bDxzO2wrKylyLnNldChoLGwsci5nZXQoaCxsKS1yLmdldCh1LGwpKm4uZ2V0KGgsdSkpfXJldHVybiByLnN1Yk1hdHJpeCgwLGktMSwwLHMtMSl9aXNGdWxsUmFuaygpe2xldCBlPXRoaXMuUVIuY29sdW1ucztmb3IobGV0IG49MDtuPGU7bisrKWlmKHRoaXMuUmRpYWdbbl09PT0wKXJldHVybiExO3JldHVybiEwfWdldCB1cHBlclRyaWFuZ3VsYXJNYXRyaXgoKXtsZXQgZT10aGlzLlFSLG49ZS5jb2x1bW5zLHQ9bmV3IEkobixuKSxzLHI7Zm9yKHM9MDtzPG47cysrKWZvcihyPTA7cjxuO3IrKylzPHI/dC5zZXQocyxyLGUuZ2V0KHMscikpOnM9PT1yP3Quc2V0KHMscix0aGlzLlJkaWFnW3NdKTp0LnNldChzLHIsMCk7cmV0dXJuIHR9Z2V0IG9ydGhvZ29uYWxNYXRyaXgoKXtsZXQgZT10aGlzLlFSLG49ZS5yb3dzLHQ9ZS5jb2x1bW5zLHM9bmV3IEkobix0KSxyLGksaCxsO2ZvcihoPXQtMTtoPj0wO2gtLSl7Zm9yKHI9MDtyPG47cisrKXMuc2V0KHIsaCwwKTtmb3Iocy5zZXQoaCxoLDEpLGk9aDtpPHQ7aSsrKWlmKGUuZ2V0KGgsaCkhPT0wKXtmb3IobD0wLHI9aDtyPG47cisrKWwrPWUuZ2V0KHIsaCkqcy5nZXQocixpKTtmb3IobD0tbC9lLmdldChoLGgpLHI9aDtyPG47cisrKXMuc2V0KHIsaSxzLmdldChyLGkpK2wqZS5nZXQocixoKSl9fXJldHVybiBzfX1jbGFzcyBEdHtjb25zdHJ1Y3RvcihlLG49e30pe2lmKGU9bnQuY2hlY2tNYXRyaXgoZSksZS5pc0VtcHR5KCkpdGhyb3cgbmV3IEVycm9yKCJNYXRyaXggbXVzdCBiZSBub24tZW1wdHkiKTtsZXQgdD1lLnJvd3Mscz1lLmNvbHVtbnM7Y29uc3R7Y29tcHV0ZUxlZnRTaW5ndWxhclZlY3RvcnM6cj0hMCxjb21wdXRlUmlnaHRTaW5ndWxhclZlY3RvcnM6aT0hMCxhdXRvVHJhbnNwb3NlOmg9ITF9PW47bGV0IGw9Qm9vbGVhbihyKSx1PUJvb2xlYW4oaSksZj0hMSxnO2lmKHQ8cylpZighaClnPWUuY2xvbmUoKSxjb25zb2xlLndhcm4oIkNvbXB1dGluZyBTVkQgb24gYSBtYXRyaXggd2l0aCBtb3JlIGNvbHVtbnMgdGhhbiByb3dzLiBDb25zaWRlciBlbmFibGluZyBhdXRvVHJhbnNwb3NlIik7ZWxzZXtnPWUudHJhbnNwb3NlKCksdD1nLnJvd3Mscz1nLmNvbHVtbnMsZj0hMDtsZXQgYz1sO2w9dSx1PWN9ZWxzZSBnPWUuY2xvbmUoKTtsZXQgYT1NYXRoLm1pbih0LHMpLGo9TWF0aC5taW4odCsxLHMpLHc9bmV3IEZsb2F0NjRBcnJheShqKSx5PW5ldyBJKHQsYSksbT1uZXcgSShzLHMpLE09bmV3IEZsb2F0NjRBcnJheShzKSx6PW5ldyBGbG9hdDY0QXJyYXkodCksRT1uZXcgRmxvYXQ2NEFycmF5KGopO2ZvcihsZXQgYz0wO2M8ajtjKyspRVtjXT1jO2xldCBrPU1hdGgubWluKHQtMSxzKSxSPU1hdGgubWF4KDAsTWF0aC5taW4ocy0yLHQpKSxxPU1hdGgubWF4KGssUik7Zm9yKGxldCBjPTA7YzxxO2MrKyl7aWYoYzxrKXt3W2NdPTA7Zm9yKGxldCBwPWM7cDx0O3ArKyl3W2NdPVood1tjXSxnLmdldChwLGMpKTtpZih3W2NdIT09MCl7Zy5nZXQoYyxjKTwwJiYod1tjXT0td1tjXSk7Zm9yKGxldCBwPWM7cDx0O3ArKylnLnNldChwLGMsZy5nZXQocCxjKS93W2NdKTtnLnNldChjLGMsZy5nZXQoYyxjKSsxKX13W2NdPS13W2NdfWZvcihsZXQgcD1jKzE7cDxzO3ArKyl7aWYoYzxrJiZ3W2NdIT09MCl7bGV0IFM9MDtmb3IobGV0IGQ9YztkPHQ7ZCsrKVMrPWcuZ2V0KGQsYykqZy5nZXQoZCxwKTtTPS1TL2cuZ2V0KGMsYyk7Zm9yKGxldCBkPWM7ZDx0O2QrKylnLnNldChkLHAsZy5nZXQoZCxwKStTKmcuZ2V0KGQsYykpfU1bcF09Zy5nZXQoYyxwKX1pZihsJiZjPGspZm9yKGxldCBwPWM7cDx0O3ArKyl5LnNldChwLGMsZy5nZXQocCxjKSk7aWYoYzxSKXtNW2NdPTA7Zm9yKGxldCBwPWMrMTtwPHM7cCsrKU1bY109WihNW2NdLE1bcF0pO2lmKE1bY10hPT0wKXtNW2MrMV08MCYmKE1bY109MC1NW2NdKTtmb3IobGV0IHA9YysxO3A8cztwKyspTVtwXS89TVtjXTtNW2MrMV0rPTF9aWYoTVtjXT0tTVtjXSxjKzE8dCYmTVtjXSE9PTApe2ZvcihsZXQgcD1jKzE7cDx0O3ArKyl6W3BdPTA7Zm9yKGxldCBwPWMrMTtwPHQ7cCsrKWZvcihsZXQgUz1jKzE7UzxzO1MrKyl6W3BdKz1NW1NdKmcuZ2V0KHAsUyk7Zm9yKGxldCBwPWMrMTtwPHM7cCsrKXtsZXQgUz0tTVtwXS9NW2MrMV07Zm9yKGxldCBkPWMrMTtkPHQ7ZCsrKWcuc2V0KGQscCxnLmdldChkLHApK1MqeltkXSl9fWlmKHUpZm9yKGxldCBwPWMrMTtwPHM7cCsrKW0uc2V0KHAsYyxNW3BdKX19bGV0IGI9TWF0aC5taW4ocyx0KzEpO2lmKGs8cyYmKHdba109Zy5nZXQoayxrKSksdDxiJiYod1tiLTFdPTApLFIrMTxiJiYoTVtSXT1nLmdldChSLGItMSkpLE1bYi0xXT0wLGwpe2ZvcihsZXQgYz1rO2M8YTtjKyspe2ZvcihsZXQgcD0wO3A8dDtwKyspeS5zZXQocCxjLDApO3kuc2V0KGMsYywxKX1mb3IobGV0IGM9ay0xO2M+PTA7Yy0tKWlmKHdbY10hPT0wKXtmb3IobGV0IHA9YysxO3A8YTtwKyspe2xldCBTPTA7Zm9yKGxldCBkPWM7ZDx0O2QrKylTKz15LmdldChkLGMpKnkuZ2V0KGQscCk7Uz0tUy95LmdldChjLGMpO2ZvcihsZXQgZD1jO2Q8dDtkKyspeS5zZXQoZCxwLHkuZ2V0KGQscCkrUyp5LmdldChkLGMpKX1mb3IobGV0IHA9YztwPHQ7cCsrKXkuc2V0KHAsYywteS5nZXQocCxjKSk7eS5zZXQoYyxjLDEreS5nZXQoYyxjKSk7Zm9yKGxldCBwPTA7cDxjLTE7cCsrKXkuc2V0KHAsYywwKX1lbHNle2ZvcihsZXQgcD0wO3A8dDtwKyspeS5zZXQocCxjLDApO3kuc2V0KGMsYywxKX19aWYodSlmb3IobGV0IGM9cy0xO2M+PTA7Yy0tKXtpZihjPFImJk1bY10hPT0wKWZvcihsZXQgcD1jKzE7cDxzO3ArKyl7bGV0IFM9MDtmb3IobGV0IGQ9YysxO2Q8cztkKyspUys9bS5nZXQoZCxjKSptLmdldChkLHApO1M9LVMvbS5nZXQoYysxLGMpO2ZvcihsZXQgZD1jKzE7ZDxzO2QrKyltLnNldChkLHAsbS5nZXQoZCxwKStTKm0uZ2V0KGQsYykpfWZvcihsZXQgcD0wO3A8cztwKyspbS5zZXQocCxjLDApO20uc2V0KGMsYywxKX1sZXQgRj1iLTEsWD1OdW1iZXIuRVBTSUxPTjtmb3IoO2I+MDspe2xldCBjLHA7Zm9yKGM9Yi0yO2M+PS0xJiZjIT09LTE7Yy0tKXtjb25zdCBTPU51bWJlci5NSU5fVkFMVUUrWCpNYXRoLmFicyh3W2NdK01hdGguYWJzKHdbYysxXSkpO2lmKE1hdGguYWJzKE1bY10pPD1TfHxOdW1iZXIuaXNOYU4oTVtjXSkpe01bY109MDticmVha319aWYoYz09PWItMilwPTQ7ZWxzZXtsZXQgUztmb3IoUz1iLTE7Uz49YyYmUyE9PWM7Uy0tKXtsZXQgZD0oUyE9PWI/TWF0aC5hYnMoTVtTXSk6MCkrKFMhPT1jKzE/TWF0aC5hYnMoTVtTLTFdKTowKTtpZihNYXRoLmFicyh3W1NdKTw9WCpkKXt3W1NdPTA7YnJlYWt9fVM9PT1jP3A9MzpTPT09Yi0xP3A9MToocD0yLGM9Uyl9c3dpdGNoKGMrKyxwKXtjYXNlIDE6e2xldCBTPU1bYi0yXTtNW2ItMl09MDtmb3IobGV0IGQ9Yi0yO2Q+PWM7ZC0tKXtsZXQgUD1aKHdbZF0sUyksTz13W2RdL1AsVD1TL1A7aWYod1tkXT1QLGQhPT1jJiYoUz0tVCpNW2QtMV0sTVtkLTFdPU8qTVtkLTFdKSx1KWZvcihsZXQgRD0wO0Q8cztEKyspUD1PKm0uZ2V0KEQsZCkrVCptLmdldChELGItMSksbS5zZXQoRCxiLTEsLVQqbS5nZXQoRCxkKStPKm0uZ2V0KEQsYi0xKSksbS5zZXQoRCxkLFApfWJyZWFrfWNhc2UgMjp7bGV0IFM9TVtjLTFdO01bYy0xXT0wO2ZvcihsZXQgZD1jO2Q8YjtkKyspe2xldCBQPVood1tkXSxTKSxPPXdbZF0vUCxUPVMvUDtpZih3W2RdPVAsUz0tVCpNW2RdLE1bZF09TypNW2RdLGwpZm9yKGxldCBEPTA7RDx0O0QrKylQPU8qeS5nZXQoRCxkKStUKnkuZ2V0KEQsYy0xKSx5LnNldChELGMtMSwtVCp5LmdldChELGQpK08qeS5nZXQoRCxjLTEpKSx5LnNldChELGQsUCl9YnJlYWt9Y2FzZSAzOntjb25zdCBTPU1hdGgubWF4KE1hdGguYWJzKHdbYi0xXSksTWF0aC5hYnMod1tiLTJdKSxNYXRoLmFicyhNW2ItMl0pLE1hdGguYWJzKHdbY10pLE1hdGguYWJzKE1bY10pKSxkPXdbYi0xXS9TLFA9d1tiLTJdL1MsTz1NW2ItMl0vUyxUPXdbY10vUyxEPU1bY10vUyxZPSgoUCtkKSooUC1kKStPKk8pLzIsRz1kKk8qKGQqTyk7bGV0IHY9MDsoWSE9PTB8fEchPT0wKSYmKFk8MD92PTAtTWF0aC5zcXJ0KFkqWStHKTp2PU1hdGguc3FydChZKlkrRyksdj1HLyhZK3YpKTtsZXQgVj0oVCtkKSooVC1kKSt2LEo9VCpEO2ZvcihsZXQgTj1jO048Yi0xO04rKyl7bGV0IEI9WihWLEopO0I9PT0wJiYoQj1OdW1iZXIuTUlOX1ZBTFVFKTtsZXQgJD1WL0IsQz1KL0I7aWYoTiE9PWMmJihNW04tMV09QiksVj0kKndbTl0rQypNW05dLE1bTl09JCpNW05dLUMqd1tOXSxKPUMqd1tOKzFdLHdbTisxXT0kKndbTisxXSx1KWZvcihsZXQgVT0wO1U8cztVKyspQj0kKm0uZ2V0KFUsTikrQyptLmdldChVLE4rMSksbS5zZXQoVSxOKzEsLUMqbS5nZXQoVSxOKSskKm0uZ2V0KFUsTisxKSksbS5zZXQoVSxOLEIpO2lmKEI9WihWLEopLEI9PT0wJiYoQj1OdW1iZXIuTUlOX1ZBTFVFKSwkPVYvQixDPUovQix3W05dPUIsVj0kKk1bTl0rQyp3W04rMV0sd1tOKzFdPS1DKk1bTl0rJCp3W04rMV0sSj1DKk1bTisxXSxNW04rMV09JCpNW04rMV0sbCYmTjx0LTEpZm9yKGxldCBVPTA7VTx0O1UrKylCPSQqeS5nZXQoVSxOKStDKnkuZ2V0KFUsTisxKSx5LnNldChVLE4rMSwtQyp5LmdldChVLE4pKyQqeS5nZXQoVSxOKzEpKSx5LnNldChVLE4sQil9TVtiLTJdPVY7YnJlYWt9Y2FzZSA0OntpZih3W2NdPD0wJiYod1tjXT13W2NdPDA/LXdbY106MCx1KSlmb3IobGV0IFM9MDtTPD1GO1MrKyltLnNldChTLGMsLW0uZ2V0KFMsYykpO2Zvcig7YzxGJiYhKHdbY10+PXdbYysxXSk7KXtsZXQgUz13W2NdO2lmKHdbY109d1tjKzFdLHdbYysxXT1TLHUmJmM8cy0xKWZvcihsZXQgZD0wO2Q8cztkKyspUz1tLmdldChkLGMrMSksbS5zZXQoZCxjKzEsbS5nZXQoZCxjKSksbS5zZXQoZCxjLFMpO2lmKGwmJmM8dC0xKWZvcihsZXQgZD0wO2Q8dDtkKyspUz15LmdldChkLGMrMSkseS5zZXQoZCxjKzEseS5nZXQoZCxjKSkseS5zZXQoZCxjLFMpO2MrK31iLS07YnJlYWt9fX1pZihmKXtsZXQgYz1tO209eSx5PWN9dGhpcy5tPXQsdGhpcy5uPXMsdGhpcy5zPXcsdGhpcy5VPXksdGhpcy5WPW19c29sdmUoZSl7bGV0IG49ZSx0PXRoaXMudGhyZXNob2xkLHM9dGhpcy5zLmxlbmd0aCxyPUkuemVyb3MocyxzKTtmb3IobGV0IGE9MDthPHM7YSsrKU1hdGguYWJzKHRoaXMuc1thXSk8PXQ/ci5zZXQoYSxhLDApOnIuc2V0KGEsYSwxL3RoaXMuc1thXSk7bGV0IGk9dGhpcy5VLGg9dGhpcy5yaWdodFNpbmd1bGFyVmVjdG9ycyxsPWgubW11bChyKSx1PWgucm93cyxmPWkucm93cyxnPUkuemVyb3ModSxmKTtmb3IobGV0IGE9MDthPHU7YSsrKWZvcihsZXQgaj0wO2o8ZjtqKyspe2xldCB3PTA7Zm9yKGxldCB5PTA7eTxzO3krKyl3Kz1sLmdldChhLHkpKmkuZ2V0KGoseSk7Zy5zZXQoYSxqLHcpfXJldHVybiBnLm1tdWwobil9c29sdmVGb3JEaWFnb25hbChlKXtyZXR1cm4gdGhpcy5zb2x2ZShJLmRpYWcoZSkpfWludmVyc2UoKXtsZXQgZT10aGlzLlYsbj10aGlzLnRocmVzaG9sZCx0PWUucm93cyxzPWUuY29sdW1ucyxyPW5ldyBJKHQsdGhpcy5zLmxlbmd0aCk7Zm9yKGxldCBmPTA7Zjx0O2YrKylmb3IobGV0IGc9MDtnPHM7ZysrKU1hdGguYWJzKHRoaXMuc1tnXSk+biYmci5zZXQoZixnLGUuZ2V0KGYsZykvdGhpcy5zW2ddKTtsZXQgaT10aGlzLlUsaD1pLnJvd3MsbD1pLmNvbHVtbnMsdT1uZXcgSSh0LGgpO2ZvcihsZXQgZj0wO2Y8dDtmKyspZm9yKGxldCBnPTA7ZzxoO2crKyl7bGV0IGE9MDtmb3IobGV0IGo9MDtqPGw7aisrKWErPXIuZ2V0KGYsaikqaS5nZXQoZyxqKTt1LnNldChmLGcsYSl9cmV0dXJuIHV9Z2V0IGNvbmRpdGlvbigpe3JldHVybiB0aGlzLnNbMF0vdGhpcy5zW01hdGgubWluKHRoaXMubSx0aGlzLm4pLTFdfWdldCBub3JtMigpe3JldHVybiB0aGlzLnNbMF19Z2V0IHJhbmsoKXtsZXQgZT1NYXRoLm1heCh0aGlzLm0sdGhpcy5uKSp0aGlzLnNbMF0qTnVtYmVyLkVQU0lMT04sbj0wLHQ9dGhpcy5zO2ZvcihsZXQgcz0wLHI9dC5sZW5ndGg7czxyO3MrKyl0W3NdPmUmJm4rKztyZXR1cm4gbn1nZXQgZGlhZ29uYWwoKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnMpfWdldCB0aHJlc2hvbGQoKXtyZXR1cm4gTnVtYmVyLkVQU0lMT04vMipNYXRoLm1heCh0aGlzLm0sdGhpcy5uKSp0aGlzLnNbMF19Z2V0IGxlZnRTaW5ndWxhclZlY3RvcnMoKXtyZXR1cm4gdGhpcy5VfWdldCByaWdodFNpbmd1bGFyVmVjdG9ycygpe3JldHVybiB0aGlzLlZ9Z2V0IGRpYWdvbmFsTWF0cml4KCl7cmV0dXJuIEkuZGlhZyh0aGlzLnMpfX1mdW5jdGlvbiBNdChvLGU9ITEpe3JldHVybiBvPW50LmNoZWNrTWF0cml4KG8pLGU/bmV3IER0KG8pLmludmVyc2UoKTpOZShvLEkuZXllKG8ucm93cykpfWZ1bmN0aW9uIE5lKG8sZSxuPSExKXtyZXR1cm4gbz1udC5jaGVja01hdHJpeChvKSxlPW50LmNoZWNrTWF0cml4KGUpLG4/bmV3IER0KG8pLnNvbHZlKGUpOm8uaXNTcXVhcmUoKT9uZXcgUmUobykuc29sdmUoZSk6bmV3IHZlKG8pLnNvbHZlKGUpfWNvbnN0IHFlPTEyMzQsX2U9KCk9Pih7c2VlZDpxZSxhcnJheVNodWZmbGUoZSl7Y29uc3R7YXJyOm4sc2FtcGxlU2l6ZTp0fT1lO2ZvcihsZXQgcz0wO3M8dDtzKyspe3RoaXMuc2VlZD0oMjE0MDEzKnRoaXMuc2VlZCsyNTMxMDExKSUtMjE0NzQ4MzY0ODtsZXQgcj10aGlzLnNlZWQ+PjE2JjMyNzY3O3I9ciVuLmxlbmd0aDtsZXQgaT1uW3NdO25bc109bltyXSxuW3JdPWl9fSxuZXh0SW50KGUpe3RoaXMuc2VlZD0oMjE0MDEzKnRoaXMuc2VlZCsyNTMxMDExKSUtMjE0NzQ4MzY0ODtsZXQgbj10aGlzLnNlZWQ+PjE2JjMyNzY3O3JldHVybiBuPW4lZSxufX0pLEs9KG8sZSxuKT0+KGVbMF0tb1swXSkqKG5bMV0tb1sxXSktKGVbMV0tb1sxXSkqKG5bMF0tb1swXSksemU9KG8sZSxuLHQscyxyLGksaCk9PiEoSyhvLGUsbik+MCE9SyhzLHIsaSk+MHx8SyhlLG4sdCk+MCE9SyhyLGksaCk+MHx8SyhuLHQsbyk+MCE9SyhpLGgscyk+MHx8Syh0LG8sZSk+MCE9SyhoLHMscik+MCksRmU9KG8sZSxuLHQscyxyKT0+SyhvLGUsbik+MD09Syh0LHMscik+MCxUZT1vPT57Y29uc3QgZT1vWzRdKm9bOF0tb1s1XSpvWzddLG49b1szXSpvWzhdLW9bNV0qb1s2XSx0PW9bM10qb1s3XS1vWzRdKm9bNl07cmV0dXJuIG9bMF0qZS1vWzFdKm4rb1syXSp0fSxQdD0obyxlKT0+e2NvbnN0IG49VGUobyk7aWYoTWF0aC5hYnMobik8PWUpcmV0dXJuIG51bGw7Y29uc3QgdD0xL247cmV0dXJuWyhvWzRdKm9bOF0tb1s1XSpvWzddKSp0LChvWzJdKm9bN10tb1sxXSpvWzhdKSp0LChvWzFdKm9bNV0tb1syXSpvWzRdKSp0LChvWzVdKm9bNl0tb1szXSpvWzhdKSp0LChvWzBdKm9bOF0tb1syXSpvWzZdKSp0LChvWzJdKm9bM10tb1swXSpvWzVdKSp0LChvWzNdKm9bN10tb1s0XSpvWzZdKSp0LChvWzFdKm9bNl0tb1swXSpvWzddKSp0LChvWzBdKm9bNF0tb1sxXSpvWzNdKSp0XX0sc3Q9KG8sZSk9Pntjb25zdCBuPWVbNl0qb1swXStlWzddKm9bMV0rZVs4XSx0PVtdO3JldHVybiB0WzBdPShlWzBdKm9bMF0rZVsxXSpvWzFdK2VbMl0pL24sdFsxXT0oZVszXSpvWzBdK2VbNF0qb1sxXStlWzVdKS9uLHR9LERlPShvLGUsbix0KT0+e2NvbnN0IHM9b3QoZSxvKSxyPW90KG4sbyksaT1vdCh0LG8pLGg9b3QoZSxuKSxsPW90KHQsbiksdT1tdChzLHIpLGY9bXQocixpKSxnPW10KHMsaSksYT1tdChoLGwpO3JldHVybiBNYXRoLm1pbihNYXRoLm1pbihNYXRoLm1pbih1LGYpLGcpLGEpfSxQZT0obyxlLG4sdCk9Pntjb25zdCBzPUsobyxlLG4pPD0wO3JldHVybiEoSyhlLG4sdCk8PTAhPT1zfHxLKG4sdCxvKTw9MCE9PXN8fEsodCxvLGUpPD0wIT09cyl9LG90PShvLGUpPT5bb1swXS1lWzBdLG9bMV0tZVsxXV0sbXQ9KG8sZSk9Pntjb25zdCBuPW9bMF0qZVsxXS1vWzFdKmVbMF07cmV0dXJuIE1hdGguYWJzKG4pKi41fSxYdD0obyxlKT0+e2NvbnN0e25vcm1Qb2ludHM6bixwYXJhbTp0fT1CdChvKSx7bm9ybVBvaW50czpzLHBhcmFtOnJ9PUJ0KGUpLGk9cy5sZW5ndGgsaD1bXSxsPVtdO2ZvcihsZXQgdT0wO3U8aTt1Kyspe2NvbnN0IGY9W25bdV1bMF0sblt1XVsxXSwxLDAsMCwwLC0oblt1XVswXSpzW3VdWzBdKSwtKG5bdV1bMV0qc1t1XVswXSldLGc9WzAsMCwwLG5bdV1bMF0sblt1XVsxXSwxLC0oblt1XVswXSpzW3VdWzFdKSwtKG5bdV1bMV0qc1t1XVsxXSldO2gucHVzaChmKSxoLnB1c2goZyksbC5wdXNoKFtzW3VdWzBdXSksbC5wdXNoKFtzW3VdWzFdXSl9dHJ5e2NvbnN0IHU9bmV3IEkoaCksZj1uZXcgSShsKSxnPXUudHJhbnNwb3NlKCksYT1nLm1tdWwodSksaj1nLm1tdWwoZikseT1NdChhKS5tbXVsKGopLnRvMURBcnJheSgpO3JldHVybiBYZSh5LHQscil9Y2F0Y2h7cmV0dXJuIG51bGx9fSxCdD1vPT57bGV0IGU9MCxuPTA7Zm9yKGxldCBsPTA7bDxvLmxlbmd0aDtsKyspZSs9b1tsXVswXSxuKz1vW2xdWzFdO2xldCB0PWUvby5sZW5ndGgscz1uL28ubGVuZ3RoLHI9MDtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyl7Y29uc3QgdT1vW2xdWzBdLXQsZj1vW2xdWzFdLXM7cis9TWF0aC5zcXJ0KHUqdStmKmYpfWxldCBpPU1hdGguc3FydCgyKSpvLmxlbmd0aC9yO2NvbnN0IGg9W107Zm9yKGxldCBsPTA7bDxvLmxlbmd0aDtsKyspaC5wdXNoKFsob1tsXVswXS10KSppLChvW2xdWzFdLXMpKmldKTtyZXR1cm57bm9ybVBvaW50czpoLHBhcmFtOnttZWFuWDp0LG1lYW5ZOnMsczppfX19LFhlPShvLGUsbik9Pntjb25zdCB0PW4ucypuLm1lYW5YLHM9bi5zKm4ubWVhblkscj1bb1swXSt0Km9bNl0sb1sxXSt0Km9bN10sKG9bMF0rdCpvWzZdKSotZS5tZWFuWCsob1sxXSt0Km9bN10pKi1lLm1lYW5ZKyhvWzJdK3QpL2UucyxvWzNdK3Mqb1s2XSxvWzRdK3Mqb1s3XSwob1szXStzKm9bNl0pKi1lLm1lYW5YKyhvWzRdK3Mqb1s3XSkqLWUubWVhblkrKG9bNV0rcykvZS5zLG4ucypvWzZdLG4ucypvWzddLG4ucypvWzZdKi1lLm1lYW5YK24ucypvWzddKi1lLm1lYW5ZK24ucy9lLnNdO2ZvcihsZXQgaT0wO2k8OTtpKyspcltpXT1yW2ldL3JbOF07cmV0dXJuIHJ9LEJlPS4wMSxVZT0xMCxPZT0yMCxWZT0xMCxVdD1vPT57Y29uc3R7c3JjUG9pbnRzOmUsZHN0UG9pbnRzOm4sa2V5ZnJhbWU6dCxxdWlja01vZGU6c309byxyPVtbMCwwXSxbdC53aWR0aCwwXSxbdC53aWR0aCx0LmhlaWdodF0sWzAsdC5oZWlnaHRdXSxpPTQ7aWYoZS5sZW5ndGg8aSlyZXR1cm4gbnVsbDtjb25zdCBoPUJlLGw9MS8oaCpoKSx1PU1hdGgubWluKFVlLGUubGVuZ3RoKSxmPV9lKCksZz1bXTtmb3IobGV0IEU9MDtFPGUubGVuZ3RoO0UrKylnW0VdPUU7Zi5hcnJheVNodWZmbGUoe2FycjpnLHNhbXBsZVNpemU6Zy5sZW5ndGh9KTtjb25zdCBhPXM/VmU6T2Usaj1hKjI7bGV0IHc9MDtjb25zdCB5PVtdO2Zvcig7dzxqJiZ5Lmxlbmd0aDxhOyl7aWYodys9MSxmLmFycmF5U2h1ZmZsZSh7YXJyOmcsc2FtcGxlU2l6ZTppfSksIXplKGVbZ1swXV0sZVtnWzFdXSxlW2dbMl1dLGVbZ1szXV0sbltnWzBdXSxuW2dbMV1dLG5bZ1syXV0sbltnWzNdXSkpY29udGludWU7Y29uc3QgRT1YdChbZVtnWzBdXSxlW2dbMV1dLGVbZ1syXV0sZVtnWzNdXV0sW25bZ1swXV0sbltnWzFdXSxuW2dbMl1dLG5bZ1szXV1dKTtFIT09bnVsbCYmQ2Uoe0g6RSx0ZXN0UG9pbnRzOnJ9KSYmeS5wdXNoKEUpfWlmKHkubGVuZ3RoPT09MClyZXR1cm4gbnVsbDtjb25zdCBtPVtdO2ZvcihsZXQgRT0wO0U8eS5sZW5ndGg7RSsrKW0ucHVzaCh7SDp5W0VdLGNvc3Q6MH0pO2xldCBNPXU7Zm9yKGxldCBFPTA7RTxlLmxlbmd0aCYmbS5sZW5ndGg+MjtFKz1NKXtNPU1hdGgubWluKHUsZS5sZW5ndGgtRSk7bGV0IGs9RStNO2ZvcihsZXQgUj0wO1I8bS5sZW5ndGg7UisrKWZvcihsZXQgcT1FO3E8aztxKyspe2NvbnN0IGI9WWUoe0g6bVtSXS5ILHNyY1BvaW50OmVbcV0sZHN0UG9pbnQ6bltxXSxvbmVPdmVyU2NhbGUyOmx9KTttW1JdLmNvc3QrPWJ9bS5zb3J0KChSLHEpPT5SLmNvc3QtcS5jb3N0KSxtLnNwbGljZSgtTWF0aC5mbG9vcigobS5sZW5ndGgrMSkvMikpfWxldCB6PW51bGw7Zm9yKGxldCBFPTA7RTxtLmxlbmd0aDtFKyspe2NvbnN0IGs9TGUoe2luSDptW0VdLkh9KTtpZigkZSh7SDprLHRlc3RQb2ludHM6cixrZXlmcmFtZTp0fSkpe3o9azticmVha319cmV0dXJuIHp9LCRlPSh7SDpvLHRlc3RQb2ludHM6ZSxrZXlmcmFtZTpufSk9Pntjb25zdCB0PVB0KG8sMWUtNSk7aWYodD09PW51bGwpcmV0dXJuITE7Y29uc3Qgcz1bXTtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKylzLnB1c2goc3QoZVtpXSx0KSk7cmV0dXJuIShEZShzWzBdLHNbMV0sc1syXSxzWzNdKTxuLndpZHRoKm4uaGVpZ2h0KjFlLTR8fCFQZShzWzBdLHNbMV0sc1syXSxzWzNdKSl9LExlPSh7aW5IOm99KT0+e2NvbnN0IGU9MS9vWzhdLG49W107Zm9yKGxldCB0PTA7dDw4O3QrKyluW3RdPW9bdF0qZTtyZXR1cm4gbls4XT0xLG59LFllPSh7SDpvLHNyY1BvaW50OmUsZHN0UG9pbnQ6bixvbmVPdmVyU2NhbGUyOnR9KT0+e2NvbnN0IHM9c3QoZSxvKSxyPVtzWzBdLW5bMF0sc1sxXS1uWzFdXTtyZXR1cm4gTWF0aC5sb2coMSsoclswXSpyWzBdK3JbMV0qclsxXSkqdCl9LENlPSh7SDpvLHRlc3RQb2ludHM6ZX0pPT57Y29uc3Qgbj1bXTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyluW3RdPXN0KGVbdF0sbyk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHM9dCxyPSh0KzEpJWUubGVuZ3RoLGk9KHQrMiklZS5sZW5ndGg7aWYoIUZlKGVbc10sZVtyXSxlW2ldLG5bc10sbltyXSxuW2ldKSlyZXR1cm4hMX1yZXR1cm4hMH0sT3Q9MyxWdD02LEhlPTgsJHQ9LjcsSmU9KHtrZXlmcmFtZTpvLHF1ZXJ5cG9pbnRzOmUscXVlcnl3aWR0aDpuLHF1ZXJ5aGVpZ2h0OnQsZGVidWdNb2RlOnN9KT0+e2xldCByPXt9O2NvbnN0IGk9W107Zm9yKGxldCBtPTA7bTxlLmxlbmd0aDttKyspe2NvbnN0IE09ZVttXSx6PU0ubWF4aW1hP28ubWF4aW1hUG9pbnRzOm8ubWluaW1hUG9pbnRzO2lmKHoubGVuZ3RoPT09MCljb250aW51ZTtjb25zdCBFPU0ubWF4aW1hP28ubWF4aW1hUG9pbnRzQ2x1c3Rlci5yb290Tm9kZTpvLm1pbmltYVBvaW50c0NsdXN0ZXIucm9vdE5vZGUsaz1bXSxSPW5ldyBHdChbXSwoWCxjKT0+WC5kLWMuZCk7RXQoe25vZGU6RSxrZXlwb2ludHM6eixxdWVyeXBvaW50Ok0scXVldWU6UixrZXlwb2ludEluZGV4ZXM6ayxudW1Qb3A6MH0pO2xldCBxPS0xLGI9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsRj1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtmb3IobGV0IFg9MDtYPGsubGVuZ3RoO1grKyl7Y29uc3QgYz16W2tbWF1dLHA9eXQoe3YxOmMuZGVzY3JpcHRvcnMsdjI6TS5kZXNjcmlwdG9yc30pO3A8Yj8oRj1iLGI9cCxxPWtbWF0pOnA8RiYmKEY9cCl9cSE9PS0xJiYoRj09PU51bWJlci5NQVhfU0FGRV9JTlRFR0VSfHwxKmIvRjwkdCkmJmkucHVzaCh7cXVlcnlwb2ludDpNLGtleXBvaW50OnpbcV19KX1pZihzJiYoci5tYXRjaGVzPWkpLGkubGVuZ3RoPFZ0KXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IGg9TnQoe2tleXdpZHRoOm8ud2lkdGgsa2V5aGVpZ2h0Om8uaGVpZ2h0LHF1ZXJ5d2lkdGg6bixxdWVyeWhlaWdodDp0LG1hdGNoZXM6aX0pO3MmJihyLmhvdWdoTWF0Y2hlcz1oKTtjb25zdCBsPVV0KHtzcmNQb2ludHM6aC5tYXAobT0+W20ua2V5cG9pbnQueCxtLmtleXBvaW50LnldKSxkc3RQb2ludHM6aC5tYXAobT0+W20ucXVlcnlwb2ludC54LG0ucXVlcnlwb2ludC55XSksa2V5ZnJhbWU6b30pO2lmKGw9PT1udWxsKXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IHU9THQoe0g6bCxtYXRjaGVzOmgsdGhyZXNob2xkOk90fSk7aWYocyYmKHIuaW5saWVyTWF0Y2hlcz11KSx1Lmxlbmd0aDxWdClyZXR1cm57ZGVidWdFeHRyYTpyfTtjb25zdCBmPVB0KGwsMWUtNSksZz0xMCoxMCxhPVtdO2ZvcihsZXQgbT0wO208ZS5sZW5ndGg7bSsrKXtjb25zdCBNPWVbbV0sej1zdChbTS54LE0ueV0sZik7bGV0IEU9LTEsaz1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUixSPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2NvbnN0IHE9TS5tYXhpbWE/by5tYXhpbWFQb2ludHM6by5taW5pbWFQb2ludHM7Zm9yKGxldCBiPTA7YjxxLmxlbmd0aDtiKyspe2NvbnN0IEY9cVtiXTtpZigoRi54LXpbMF0pKihGLngtelswXSkrKEYueS16WzFdKSooRi55LXpbMV0pPmcpY29udGludWU7Y29uc3QgYz15dCh7djE6Ri5kZXNjcmlwdG9ycyx2MjpNLmRlc2NyaXB0b3JzfSk7YzxrPyhSPWssaz1jLEU9Yik6YzxSJiYoUj1jKX1FIT09LTEmJihSPT09TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ8fDEqay9SPCR0KSYmYS5wdXNoKHtxdWVyeXBvaW50Ok0sa2V5cG9pbnQ6cVtFXX0pfXMmJihyLm1hdGNoZXMyPWEpO2NvbnN0IGo9TnQoe2tleXdpZHRoOm8ud2lkdGgsa2V5aGVpZ2h0Om8uaGVpZ2h0LHF1ZXJ5d2lkdGg6bixxdWVyeWhlaWdodDp0LG1hdGNoZXM6YX0pO3MmJihyLmhvdWdoTWF0Y2hlczI9aik7Y29uc3Qgdz1VdCh7c3JjUG9pbnRzOmoubWFwKG09PlttLmtleXBvaW50LngsbS5rZXlwb2ludC55XSksZHN0UG9pbnRzOmoubWFwKG09PlttLnF1ZXJ5cG9pbnQueCxtLnF1ZXJ5cG9pbnQueV0pLGtleWZyYW1lOm99KTtpZih3PT09bnVsbClyZXR1cm57ZGVidWdFeHRyYTpyfTtjb25zdCB5PUx0KHtIOncsbWF0Y2hlczpqLHRocmVzaG9sZDpPdH0pO3JldHVybiBzJiYoci5pbmxpZXJNYXRjaGVzMj15KSx7SDp3LG1hdGNoZXM6eSxkZWJ1Z0V4dHJhOnJ9fSxFdD0oe25vZGU6byxrZXlwb2ludHM6ZSxxdWVyeXBvaW50Om4scXVldWU6dCxrZXlwb2ludEluZGV4ZXM6cyxudW1Qb3A6cn0pPT57aWYoby5sZWFmKXtmb3IobGV0IGw9MDtsPG8ucG9pbnRJbmRleGVzLmxlbmd0aDtsKyspcy5wdXNoKG8ucG9pbnRJbmRleGVzW2xdKTtyZXR1cm59Y29uc3QgaT1bXTtmb3IobGV0IGw9MDtsPG8uY2hpbGRyZW4ubGVuZ3RoO2wrKyl7Y29uc3QgZj1vLmNoaWxkcmVuW2xdLmNlbnRlclBvaW50SW5kZXgsZz15dCh7djE6ZVtmXS5kZXNjcmlwdG9ycyx2MjpuLmRlc2NyaXB0b3JzfSk7aS5wdXNoKGcpfWxldCBoPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKWg9TWF0aC5taW4oaCxpW2xdKTtmb3IobGV0IGw9MDtsPG8uY2hpbGRyZW4ubGVuZ3RoO2wrKylpW2xdIT09aCYmdC5wdXNoKHtub2RlOm8uY2hpbGRyZW5bbF0sZDppW2xdfSk7Zm9yKGxldCBsPTA7bDxvLmNoaWxkcmVuLmxlbmd0aDtsKyspaVtsXT09PWgmJkV0KHtub2RlOm8uY2hpbGRyZW5bbF0sa2V5cG9pbnRzOmUscXVlcnlwb2ludDpuLHF1ZXVlOnQsa2V5cG9pbnRJbmRleGVzOnMsbnVtUG9wOnJ9KTtpZihyPEhlJiZ0Lmxlbmd0aD4wKXtjb25zdHtub2RlOmwsZDp1fT10LnBvcCgpO3IrPTEsRXQoe25vZGU6bCxrZXlwb2ludHM6ZSxxdWVyeXBvaW50Om4scXVldWU6dCxrZXlwb2ludEluZGV4ZXM6cyxudW1Qb3A6cn0pfX0sTHQ9bz0+e2NvbnN0e0g6ZSxtYXRjaGVzOm4sdGhyZXNob2xkOnR9PW8scz10KnQscj1bXTtmb3IobGV0IGk9MDtpPG4ubGVuZ3RoO2krKyl7Y29uc3QgaD1uW2ldLnF1ZXJ5cG9pbnQsbD1uW2ldLmtleXBvaW50LHU9c3QoW2wueCxsLnldLGUpOyh1WzBdLWgueCkqKHVbMF0taC54KSsodVsxXS1oLnkpKih1WzFdLWgueSk8PXMmJnIucHVzaChuW2ldKX1yZXR1cm4gcn07Y2xhc3MgS2V7Y29uc3RydWN0b3IoZSxuLHQ9ITEpe3RoaXMucXVlcnlXaWR0aD1lLHRoaXMucXVlcnlIZWlnaHQ9bix0aGlzLmRlYnVnTW9kZT10fW1hdGNoRGV0ZWN0aW9uKGUsbil7bGV0IHQ9e2ZyYW1lczpbXX0scz1udWxsO2ZvcihsZXQgbD0wO2w8ZS5sZW5ndGg7bCsrKXtjb25zdHtIOnUsbWF0Y2hlczpmLGRlYnVnRXh0cmE6Z309SmUoe2tleWZyYW1lOmVbbF0scXVlcnlwb2ludHM6bixxdWVyeXdpZHRoOnRoaXMucXVlcnlXaWR0aCxxdWVyeWhlaWdodDp0aGlzLnF1ZXJ5SGVpZ2h0LGRlYnVnTW9kZTp0aGlzLmRlYnVnTW9kZX0pO3QuZnJhbWVzLnB1c2goZyksdSYmKHM9PT1udWxsfHxzLm1hdGNoZXMubGVuZ3RoPGYubGVuZ3RoKSYmKHM9e2tleWZyYW1lSW5kZXg6bCxIOnUsbWF0Y2hlczpmfSl9aWYocz09PW51bGwpcmV0dXJue2tleWZyYW1lSW5kZXg6LTEsZGVidWdFeHRyYTp0fTtjb25zdCByPVtdLGk9W10saD1lW3Mua2V5ZnJhbWVJbmRleF07Zm9yKGxldCBsPTA7bDxzLm1hdGNoZXMubGVuZ3RoO2wrKyl7Y29uc3QgdT1zLm1hdGNoZXNbbF0ucXVlcnlwb2ludCxmPXMubWF0Y2hlc1tsXS5rZXlwb2ludDtyLnB1c2goe3g6dS54LHk6dS55fSksaS5wdXNoKHt4OihmLngrLjUpL2guc2NhbGUseTooZi55Ky41KS9oLnNjYWxlLHo6MH0pfXJldHVybntzY3JlZW5Db29yZHM6cix3b3JsZENvb3JkczppLGtleWZyYW1lSW5kZXg6cy5rZXlmcmFtZUluZGV4LGRlYnVnRXh0cmE6dH19fWNvbnN0IEdlPSh7c2NyZWVuQ29vcmRzOm8sd29ybGRDb29yZHM6ZSxwcm9qZWN0aW9uVHJhbnNmb3JtOm59KT0+e2NvbnN0IHQ9WHQoZS5tYXAobT0+W20ueCxtLnldKSxvLm1hcChtPT5bbS54LG0ueV0pKSxzPW5ldyBJKFtbdFswXSx0WzFdLHRbMl1dLFt0WzNdLHRbNF0sdFs1XV0sW3RbNl0sdFs3XSx0WzhdXV0pLHI9bmV3IEkobiksbD1NdChyKS5tbXVsKHMpLnRvMURBcnJheSgpLHU9TWF0aC5zcXJ0KGxbMF0qbFswXStsWzNdKmxbM10rbFs2XSpsWzZdKSxmPU1hdGguc3FydChsWzFdKmxbMV0rbFs0XSpsWzRdK2xbN10qbFs3XSksZz0odStmKS8yLGE9W107YVswXT1sWzBdL3UsYVszXT1sWzNdL3UsYVs2XT1sWzZdL3UsYVsxXT1sWzFdL2YsYVs0XT1sWzRdL2YsYVs3XT1sWzddL2YsYVsyXT1hWzNdKmFbN10tYVs2XSphWzRdLGFbNV09YVs2XSphWzFdLWFbMF0qYVs3XSxhWzhdPWFbMF0qYVs0XS1hWzFdKmFbM107Y29uc3Qgaj1NYXRoLnNxcnQoYVsyXSphWzJdK2FbNV0qYVs1XSthWzhdKmFbOF0pO2FbMl0vPWosYVs1XS89aixhWzhdLz1qO2NvbnN0IHc9W107cmV0dXJuIHdbMF09bFsyXS9nLHdbMV09bFs1XS9nLHdbMl09bFs4XS9nLFtbYVswXSxhWzFdLGFbMl0sd1swXV0sW2FbM10sYVs0XSxhWzVdLHdbMV1dLFthWzZdLGFbN10sYVs4XSx3WzJdXV19LFFlPShvLGUpPT5bW29bMF1bMF0qZVswXVswXStvWzBdWzJdKmVbMl1bMF0sb1swXVswXSplWzBdWzFdK29bMF1bMl0qZVsyXVsxXSxvWzBdWzBdKmVbMF1bMl0rb1swXVsyXSplWzJdWzJdLG9bMF1bMF0qZVswXVszXStvWzBdWzJdKmVbMl1bM11dLFtvWzFdWzFdKmVbMV1bMF0rb1sxXVsyXSplWzJdWzBdLG9bMV1bMV0qZVsxXVsxXStvWzFdWzJdKmVbMl1bMV0sb1sxXVsxXSplWzFdWzJdK29bMV1bMl0qZVsyXVsyXSxvWzFdWzFdKmVbMV1bM10rb1sxXVsyXSplWzJdWzNdXSxbZVsyXVswXSxlWzJdWzFdLGVbMl1bMl0sZVsyXVszXV1dLFl0PShvLGUsbix0KT0+e2NvbnN0IHM9b1swXVswXSplK29bMF1bMV0qbitvWzBdWzNdLHI9b1sxXVswXSplK29bMV1bMV0qbitvWzFdWzNdLGk9b1syXVswXSplK29bMl1bMV0qbitvWzJdWzNdO3JldHVybnt4OnMseTpyLHo6aX19LFdlPShvLGUsbix0KT0+e2NvbnN0e3g6cyx5OnIsejppfT1ZdChvLGUsbik7cmV0dXJue3g6cy9pLHk6ci9pfX0sWmU9NSx4ZT00LEN0PTEwLEFlPS4xLHRuPS45OTtsZXQgSD1bW10sW10sW11dLHg9W1tdLFtdXSxMPVtbXSxbXSxbXV07Y29uc3QgZW49KHtpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtOm8scHJvamVjdGlvblRyYW5zZm9ybTplLHdvcmxkQ29vcmRzOm4sc2NyZWVuQ29vcmRzOnR9KT0+e2xldCBzPTAscj0wO2ZvcihsZXQgZz0wO2c8bi5sZW5ndGg7ZysrKXMrPW5bZ10ueCxyKz1uW2ddLnk7cy89bi5sZW5ndGgsci89bi5sZW5ndGg7Y29uc3QgaT1bXTtmb3IobGV0IGc9MDtnPG4ubGVuZ3RoO2crKylpLnB1c2goe3g6bltnXS54LXMseTpuW2ddLnktcix6Om5bZ10uen0pO2NvbnN0IGg9W1tdLFtdLFtdXTtmb3IobGV0IGc9MDtnPDM7ZysrKWZvcihsZXQgYT0wO2E8MzthKyspaFtnXVthXT1vW2ddW2FdO2hbMF1bM109b1swXVswXSpzK29bMF1bMV0qcitvWzBdWzNdLGhbMV1bM109b1sxXVswXSpzK29bMV1bMV0qcitvWzFdWzNdLGhbMl1bM109b1syXVswXSpzK29bMl1bMV0qcitvWzJdWzNdO2NvbnN0IGw9WzEsLjgsLjYsLjQsMF07bGV0IHU9aCxmPW51bGw7Zm9yKGxldCBnPTA7ZzxsLmxlbmd0aDtnKyspe2NvbnN0IGE9bm4oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06dSxwcm9qZWN0aW9uVHJhbnNmb3JtOmUsd29ybGRDb29yZHM6aSxzY3JlZW5Db29yZHM6dCxpbmxpZXJQcm9iOmxbZ119KTtpZih1PWEubW9kZWxWaWV3VHJhbnNmb3JtLGEuZXJyPFplKXtmPXU7YnJlYWt9fXJldHVybiBmPT09bnVsbD9udWxsOihmWzBdWzNdPWZbMF1bM10tZlswXVswXSpzLWZbMF1bMV0qcixmWzFdWzNdPWZbMV1bM10tZlsxXVswXSpzLWZbMV1bMV0qcixmWzJdWzNdPWZbMl1bM10tZlsyXVswXSpzLWZbMl1bMV0qcixmKX0sbm49KHtpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtOm8scHJvamVjdGlvblRyYW5zZm9ybTplLHdvcmxkQ29vcmRzOm4sc2NyZWVuQ29vcmRzOnQsaW5saWVyUHJvYjpzfSk9Pntjb25zdCByPXM8MTtsZXQgaT1vLGg9MCxsPTAsdT1uZXcgQXJyYXkobi5sZW5ndGgpLGY9bmV3IEFycmF5KG4ubGVuZ3RoKSxnPW5ldyBBcnJheShuLmxlbmd0aCksYT1uZXcgQXJyYXkobi5sZW5ndGgpO2ZvcihsZXQgaj0wO2o8PUN0O2orKyl7Y29uc3Qgdz1RZShlLGkpO2ZvcihsZXQgRT0wO0U8bi5sZW5ndGg7RSsrKXtjb25zdCBrPVdlKHcsbltFXS54LG5bRV0ueSxuW0VdLnopLFI9dFtFXS54LWsueCxxPXRbRV0ueS1rLnk7Z1tFXT1SLGFbRV09cSx1W0VdPVIqUitxKnF9bGV0IHk7aWYobD0wLHIpe2NvbnN0IEU9TWF0aC5tYXgoMyxNYXRoLmZsb29yKG4ubGVuZ3RoKnMpLTEpO2ZvcihsZXQgaz0wO2s8bi5sZW5ndGg7aysrKWZba109dVtrXTtmLnNvcnQoKGssUik9PmstUikseT1NYXRoLm1heChmW0VdKnhlLDE2KTtmb3IobGV0IGs9MDtrPG4ubGVuZ3RoO2srKylmW2tdPnk/bCs9eS82OmwrPXkvNiooMS0oMS1mW2tdL3kpKigxLWZba10veSkqKDEtZltrXS95KSl9ZWxzZSBmb3IobGV0IEU9MDtFPG4ubGVuZ3RoO0UrKylsKz11W0VdO2lmKGwvPW4ubGVuZ3RoLGw8QWV8fGo+MCYmbC9oPnRufHxqPT09Q3QpYnJlYWs7aD1sO2NvbnN0IG09W10sTT1bXTtmb3IobGV0IEU9MDtFPG4ubGVuZ3RoO0UrKyl7aWYociYmdVtFXT55KWNvbnRpbnVlO2NvbnN0IGs9cm4oe21vZGVsVmlld1Byb2plY3Rpb25UcmFuc2Zvcm06dyxtb2RlbFZpZXdUcmFuc2Zvcm06aSxwcm9qZWN0aW9uVHJhbnNmb3JtOmUsd29ybGRDb29yZDpuW0VdfSk7aWYocil7Y29uc3QgUj0oMS11W0VdL3kpKigxLXVbRV0veSk7Zm9yKGxldCBxPTA7cTwyO3ErKylmb3IobGV0IGI9MDtiPDY7YisrKWtbcV1bYl0qPVI7bS5wdXNoKFtnW0VdKlJdKSxtLnB1c2goW2FbRV0qUl0pfWVsc2UgbS5wdXNoKFtnW0VdXSksbS5wdXNoKFthW0VdXSk7Zm9yKGxldCBSPTA7UjxrLmxlbmd0aDtSKyspTS5wdXNoKGtbUl0pfWNvbnN0IHo9b24oe2RVOm0sSl9VX1M6TX0pO2lmKHo9PT1udWxsKWJyZWFrO2k9c24oe21vZGVsVmlld1RyYW5zZm9ybTppLGRTOnp9KX1yZXR1cm57bW9kZWxWaWV3VHJhbnNmb3JtOmksZXJyOmx9fSxzbj0oe21vZGVsVmlld1RyYW5zZm9ybTpvLGRTOmV9KT0+e2xldCBuPWVbMF0qZVswXStlWzFdKmVbMV0rZVsyXSplWzJdLHQscyxyO248MWUtNj8odD0xLHM9MCxyPTAsbj0wKToobj1NYXRoLnNxcnQobiksdD1lWzBdL24scz1lWzFdL24scj1lWzJdL24pO2NvbnN0IGk9TWF0aC5jb3MobiksaD1NYXRoLnNpbihuKSxsPTEtaTtIWzBdWzBdPXQqdCpsK2ksSFswXVsxXT10KnMqbC1yKmgsSFswXVsyXT10KnIqbCtzKmgsSFswXVszXT1lWzNdLEhbMV1bMF09cyp0KmwrcipoLEhbMV1bMV09cypzKmwraSxIWzFdWzJdPXMqcipsLXQqaCxIWzFdWzNdPWVbNF0sSFsyXVswXT1yKnQqbC1zKmgsSFsyXVsxXT1yKnMqbCt0KmgsSFsyXVsyXT1yKnIqbCtpLEhbMl1bM109ZVs1XTtjb25zdCB1PVtbXSxbXSxbXV07Zm9yKGxldCBmPTA7ZjwzO2YrKyl7Zm9yKGxldCBnPTA7Zzw0O2crKyl1W2ZdW2ddPW9bZl1bMF0qSFswXVtnXStvW2ZdWzFdKkhbMV1bZ10rb1tmXVsyXSpIWzJdW2ddO3VbZl1bM10rPW9bZl1bM119cmV0dXJuIHV9LG9uPSh7ZFU6byxKX1VfUzplfSk9Pntjb25zdCBuPW5ldyBJKGUpLHQ9bmV3IEkobykscz1uLnRyYW5zcG9zZSgpLHI9cy5tbXVsKG4pLGk9cy5tbXVsKHQpO2xldCBoO3RyeXtoPU10KHIpfWNhdGNoe3JldHVybiBudWxsfXJldHVybiBoLm1tdWwoaSkudG8xREFycmF5KCl9LHJuPSh7bW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybTpvLG1vZGVsVmlld1RyYW5zZm9ybTplLHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkOnR9KT0+e2NvbnN0IHM9ZSx7eDpyLHk6aSx6Omh9PXQsbD1ZdChvLHIsaSksdT1sLnoqbC56O3hbMF1bMF09blswXVswXSpsLnovdSx4WzBdWzFdPW5bMF1bMV0qbC56L3UseFswXVsyXT0oblswXVsyXSpsLnotblsyXVsyXSpsLngpL3UseFsxXVswXT1uWzFdWzBdKmwuei91LHhbMV1bMV09blsxXVsxXSpsLnovdSx4WzFdWzJdPShuWzFdWzJdKmwuei1uWzJdWzJdKmwueSkvdSxMWzBdWzBdPXNbMF1bMl0qaSxMWzBdWzFdPS1zWzBdWzJdKnIsTFswXVsyXT1zWzBdWzFdKnItc1swXVswXSppLExbMF1bM109c1swXVswXSxMWzBdWzRdPXNbMF1bMV0sTFswXVs1XT1zWzBdWzJdLExbMV1bMF09c1sxXVsyXSppLExbMV1bMV09LXNbMV1bMl0qcixMWzFdWzJdPXNbMV1bMV0qci1zWzFdWzBdKmksTFsxXVszXT1zWzFdWzBdLExbMV1bNF09c1sxXVsxXSxMWzFdWzVdPXNbMV1bMl0sTFsyXVswXT1zWzJdWzJdKmksTFsyXVsxXT0tc1syXVsyXSpyLExbMl1bMl09c1syXVsxXSpyLXNbMl1bMF0qaSxMWzJdWzNdPXNbMl1bMF0sTFsyXVs0XT1zWzJdWzFdLExbMl1bNV09c1syXVsyXTtjb25zdCBmPVtbXSxbXV07Zm9yKGxldCBnPTA7ZzwyO2crKylmb3IobGV0IGE9MDthPDY7YSsrKXtmW2ddW2FdPTA7Zm9yKGxldCBqPTA7ajwzO2orKylmW2ddW2FdKz14W2ddW2pdKkxbal1bYV19cmV0dXJuIGZ9O2NsYXNzIGxue2NvbnN0cnVjdG9yKGUpe3RoaXMucHJvamVjdGlvblRyYW5zZm9ybT1lfWVzdGltYXRlKHtzY3JlZW5Db29yZHM6ZSx3b3JsZENvb3JkczpufSl7cmV0dXJuIEdlKHtzY3JlZW5Db29yZHM6ZSx3b3JsZENvb3JkczpuLHByb2plY3Rpb25UcmFuc2Zvcm06dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtfSl9cmVmaW5lRXN0aW1hdGUoe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06ZSx3b3JsZENvb3JkczpuLHNjcmVlbkNvb3Jkczp0fSl7cmV0dXJuIGVuKHtpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtOmUsd29ybGRDb29yZHM6bixzY3JlZW5Db29yZHM6dCxwcm9qZWN0aW9uVHJhbnNmb3JtOnRoaXMucHJvamVjdGlvblRyYW5zZm9ybX0pfX1sZXQgSHQ9bnVsbCxKdD0hMSxLdD1udWxsLFN0PW51bGw7b25tZXNzYWdlPW89Pntjb25zdHtkYXRhOmV9PW87c3dpdGNoKGUudHlwZSl7Y2FzZSJzZXR1cCI6ZS5wcm9qZWN0aW9uVHJhbnNmb3JtLEh0PWUubWF0Y2hpbmdEYXRhTGlzdCxKdD1lLmRlYnVnTW9kZSxLdD1uZXcgS2UoZS5pbnB1dFdpZHRoLGUuaW5wdXRIZWlnaHQsSnQpLFN0PW5ldyBsbihlLnByb2plY3Rpb25UcmFuc2Zvcm0pO2JyZWFrO2Nhc2UibWF0Y2giOmNvbnN0IG49ZS50YXJnZXRJbmRleGVzO2xldCB0PS0xLHM9bnVsbCxyPW51bGw7Zm9yKGxldCBmPTA7ZjxuLmxlbmd0aDtmKyspe2NvbnN0IGc9bltmXSx7a2V5ZnJhbWVJbmRleDphLHNjcmVlbkNvb3JkczpqLHdvcmxkQ29vcmRzOncsZGVidWdFeHRyYTp5fT1LdC5tYXRjaERldGVjdGlvbihIdFtnXSxlLmZlYXR1cmVQb2ludHMpO2lmKHI9eSxhIT09LTEpe2NvbnN0IG09U3QuZXN0aW1hdGUoe3NjcmVlbkNvb3JkczpqLHdvcmxkQ29vcmRzOnd9KTttJiYodD1nLHM9bSk7YnJlYWt9fXBvc3RNZXNzYWdlKHt0eXBlOiJtYXRjaERvbmUiLHRhcmdldEluZGV4OnQsbW9kZWxWaWV3VHJhbnNmb3JtOnMsZGVidWdFeHRyYTpyfSk7YnJlYWs7Y2FzZSJ0cmFja1VwZGF0ZSI6Y29uc3R7bW9kZWxWaWV3VHJhbnNmb3JtOmksd29ybGRDb29yZHM6aCxzY3JlZW5Db29yZHM6bH09ZSx1PVN0LnJlZmluZUVzdGltYXRlKHtpbml0aWFsTW9kZWxWaWV3VHJhbnNmb3JtOmksd29ybGRDb29yZHM6aCxzY3JlZW5Db29yZHM6bH0pO3Bvc3RNZXNzYWdlKHt0eXBlOiJ0cmFja1VwZGF0ZURvbmUiLG1vZGVsVmlld1RyYW5zZm9ybTp1fSk7YnJlYWs7Y2FzZSJkaXNwb3NlIjpjbG9zZSgpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgdHlwZSAnJHtlLnR5cGV9J2ApfX19KSgpOwo=",uF=typeof window<"u"&&window.Blob&&new Blob([atob(cF)],{type:"text/javascript;charset=utf-8"});function soe(){const s=uF&&(window.URL||window.webkitURL).createObjectURL(uF);try{return s?new Worker(s):new Worker("data:application/javascript;base64,"+cF)}finally{s&&(window.URL||window.webkitURL).revokeObjectURL(s)}}const roe=(s,t)=>[[s[0][0]*t[0][0]+s[0][2]*t[2][0],s[0][0]*t[0][1]+s[0][2]*t[2][1],s[0][0]*t[0][2]+s[0][2]*t[2][2],s[0][0]*t[0][3]+s[0][2]*t[2][3]],[s[1][1]*t[1][0]+s[1][2]*t[2][0],s[1][1]*t[1][1]+s[1][2]*t[2][1],s[1][1]*t[1][2]+s[1][2]*t[2][2],s[1][1]*t[1][3]+s[1][2]*t[2][3]],[t[2][0],t[2][1],t[2][2],t[2][3]]],aoe=(s,t,i,o)=>{const l=s[0][0]*t+s[0][1]*i+s[0][3],u=s[1][0]*t+s[1][1]*i+s[1][3],f=s[2][0]*t+s[2][1]*i+s[2][3];return{x:l,y:u,z:f}},ooe=(s,t,i,o)=>{const{x:l,y:u,z:f}=aoe(s,t,i);return{x:l/f,y:u/f}},loe=6,coe=1,uoe=10,hoe=1,doe=.8,foe=1,uu=1e3;class poe{constructor(t,i,o,l,u,f=!1){this.markerDimensions=t,this.trackingDataList=i,this.projectionTransform=o,this.debugMode=f,this.trackingKeyframeList=[];for(let A=0;A<i.length;A++)this.trackingKeyframeList.push(i[A][foe]);let g=0;for(let A=0;A<this.trackingKeyframeList.length;A++)g=Math.max(g,this.trackingKeyframeList[A].points.length);this.featurePointsListT=[],this.imagePixelsListT=[],this.imagePropertiesListT=[];for(let A=0;A<this.trackingKeyframeList.length;A++){const{featurePoints:v,imagePixels:C,imageProperties:S}=this._prebuild(this.trackingKeyframeList[A],g);this.featurePointsListT[A]=v,this.imagePixelsListT[A]=C,this.imagePropertiesListT[A]=S}this.kernelCaches={}}dummyRun(t){let i=[[1,1,1,1],[1,1,1,1],[1,1,1,1]];for(let o=0;o<this.featurePointsListT.length;o++)this.track(t,i,o)}track(t,i,o){let l={};const u=roe(this.projectionTransform,i),f=this._buildAdjustedModelViewTransform(u);this.markerDimensions[o][0],this.markerDimensions[o][1],this.trackingKeyframeList[o].width,this.trackingKeyframeList[o].height;const g=this.featurePointsListT[o],A=this.imagePixelsListT[o],v=this.imagePropertiesListT[o],C=this._computeProjection(f,t,o),{matchingPointsT:S,simT:M}=this._computeMatching(g,A,v,C),_=S.arraySync(),B=M.arraySync(),F=this.trackingKeyframeList[o],P=[],U=[],V=[];for(let $=0;$<_.length;$++)if(B[$]>doe&&$<F.points.length){V.push($);const q=ooe(u,_[$][0],_[$][1]);U.push(q),P.push({x:F.points[$].x/F.scale,y:F.points[$].y/F.scale,z:0})}return this.debugMode&&(l={projectedImage:C.arraySync(),matchingPoints:S.arraySync(),goodTrack:V,trackedPoints:U}),f.dispose(),C.dispose(),S.dispose(),M.dispose(),{worldCoords:P,screenCoords:U,debugExtra:l}}_computeMatching(t,i,o,l){const u=loe,f=u*2+1,g=uoe*coe,A=hoe,v=g*2+1,C=l.shape[0],S=l.shape[1],M=t.shape[0];if(!this.kernelCaches.computeMatching){const _={variableNames:["features","markerPixels","markerProperties","targetPixels"],outputShape:[M,v*v],userCode:`
	  void main() {
	    ivec2 coords = getOutputCoords();

	    int featureIndex = coords[0];
	    int searchOffsetIndex = coords[1];

	    int markerWidth = int(getMarkerProperties(0));
	    int markerHeight = int(getMarkerProperties(1));
	    float markerScale = getMarkerProperties(2);

	    int searchOffsetX = imod(searchOffsetIndex, ${v}) * ${A};
	    int searchOffsetY = searchOffsetIndex / ${v} * ${A};

	    int sCenterX = int(getFeatures(featureIndex, 0) * markerScale);
	    int sCenterY = int(getFeatures(featureIndex, 1) * markerScale);

	    int sx = sCenterX + searchOffsetX - ${g};
	    int sy = sCenterY + searchOffsetY - ${g};

	    if (sx < ${u} || sx >= (${S} - ${u}) || sy < ${u} || sy >= (${C} - ${u})) {
	      setOutput(-2.);
	    } 
	    else {
	      float sumPoint = 0.;
	      float sumPointSquare = 0.;
	      float sumTemplate = 0.;
	      float sumTemplateSquare = 0.;
	      float sumPointTemplate = 0.;

	      for (int templateOffsetY = 0; templateOffsetY < ${f}; templateOffsetY++) {
		for (int templateOffsetX = 0; templateOffsetX < ${f}; templateOffsetX++) {
		  int fx2 = sCenterX + templateOffsetX - ${u};
		  int fy2 = sCenterY + templateOffsetY - ${u};

		  int sx2 = sx + templateOffsetX - ${u};
		  int sy2 = sy + templateOffsetY - ${u};

		  int markerPixelIndex = fy2 * markerWidth + fx2;
		  float markerPixel = getMarkerPixels(markerPixelIndex);
		  float targetPixel = getTargetPixels(sy2, sx2);

		  sumTemplate += markerPixel;
		  sumTemplateSquare += markerPixel * markerPixel;
		  sumPoint += targetPixel;
		  sumPointSquare += targetPixel * targetPixel;
		  sumPointTemplate += targetPixel * markerPixel;
		}
	      }

	      // Normalized cross-correlation
	      // !important divide first avoid overflow (e.g. sumPoint / count * sumPoint)
	      float count = float(${f} * ${f});
	      float pointVariance = sqrt(sumPointSquare - sumPoint / count * sumPoint);
	      float templateVariance = sqrt(sumTemplateSquare - sumTemplate / count * sumTemplate);

	      if (pointVariance < 0.0000001) {
		setOutput(-3.);
	      } else if (templateVariance < 0.0000001) {
		//setOutput(sumTemplate);
		setOutput(-4.);
	      } else {
		sumPointTemplate -= sumPoint / count * sumTemplate;
		float sim = sumPointTemplate / pointVariance / templateVariance;  
		setOutput(sim);
	      }
	    }
	  }
	`},B={variableNames:["featurePoints","markerProperties","maxIndex"],outputShape:[M,2],userCode:`
	  void main() {
	    ivec2 coords = getOutputCoords();

	    float markerScale = getMarkerProperties(2);

	    int featureIndex = coords[0];

	    int maxIndex = int(getMaxIndex(featureIndex));
	    int searchLocationIndex = maxIndex / ${v*v};
	    int searchOffsetIndex = imod(maxIndex, ${v*v});

	    if (coords[1] == 0) {
	      int searchOffsetX = imod(searchOffsetIndex, ${v}) * ${A};
	      setOutput(getFeaturePoints(featureIndex, 0) + float(searchOffsetX - ${g}) / markerScale);
	    }
	    else if (coords[1] == 1) {
	      int searchOffsetY = searchOffsetIndex / ${v} * ${A};
	      setOutput(getFeaturePoints(featureIndex, 1) + float(searchOffsetY - ${g}) / markerScale);
	    }
	  }
	`},F={variableNames:["sims","maxIndex"],outputShape:[M],userCode:`
	  void main() {
	    int featureIndex = getOutputCoords();
	    int maxIndex = int(getMaxIndex(featureIndex));
	    setOutput(getSims(featureIndex, maxIndex));
	  }
	`};this.kernelCaches.computeMatching=[_,B,F]}return $e(()=>{const _=this.kernelCaches.computeMatching,B=this._compileAndRun(_[0],[t,i,o,l]),F=B.argMax(1),P=this._compileAndRun(_[1],[t,o,F]),U=this._compileAndRun(_[2],[B,F]);return{matchingPointsT:P,simT:U}})}_computeProjection(t,i,o){const l=this.trackingKeyframeList[o].width,u=this.trackingKeyframeList[o].height,f=this.trackingKeyframeList[o].scale,g=l+"-"+u+"-"+f;if(this.kernelCaches.computeProjection||(this.kernelCaches.computeProjection={}),!this.kernelCaches.computeProjection[g]){const A={variableNames:["M","pixel"],outputShape:[u,l],userCode:`
	  void main() {
	      ivec2 coords = getOutputCoords();

	      float m00 = getM(0, 0) * ${uu}.;
	      float m01 = getM(0, 1) * ${uu}.;
	      float m03 = getM(0, 3) * ${uu}.;
	      float m10 = getM(1, 0) * ${uu}.;
	      float m11 = getM(1, 1) * ${uu}.;
	      float m13 = getM(1, 3) * ${uu}.;
	      float m20 = getM(2, 0) * ${uu}.;
	      float m21 = getM(2, 1) * ${uu}.;
	      float m23 = getM(2, 3) * ${uu}.;

	      float y = float(coords[0]) / float(${f});
	      float x = float(coords[1]) / float(${f});
	      float uz = (x * m20) + (y * m21) + m23;
	      float oneOverUz = 1. / uz;

	      float ux = (x * m00) + (y * m01) + m03;
	      float uy = (x * m10) + (y * m11) + m13;

	      ux = floor(ux * oneOverUz + 0.5);
	      uy = floor(uy * oneOverUz + 0.5);
	      setOutput(getPixel(int(uy), int(ux)));
	    }
	`};this.kernelCaches.computeProjection[g]=A}return $e(()=>{const A=this.kernelCaches.computeProjection[g];return this._compileAndRun(A,[t,i])})}_buildAdjustedModelViewTransform(t){return $e(()=>{let i=[];for(let o=0;o<t.length;o++){i.push([]);for(let l=0;l<t[o].length;l++)i[o].push(t[o][l]/uu)}return Ur(i,[3,4])})}_prebuild(t,i){return $e(()=>{const o=t.scale,l=[];for(let g=0;g<i;g++)g<t.points.length?l.push([t.points[g].x/o,t.points[g].y/o]):l.push([-1,-1]);const u=Ur(t.data,[t.width*t.height]),f=Ur([t.width,t.height,t.scale],[3]);return{featurePoints:Ur(l,[l.length,2],"float32"),imagePixels:u,imageProperties:f}})}_compileAndRun(t,i){const o=Fc().compileAndRun(t,i);return os().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}}const Fw=[{sigma:.55,points:[[-1,0],[-.5,-.866025],[.5,-.866025],[1,-0],[.5,.866025],[-.5,.866025]]},{sigma:.475,points:[[0,.930969],[-.806243,.465485],[-.806243,-.465485],[-0,-.930969],[.806243,-.465485],[.806243,.465485]]},{sigma:.4,points:[[.847306,-0],[.423653,.733789],[-.423653,.733789],[-.847306,0],[-.423653,-.733789],[.423653,-.733789]]},{sigma:.325,points:[[-0,-.741094],[.641806,-.370547],[.641806,.370547],[0,.741094],[-.641806,.370547],[-.641806,-.370547]]},{sigma:.25,points:[[-.595502,0],[-.297751,-.51572],[.297751,-.51572],[.595502,-0],[.297751,.51572],[-.297751,.51572]]},{sigma:.175,points:[[0,.362783],[-.314179,.181391],[-.314179,-.181391],[-0,-.362783],[.314179,-.181391],[.314179,.181391]]},{sigma:.1,points:[[0,0]]}],Qp=[];for(let s=0;s<Fw.length;s++){const t=Fw[s].sigma;for(let i=0;i<Fw[s].points.length;i++){const o=Fw[s].points[i];Qp.push([t,o[0],o[1]])}}const YT={};function moe(s){const t=s.shape[1],i=s.shape[0],o="w"+t+"h"+i;if(!YT.hasOwnProperty(o)){const l={variableNames:["p"],outputShape:[i,t],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();

          float sum = getP(coords[0], coords[1]-2);
          sum += getP(coords[0], coords[1]-1) * 4.;
          sum += getP(coords[0], coords[1]) * 6.;
          sum += getP(coords[0], coords[1]+1) * 4.;
          sum += getP(coords[0], coords[1]+2);
          setOutput(sum);
        }
      `},u={variableNames:["p"],outputShape:[i,t],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();

          float sum = getP(coords[0]-2, coords[1]);
          sum += getP(coords[0]-1, coords[1]) * 4.;
          sum += getP(coords[0], coords[1]) * 6.;
          sum += getP(coords[0]+1, coords[1]) * 4.;
          sum += getP(coords[0]+2, coords[1]);
          sum /= 256.;
          setOutput(sum);
        }
      `};YT[o]=[l,u]}return YT[o]}const goe={kernelName:"BinomialFilter",backendName:"webgl",kernelFunc:s=>{const t=s.inputs.image,i=s.backend,[o,l]=moe(t),u=i.runWebGLProgram(o,[t],t.dtype),f=i.runWebGLProgram(l,[u],t.dtype);return i.disposeIntermediateTensorInfo(u),f}},Ow=7,hF=3,Aoe=hF*hF,jT=4,boe=(jT+1)*(jT+1)/jT,qT={};function yoe(s){const t=s.shape[1],i=s.shape[0],o="w"+t+"h"+i;if(!qT.hasOwnProperty(o)){const l={variableNames:["image0","image1","image2"],outputShape:[i,t],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();
    
          int y = coords[0];
          int x = coords[1];
    
          float value = getImage1(y, x);
    
          // Step 1: find local maxima/minima
          if (value * value < ${Aoe}.) {
            setOutput(0.);
            return;
          }
          if (y < ${Ow} || y > ${i-1-Ow}) {
            setOutput(0.);
            return;
          }
          if (x < ${Ow} || x > ${t-1-Ow}) {
            setOutput(0.);
            return;
          }
    
          bool isMax = true;
          bool isMin = true;
          for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
              float value0 = getImage0(y+dy, x+dx);
              float value1 = getImage1(y+dy, x+dx);
              float value2 = getImage2(y+dy, x+dx);
    
        if (value < value0 || value < value1 || value < value2) {
          isMax = false;
        }
        if (value > value0 || value > value1 || value > value2) {
          isMin = false;
        }
            }
          }
    
          if (!isMax && !isMin) {
            setOutput(0.);
            return;
          }
    
          // compute edge score and reject based on threshold
          float dxx = getImage1(y, x+1) + getImage1(y, x-1) - 2. * getImage1(y, x);
          float dyy = getImage1(y+1, x) + getImage1(y-1, x) - 2. * getImage1(y, x);
          float dxy = 0.25 * (getImage1(y-1,x-1) + getImage1(y+1,x+1) - getImage1(y-1,x+1) - getImage1(y+1,x-1));
    
          float det = (dxx * dyy) - (dxy * dxy);
    
          if (abs(det) < 0.0001) { // determinant undefined. no solution
            setOutput(0.);
            return;
          }
    
          float edgeScore = (dxx + dyy) * (dxx + dyy) / det;
    
          if (abs(edgeScore) >= ${boe} ) {
            setOutput(0.);
            return;
          }
          setOutput(getImage1(y,x));
        }
      `};qT[o]=l}return qT[o]}const voe={kernelName:"BuildExtremas",backendName:"webgl",kernelFunc:s=>{let{image0:t,image1:i,image2:o}=s.inputs;const l=s.backend,u=yoe(i);return t=os().runKernel("DownsampleBilinear",{image:t}),o=os().runKernel("UpsampleBilinear",{image:o,targetImage:i}),l.runWebGLProgram(u,[t,i,o],i.dtype)}},Sy=36,JT={};function xoe(s){const t=s.shape[0];if(!JT.hasOwnProperty(t)){const i={variableNames:["histogram"],outputShape:[s.shape[0]],userCode:`
            void main() {
                int featureIndex = getOutputCoords();

                int maxIndex = 0;
                for (int i = 1; i < ${Sy}; i++) {
                    if (getHistogram(featureIndex, i) > getHistogram(featureIndex, maxIndex)) {
                        maxIndex = i;
                    }
                }

                int prev = imod(maxIndex - 1 + ${Sy}, ${Sy});
                int next = imod(maxIndex + 1, ${Sy});

                /**
                 * Fit a quatratic to 3 points. The system of equations is:
                 *
                 * y0 = A*x0^2 + B*x0 + C
                 * y1 = A*x1^2 + B*x1 + C
                 * y2 = A*x2^2 + B*x2 + C
                 *
                 * This system of equations is solved for A,B,C.
                 */
                float p10 = float(maxIndex - 1);
                float p11 = getHistogram(featureIndex, prev); 
                float p20 = float(maxIndex);
                float p21 = getHistogram(featureIndex, maxIndex); 
                float p30 = float(maxIndex + 1);
                float p31 = getHistogram(featureIndex, next); 

                float d1 = (p30-p20)*(p30-p10);
                float d2 = (p10-p20)*(p30-p10);
                float d3 = p10-p20;

                // If any of the denominators are zero then, just use maxIndex.
                    float fbin = float(maxIndex);
                if ( abs(d1) > 0.00001 && abs(d2) > 0.00001 && abs(d3) > 0.00001) {
                float a = p10*p10;
                float b = p20*p20;

                // Solve for the coefficients A,B,C
                float A = ((p31-p21)/d1)-((p11-p21)/d2);
                float B = ((p11-p21)+(A*(b-a)))/d3;
                float C = p11-(A*a)-(B*p10);
                fbin = -B / (2. * A);
                }

                float an = 2.0 *${Math.PI} * (fbin + 0.5) / ${Sy}. - ${Math.PI};
                setOutput(an);
            }
            `};JT[t]=i}return JT[t]}const woe={kernelName:"ComputeExtremaAngles",backendName:"webgl",kernelFunc:s=>{const{histograms:t}=s.inputs,i=s.backend,o=xoe(t);return i.runWebGLProgram(o,[t],t.dtype)}},dF=7,eM={};function Coe(s,t){const i=`${s}|${t.shape[0]}`;if(!eM.hasOwnProperty(i)){const o=[];for(let f=1;f<s;f++)o.push("image"+f);let l="float getPixel(int octave, int y, int x) {";for(let f=1;f<s;f++)l+=`
  if (octave == ${f}) {
	return getImage${f}(y, x);
  }
`;l+="}";const u={variableNames:[...o,"extrema","angles","freakPoints"],outputShape:[t.shape[0],Qp.length],userCode:`
  ${l}
  void main() {
	ivec2 coords = getOutputCoords();
	int featureIndex = coords[0];
	int freakIndex = coords[1];

	float freakSigma = getFreakPoints(freakIndex, 0);
	float freakX = getFreakPoints(freakIndex, 1);
	float freakY = getFreakPoints(freakIndex, 2);

	int octave = int(getExtrema(featureIndex, 1));
	float inputY = getExtrema(featureIndex, 2);
	float inputX = getExtrema(featureIndex, 3);
	float inputAngle = getAngles(featureIndex);
	float cos = ${dF}. * cos(inputAngle);
	float sin = ${dF}. * sin(inputAngle);

	float yp = inputY + freakX * sin + freakY * cos;
	float xp = inputX + freakX * cos + freakY * -sin;

	int x0 = int(floor(xp));
	int x1 = x0 + 1;
	int y0 = int(floor(yp));
	int y1 = y0 + 1;

	float f1 = getPixel(octave, y0, x0);
	float f2 = getPixel(octave, y0, x1);
	float f3 = getPixel(octave, y1, x0);
	float f4 = getPixel(octave, y1, x1);

	float x1f = float(x1);
	float y1f = float(y1);
	float x0f = float(x0);
	float y0f = float(y0);

	// ratio for interpolation between four neighbouring points
	float value = (x1f - xp) * (y1f - yp) * f1
		+ (xp - x0f) * (y1f - yp) * f2
		+ (x1f - xp) * (yp - y0f) * f3
		+ (xp - x0f) * (yp - y0f) * f4;

	setOutput(value);
  }
`};eM[i]=u}return eM[i]}const Eoe={kernelName:"ComputeExtremaFreak",backendName:"webgl",kernelFunc:s=>{const{gaussianImagesT:t,prunedExtremas:i,prunedExtremasAngles:o,freakPointsT:l,pyramidImagesLength:u}=s.inputs,f=s.backend,g=Coe(u,i);return f.runWebGLProgram(g,[...t,i,o,l],"float32")}},fF=(Qp.length-1)*Qp.length/2,Soe=Math.ceil(fF/8),tM={};function Ioe(s){const t=`${s.shape[0]}`;if(!tM.hasOwnProperty(t)){const i={variableNames:["freak","p"],outputShape:[s.shape[0],Soe],userCode:`
  void main() {
    ivec2 coords = getOutputCoords();
    int featureIndex = coords[0];
    int descIndex = coords[1] * 8;

    int sum = 0;
    for (int i = 0; i < 8; i++) {
      if (descIndex + i >= ${fF}) {
        continue;
      }

      int p1 = int(getP(descIndex + i, 0));
      int p2 = int(getP(descIndex + i, 1));

      float v1 = getFreak(featureIndex, p1);
      float v2 = getFreak(featureIndex, p2);

      if (v1 < v2 + 0.01) {
        sum += int(pow(2.0, float(7 - i)));
      }
    }
    setOutput(float(sum));
  }
`};tM[t]=i}return tM[t]}const Toe={kernelName:"ComputeFreakDescriptors",backendName:"webgl",kernelFunc:s=>{const{extremaFreaks:t,positionT:i}=s.inputs,{backend:o}=s,l=Ioe(t);return o.runWebGLProgram(l,[t,i],"int32")}},nM={};function Moe(s,t){const i=`${s}|${t}`;if(!nM.hasOwnProperty(i)){const o=[];let l="float getPixel(int octave, int y, int x) {";for(let u=1;u<s;u++)o.push("image"+u),l+=`
				if (octave == ${u}) {
					return getImage${u}(y, x);
				}
			`;l+="}",nM[i]={variableNames:[...o,"extrema"],outputShape:[t,3,3],userCode:`
			${l}
		
			void main() {
				ivec3 coords = getOutputCoords();
				int featureIndex = coords[0];
				float score = getExtrema(featureIndex, 0);
				if (score == 0.0) {
					return;
				}
		
				int dy = coords[1]-1;
				int dx = coords[2]-1;
				int octave = int(getExtrema(featureIndex, 1));
				int y = int(getExtrema(featureIndex, 2));
				int x = int(getExtrema(featureIndex, 3));
				setOutput(getPixel(octave, y+dy, x+dx));
			}
			`}}return nM[i]}const _oe={kernelName:"ComputeLocalization",backendName:"webgl",kernelFunc:s=>{const{prunedExtremasList:t,dogPyramidImagesT:i}=s.inputs,o=s.backend,l=Moe(i.length,t.length),u=Ur(t,[t.length,t[0].length],"int32");return o.runWebGLProgram(l,[...i.slice(1),u],i[0].dtype)}},Roe=.159154943091895,g0=36,iM={};function koe(s,t,i){const o=`${i}|${s.shape[0]}|${t.shape[0]}`;if(!iM.hasOwnProperty(o)){const l=[];for(let A=1;A<i;A++)l.push("image"+A);let u="float getPixel(int octave, int y, int x) {";for(let A=1;A<i;A++)u+=`
            if (octave == ${A}) {
                return getImage${A}(y, x);
            }
            `;u+="}";const f={variableNames:[...l,"extrema","radial"],outputShape:[s.shape[0],t.shape[0],2],userCode:`
                ${u}

                void main() {
                    ivec3 coords = getOutputCoords();
                    int featureIndex = coords[0];
                    int radialIndex = coords[1];
                    int propertyIndex = coords[2];

                    int radialY = int(getRadial(radialIndex, 0));
                    int radialX = int(getRadial(radialIndex, 1));
                    float radialW = getRadial(radialIndex, 2);

                    int octave = int(getExtrema(featureIndex, 1));
                    int y = int(getExtrema(featureIndex, 2));
                    int x = int(getExtrema(featureIndex, 3));

                    int xp = x + radialX;
                    int yp = y + radialY;

                    float dy = getPixel(octave, yp+1, xp) - getPixel(octave, yp-1, xp);
                    float dx = getPixel(octave, yp, xp+1) - getPixel(octave, yp, xp-1);

                    if (propertyIndex == 0) {
                    // be careful that atan(0, 0) gives 1.57 instead of 0 (different from js), but doesn't matter here, coz magnitude is 0
                    
                    float angle = atan(dy, dx) + ${Math.PI};
                    float fbin = angle * ${g0}. * ${Roe};
                    setOutput(fbin);
                    return;
                    }

                    if (propertyIndex == 1) {
                        float mag = sqrt(dx * dx + dy * dy);
                        float magnitude = radialW * mag;
                        setOutput(magnitude);
                        return;
                    }
                }

                `},g={variableNames:["fbinMag"],outputShape:[s.shape[0],g0],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();
                int featureIndex = coords[0];
                int binIndex = coords[1];

                float sum = 0.;
                for (int i = 0; i < ${t.shape[0]}; i++) {
                    float fbin = getFbinMag(featureIndex, i, 0);
                    int bin = int(floor(fbin - 0.5));
                    int b1 = imod(bin + ${g0}, ${g0});
                    int b2 = imod(bin + 1 + ${g0}, ${g0});

                    if (b1 == binIndex || b2 == binIndex) {
                        float magnitude = getFbinMag(featureIndex, i, 1);
                        float w2 = fbin - float(bin) - 0.5;
                        float w1 = w2 * -1. + 1.;

                        if (b1 == binIndex) {
                            sum += w1 * magnitude;
                        }
                        if (b2 == binIndex) {
                            sum += w2 * magnitude;
                        }
                    }
                }
                setOutput(sum);
            }
            `};iM[o]=[f,g]}return iM[o]}const Boe={kernelName:"ComputeOrientationHistograms",backendName:"webgl",kernelFunc:s=>{const{gaussianImagesT:t,prunedExtremasT:i,radialPropertiesT:o,pyramidImagesLength:l}=s.inputs,u=s.backend,[f,g]=koe(i,o,l),A=u.runWebGLProgram(f,[...t,i,o],o.dtype),v=u.runWebGLProgram(g,[A],o.dtype);return u.disposeIntermediateTensorInfo(A),v}},sM={};function Loe(s){const t=s.shape[1],i=s.shape[0],o="w"+t+"h"+i;if(!sM.hasOwnProperty(o)){const l={variableNames:["p"],outputShape:[Math.floor(i/2),Math.floor(t/2)],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();
                int y = coords[0] * 2;
                int x = coords[1] * 2;
        
                float sum = getP(y, x) * 0.25;
                sum += getP(y+1,x) * 0.25; 
                sum += getP(y, x+1) * 0.25; 
                sum += getP(y+1,x+1) * 0.25;
                setOutput(sum);
            }
            `};sM[o]=l}return sM[o]}const Noe={kernelName:"DownsampleBilinear",backendName:"webgl",kernelFunc:s=>{const t=s.inputs.image,i=s.backend,o=Loe(t);return i.runWebGLProgram(o,[t],t.dtype)}},Doe={kernelName:"ExtremaReduction",backendName:"webgl",kernelFunc:s=>{const{extremasResultT:t}=s.inputs,i=s.backend,o=t.shape[0],l=t.shape[1],u={variableNames:["extrema"],outputShape:[Math.floor(o/2),Math.floor(l/2)],userCode:`
		  void main() {
			ivec2 coords = getOutputCoords();
			int y = coords[0] * 2;
			int x = coords[1] * 2;
  
			float location = 0.0;
			float values = getExtrema(y, x);
  
			if (getExtrema(y+1, x) != 0.0) {
			  location = 1.0;
		  values = getExtrema(y+1, x);
			}
			else if (getExtrema(y, x+1) != 0.0) {
			  location = 2.0;
		  values = getExtrema(y, x+1);
			}
			else if (getExtrema(y+1, x+1) != 0.0) {
			  location = 3.0;
		  values = getExtrema(y+1, x+1);
			}
  
			if (values < 0.0) {
			  setOutput(location * -1000.0 + values);
			} else {
			  setOutput(location * 1000.0 + values);
			}
		  }
		`};return i.runWebGLProgram(u,[t],t.dtype)}},Gw=36,Foe=5,rM={};function Ooe(s){const t=`h${s.shape[0]}`;if(!rM.hasOwnProperty(t)){const i={variableNames:["histogram"],outputShape:[s.shape[0],Gw],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();

                int featureIndex = coords[0];
                int binIndex = coords[1];

                int prevBin = imod(binIndex - 1 + ${Gw}, ${Gw});
                int nextBin = imod(binIndex + 1, ${Gw});
                float result = 0.274068619061197 * getHistogram(featureIndex, prevBin) + 0.451862761877606 * getHistogram(featureIndex, binIndex) + 0.274068619061197 * getHistogram(featureIndex, nextBin);

                setOutput(result);
            }
            `};rM[t]=i}return rM[t]}const Goe={kernelName:"SmoothHistograms",backendName:"webgl",kernelFunc:s=>{let{histograms:t}=s.inputs;const i=s.backend,o=Ooe(t);for(let l=0;l<Foe;l++){const u=t;t=i.runWebGLProgram(o,[t],t.dtype),l>0&&i.disposeIntermediateTensorInfo(u)}return t}},aM={};function Uoe(s,t){const i=t.shape[1],o=t.shape[0],l="w"+i+"h"+o;if(!aM.hasOwnProperty(l)){const u={variableNames:["p"],outputShape:[o,i],userCode:`
              void main() {
                ivec2 coords = getOutputCoords();
                int j = coords[0];
                int i = coords[1];
        
                float sj = 0.5 * float(j) - 0.25; 
                float si = 0.5 * float(i) - 0.25;
        
                float sj0 = floor(sj);
                float sj1 = ceil(sj);
                float si0 = floor(si);
                float si1 = ceil(si);
        
                int sj0I = int(sj0);
                int sj1I = int(sj1);
                int si0I = int(si0);
                int si1I = int(si1);
        
                float sum = 0.0;
                sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);
                sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);
                sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);
                sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);
                setOutput(sum);
              }
            `};aM[l]=u}return aM[l]}const Poe={kernelName:"UpsampleBilinear",backendName:"webgl",kernelFunc:s=>{const{image:t,targetImage:i}=s.inputs,o=s.backend,l=Uoe(t,i);return o.runWebGLProgram(l,[t],t.dtype)}};Ir(goe),Ir(voe),Ir(woe),Ir(Eoe),Ir(Toe),Ir(_oe),Ir(Boe),Ir(Noe),Ir(Doe),Ir(Goe),Ir(Poe);const pF=8,zoe=5,Iy=10,Voe=5,oM=3,Woe=1.5;(Qp.length-1)*Qp.length/2;class mF{constructor(t,i,o=!1){this.debugMode=o,this.width=t,this.height=i;let l=0;for(;t>=pF&&i>=pF&&(t/=2,i/=2,l++,l!==zoe););this.numOctaves=l,this.tensorCaches={},this.kernelCaches={}}detectImageData(t){const i=new Uint8ClampedArray(4*t.length);for(let l=0;l<t.length;l++)i[4*l]=t[l],i[4*l+1]=t[l],i[4*l+2]=t[l],i[4*l+3]=255;const o=new ImageData(i,this.width,this.height);return this.detect(o)}detect(t){let i=null;const o=[];for(let U=0;U<this.numOctaves;U++){let V,$;U===0?V=this._applyFilter(t):V=this._downsampleBilinear(o[U-1][o[U-1].length-1]),$=this._applyFilter(V),o.push([V,$])}const l=[];for(let U=0;U<this.numOctaves;U++){let V=this._differenceImageBinomial(o[U][0],o[U][1]);l.push(V)}const u=[];for(let U=1;U<this.numOctaves-1;U++){const V=this._buildExtremas(l[U-1],l[U],l[U+1]);u.push(V)}const f=this._applyPrune(u),g=this._computeLocalization(f,l),A=this._computeOrientationHistograms(g,o),v=this._smoothHistograms(A),C=this._computeExtremaAngles(v),S=this._computeExtremaFreak(o,g,C),M=this._computeFreakDescriptors(S),_=g.arraySync(),B=C.arraySync(),F=M.arraySync();this.debugMode&&(i={pyramidImages:o.map(U=>U.map(V=>V.arraySync())),dogPyramidImages:l.map(U=>U?U.arraySync():null),extremasResults:u.map(U=>U.arraySync()),extremaAngles:C.arraySync(),prunedExtremas:f,localizedExtremas:g.arraySync()}),o.forEach(U=>U.forEach(V=>V.dispose())),l.forEach(U=>U&&U.dispose()),u.forEach(U=>U.dispose()),g.dispose(),A.dispose(),v.dispose(),C.dispose(),S.dispose(),M.dispose();const P=[];for(let U=0;U<_.length;U++){if(_[U][0]==0)continue;const V=[];for(let pe=0;pe<F[U].length;pe+=4){const ye=F[U][pe],Te=F[U][pe+1],Ye=F[U][pe+2],et=F[U][pe+3];let nt=ye*16777216+Te*65536+Ye*256+et;V.push(nt)}const $=_[U][1],q=_[U][2],ne=_[U][3]*Math.pow(2,$)+Math.pow(2,$-1)-.5,he=q*Math.pow(2,$)+Math.pow(2,$-1)-.5,me=Math.pow(2,$);P.push({maxima:_[U][0]>0,x:ne,y:he,scale:me,angle:B[U],descriptors:V})}return{featurePoints:P,debugExtra:i}}_computeFreakDescriptors(t){if(!this.tensorCaches.computeFreakDescriptors){const o=[],l=[];for(let g=0;g<t.shape[1];g++)for(let A=g+1;A<t.shape[1];A++)o.push(g),l.push(A);const u=Ur(o,[o.length]).cast("int32"),f=Ur(l,[l.length]).cast("int32");this.tensorCaches.computeFreakDescriptors={positionT:ca(Xo([u,f],1))}}const{positionT:i}=this.tensorCaches.computeFreakDescriptors;return $e(()=>os().runKernel("ComputeFreakDescriptors",{extremaFreaks:t,positionT:i}))}_computeExtremaFreak(t,i,o){this.tensorCaches._computeExtremaFreak||$e(()=>{const f=Ur(Qp);this.tensorCaches._computeExtremaFreak={freakPointsT:ca(f)}});const{freakPointsT:l}=this.tensorCaches._computeExtremaFreak,u=[];for(let f=1;f<t.length;f++)u.push(t[f][1]);return $e(()=>os().runKernel("ComputeExtremaFreak",{gaussianImagesT:u,prunedExtremas:i,prunedExtremasAngles:o,freakPointsT:l,pyramidImagesLength:t.length}))}_computeExtremaAngles(t){return $e(()=>os().runKernel("ComputeExtremaAngles",{histograms:t}))}_computeOrientationHistograms(t,i){const o=[];for(let u=1;u<i.length;u++)o.push(i[u][1]);this.tensorCaches.orientationHistograms||$e(()=>{const u=-1/(2*oM*oM),f=oM*Woe,g=Math.ceil(f),A=[];for(let v=-g;v<=g;v++)for(let C=-g;C<=g;C++){const S=C*C+v*v;if(S<=f*f){const M=S*u;let _=(720+M*(720+M*(360+M*(120+M*(30+M*(6+M))))))*.0013888888;A.push([v,C,_])}}this.tensorCaches.orientationHistograms={radialPropertiesT:ca(Ur(A,[A.length,3]))}});const{radialPropertiesT:l}=this.tensorCaches.orientationHistograms;return $e(()=>os().runKernel("ComputeOrientationHistograms",{gaussianImagesT:o,prunedExtremasT:t,radialPropertiesT:l,pyramidImagesLength:i.length}))}_smoothHistograms(t){return $e(()=>os().runKernel("SmoothHistograms",{histograms:t}))}_computeLocalization(t,i){return $e(()=>{const o=os().runKernel("ComputeLocalization",{prunedExtremasList:t,dogPyramidImagesT:i}).arraySync(),l=[];for(let f=0;f<o.length;f++){l.push([]);for(let g=0;g<o[f].length;g++)l[f].push([])}const u=[];for(let f=0;f<t.length;f++)u[f]=[t[f][0],t[f][1],t[f][2],t[f][3]];for(let f=0;f<u.length;f++){if(u[f][0]===0)continue;const g=o[f],A=.5*(g[1][2]-g[1][0]),v=.5*(g[2][1]-g[0][1]),C=g[1][2]+g[1][0]-2*g[1][1],S=g[2][1]+g[0][1]-2*g[1][1],M=.25*(g[0][0]+g[2][2]-g[0][2]-g[2][0]),_=C*S-M*M,B=(S*-A+-M*-v)/_,F=(-M*-A+C*-v)/_,P=u[f][2]+F,U=u[f][3]+B;Math.abs(_)<1e-4||(u[f][2]=P,u[f][3]=U)}return Ur(u,[u.length,u[0].length],"float32")})}_applyPrune(t){const i=Iy*Iy,o=Voe,l=[],u=[];for(let g=0;g<i;g++){u.push([]),l.push([]);for(let A=0;A<o;A++)u[g].push([0,0,0,0]),l[g].push(0)}$e(()=>{for(let g=0;g<t.length;g++){const A=os().runKernel("ExtremaReduction",{extremasResultT:t[g]}),v=g+1,C=A.arraySync(),S=A.shape[0],M=A.shape[1],_=M*2/Iy,B=S*2/Iy;for(let F=0;F<S;F++)for(let P=0;P<M;P++){const U=C[F][P];if(U==0)continue;const V=U%1e3,$=Math.floor(Math.abs(U)/1e3),q=P*2+($===2||$===3?1:0),ne=F*2+($===1||$===3?1:0),he=Math.floor(q/_),me=Math.floor(ne/B)*Iy+he,pe=Math.abs(V);let ye=o;for(;ye>=1&&pe>l[me][ye-1];)ye-=1;if(ye<o){for(let Te=o-1;Te>=ye+1;Te--)l[me][Te]=l[me][Te-1],u[me][Te][0]=u[me][Te-1][0],u[me][Te][1]=u[me][Te-1][1],u[me][Te][2]=u[me][Te-1][2],u[me][Te][3]=u[me][Te-1][3];l[me][ye]=pe,u[me][ye][0]=V,u[me][ye][1]=v,u[me][ye][2]=ne,u[me][ye][3]=q}}}});const f=[];for(let g=0;g<i;g++)for(let A=0;A<o;A++)f.push(u[g][A]);return f}_buildExtremas(t,i,o){return $e(()=>os().runKernel("BuildExtremas",{image0:t,image1:i,image2:o}))}_differenceImageBinomial(t,i){return $e(()=>t.sub(i))}_applyFilter(t){return $e(()=>os().runKernel("BinomialFilter",{image:t}))}_downsampleBilinear(t){return $e(()=>os().runKernel("DownsampleBilinear",{image:t}))}_compileAndRun(t,i){const o=Fc().compileAndRun(t,i);return os().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}_runWebGLProgram(t,i,o){const l=Fc().runWebGLProgram(t,i,o);return os().makeTensorFromDataId(l.dataId,l.shape,l.dtype)}}class Hoe{constructor(t,i,o=!1){this.debugMode=o,this.width=t,this.height=i;let l=Math.min(t,i)/2,u=Math.pow(2,Math.round(Math.log(l)/Math.log(2)));this.cropSize=u,this.detector=new mF(u,u,o),this.kernelCaches={},this.lastRandomIndex=4}detect(t){const i=Math.floor(this.height/2-this.cropSize/2),o=Math.floor(this.width/2-this.cropSize/2),l=this._detect(t,o,i);return this.debugMode&&(l.debugExtra.crop={startX:o,startY:i,cropSize:this.cropSize}),l}detectMoving(t){const i=this.lastRandomIndex%3,o=Math.floor(this.lastRandomIndex/3);let l=Math.floor(this.height/2-this.cropSize+o*this.cropSize/2),u=Math.floor(this.width/2-this.cropSize+i*this.cropSize/2);return u<0&&(u=0),l<0&&(l=0),u>=this.width-this.cropSize&&(u=this.width-this.cropSize-1),l>=this.height-this.cropSize&&(l=this.height-this.cropSize-1),this.lastRandomIndex=(this.lastRandomIndex+1)%9,this._detect(t,u,l)}_detect(t,i,o){const l=t.slice([o,i],[this.cropSize,this.cropSize]),{featurePoints:u,debugExtra:f}=this.detector.detect(l);return u.forEach(g=>{g.x+=i,g.y+=o}),this.debugMode&&(f.projectedImage=l.arraySync()),l.dispose(),{featurePoints:u,debugExtra:f}}}const gF=({image:s,ratio:t})=>{const i=Math.round(s.width*t),o=Math.round(s.height*t),l=new Uint8Array(i*o);for(let u=0;u<i;u++){let f=Math.round(1*u/t),g=Math.round(1*(u+1)/t)-1;g>=s.width&&(g=s.width-1);for(let A=0;A<o;A++){let v=Math.round(1*A/t),C=Math.round(1*(A+1)/t)-1;C>=s.height&&(C=s.height-1);let S=0,M=0;for(let _=f;_<=g;_++)for(let B=v;B<=C;B++)S+=1*s.data[B*s.width+_],M+=1;l[A*i+u]=Math.floor(S/M)}}return{data:l,width:i,height:o}},Xoe=100,Qoe=s=>{const t=Xoe/Math.min(s.width,s.height),i=[];let o=t;for(;;)if(i.push(o),o*=Math.pow(2,1/3),o>=.95){o=1;break}i.push(o),i.reverse();const l=[];for(let u=0;u<i.length;u++)s.width*i[u],s.height*i[u],l.push(Object.assign(gF({image:s,ratio:i[u]}),{scale:i[u]}));return l},Koe=s=>{const t=Math.min(s.width,s.height),i=[],o=[];i.push(256/t),i.push(128/t);for(let l=0;l<i.length;l++)o.push(Object.assign(gF({image:s,ratio:i[l]}),{scale:i[l]}));return o},Zoe=s=>{const{v1:t,v2:i}=s;let o=0;for(let l=0;l<t.length;l++){let u=(t[l]^i[l])>>>0;o+=$oe(u)}return o},$oe=s=>{var t=s-(s>>1&1431655765);return t=(t>>2&858993459)+(t&858993459),t=(t>>4)+t&252645135,t=(t>>8)+t&16711935,t=(t>>16)+t&65535,t},Yoe=1234,joe=()=>({seed:Yoe,arrayShuffle(s){const{arr:t,sampleSize:i}=s;for(let o=0;o<i;o++){this.seed=(214013*this.seed+2531011)%-2147483648;let l=this.seed>>16&32767;l=l%t.length;let u=t[o];t[o]=t[l],t[l]=u}},nextInt(s){this.seed=(214013*this.seed+2531011)%-2147483648;let t=this.seed>>16&32767;return t=t%s,t}}),qoe=16,Joe=128,lM=8,ele=s=>{const{points:t,pointIndexes:i,randomizer:o}=s,l=[];for(let A=0;A<i.length;A++)l.push(A);let u=Number.MAX_SAFE_INTEGER,f=-1;const g=[];for(let A=0;A<Joe;A++){o.arrayShuffle({arr:l,sampleSize:lM});let v=0;const C=[];for(let S=0;S<i.length;S++){let M=Number.MAX_SAFE_INTEGER;for(let _=0;_<lM;_++){const B=i[l[_]],F=Zoe({v1:t[i[S]].descriptors,v2:t[B].descriptors});F<M&&(C[S]=l[_],M=F)}v+=M}g.push(C),v<u&&(u=v,f=A)}return g[f]},AF=({points:s})=>{const t=[];for(let o=0;o<s.length;o++)t.push(o);const i=joe();return{rootNode:bF({points:s,pointIndexes:t,centerPointIndex:null,randomizer:i})}},bF=s=>{const{points:t,pointIndexes:i,centerPointIndex:o,randomizer:l}=s;let u=!1;(i.length<=lM||i.length<=qoe)&&(u=!0);const f={};if(!u){const A=ele({points:t,pointIndexes:i,randomizer:l});for(let v=0;v<A.length;v++)f[i[A[v]]]===void 0&&(f[i[A[v]]]=[]),f[i[A[v]]].push(i[v])}Object.keys(f).length===1&&(u=!0);const g={centerPointIndex:o};if(u){g.leaf=!0,g.pointIndexes=[];for(let A=0;A<i.length;A++)g.pointIndexes.push(i[A]);return g}return g.leaf=!1,g.children=[],Object.keys(f).forEach(A=>{g.children.push(bF({points:t,pointIndexes:f[A],centerPointIndex:A,randomizer:l}))}),g};var Uw={},tle={get exports(){return Uw},set exports(s){Uw=s}};(function(s,t){(function(i,o){s.exports=o()})(ra,function(){return(function(i){var o={};function l(u){if(o[u])return o[u].exports;var f=o[u]={i:u,l:!1,exports:{}};return i[u].call(f.exports,f,f.exports,l),f.l=!0,f.exports}return l.m=i,l.c=o,l.d=function(u,f,g){l.o(u,f)||Object.defineProperty(u,f,{enumerable:!0,get:g})},l.r=function(u){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(u,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(u,"__esModule",{value:!0})},l.t=function(u,f){if(1&f&&(u=l(u)),8&f||4&f&&typeof u=="object"&&u&&u.__esModule)return u;var g=Object.create(null);if(l.r(g),Object.defineProperty(g,"default",{enumerable:!0,value:u}),2&f&&typeof u!="string")for(var A in u)l.d(g,A,(function(v){return u[v]}).bind(null,A));return g},l.n=function(u){var f=u&&u.__esModule?function(){return u.default}:function(){return u};return l.d(f,"a",f),f},l.o=function(u,f){return Object.prototype.hasOwnProperty.call(u,f)},l.p="",l(l.s=0)})([function(i,o,l){l.r(o),l.d(o,"encode",function(){return ht}),l.d(o,"decode",function(){return Kn}),l.d(o,"decodeAsync",function(){return Ns}),l.d(o,"decodeArrayStream",function(){return zs}),l.d(o,"decodeStream",function(){return oc}),l.d(o,"Decoder",function(){return An}),l.d(o,"Encoder",function(){return et}),l.d(o,"ExtensionCodec",function(){return ye}),l.d(o,"ExtData",function(){return F}),l.d(o,"EXT_TIMESTAMP",function(){return V}),l.d(o,"encodeDateToTimeSpec",function(){return q}),l.d(o,"encodeTimeSpecToTimestamp",function(){return $}),l.d(o,"decodeTimestampToTimeSpec",function(){return he}),l.d(o,"encodeTimestampExtension",function(){return ne}),l.d(o,"decodeTimestampExtension",function(){return me});var u=function(De,oe){var xe=typeof Symbol=="function"&&De[Symbol.iterator];if(!xe)return De;var Be,Me,mt=xe.call(De),tt=[];try{for(;(oe===void 0||oe-- >0)&&!(Be=mt.next()).done;)tt.push(Be.value)}catch(Qt){Me={error:Qt}}finally{try{Be&&!Be.done&&(xe=mt.return)&&xe.call(mt)}finally{if(Me)throw Me.error}}return tt},f=function(){for(var De=[],oe=0;oe<arguments.length;oe++)De=De.concat(u(arguments[oe]));return De},g=typeof process<"u"&&typeof TextEncoder<"u"&&typeof TextDecoder<"u";function A(De){for(var oe=De.length,xe=0,Be=0;Be<oe;){var Me=De.charCodeAt(Be++);if(4294967168&Me)if(!(4294965248&Me))xe+=2;else{if(Me>=55296&&Me<=56319&&Be<oe){var mt=De.charCodeAt(Be);(64512&mt)==56320&&(++Be,Me=((1023&Me)<<10)+(1023&mt)+65536)}xe+=4294901760&Me?4:3}else xe++}return xe}var v=g?new TextEncoder:void 0,C=typeof process<"u"?200:0,S=v!=null&&v.encodeInto?function(De,oe,xe){v.encodeInto(De,oe.subarray(xe))}:function(De,oe,xe){oe.set(v.encode(De),xe)};function M(De,oe,xe){for(var Be=oe,Me=Be+xe,mt=[],tt="";Be<Me;){var Qt=De[Be++];if(!(128&Qt))mt.push(Qt);else if((224&Qt)==192){var Cn=63&De[Be++];mt.push((31&Qt)<<6|Cn)}else if((240&Qt)==224){Cn=63&De[Be++];var Bn=63&De[Be++];mt.push((31&Qt)<<12|Cn<<6|Bn)}else if((248&Qt)==240){var ft=(7&Qt)<<18|(Cn=63&De[Be++])<<12|(Bn=63&De[Be++])<<6|63&De[Be++];ft>65535&&(ft-=65536,mt.push(ft>>>10&1023|55296),ft=56320|1023&ft),mt.push(ft)}else mt.push(Qt);mt.length>=4096&&(tt+=String.fromCharCode.apply(String,f(mt)),mt.length=0)}return mt.length>0&&(tt+=String.fromCharCode.apply(String,f(mt))),tt}var _=g?new TextDecoder:null,B=typeof process<"u"?200:0,F=function(De,oe){this.type=De,this.data=oe};function P(De,oe,xe){var Be=Math.floor(xe/4294967296),Me=xe;De.setUint32(oe,Be),De.setUint32(oe+4,Me)}function U(De,oe){return 4294967296*De.getInt32(oe)+De.getUint32(oe+4)}var V=-1;function $(De){var oe=De.sec,xe=De.nsec;if(oe>=0&&xe>=0&&oe<=17179869183){if(xe===0&&oe<=4294967295){var Be=new Uint8Array(4);return(tt=new DataView(Be.buffer)).setUint32(0,oe),Be}var Me=oe/4294967296,mt=4294967295&oe;return Be=new Uint8Array(8),(tt=new DataView(Be.buffer)).setUint32(0,xe<<2|3&Me),tt.setUint32(4,mt),Be}var tt;return Be=new Uint8Array(12),(tt=new DataView(Be.buffer)).setUint32(0,xe),P(tt,4,oe),Be}function q(De){var oe=De.getTime(),xe=Math.floor(oe/1e3),Be=1e6*(oe-1e3*xe),Me=Math.floor(Be/1e9);return{sec:xe+Me,nsec:Be-1e9*Me}}function ne(De){return De instanceof Date?$(q(De)):null}function he(De){var oe=new DataView(De.buffer,De.byteOffset,De.byteLength);switch(De.byteLength){case 4:return{sec:oe.getUint32(0),nsec:0};case 8:var xe=oe.getUint32(0);return{sec:4294967296*(3&xe)+oe.getUint32(4),nsec:xe>>>2};case 12:return{sec:U(oe,4),nsec:oe.getUint32(0)};default:throw new Error("Unrecognized data size for timestamp: "+De.length)}}function me(De){var oe=he(De);return new Date(1e3*oe.sec+oe.nsec/1e6)}var pe={type:V,encode:ne,decode:me},ye=(function(){function De(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(pe)}return De.prototype.register=function(oe){var xe=oe.type,Be=oe.encode,Me=oe.decode;if(xe>=0)this.encoders[xe]=Be,this.decoders[xe]=Me;else{var mt=1+xe;this.builtInEncoders[mt]=Be,this.builtInDecoders[mt]=Me}},De.prototype.tryToEncode=function(oe,xe){for(var Be=0;Be<this.builtInEncoders.length;Be++)if((Me=this.builtInEncoders[Be])!=null&&(mt=Me(oe,xe))!=null)return new F(-1-Be,mt);for(Be=0;Be<this.encoders.length;Be++){var Me,mt;if((Me=this.encoders[Be])!=null&&(mt=Me(oe,xe))!=null)return new F(Be,mt)}return oe instanceof F?oe:null},De.prototype.decode=function(oe,xe,Be){var Me=xe<0?this.builtInDecoders[-1-xe]:this.decoders[xe];return Me?Me(oe,xe,Be):new F(xe,oe)},De.defaultCodec=new De,De})();function Te(De){return De instanceof Uint8Array?De:ArrayBuffer.isView(De)?new Uint8Array(De.buffer,De.byteOffset,De.byteLength):De instanceof ArrayBuffer?new Uint8Array(De):Uint8Array.from(De)}var Ye=function(De){var oe=typeof Symbol=="function"&&Symbol.iterator,xe=oe&&De[oe],Be=0;if(xe)return xe.call(De);if(De&&typeof De.length=="number")return{next:function(){return De&&Be>=De.length&&(De=void 0),{value:De&&De[Be++],done:!De}}};throw new TypeError(oe?"Object is not iterable.":"Symbol.iterator is not defined.")},et=(function(){function De(oe,xe,Be,Me,mt,tt,Qt){oe===void 0&&(oe=ye.defaultCodec),Be===void 0&&(Be=100),Me===void 0&&(Me=2048),mt===void 0&&(mt=!1),tt===void 0&&(tt=!1),Qt===void 0&&(Qt=!1),this.extensionCodec=oe,this.context=xe,this.maxDepth=Be,this.initialBufferSize=Me,this.sortKeys=mt,this.forceFloat32=tt,this.ignoreUndefined=Qt,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return De.prototype.encode=function(oe,xe){if(xe>this.maxDepth)throw new Error("Too deep objects in depth "+xe);oe==null?this.encodeNil():typeof oe=="boolean"?this.encodeBoolean(oe):typeof oe=="number"?this.encodeNumber(oe):typeof oe=="string"?this.encodeString(oe):this.encodeObject(oe,xe)},De.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},De.prototype.ensureBufferSizeToWrite=function(oe){var xe=this.pos+oe;this.view.byteLength<xe&&this.resizeBuffer(2*xe)},De.prototype.resizeBuffer=function(oe){var xe=new ArrayBuffer(oe),Be=new Uint8Array(xe),Me=new DataView(xe);Be.set(this.bytes),this.view=Me,this.bytes=Be},De.prototype.encodeNil=function(){this.writeU8(192)},De.prototype.encodeBoolean=function(oe){oe===!1?this.writeU8(194):this.writeU8(195)},De.prototype.encodeNumber=function(oe){Number.isSafeInteger(oe)?oe>=0?oe<128?this.writeU8(oe):oe<256?(this.writeU8(204),this.writeU8(oe)):oe<65536?(this.writeU8(205),this.writeU16(oe)):oe<4294967296?(this.writeU8(206),this.writeU32(oe)):(this.writeU8(207),this.writeU64(oe)):oe>=-32?this.writeU8(224|oe+32):oe>=-128?(this.writeU8(208),this.writeI8(oe)):oe>=-32768?(this.writeU8(209),this.writeI16(oe)):oe>=-2147483648?(this.writeU8(210),this.writeI32(oe)):(this.writeU8(211),this.writeI64(oe)):this.forceFloat32?(this.writeU8(202),this.writeF32(oe)):(this.writeU8(203),this.writeF64(oe))},De.prototype.writeStringHeader=function(oe){if(oe<32)this.writeU8(160+oe);else if(oe<256)this.writeU8(217),this.writeU8(oe);else if(oe<65536)this.writeU8(218),this.writeU16(oe);else{if(!(oe<4294967296))throw new Error("Too long string: "+oe+" bytes in UTF-8");this.writeU8(219),this.writeU32(oe)}},De.prototype.encodeString=function(oe){var xe=oe.length;if(g&&xe>C){var Be=A(oe);this.ensureBufferSizeToWrite(5+Be),this.writeStringHeader(Be),S(oe,this.bytes,this.pos),this.pos+=Be}else Be=A(oe),this.ensureBufferSizeToWrite(5+Be),this.writeStringHeader(Be),(function(Me,mt,tt){for(var Qt=Me.length,Cn=tt,Bn=0;Bn<Qt;){var ft=Me.charCodeAt(Bn++);if(4294967168&ft){if(!(4294965248&ft))mt[Cn++]=ft>>6&31|192;else{if(ft>=55296&&ft<=56319&&Bn<Qt){var Xn=Me.charCodeAt(Bn);(64512&Xn)==56320&&(++Bn,ft=((1023&ft)<<10)+(1023&Xn)+65536)}4294901760&ft?(mt[Cn++]=ft>>18&7|240,mt[Cn++]=ft>>12&63|128,mt[Cn++]=ft>>6&63|128):(mt[Cn++]=ft>>12&15|224,mt[Cn++]=ft>>6&63|128)}mt[Cn++]=63&ft|128}else mt[Cn++]=ft}})(oe,this.bytes,this.pos),this.pos+=Be},De.prototype.encodeObject=function(oe,xe){var Be=this.extensionCodec.tryToEncode(oe,this.context);if(Be!=null)this.encodeExtension(Be);else if(Array.isArray(oe))this.encodeArray(oe,xe);else if(ArrayBuffer.isView(oe))this.encodeBinary(oe);else{if(typeof oe!="object")throw new Error("Unrecognized object: "+Object.prototype.toString.apply(oe));this.encodeMap(oe,xe)}},De.prototype.encodeBinary=function(oe){var xe=oe.byteLength;if(xe<256)this.writeU8(196),this.writeU8(xe);else if(xe<65536)this.writeU8(197),this.writeU16(xe);else{if(!(xe<4294967296))throw new Error("Too large binary: "+xe);this.writeU8(198),this.writeU32(xe)}var Be=Te(oe);this.writeU8a(Be)},De.prototype.encodeArray=function(oe,xe){var Be,Me,mt=oe.length;if(mt<16)this.writeU8(144+mt);else if(mt<65536)this.writeU8(220),this.writeU16(mt);else{if(!(mt<4294967296))throw new Error("Too large array: "+mt);this.writeU8(221),this.writeU32(mt)}try{for(var tt=Ye(oe),Qt=tt.next();!Qt.done;Qt=tt.next()){var Cn=Qt.value;this.encode(Cn,xe+1)}}catch(Bn){Be={error:Bn}}finally{try{Qt&&!Qt.done&&(Me=tt.return)&&Me.call(tt)}finally{if(Be)throw Be.error}}},De.prototype.countWithoutUndefined=function(oe,xe){var Be,Me,mt=0;try{for(var tt=Ye(xe),Qt=tt.next();!Qt.done;Qt=tt.next())oe[Qt.value]!==void 0&&mt++}catch(Cn){Be={error:Cn}}finally{try{Qt&&!Qt.done&&(Me=tt.return)&&Me.call(tt)}finally{if(Be)throw Be.error}}return mt},De.prototype.encodeMap=function(oe,xe){var Be,Me,mt=Object.keys(oe);this.sortKeys&&mt.sort();var tt=this.ignoreUndefined?this.countWithoutUndefined(oe,mt):mt.length;if(tt<16)this.writeU8(128+tt);else if(tt<65536)this.writeU8(222),this.writeU16(tt);else{if(!(tt<4294967296))throw new Error("Too large map object: "+tt);this.writeU8(223),this.writeU32(tt)}try{for(var Qt=Ye(mt),Cn=Qt.next();!Cn.done;Cn=Qt.next()){var Bn=Cn.value,ft=oe[Bn];this.ignoreUndefined&&ft===void 0||(this.encodeString(Bn),this.encode(ft,xe+1))}}catch(Xn){Be={error:Xn}}finally{try{Cn&&!Cn.done&&(Me=Qt.return)&&Me.call(Qt)}finally{if(Be)throw Be.error}}},De.prototype.encodeExtension=function(oe){var xe=oe.data.length;if(xe===1)this.writeU8(212);else if(xe===2)this.writeU8(213);else if(xe===4)this.writeU8(214);else if(xe===8)this.writeU8(215);else if(xe===16)this.writeU8(216);else if(xe<256)this.writeU8(199),this.writeU8(xe);else if(xe<65536)this.writeU8(200),this.writeU16(xe);else{if(!(xe<4294967296))throw new Error("Too large extension object: "+xe);this.writeU8(201),this.writeU32(xe)}this.writeI8(oe.type),this.writeU8a(oe.data)},De.prototype.writeU8=function(oe){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,oe),this.pos++},De.prototype.writeU8a=function(oe){var xe=oe.length;this.ensureBufferSizeToWrite(xe),this.bytes.set(oe,this.pos),this.pos+=xe},De.prototype.writeI8=function(oe){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,oe),this.pos++},De.prototype.writeU16=function(oe){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,oe),this.pos+=2},De.prototype.writeI16=function(oe){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,oe),this.pos+=2},De.prototype.writeU32=function(oe){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,oe),this.pos+=4},De.prototype.writeI32=function(oe){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,oe),this.pos+=4},De.prototype.writeF32=function(oe){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,oe),this.pos+=4},De.prototype.writeF64=function(oe){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,oe),this.pos+=8},De.prototype.writeU64=function(oe){this.ensureBufferSizeToWrite(8),(function(xe,Be,Me){var mt=Me/4294967296,tt=Me;xe.setUint32(Be,mt),xe.setUint32(Be+4,tt)})(this.view,this.pos,oe),this.pos+=8},De.prototype.writeI64=function(oe){this.ensureBufferSizeToWrite(8),P(this.view,this.pos,oe),this.pos+=8},De})(),nt={};function ht(De,oe){oe===void 0&&(oe=nt);var xe=new et(oe.extensionCodec,oe.context,oe.maxDepth,oe.initialBufferSize,oe.sortKeys,oe.forceFloat32,oe.ignoreUndefined);return xe.encode(De,1),xe.getUint8Array()}function ct(De){return(De<0?"-":"")+"0x"+Math.abs(De).toString(16).padStart(2,"0")}var pt=(function(){function De(oe,xe){oe===void 0&&(oe=16),xe===void 0&&(xe=16),this.maxKeyLength=oe,this.maxLengthPerKey=xe,this.caches=[];for(var Be=0;Be<this.maxKeyLength;Be++)this.caches.push([])}return De.prototype.canBeCached=function(oe){return oe>0&&oe<=this.maxKeyLength},De.prototype.get=function(oe,xe,Be){var Me=this.caches[Be-1],mt=Me.length;e:for(var tt=0;tt<mt;tt++){for(var Qt=Me[tt],Cn=Qt.bytes,Bn=0;Bn<Be;Bn++)if(Cn[Bn]!==oe[xe+Bn])continue e;return Qt.value}return null},De.prototype.store=function(oe,xe){var Be=this.caches[oe.length-1],Me={bytes:oe,value:xe};Be.length>=this.maxLengthPerKey?Be[Math.random()*Be.length|0]=Me:Be.push(Me)},De.prototype.decode=function(oe,xe,Be){var Me=this.get(oe,xe,Be);if(Me!=null)return Me;var mt=M(oe,xe,Be),tt=Uint8Array.prototype.slice.call(oe,xe,xe+Be);return this.store(tt,mt),mt},De})(),Et=function(De,oe,xe,Be){return new(xe||(xe=Promise))(function(Me,mt){function tt(Bn){try{Cn(Be.next(Bn))}catch(ft){mt(ft)}}function Qt(Bn){try{Cn(Be.throw(Bn))}catch(ft){mt(ft)}}function Cn(Bn){var ft;Bn.done?Me(Bn.value):(ft=Bn.value,ft instanceof xe?ft:new xe(function(Xn){Xn(ft)})).then(tt,Qt)}Cn((Be=Be.apply(De,[])).next())})},yt=function(De,oe){var xe,Be,Me,mt,tt={label:0,sent:function(){if(1&Me[0])throw Me[1];return Me[1]},trys:[],ops:[]};return mt={next:Qt(0),throw:Qt(1),return:Qt(2)},typeof Symbol=="function"&&(mt[Symbol.iterator]=function(){return this}),mt;function Qt(Cn){return function(Bn){return(function(ft){if(xe)throw new TypeError("Generator is already executing.");for(;tt;)try{if(xe=1,Be&&(Me=2&ft[0]?Be.return:ft[0]?Be.throw||((Me=Be.return)&&Me.call(Be),0):Be.next)&&!(Me=Me.call(Be,ft[1])).done)return Me;switch(Be=0,Me&&(ft=[2&ft[0],Me.value]),ft[0]){case 0:case 1:Me=ft;break;case 4:return tt.label++,{value:ft[1],done:!1};case 5:tt.label++,Be=ft[1],ft=[0];continue;case 7:ft=tt.ops.pop(),tt.trys.pop();continue;default:if(Me=tt.trys,!((Me=Me.length>0&&Me[Me.length-1])||ft[0]!==6&&ft[0]!==2)){tt=0;continue}if(ft[0]===3&&(!Me||ft[1]>Me[0]&&ft[1]<Me[3])){tt.label=ft[1];break}if(ft[0]===6&&tt.label<Me[1]){tt.label=Me[1],Me=ft;break}if(Me&&tt.label<Me[2]){tt.label=Me[2],tt.ops.push(ft);break}Me[2]&&tt.ops.pop(),tt.trys.pop();continue}ft=oe.call(De,tt)}catch(Xn){ft=[6,Xn],Be=0}finally{xe=Me=0}if(5&ft[0])throw ft[1];return{value:ft[0]?ft[1]:void 0,done:!0}})([Cn,Bn])}}},It=function(De){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var oe,xe=De[Symbol.asyncIterator];return xe?xe.call(De):(De=typeof __values=="function"?__values(De):De[Symbol.iterator](),oe={},Be("next"),Be("throw"),Be("return"),oe[Symbol.asyncIterator]=function(){return this},oe);function Be(Me){oe[Me]=De[Me]&&function(mt){return new Promise(function(tt,Qt){(function(Cn,Bn,ft,Xn){Promise.resolve(Xn).then(function(Ti){Cn({value:Ti,done:ft})},Bn)})(tt,Qt,(mt=De[Me](mt)).done,mt.value)})}}},Pt=function(De){return this instanceof Pt?(this.v=De,this):new Pt(De)},Ft=function(De,oe,xe){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var Be,Me=xe.apply(De,oe||[]),mt=[];return Be={},tt("next"),tt("throw"),tt("return"),Be[Symbol.asyncIterator]=function(){return this},Be;function tt(Xn){Me[Xn]&&(Be[Xn]=function(Ti){return new Promise(function(kr,xr){mt.push([Xn,Ti,kr,xr])>1||Qt(Xn,Ti)})})}function Qt(Xn,Ti){try{(kr=Me[Xn](Ti)).value instanceof Pt?Promise.resolve(kr.value.v).then(Cn,Bn):ft(mt[0][2],kr)}catch(xr){ft(mt[0][3],xr)}var kr}function Cn(Xn){Qt("next",Xn)}function Bn(Xn){Qt("throw",Xn)}function ft(Xn,Ti){Xn(Ti),mt.shift(),mt.length&&Qt(mt[0][0],mt[0][1])}},Xt=new DataView(new ArrayBuffer(0)),$t=new Uint8Array(Xt.buffer),Yt=(function(){try{Xt.getInt8(0)}catch(De){return De.constructor}throw new Error("never reached")})(),en=new Yt("Insufficient data"),_n=new pt,An=(function(){function De(oe,xe,Be,Me,mt,tt,Qt,Cn){oe===void 0&&(oe=ye.defaultCodec),Be===void 0&&(Be=4294967295),Me===void 0&&(Me=4294967295),mt===void 0&&(mt=4294967295),tt===void 0&&(tt=4294967295),Qt===void 0&&(Qt=4294967295),Cn===void 0&&(Cn=_n),this.extensionCodec=oe,this.context=xe,this.maxStrLength=Be,this.maxBinLength=Me,this.maxArrayLength=mt,this.maxMapLength=tt,this.maxExtLength=Qt,this.cachedKeyDecoder=Cn,this.totalPos=0,this.pos=0,this.view=Xt,this.bytes=$t,this.headByte=-1,this.stack=[]}return De.prototype.setBuffer=function(oe){this.bytes=Te(oe),this.view=(function(xe){if(xe instanceof ArrayBuffer)return new DataView(xe);var Be=Te(xe);return new DataView(Be.buffer,Be.byteOffset,Be.byteLength)})(this.bytes),this.pos=0},De.prototype.appendBuffer=function(oe){if(this.headByte!==-1||this.hasRemaining()){var xe=this.bytes.subarray(this.pos),Be=Te(oe),Me=new Uint8Array(xe.length+Be.length);Me.set(xe),Me.set(Be,xe.length),this.setBuffer(Me)}else this.setBuffer(oe)},De.prototype.hasRemaining=function(oe){return oe===void 0&&(oe=1),this.view.byteLength-this.pos>=oe},De.prototype.createNoExtraBytesError=function(oe){var xe=this.view,Be=this.pos;return new RangeError("Extra "+(xe.byteLength-Be)+" byte(s) found at buffer["+oe+"]")},De.prototype.decodeSingleSync=function(){var oe=this.decodeSync();if(this.hasRemaining())throw this.createNoExtraBytesError(this.pos);return oe},De.prototype.decodeSingleAsync=function(oe){var xe,Be,Me,mt;return Et(this,void 0,void 0,function(){var tt,Qt,Cn,Bn,ft,Xn,Ti,kr;return yt(this,function(xr){switch(xr.label){case 0:tt=!1,xr.label=1;case 1:xr.trys.push([1,6,7,12]),xe=It(oe),xr.label=2;case 2:return[4,xe.next()];case 3:if((Be=xr.sent()).done)return[3,5];if(Cn=Be.value,tt)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(Cn);try{Qt=this.decodeSync(),tt=!0}catch(Pw){if(!(Pw instanceof Yt))throw Pw}this.totalPos+=this.pos,xr.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return Bn=xr.sent(),Me={error:Bn},[3,12];case 7:return xr.trys.push([7,,10,11]),Be&&!Be.done&&(mt=xe.return)?[4,mt.call(xe)]:[3,9];case 8:xr.sent(),xr.label=9;case 9:return[3,11];case 10:if(Me)throw Me.error;return[7];case 11:return[7];case 12:if(tt){if(this.hasRemaining())throw this.createNoExtraBytesError(this.totalPos);return[2,Qt]}throw Xn=(ft=this).headByte,Ti=ft.pos,kr=ft.totalPos,new RangeError("Insufficient data in parcing "+ct(Xn)+" at "+kr+" ("+Ti+" in the current buffer)")}})})},De.prototype.decodeArrayStream=function(oe){return this.decodeMultiAsync(oe,!0)},De.prototype.decodeStream=function(oe){return this.decodeMultiAsync(oe,!1)},De.prototype.decodeMultiAsync=function(oe,xe){return Ft(this,arguments,function(){var Be,Me,mt,tt,Qt,Cn,Bn,ft,Xn;return yt(this,function(Ti){switch(Ti.label){case 0:Be=xe,Me=-1,Ti.label=1;case 1:Ti.trys.push([1,13,14,19]),mt=It(oe),Ti.label=2;case 2:return[4,Pt(mt.next())];case 3:if((tt=Ti.sent()).done)return[3,12];if(Qt=tt.value,xe&&Me===0)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(Qt),Be&&(Me=this.readArraySize(),Be=!1,this.complete()),Ti.label=4;case 4:Ti.trys.push([4,9,,10]),Ti.label=5;case 5:return[4,Pt(this.decodeSync())];case 6:return[4,Ti.sent()];case 7:return Ti.sent(),--Me==0?[3,8]:[3,5];case 8:return[3,10];case 9:if(!((Cn=Ti.sent())instanceof Yt))throw Cn;return[3,10];case 10:this.totalPos+=this.pos,Ti.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return Bn=Ti.sent(),ft={error:Bn},[3,19];case 14:return Ti.trys.push([14,,17,18]),tt&&!tt.done&&(Xn=mt.return)?[4,Pt(Xn.call(mt))]:[3,16];case 15:Ti.sent(),Ti.label=16;case 16:return[3,18];case 17:if(ft)throw ft.error;return[7];case 18:return[7];case 19:return[2]}})})},De.prototype.decodeSync=function(){e:for(;;){var oe=this.readHeadByte(),xe=void 0;if(oe>=224)xe=oe-256;else if(oe<192)if(oe<128)xe=oe;else if(oe<144){if((Me=oe-128)!==0){this.pushMapState(Me),this.complete();continue e}xe={}}else if(oe<160){if((Me=oe-144)!==0){this.pushArrayState(Me),this.complete();continue e}xe=[]}else{var Be=oe-160;xe=this.decodeUtf8String(Be,0)}else if(oe===192)xe=null;else if(oe===194)xe=!1;else if(oe===195)xe=!0;else if(oe===202)xe=this.readF32();else if(oe===203)xe=this.readF64();else if(oe===204)xe=this.readU8();else if(oe===205)xe=this.readU16();else if(oe===206)xe=this.readU32();else if(oe===207)xe=this.readU64();else if(oe===208)xe=this.readI8();else if(oe===209)xe=this.readI16();else if(oe===210)xe=this.readI32();else if(oe===211)xe=this.readI64();else if(oe===217)Be=this.lookU8(),xe=this.decodeUtf8String(Be,1);else if(oe===218)Be=this.lookU16(),xe=this.decodeUtf8String(Be,2);else if(oe===219)Be=this.lookU32(),xe=this.decodeUtf8String(Be,4);else if(oe===220){if((Me=this.readU16())!==0){this.pushArrayState(Me),this.complete();continue e}xe=[]}else if(oe===221){if((Me=this.readU32())!==0){this.pushArrayState(Me),this.complete();continue e}xe=[]}else if(oe===222){if((Me=this.readU16())!==0){this.pushMapState(Me),this.complete();continue e}xe={}}else if(oe===223){if((Me=this.readU32())!==0){this.pushMapState(Me),this.complete();continue e}xe={}}else if(oe===196){var Me=this.lookU8();xe=this.decodeBinary(Me,1)}else if(oe===197)Me=this.lookU16(),xe=this.decodeBinary(Me,2);else if(oe===198)Me=this.lookU32(),xe=this.decodeBinary(Me,4);else if(oe===212)xe=this.decodeExtension(1,0);else if(oe===213)xe=this.decodeExtension(2,0);else if(oe===214)xe=this.decodeExtension(4,0);else if(oe===215)xe=this.decodeExtension(8,0);else if(oe===216)xe=this.decodeExtension(16,0);else if(oe===199)Me=this.lookU8(),xe=this.decodeExtension(Me,1);else if(oe===200)Me=this.lookU16(),xe=this.decodeExtension(Me,2);else{if(oe!==201)throw new Error("Unrecognized type byte: "+ct(oe));Me=this.lookU32(),xe=this.decodeExtension(Me,4)}this.complete();for(var mt=this.stack;mt.length>0;){var tt=mt[mt.length-1];if(tt.type===0){if(tt.array[tt.position]=xe,tt.position++,tt.position!==tt.size)continue e;mt.pop(),xe=tt.array}else{if(tt.type===1){if(Qt=void 0,(Qt=typeof xe)!="string"&&Qt!=="number")throw new Error("The type of key must be string or number but "+typeof xe);tt.key=xe,tt.type=2;continue e}if(tt.map[tt.key]=xe,tt.readCount++,tt.readCount!==tt.size){tt.key=null,tt.type=1;continue e}mt.pop(),xe=tt.map}}return xe}var Qt},De.prototype.readHeadByte=function(){return this.headByte===-1&&(this.headByte=this.readU8()),this.headByte},De.prototype.complete=function(){this.headByte=-1},De.prototype.readArraySize=function(){var oe=this.readHeadByte();switch(oe){case 220:return this.readU16();case 221:return this.readU32();default:if(oe<160)return oe-144;throw new Error("Unrecognized array type byte: "+ct(oe))}},De.prototype.pushMapState=function(oe){if(oe>this.maxMapLength)throw new Error("Max length exceeded: map length ("+oe+") > maxMapLengthLength ("+this.maxMapLength+")");this.stack.push({type:1,size:oe,key:null,readCount:0,map:{}})},De.prototype.pushArrayState=function(oe){if(oe>this.maxArrayLength)throw new Error("Max length exceeded: array length ("+oe+") > maxArrayLength ("+this.maxArrayLength+")");this.stack.push({type:0,size:oe,array:new Array(oe),position:0})},De.prototype.decodeUtf8String=function(oe,xe){var Be;if(oe>this.maxStrLength)throw new Error("Max length exceeded: UTF-8 byte length ("+oe+") > maxStrLength ("+this.maxStrLength+")");if(this.bytes.byteLength<this.pos+xe+oe)throw en;var Me,mt=this.pos+xe;return Me=this.stateIsMapKey()&&!((Be=this.cachedKeyDecoder)===null||Be===void 0)&&Be.canBeCached(oe)?this.cachedKeyDecoder.decode(this.bytes,mt,oe):g&&oe>B?(function(tt,Qt,Cn){var Bn=tt.subarray(Qt,Qt+Cn);return _.decode(Bn)})(this.bytes,mt,oe):M(this.bytes,mt,oe),this.pos+=xe+oe,Me},De.prototype.stateIsMapKey=function(){return this.stack.length>0&&this.stack[this.stack.length-1].type===1},De.prototype.decodeBinary=function(oe,xe){if(oe>this.maxBinLength)throw new Error("Max length exceeded: bin length ("+oe+") > maxBinLength ("+this.maxBinLength+")");if(!this.hasRemaining(oe+xe))throw en;var Be=this.pos+xe,Me=this.bytes.subarray(Be,Be+oe);return this.pos+=xe+oe,Me},De.prototype.decodeExtension=function(oe,xe){if(oe>this.maxExtLength)throw new Error("Max length exceeded: ext length ("+oe+") > maxExtLength ("+this.maxExtLength+")");var Be=this.view.getInt8(this.pos+xe),Me=this.decodeBinary(oe,xe+1);return this.extensionCodec.decode(Me,Be,this.context)},De.prototype.lookU8=function(){return this.view.getUint8(this.pos)},De.prototype.lookU16=function(){return this.view.getUint16(this.pos)},De.prototype.lookU32=function(){return this.view.getUint32(this.pos)},De.prototype.readU8=function(){var oe=this.view.getUint8(this.pos);return this.pos++,oe},De.prototype.readI8=function(){var oe=this.view.getInt8(this.pos);return this.pos++,oe},De.prototype.readU16=function(){var oe=this.view.getUint16(this.pos);return this.pos+=2,oe},De.prototype.readI16=function(){var oe=this.view.getInt16(this.pos);return this.pos+=2,oe},De.prototype.readU32=function(){var oe=this.view.getUint32(this.pos);return this.pos+=4,oe},De.prototype.readI32=function(){var oe=this.view.getInt32(this.pos);return this.pos+=4,oe},De.prototype.readU64=function(){var oe,xe,Be=(oe=this.view,xe=this.pos,4294967296*oe.getUint32(xe)+oe.getUint32(xe+4));return this.pos+=8,Be},De.prototype.readI64=function(){var oe=U(this.view,this.pos);return this.pos+=8,oe},De.prototype.readF32=function(){var oe=this.view.getFloat32(this.pos);return this.pos+=4,oe},De.prototype.readF64=function(){var oe=this.view.getFloat64(this.pos);return this.pos+=8,oe},De})(),Rn={};function Kn(De,oe){oe===void 0&&(oe=Rn);var xe=new An(oe.extensionCodec,oe.context,oe.maxStrLength,oe.maxBinLength,oe.maxArrayLength,oe.maxMapLength,oe.maxExtLength);return xe.setBuffer(De),xe.decodeSingleSync()}var ni=function(De,oe){var xe,Be,Me,mt,tt={label:0,sent:function(){if(1&Me[0])throw Me[1];return Me[1]},trys:[],ops:[]};return mt={next:Qt(0),throw:Qt(1),return:Qt(2)},typeof Symbol=="function"&&(mt[Symbol.iterator]=function(){return this}),mt;function Qt(Cn){return function(Bn){return(function(ft){if(xe)throw new TypeError("Generator is already executing.");for(;tt;)try{if(xe=1,Be&&(Me=2&ft[0]?Be.return:ft[0]?Be.throw||((Me=Be.return)&&Me.call(Be),0):Be.next)&&!(Me=Me.call(Be,ft[1])).done)return Me;switch(Be=0,Me&&(ft=[2&ft[0],Me.value]),ft[0]){case 0:case 1:Me=ft;break;case 4:return tt.label++,{value:ft[1],done:!1};case 5:tt.label++,Be=ft[1],ft=[0];continue;case 7:ft=tt.ops.pop(),tt.trys.pop();continue;default:if(Me=tt.trys,!((Me=Me.length>0&&Me[Me.length-1])||ft[0]!==6&&ft[0]!==2)){tt=0;continue}if(ft[0]===3&&(!Me||ft[1]>Me[0]&&ft[1]<Me[3])){tt.label=ft[1];break}if(ft[0]===6&&tt.label<Me[1]){tt.label=Me[1],Me=ft;break}if(Me&&tt.label<Me[2]){tt.label=Me[2],tt.ops.push(ft);break}Me[2]&&tt.ops.pop(),tt.trys.pop();continue}ft=oe.call(De,tt)}catch(Xn){ft=[6,Xn],Be=0}finally{xe=Me=0}if(5&ft[0])throw ft[1];return{value:ft[0]?ft[1]:void 0,done:!0}})([Cn,Bn])}}},jn=function(De){return this instanceof jn?(this.v=De,this):new jn(De)},Fi=function(De,oe,xe){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var Be,Me=xe.apply(De,oe||[]),mt=[];return Be={},tt("next"),tt("throw"),tt("return"),Be[Symbol.asyncIterator]=function(){return this},Be;function tt(Xn){Me[Xn]&&(Be[Xn]=function(Ti){return new Promise(function(kr,xr){mt.push([Xn,Ti,kr,xr])>1||Qt(Xn,Ti)})})}function Qt(Xn,Ti){try{(kr=Me[Xn](Ti)).value instanceof jn?Promise.resolve(kr.value.v).then(Cn,Bn):ft(mt[0][2],kr)}catch(xr){ft(mt[0][3],xr)}var kr}function Cn(Xn){Qt("next",Xn)}function Bn(Xn){Qt("throw",Xn)}function ft(Xn,Ti){Xn(Ti),mt.shift(),mt.length&&Qt(mt[0][0],mt[0][1])}};function cs(De){if(De==null)throw new Error("Assertion Failure: value must not be null nor undefined")}function gs(De){return De[Symbol.asyncIterator]!=null?De:(function(oe){return Fi(this,arguments,function(){var xe,Be,Me,mt;return ni(this,function(tt){switch(tt.label){case 0:xe=oe.getReader(),tt.label=1;case 1:tt.trys.push([1,,9,10]),tt.label=2;case 2:return[4,jn(xe.read())];case 3:return Be=tt.sent(),Me=Be.done,mt=Be.value,Me?[4,jn(void 0)]:[3,5];case 4:return[2,tt.sent()];case 5:return cs(mt),[4,jn(mt)];case 6:return[4,tt.sent()];case 7:return tt.sent(),[3,2];case 8:return[3,10];case 9:return xe.releaseLock(),[7];case 10:return[2]}})})})(De)}var us=function(De,oe,xe,Be){return new(xe||(xe=Promise))(function(Me,mt){function tt(Bn){try{Cn(Be.next(Bn))}catch(ft){mt(ft)}}function Qt(Bn){try{Cn(Be.throw(Bn))}catch(ft){mt(ft)}}function Cn(Bn){var ft;Bn.done?Me(Bn.value):(ft=Bn.value,ft instanceof xe?ft:new xe(function(Xn){Xn(ft)})).then(tt,Qt)}Cn((Be=Be.apply(De,[])).next())})},As=function(De,oe){var xe,Be,Me,mt,tt={label:0,sent:function(){if(1&Me[0])throw Me[1];return Me[1]},trys:[],ops:[]};return mt={next:Qt(0),throw:Qt(1),return:Qt(2)},typeof Symbol=="function"&&(mt[Symbol.iterator]=function(){return this}),mt;function Qt(Cn){return function(Bn){return(function(ft){if(xe)throw new TypeError("Generator is already executing.");for(;tt;)try{if(xe=1,Be&&(Me=2&ft[0]?Be.return:ft[0]?Be.throw||((Me=Be.return)&&Me.call(Be),0):Be.next)&&!(Me=Me.call(Be,ft[1])).done)return Me;switch(Be=0,Me&&(ft=[2&ft[0],Me.value]),ft[0]){case 0:case 1:Me=ft;break;case 4:return tt.label++,{value:ft[1],done:!1};case 5:tt.label++,Be=ft[1],ft=[0];continue;case 7:ft=tt.ops.pop(),tt.trys.pop();continue;default:if(Me=tt.trys,!((Me=Me.length>0&&Me[Me.length-1])||ft[0]!==6&&ft[0]!==2)){tt=0;continue}if(ft[0]===3&&(!Me||ft[1]>Me[0]&&ft[1]<Me[3])){tt.label=ft[1];break}if(ft[0]===6&&tt.label<Me[1]){tt.label=Me[1],Me=ft;break}if(Me&&tt.label<Me[2]){tt.label=Me[2],tt.ops.push(ft);break}Me[2]&&tt.ops.pop(),tt.trys.pop();continue}ft=oe.call(De,tt)}catch(Xn){ft=[6,Xn],Be=0}finally{xe=Me=0}if(5&ft[0])throw ft[1];return{value:ft[0]?ft[1]:void 0,done:!0}})([Cn,Bn])}}};function Ns(De,oe){return oe===void 0&&(oe=Rn),us(this,void 0,void 0,function(){var xe;return As(this,function(Be){return xe=gs(De),[2,new An(oe.extensionCodec,oe.context,oe.maxStrLength,oe.maxBinLength,oe.maxArrayLength,oe.maxMapLength,oe.maxExtLength).decodeSingleAsync(xe)]})})}function zs(De,oe){oe===void 0&&(oe=Rn);var xe=gs(De);return new An(oe.extensionCodec,oe.context,oe.maxStrLength,oe.maxBinLength,oe.maxArrayLength,oe.maxMapLength,oe.maxExtLength).decodeArrayStream(xe)}function oc(De,oe){oe===void 0&&(oe=Rn);var xe=gs(De);return new An(oe.extensionCodec,oe.context,oe.maxStrLength,oe.maxBinLength,oe.maxArrayLength,oe.maxMapLength,oe.maxExtLength).decodeStream(xe)}}])})})(tle);const yF=2;class nle{constructor(){this.data=null}compileImageTargets(t,i){return new Promise(async(o,l)=>{const u=[];for(let v=0;v<t.length;v++){const C=t[v],S=this.createProcessCanvas(C).getContext("2d");S.drawImage(C,0,0,C.width,C.height);const M=S.getImageData(0,0,C.width,C.height),_=new Uint8Array(C.width*C.height);for(let F=0;F<_.length;F++){const P=F*4;_[F]=Math.floor((M.data[P]+M.data[P+1]+M.data[P+2])/3)}const B={data:_,height:C.height,width:C.width};u.push(B)}const f=50/u.length;let g=0;this.data=[];for(let v=0;v<u.length;v++){const C=u[v],S=Qoe(C),M=f/S.length,_=await ile(S,()=>{g+=M,i(g)});this.data.push({targetImage:C,imageList:S,matchingData:_})}for(let v=0;v<u.length;v++){const C=Koe(u[v]);this.data[v].trackingImageList=C}const A=await this.compileTrack({progressCallback:i,targetImages:u,basePercent:50});for(let v=0;v<u.length;v++)this.data[v].trackingData=A[v];o(this.data)})}exportData(){const t=[];for(let i=0;i<this.data.length;i++)t.push({targetImage:{width:this.data[i].targetImage.width,height:this.data[i].targetImage.height},trackingData:this.data[i].trackingData,matchingData:this.data[i].matchingData});return Uw.encode({v:yF,dataList:t})}importData(t){const i=Uw.decode(new Uint8Array(t));if(!i.v||i.v!==yF)return console.error("Your compiled .mind might be outdated. Please recompile"),[];const{dataList:o}=i;this.data=[];for(let l=0;l<o.length;l++)this.data.push({targetImage:o[l].targetImage,trackingData:o[l].trackingData,matchingData:o[l].matchingData});return this.data}createProcessCanvas(t){console.warn("missing createProcessCanvas implementation")}compileTrack({progressCallback:t,targetImages:i,basePercent:o}){console.warn("missing compileTrack implementation")}}const ile=async(s,t)=>{const i=[];for(let o=0;o<s.length;o++){const l=s[o],u=new mF(l.width,l.height);await P1(),$e(()=>{const f=Ur(l.data,[l.data.length],"float32").reshape([l.height,l.width]),{featurePoints:g}=u.detect(f),A=g.filter(M=>M.maxima),v=g.filter(M=>!M.maxima),C=AF({points:A}),S=AF({points:v});i.push({maximaPoints:A,minimaPoints:v,maximaPointsCluster:C,minimaPointsCluster:S,width:l.width,height:l.height,scale:l.scale}),t(o)})}return i},vF="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHp7Y29uc3RydWN0b3Iocyx0LG8pe3RoaXMuY3Vtc3VtPVtdO2ZvcihsZXQgZT0wO2U8bztlKyspe3RoaXMuY3Vtc3VtLnB1c2goW10pO2ZvcihsZXQgbj0wO248dDtuKyspdGhpcy5jdW1zdW1bZV0ucHVzaCgwKX10aGlzLmN1bXN1bVswXVswXT1zWzBdO2ZvcihsZXQgZT0xO2U8dDtlKyspdGhpcy5jdW1zdW1bMF1bZV09dGhpcy5jdW1zdW1bMF1bZS0xXStzW2VdO2ZvcihsZXQgZT0xO2U8bztlKyspdGhpcy5jdW1zdW1bZV1bMF09dGhpcy5jdW1zdW1bZS0xXVswXStzW2UqdF07Zm9yKGxldCBlPTE7ZTxvO2UrKylmb3IobGV0IG49MTtuPHQ7bisrKXRoaXMuY3Vtc3VtW2VdW25dPXNbZSp0K25dK3RoaXMuY3Vtc3VtW2UtMV1bbl0rdGhpcy5jdW1zdW1bZV1bbi0xXS10aGlzLmN1bXN1bVtlLTFdW24tMV19cXVlcnkocyx0LG8sZSl7bGV0IG49dGhpcy5jdW1zdW1bZV1bb107cmV0dXJuIHQ+MCYmKG4tPXRoaXMuY3Vtc3VtW3QtMV1bb10pLHM+MCYmKG4tPXRoaXMuY3Vtc3VtW2VdW3MtMV0pLHM+MCYmdD4wJiYobis9dGhpcy5jdW1zdW1bdC0xXVtzLTFdKSxufX1jb25zdCBDPTEwLGI9MixNPTYsRj01LEk9Ljk1LEw9LjksTz0uMixaPTgsTj0yNCoyLzMsVT1yPT57Y29uc3R7ZGF0YTpzLHdpZHRoOnQsaGVpZ2h0Om8sc2NhbGU6ZX09cixuPVt0Km9dO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKW5baV09ITE7Y29uc3QgYT1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWFbaV09LTEsYVt0KihvLTEpK2ldPS0xO2ZvcihsZXQgaT0wO2k8bztpKyspYVtpKnRdPS0xLGFbaSp0K3QtMV09LTE7Zm9yKGxldCBpPTE7aTx0LTE7aSsrKWZvcihsZXQgcD0xO3A8by0xO3ArKyl7bGV0IGY9aSt0KnAsaD0wLGM9MDtmb3IobGV0IHU9LTE7dTw9MTt1KyspaCs9c1tmK3QqdSsxXS1zW2YrdCp1LTFdLGMrPXNbZit0K3VdLXNbZi10K3VdO2gvPTMqMjU2LGMvPTMqMjU2LGFbZl09TWF0aC5zcXJ0KChoKmgrYypjKS8yKX1jb25zdCBnPW5ldyBVaW50MzJBcnJheSgxZTMpO2ZvcihsZXQgaT0wO2k8MWUzO2krKylnW2ldPTA7Y29uc3QgZD1bLTEsMSwtdCx0XTtmb3IobGV0IGk9MTtpPHQtMTtpKyspZm9yKGxldCBwPTE7cDxvLTE7cCsrKXtsZXQgZj1pK3QqcCxoPSEwO2ZvcihsZXQgYz0wO2M8ZC5sZW5ndGg7YysrKWlmKGFbZl08PWFbZitkW2NdXSl7aD0hMTticmVha31pZihoKXtsZXQgYz1NYXRoLmZsb29yKGFbZl0qMWUzKTtjPjk5OSYmKGM9OTk5KSxjPDAmJihjPTApLGdbY10rPTEsbltmXT0hMH19Y29uc3Qgdz0uMDIqdCpvO2xldCBqPTk5OSxFPTA7Zm9yKDtqPj0wJiYoRSs9Z1tqXSwhKEU+dykpOylqLS07Zm9yKGxldCBpPTA7aTxuLmxlbmd0aDtpKyspbltpXSYmYVtpXSoxZTM8aiYmKG5baV09ITEpO2NvbnN0IGw9W107Zm9yKGxldCBpPTA7aTxzLmxlbmd0aDtpKyspbFtpXT1zW2ldKnNbaV07Y29uc3QgUz1uZXcgeihzLHQsbyksRD1uZXcgeihsLHQsbyksaz1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgcD0wO3A8bztwKyspe2NvbnN0IGY9cCp0K2k7aWYoIW5bZl0pe2tbZl09MTtjb250aW51ZX1jb25zdCBoPVAoe2ltYWdlOnIsY3g6aSxjeTpwLHNkVGhyZXNoOkYsaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KTtpZihoPT09bnVsbCl7a1tmXT0xO2NvbnRpbnVlfWxldCBjPS0xO2ZvcihsZXQgdT0tQzt1PD1DO3UrKyl7Zm9yKGxldCBtPS1DO208PUM7bSsrKXtpZihtKm0rdSp1PD1iKmIpY29udGludWU7Y29uc3QgeD1SKHtpbWFnZTpyLGN4OmkrbSxjeTpwK3UsdmxlbjpoLHR4OmksdHk6cCxpbWFnZURhdGFDdW1zdW06UyxpbWFnZURhdGFTcXJDdW1zdW06RH0pO2lmKHghPT1udWxsJiZ4PmMmJihjPXgsYz5JKSlicmVha31pZihjPkkpYnJlYWt9a1tmXT1jfXJldHVybiBWKHtpbWFnZTpyLGZlYXR1cmVNYXA6ayx0ZW1wbGF0ZVNpemU6TSxzZWFyY2hTaXplOmIsb2NjU2l6ZTpOLG1heFNpbVRocmVzaDpMLG1pblNpbVRocmVzaDpPLHNkVGhyZXNoOlosaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KX0sVj1yPT57bGV0e2ltYWdlOnMsZmVhdHVyZU1hcDp0LHRlbXBsYXRlU2l6ZTpvLHNlYXJjaFNpemU6ZSxvY2NTaXplOm4sbWF4U2ltVGhyZXNoOmEsbWluU2ltVGhyZXNoOmcsc2RUaHJlc2g6ZCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an09cjtjb25zdHtkYXRhOkUsd2lkdGg6bCxoZWlnaHQ6UyxzY2FsZTpEfT1zO249TWF0aC5mbG9vcihNYXRoLm1pbihzLndpZHRoLHMuaGVpZ2h0KS8xMCk7Y29uc3Qgaz0obyoyKzEpKjMsQT1NYXRoLmZsb29yKGwvayksaT1NYXRoLmZsb29yKFMvayk7bGV0IHA9TWF0aC5mbG9vcihsL24pKk1hdGguZmxvb3IoUy9uKStBKmk7Y29uc3QgZj1bXSxoPW5ldyBGbG9hdDMyQXJyYXkoRS5sZW5ndGgpO2ZvcihsZXQgdT0wO3U8aC5sZW5ndGg7dSsrKWhbdV09dFt1XTtsZXQgYz0wO2Zvcig7YzxwOyl7bGV0IHU9YSxtPS0xLHg9LTE7Zm9yKGxldCB5PTA7eTxTO3krKylmb3IobGV0IFQ9MDtUPGw7VCsrKWhbeSpsK1RdPHUmJih1PWhbeSpsK1RdLG09VCx4PXkpO2lmKG09PT0tMSlicmVhaztjb25zdCB2PVAoe2ltYWdlOnMsY3g6bSxjeTp4LHNkVGhyZXNoOjAsaW1hZ2VEYXRhQ3Vtc3VtOncsaW1hZ2VEYXRhU3FyQ3Vtc3VtOmp9KTtpZih2PT09bnVsbCl7aFt4KmwrbV09MTtjb250aW51ZX1pZih2LyhvKjIrMSk8ZCl7aFt4KmwrbV09MTtjb250aW51ZX1sZXQgcT0xLF89LTE7Zm9yKGxldCB5PS1lO3k8PWU7eSsrKXtmb3IobGV0IFQ9LWU7VDw9ZTtUKyspe2lmKFQqVCt5Knk+ZSplfHxUPT09MCYmeT09PTApY29udGludWU7Y29uc3QgSD1SKHtpbWFnZTpzLHZsZW46dixjeDptK1QsY3k6eCt5LHR4Om0sdHk6eCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an0pO2lmKEghPT1udWxsJiYoSDxxJiYocT1ILHE8ZyYmcTx1KXx8SD5fJiYoXz1ILF8+Ljk5KSkpYnJlYWt9aWYocTxnJiZxPHV8fF8+Ljk5KWJyZWFrfWlmKHE8ZyYmcTx1fHxfPi45OSl7aFt4KmwrbV09MTtjb250aW51ZX1mLnB1c2goe3g6bSx5Onh9KSxjKz0xO2ZvcihsZXQgeT0tbjt5PD1uO3krKylmb3IobGV0IFQ9LW47VDw9bjtUKyspeCt5PDB8fHgreT49U3x8bStUPDB8fG0rVD49bHx8KGhbKHgreSkqbCsobStUKV09MSl9cmV0dXJuIGZ9LFA9KHtpbWFnZTpyLGN4OnMsY3k6dCxzZFRocmVzaDpvLGltYWdlRGF0YUN1bXN1bTplLGltYWdlRGF0YVNxckN1bXN1bTpufSk9PntpZihzLU08MHx8cytNPj1yLndpZHRofHx0LU08MHx8dCtNPj1yLmhlaWdodClyZXR1cm4gbnVsbDtjb25zdCBhPTIqTSsxLGc9YSphO2xldCBkPWUucXVlcnkocy1NLHQtTSxzK00sdCtNKTtkLz1nO2xldCB3PW4ucXVlcnkocy1NLHQtTSxzK00sdCtNKTtyZXR1cm4gdy09MipkKmUucXVlcnkocy1NLHQtTSxzK00sdCtNKSx3Kz1nKmQqZCx3L2c8bypvP251bGw6KHc9TWF0aC5zcXJ0KHcpLHcpfSxSPXI9Pntjb25zdHtpbWFnZTpzLGN4OnQsY3k6byx2bGVuOmUsdHg6bix0eTphLGltYWdlRGF0YUN1bXN1bTpnLGltYWdlRGF0YVNxckN1bXN1bTpkfT1yLHtkYXRhOncsd2lkdGg6aixoZWlnaHQ6RX09cyxsPU07aWYodC1sPDB8fHQrbD49anx8by1sPDB8fG8rbD49RSlyZXR1cm4gbnVsbDtjb25zdCBTPTIqbCsxO2xldCBEPWcucXVlcnkodC1sLG8tbCx0K2wsbytsKSxrPWQucXVlcnkodC1sLG8tbCx0K2wsbytsKSxBPTAsaT0oby1sKSpqKyh0LWwpLHA9KGEtbCkqaisobi1sKSxmPWotUztmb3IobGV0IG09MDttPFM7bSsrKXtmb3IobGV0IHg9MDt4PFM7eCsrKUErPXdbaV0qd1twXSxpKz0xLHArPTE7aSs9ZixwKz1mfWxldCBoPWcucXVlcnkobi1sLGEtbCxuK2wsYStsKTtoLz1TKlMsQS09aCpEO2xldCBjPWstRCpELyhTKlMpO3JldHVybiBjPT0wP251bGw6KGM9TWF0aC5zcXJ0KGMpLDEqQS8oZSpjKSl9LFc9KHIscyk9Pntjb25zdCB0PVtdO2ZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtjb25zdCBlPXJbb10sbj1VKGUpLGE9e2RhdGE6ZS5kYXRhLHNjYWxlOmUuc2NhbGUsd2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHQscG9pbnRzOm59O3QucHVzaChhKSxzKG8pfXJldHVybiB0fSxYPSh7aW1hZ2U6cixyYXRpbzpzfSk9Pntjb25zdCB0PU1hdGgucm91bmQoci53aWR0aCpzKSxvPU1hdGgucm91bmQoci5oZWlnaHQqcyksZT1uZXcgVWludDhBcnJheSh0Km8pO2ZvcihsZXQgbj0wO248dDtuKyspe2xldCBhPU1hdGgucm91bmQoMSpuL3MpLGc9TWF0aC5yb3VuZCgxKihuKzEpL3MpLTE7Zz49ci53aWR0aCYmKGc9ci53aWR0aC0xKTtmb3IobGV0IGQ9MDtkPG87ZCsrKXtsZXQgdz1NYXRoLnJvdW5kKDEqZC9zKSxqPU1hdGgucm91bmQoMSooZCsxKS9zKS0xO2o+PXIuaGVpZ2h0JiYoaj1yLmhlaWdodC0xKTtsZXQgRT0wLGw9MDtmb3IobGV0IFM9YTtTPD1nO1MrKylmb3IobGV0IEQ9dztEPD1qO0QrKylFKz0xKnIuZGF0YVtEKnIud2lkdGgrU10sbCs9MTtlW2QqdCtuXT1NYXRoLmZsb29yKEUvbCl9fXJldHVybntkYXRhOmUsd2lkdGg6dCxoZWlnaHQ6b319LFk9cj0+e2NvbnN0IHM9TWF0aC5taW4oci53aWR0aCxyLmhlaWdodCksdD1bXSxvPVtdO3QucHVzaCgyNTYvcyksdC5wdXNoKDEyOC9zKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylvLnB1c2goT2JqZWN0LmFzc2lnbihYKHtpbWFnZTpyLHJhdGlvOnRbZV19KSx7c2NhbGU6dFtlXX0pKTtyZXR1cm4gb307b25tZXNzYWdlPXI9Pntjb25zdHtkYXRhOnN9PXI7aWYocy50eXBlPT09ImNvbXBpbGUiKXtjb25zdHt0YXJnZXRJbWFnZXM6dH09cyxvPTEwMC90Lmxlbmd0aDtsZXQgZT0wO2NvbnN0IG49W107Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspe2NvbnN0IGc9dFthXSxkPVkoZyksdz1vL2QubGVuZ3RoLGo9VyhkLEU9PntlKz13LHBvc3RNZXNzYWdlKHt0eXBlOiJwcm9ncmVzcyIscGVyY2VudDplfSl9KTtuLnB1c2goail9cG9zdE1lc3NhZ2Uoe3R5cGU6ImNvbXBpbGVEb25lIixsaXN0Om59KX19fSkoKTsK",xF=typeof window<"u"&&window.Blob&&new Blob([atob(vF)],{type:"text/javascript;charset=utf-8"});function sle(){const s=xF&&(window.URL||window.webkitURL).createObjectURL(xF);try{return s?new Worker(s):new Worker("data:application/javascript;base64,"+vF)}finally{s&&(window.URL||window.webkitURL).revokeObjectURL(s)}}class wF extends nle{createProcessCanvas(t){const i=document.createElement("canvas");return i.width=t.width,i.height=t.height,i}compileTrack({progressCallback:t,targetImages:i,basePercent:o}){return new Promise((l,u)=>{const f=new sle;f.onmessage=g=>{g.data.type==="progress"?t(o+g.data.percent*o/100):g.data.type==="compileDone"&&l(g.data.list)},f.postMessage({type:"compile",targetImages:i})})}}class rle{constructor(t,i){this.width=t,this.height=i,this.texShape=[i,t];const o=document.createElement("canvas").getContext("2d");o.canvas.width=t,o.canvas.height=i,this.context=o,this.program=this.buildProgram(t,i);const l=Fc();this.tempPixelHandle=l.makeTensorInfo(this.texShape,"float32"),l.texData.get(this.tempPixelHandle.dataId).usage=2}_loadInput(t){return $e(()=>{let i=bx(t);return i=i.mean(2),i})}loadInput(t){this.context.drawImage(t,0,0,this.width,this.height);const i=Fc();return i.gpgpu.uploadPixelDataToTexture(i.getTexture(this.tempPixelHandle.dataId),this.context.canvas),this._compileAndRun(this.program,[this.tempPixelHandle])}buildProgram(t,i){const o=Ee().getNumber("WEBGL_VERSION")===2?"texture":"texture2D";return{variableNames:["A"],outputShape:this.texShape,userCode:`
	void main() {
	  ivec2 coords = getOutputCoords();
	  int texR = coords[0];
	  int texC = coords[1];
	  vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${t}.0, ${i}.0);

	  vec4 values = ${o}(A, uv);
	  setOutput((0.299 * values.r + 0.587 * values.g + 0.114 * values.b) * 255.0);
	}
      `}}_compileAndRun(t,i){const o=Fc().compileAndRun(t,i);return os().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}_runWebGLProgram(t,i,o){const l=Fc().runWebGLProgram(t,i,o);return os().makeTensorFromDataId(l.dataId,l.shape,l.dtype)}}const CF=(s,t)=>{const i=2*Math.PI*t*s;return i/(i+1)},EF=(s,t,i)=>s*t+(1-s)*i;class ale{constructor({minCutOff:t,beta:i}){this.minCutOff=t,this.beta=i,this.dCutOff=.001,this.xPrev=null,this.dxPrev=null,this.tPrev=null,this.initialized=!1}reset(){this.initialized=!1}filter(t,i){if(!this.initialized)return this.initialized=!0,this.xPrev=i,this.dxPrev=i.map(()=>0),this.tPrev=t,i;const{xPrev:o,tPrev:l,dxPrev:u}=this,f=t-l,g=CF(f,this.dCutOff),A=[],v=[],C=[];for(let S=0;S<i.length;S++){A[S]=(i[S]-o[S])/f,v[S]=EF(g,A[S],u[S]);const M=this.minCutOff+this.beta*Math.abs(v[S]),_=CF(f,M);C[S]=EF(_,i[S],o[S])}return this.xPrev=C,this.dxPrev=v,this.tPrev=t,C}}const cM={memory:cg,nextFrame:P1},ole=.001,lle=1e3,cle=5,ule=5;class SF{constructor({inputWidth:t,inputHeight:i,onUpdate:o=null,debugMode:l=!1,maxTrack:u=1,warmupTolerance:f=null,missTolerance:g=null,filterMinCF:A=null,filterBeta:v=null}){this.inputWidth=t,this.inputHeight=i,this.maxTrack=u,this.filterMinCF=A===null?ole:A,this.filterBeta=v===null?lle:v,this.warmupTolerance=f===null?cle:f,this.missTolerance=g===null?ule:g,this.cropDetector=new Hoe(this.inputWidth,this.inputHeight,l),this.inputLoader=new rle(this.inputWidth,this.inputHeight),this.markerDimensions=null,this.onUpdate=o,this.debugMode=l,this.processingVideo=!1,this.interestedTargetIndex=-1,this.trackingStates=[];const C=10,S=1e5,M=45*Math.PI/180,_=this.inputHeight/2/Math.tan(M/2);this.projectionTransform=[[_,0,this.inputWidth/2],[0,_,this.inputHeight/2],[0,0,1]],this.projectionMatrix=this._glProjectionMatrix({projectionTransform:this.projectionTransform,width:this.inputWidth,height:this.inputHeight,near:C,far:S}),this.worker=new soe,this.workerMatchDone=null,this.workerTrackDone=null,this.worker.onmessage=B=>{B.data.type==="matchDone"&&this.workerMatchDone!==null&&this.workerMatchDone(B.data),B.data.type==="trackUpdateDone"&&this.workerTrackDone!==null&&this.workerTrackDone(B.data)}}showTFStats(){console.log(cM.memory().numTensors),console.table(cM.memory())}addImageTargets(t){return new Promise(async(i,o)=>{const l=await(await fetch(t)).arrayBuffer(),u=this.addImageTargetsFromBuffer(l);i(u)})}addImageTargetsFromBuffer(t){const i=new wF().importData(t),o=[],l=[],u=[];for(let f=0;f<i.length;f++)l.push(i[f].matchingData),o.push(i[f].trackingData),u.push([i[f].targetImage.width,i[f].targetImage.height]);return this.tracker=new poe(u,o,this.projectionTransform,this.inputWidth,this.inputHeight,this.debugMode),this.worker.postMessage({type:"setup",inputWidth:this.inputWidth,inputHeight:this.inputHeight,projectionTransform:this.projectionTransform,debugMode:this.debugMode,matchingDataList:l}),this.markerDimensions=u,{dimensions:u,matchingDataList:l,trackingDataList:o}}dispose(){this.stopProcessVideo(),this.worker.postMessage({type:"dispose"})}dummyRun(t){const i=this.inputLoader.loadInput(t);this.cropDetector.detect(i),this.tracker.dummyRun(i),i.dispose()}getProjectionMatrix(){return this.projectionMatrix}getWorldMatrix(t,i){return this._glModelViewMatrix(t,i)}async _detectAndMatch(t,i){const{featurePoints:o}=this.cropDetector.detectMoving(t),{targetIndex:l,modelViewTransform:u}=await this._workerMatch(o,i);return{targetIndex:l,modelViewTransform:u}}async _trackAndUpdate(t,i,o){const{worldCoords:l,screenCoords:u}=this.tracker.track(t,i,o);return l.length<4?null:await this._workerTrackUpdate(i,{worldCoords:l,screenCoords:u})}processVideo(t){if(!this.processingVideo){this.processingVideo=!0,this.trackingStates=[];for(let i=0;i<this.markerDimensions.length;i++)this.trackingStates.push({showing:!1,isTracking:!1,currentModelViewTransform:null,trackCount:0,trackMiss:0,filter:new ale({minCutOff:this.filterMinCF,beta:this.filterBeta})});(async()=>{for(;this.processingVideo;){const i=this.inputLoader.loadInput(t);if(this.trackingStates.reduce((o,l)=>o+(l.isTracking?1:0),0)<this.maxTrack){const o=[];for(let f=0;f<this.trackingStates.length;f++)this.trackingStates[f].isTracking!==!0&&(this.interestedTargetIndex!==-1&&this.interestedTargetIndex!==f||o.push(f));const{targetIndex:l,modelViewTransform:u}=await this._detectAndMatch(i,o);l!==-1&&(this.trackingStates[l].isTracking=!0,this.trackingStates[l].currentModelViewTransform=u)}for(let o=0;o<this.trackingStates.length;o++){const l=this.trackingStates[o];if(l.isTracking){let u=await this._trackAndUpdate(i,l.currentModelViewTransform,o);u===null?l.isTracking=!1:l.currentModelViewTransform=u}if(l.showing||l.isTracking&&(l.trackMiss=0,l.trackCount+=1,l.trackCount>this.warmupTolerance&&(l.showing=!0,l.trackingMatrix=null,l.filter.reset())),l.showing&&(l.isTracking?l.trackMiss=0:(l.trackCount=0,l.trackMiss+=1,l.trackMiss>this.missTolerance&&(l.showing=!1,l.trackingMatrix=null,this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:o,worldMatrix:null})))),l.showing){const u=this._glModelViewMatrix(l.currentModelViewTransform,o);l.trackingMatrix=l.filter.filter(Date.now(),u);const f=[];for(let g=0;g<l.trackingMatrix.length;g++)f[g]=l.trackingMatrix[g];this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:o,worldMatrix:f})}}i.dispose(),this.onUpdate&&this.onUpdate({type:"processDone"}),await cM.nextFrame()}})()}}stopProcessVideo(){this.processingVideo=!1}async detect(t){const i=this.inputLoader.loadInput(t),{featurePoints:o,debugExtra:l}=await this.cropDetector.detect(i);return i.dispose(),{featurePoints:o,debugExtra:l}}async match(t,i){const{modelViewTransform:o,debugExtra:l}=await this._workerMatch(t,[i]);return{modelViewTransform:o,debugExtra:l}}async track(t,i,o){const l=this.inputLoader.loadInput(t),u=this.tracker.track(l,i,o);return l.dispose(),u}async trackUpdate(t,i){return i.worldCoords.length<4?null:await this._workerTrackUpdate(t,i)}_workerMatch(t,i){return new Promise(async(o,l)=>{this.workerMatchDone=u=>{o({targetIndex:u.targetIndex,modelViewTransform:u.modelViewTransform,debugExtra:u.debugExtra})},this.worker.postMessage({type:"match",featurePoints:t,targetIndexes:i})})}_workerTrackUpdate(t,i){return new Promise(async(o,l)=>{this.workerTrackDone=g=>{o(g.modelViewTransform)};const{worldCoords:u,screenCoords:f}=i;this.worker.postMessage({type:"trackUpdate",modelViewTransform:t,worldCoords:u,screenCoords:f})})}_glModelViewMatrix(t,i){const o=this.markerDimensions[i][1];return[t[0][0],-t[1][0],-t[2][0],0,-t[0][1],t[1][1],t[2][1],0,-t[0][2],t[1][2],t[2][2],0,t[0][1]*o+t[0][3],-(t[1][1]*o+t[1][3]),-(t[2][1]*o+t[2][3]),1]}_glProjectionMatrix({projectionTransform:t,width:i,height:o,near:l,far:u}){const f=[[2*t[0][0]/i,0,-(2*t[0][2]/i-1),0],[0,2*t[1][1]/o,-(2*t[1][2]/o-1),0],[0,0,-(u+l)/(u-l),-2*u*l/(u-l)],[0,0,-1,0]],g=[];for(let A=0;A<4;A++)for(let v=0;v<4;v++)g.push(f[v][A]);return g}}const hle=`<div class="mindar-ui-overlay mindar-ui-loading">
  <div class="loader"/>
</div>
`,dle=`<div class="mindar-ui-overlay mindar-ui-compatibility">
  <div class="content">
    <h1>Failed to launch :(</h1>
    <p>
      Looks like your device/browser is not compatible.
    </p>

    <br/>
    <br/>
    <p>
      Please try the following recommended browsers:
    </p>
    <p>
      For Android device - Chrome
    </p>
    <p>
      For iOS device - Safari
    </p>
  </div>
</div>
`,fle=`<div class="mindar-ui-overlay mindar-ui-scanning">
  <div class="scanning">
    <div class="inner">
      <div class="scanline"/>
    </div>
  </div>
</div>
`,ple=".mindar-ui-overlay{display:flex;align-items:center;justify-content:center;position:absolute;left:0;right:0;top:0;bottom:0;background:transparent;z-index:2}.mindar-ui-overlay.hidden{display:none}.mindar-ui-loading .loader{border:16px solid #222;border-top:16px solid white;opacity:.8;border-radius:50%;width:120px;height:120px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.mindar-ui-compatibility .content{background:black;color:#fff;opacity:.8;text-align:center;margin:20px;padding:20px;min-height:50vh}@media (min-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:50vh;height:50vh}}@media (max-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:80vw;height:80vw}}.mindar-ui-scanning .scanning .inner{position:relative;width:100%;height:100%;opacity:.8;background:linear-gradient(to right,white 10px,transparent 10px) 0 0,linear-gradient(to right,white 10px,transparent 10px) 0 100%,linear-gradient(to left,white 10px,transparent 10px) 100% 0,linear-gradient(to left,white 10px,transparent 10px) 100% 100%,linear-gradient(to bottom,white 10px,transparent 10px) 0 0,linear-gradient(to bottom,white 10px,transparent 10px) 100% 0,linear-gradient(to top,white 10px,transparent 10px) 0 100%,linear-gradient(to top,white 10px,transparent 10px) 100% 100%;background-repeat:no-repeat;background-size:40px 40px}.mindar-ui-scanning .scanning .inner .scanline{position:absolute;width:100%;height:10px;background:white;animation:move 2s linear infinite}@keyframes move{0%,to{top:0%}50%{top:calc(100% - 10px)}}";class IF{constructor({uiLoading:t,uiScanning:i,uiError:o}){const l=document.createElement("style");l.innerText=ple,document.head.appendChild(l),t==="yes"?this.loadingModal=this._loadHTML(hle):t!=="no"&&(this.loadingModal=document.querySelector(t)),o==="yes"?this.compatibilityModal=this._loadHTML(dle):o!=="no"&&(this.compatibilityModal=document.querySelector(o)),i==="yes"?this.scanningMask=this._loadHTML(fle):i!=="no"&&(this.scanningMask=document.querySelector(i)),this.hideLoading(),this.hideCompatibility(),this.hideScanning()}showLoading(){this.loadingModal&&this.loadingModal.classList.remove("hidden")}hideLoading(){this.loadingModal&&this.loadingModal.classList.add("hidden")}showCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.remove("hidden")}hideCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.add("hidden")}showScanning(){this.scanningMask&&this.scanningMask.classList.remove("hidden")}hideScanning(){this.scanningMask&&this.scanningMask.classList.add("hidden")}_loadHTML(t){const i=document.createElement("template");i.innerHTML=t.trim();const o=i.content.firstChild;return document.getElementsByTagName("body")[0].appendChild(o),o}}window.MINDAR||(window.MINDAR={}),window.MINDAR.IMAGE={Controller:SF,Compiler:wF,UI:IF},AFRAME.registerSystem("mindar-image-system",{container:null,video:null,processingImage:!1,init:function(){this.anchorEntities=[]},tick:function(){},setup:function({imageTargetSrc:s,maxTrack:t,showStats:i,uiLoading:o,uiScanning:l,uiError:u,missTolerance:f,warmupTolerance:g,filterMinCF:A,filterBeta:v}){this.imageTargetSrc=s,this.maxTrack=t,this.filterMinCF=A,this.filterBeta=v,this.missTolerance=f,this.warmupTolerance=g,this.showStats=i,this.ui=new IF({uiLoading:o,uiScanning:l,uiError:u})},registerAnchor:function(s,t){this.anchorEntities.push({el:s,targetIndex:t})},start:function(){this.container=this.el.sceneEl.parentNode,this.showStats&&(this.mainStats=new Stats,this.mainStats.showPanel(0),this.mainStats.domElement.style.cssText="position:absolute;top:0px;left:0px;z-index:999",this.container.appendChild(this.mainStats.domElement)),this.ui.showLoading(),this._startVideo()},switchTarget:function(s){this.controller.interestedTargetIndex=s},stop:function(){this.pause(),this.video.srcObject.getTracks().forEach(function(s){s.stop()}),this.video.remove(),this.controller.dispose()},pause:function(s=!1){s||this.video.pause(),this.controller.stopProcessVideo()},unpause:function(){this.video.play(),this.controller.processVideo(this.video)},_startVideo:function(){if(this.video=document.createElement("video"),this.video.setAttribute("autoplay",""),this.video.setAttribute("muted",""),this.video.setAttribute("playsinline",""),this.video.style.position="absolute",this.video.style.top="0px",this.video.style.left="0px",this.video.style.zIndex="-2",this.container.appendChild(this.video),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia){this.el.emit("arError",{error:"VIDEO_FAIL"}),this.ui.showCompatibility();return}navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"environment"}}).then(s=>{this.video.addEventListener("loadedmetadata",()=>{this.video.setAttribute("width",this.video.videoWidth),this.video.setAttribute("height",this.video.videoHeight),this._startAR()}),this.video.srcObject=s}).catch(s=>{console.log("getUserMedia error",s),this.el.emit("arError",{error:"VIDEO_FAIL"})})},_startAR:async function(){const s=this.video;this.container,this.controller=new SF({inputWidth:s.videoWidth,inputHeight:s.videoHeight,maxTrack:this.maxTrack,filterMinCF:this.filterMinCF,filterBeta:this.filterBeta,missTolerance:this.missTolerance,warmupTolerance:this.warmupTolerance,onUpdate:i=>{if(i.type==="processDone")this.mainStats&&this.mainStats.update();else if(i.type==="updateMatrix"){const{targetIndex:o,worldMatrix:l}=i;for(let u=0;u<this.anchorEntities.length;u++)this.anchorEntities[u].targetIndex===o&&this.anchorEntities[u].el.updateWorldMatrix(l);this.anchorEntities.reduce((u,f)=>u||f.el.el.object3D.visible,!1)?this.ui.hideScanning():this.ui.showScanning()}}}),this._resize(),window.addEventListener("resize",this._resize.bind(this));const{dimensions:t}=await this.controller.addImageTargets(this.imageTargetSrc);for(let i=0;i<this.anchorEntities.length;i++){const{el:o,targetIndex:l}=this.anchorEntities[i];l<t.length&&o.setupMarker(t[l])}await this.controller.dummyRun(this.video),this.el.emit("arReady"),this.ui.hideLoading(),this.ui.showScanning(),this.controller.processVideo(this.video)},_resize:function(){const s=this.video,t=this.container;let i,o;const l=s.videoWidth/s.videoHeight,u=t.clientWidth/t.clientHeight;l>u?(o=t.clientHeight,i=o*l):(i=t.clientWidth,o=i/l);const f=this.controller.getProjectionMatrix(),g=2*Math.atan(1/f[5]/o*t.clientHeight)*180/Math.PI,A=f[14]/(f[10]-1),v=f[14]/(f[10]+1);f[5]/f[0];const C=t.clientWidth/t.clientHeight,S=t.getElementsByTagName("a-camera")[0].getObject3D("camera");S.fov=g,S.aspect=C,S.near=A,S.far=v,S.updateProjectionMatrix(),this.video.style.top=-(o-t.clientHeight)/2+"px",this.video.style.left=-(i-t.clientWidth)/2+"px",this.video.style.width=i+"px",this.video.style.height=o+"px"}}),AFRAME.registerComponent("mindar-image",{dependencies:["mindar-image-system"],schema:{imageTargetSrc:{type:"string"},maxTrack:{type:"int",default:1},filterMinCF:{type:"number",default:-1},filterBeta:{type:"number",default:-1},missTolerance:{type:"int",default:-1},warmupTolerance:{type:"int",default:-1},showStats:{type:"boolean",default:!1},autoStart:{type:"boolean",default:!0},uiLoading:{type:"string",default:"yes"},uiScanning:{type:"string",default:"yes"},uiError:{type:"string",default:"yes"}},init:function(){const s=this.el.sceneEl.systems["mindar-image-system"];s.setup({imageTargetSrc:this.data.imageTargetSrc,maxTrack:this.data.maxTrack,filterMinCF:this.data.filterMinCF===-1?null:this.data.filterMinCF,filterBeta:this.data.filterBeta===-1?null:this.data.filterBeta,missTolerance:this.data.missTolerance===-1?null:this.data.missTolerance,warmupTolerance:this.data.warmupTolerance===-1?null:this.data.warmupTolerance,showStats:this.data.showStats,uiLoading:this.data.uiLoading,uiScanning:this.data.uiScanning,uiError:this.data.uiError}),this.data.autoStart&&this.el.sceneEl.addEventListener("renderstart",()=>{s.start()})},remove:function(){this.el.sceneEl.systems["mindar-image-system"].stop()}}),AFRAME.registerComponent("mindar-image-target",{dependencies:["mindar-image-system"],schema:{targetIndex:{type:"number"}},postMatrix:null,init:function(){this.el.sceneEl.systems["mindar-image-system"].registerAnchor(this,this.data.targetIndex),this.invisibleMatrix=new AFRAME.THREE.Matrix4(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);const s=this.el.object3D;s.visible=!1,s.matrixAutoUpdate=!1},setupMarker([s,t]){const i=new AFRAME.THREE.Vector3,o=new AFRAME.THREE.Quaternion,l=new AFRAME.THREE.Vector3;i.x=s/2,i.y=s/2+(t-s)/2,l.x=s,l.y=s,l.z=s,this.postMatrix=new AFRAME.THREE.Matrix4,this.postMatrix.compose(i,o,l)},updateWorldMatrix(s){if(this.el.emit("targetUpdate"),!this.el.object3D.visible&&s!==null?this.el.emit("targetFound"):this.el.object3D.visible&&s===null&&this.el.emit("targetLost"),this.el.object3D.visible=s!==null,s===null){this.el.object3D.matrix=this.invisibleMatrix;return}var t=new AFRAME.THREE.Matrix4;t.elements=s,t.multiply(this.postMatrix),this.el.object3D.matrix=t}})})()),mP}vye();function xye(){const r=hu.useRef(null),e=hu.useRef(null),n=hu.useRef(null),a=hu.useRef(null),[c,h]=hu.useState(!1),[p,b]=hu.useState(!1),[y,w]=hu.useState(!1),[I,E]=hu.useState(!1),R=p&&y,k=()=>{e.current&&e.current.setAttribute("animation","property: rotation; to:0 0 -360; loop: true; dur: 8000; easing: linear"),n.current&&(n.current.setAttribute("animation","property: scale; from: 1 1 1; to: 3 3 3; dur: 2000; loop: true; easing: linear"),n.current.setAttribute("animation__fade","property: opacity; from: 1; to: 0; dur: 2000; loop: true")),a.current&&(a.current.setAttribute("animation","property: scale; from: 1 1 1; to: 3 3 3; dur: 2000; delay: 1000; loop: true; easing: linear"),a.current.setAttribute("animation__fade","property: opacity; from: 1; to: 0; dur: 2000; delay: 1000; loop: true"))},G=()=>{e.current&&(e.current.removeAttribute("animation"),e.current.setAttribute("rotation","0 0 0")),n.current&&(n.current.removeAttribute("animation"),n.current.removeAttribute("animation__fade"),n.current.setAttribute("opacity","0")),a.current&&(a.current.removeAttribute("animation"),a.current.removeAttribute("animation__fade"),a.current.setAttribute("opacity","0"))};hu.useEffect(()=>{R?k():G()},[R]),hu.useEffect(()=>{const W=document.querySelector("a-scene")?.querySelector("[mindar-image-target]"),H=r.current;if(!W||!H)return;const K=async()=>{if(console.log("targetFound"),w(!0),E(!0),!c){console.log(" audio pas encore dbloqu (clic requis)");return}try{await H.play()}catch(re){console.warn("play() rejet :",re)}},j=()=>{console.log("targetLost"),w(!1),H&&!H.paused&&H.pause()},J=()=>{console.log("audio playing"),b(!0)},ee=()=>{console.log("audio paused"),b(!1)};return W.addEventListener("targetFound",K),W.addEventListener("targetLost",j),H.addEventListener("play",J),H.addEventListener("pause",ee),()=>{W.removeEventListener("targetFound",K),W.removeEventListener("targetLost",j),H.removeEventListener("play",J),H.removeEventListener("pause",ee)}},[c]);const N=()=>{try{const D=new(window.AudioContext||window.webkitAudioContext);D.state==="suspended"&&D.resume(),h(!0),console.log(" Audio dbloqu selon les standards 2024")}catch(D){console.warn("Impossible de dbloquer l'audio :",D)}},O=async()=>{const D=r.current;if(D){c||await N();try{D.paused?await D.play():D.pause()}catch(W){console.warn("toggle play/pause chou :",W)}}};return Cr.jsxs(Cr.Fragment,{children:[!c&&Cr.jsx("button",{onClick:N,style:{position:"absolute",top:20,left:"50%",transform:"translateX(-50%)",zIndex:2e3,padding:"10px 18px",borderRadius:10,background:"#111",color:"white"},children:" Activer l'audio"}),Cr.jsx("audio",{ref:r,id:"player-audio",src:"https://p-alom-a.github.io/ar_vsnr/bbc_irian-jaya_nhu0501904.mp3",preload:"auto",playsInline:!0}),I&&Cr.jsxs("div",{id:"player-ui",style:{display:"flex",position:"absolute",bottom:20,left:"50%",transform:"translateX(-50%)",gap:12,alignItems:"center",background:"rgba(0,0,0,0.6)",color:"white",padding:"8px 14px",borderRadius:12,zIndex:2e3},children:[Cr.jsx("button",{onClick:O,style:{fontSize:18,background:"transparent",border:"none",color:"white"},children:p?" Pause":" Play"}),Cr.jsx("span",{style:{fontSize:14},children:p?"En cours...":"En pause"}),Cr.jsx("a",{href:"https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M",target:"_blank",rel:"noopener noreferrer",style:{color:"lightgreen",textDecoration:"none",fontSize:14},children:" Playlist"})]}),Cr.jsxs("a-scene",{"mindar-image":"imageTargetSrc: https://p-alom-a.github.io/ar_vsnr/targets-cup.mind;","color-space":"sRGB",renderer:"colorManagement: true, physicallyCorrectLights","vr-mode-ui":"enabled: false","device-orientation-permission-ui":"enabled: false",children:[Cr.jsx("a-assets",{children:Cr.jsx("a-asset-item",{id:"vinyleModel",src:"https://p-alom-a.github.io/ar_vsnr/models/vinyle2.glb"})}),Cr.jsx("a-camera",{position:"0 0 0","look-controls":"enabled: false"}),Cr.jsxs("a-entity",{"mindar-image-target":"targetIndex: 0",children:[Cr.jsx("a-gltf-model",{ref:e,position:"0 0 0",scale:"0.4 0.4 0.4",src:"#vinyleModel"}),Cr.jsx("a-ring",{ref:n,color:"pink","radius-inner":"0.3","radius-outer":"0.35",position:"0 0 0.01"}),Cr.jsx("a-ring",{ref:a,color:"pink","radius-inner":"0.3","radius-outer":"0.35",position:"0 0 0.01"})]})]})]})}function wye(){return Cr.jsx(xye,{})}Sle.createRoot(document.getElementById("root")).render(Cr.jsx(Cr.Fragment,{children:Cr.jsx(wye,{})}));
//# sourceMappingURL=index-B09F5H90.js.map
